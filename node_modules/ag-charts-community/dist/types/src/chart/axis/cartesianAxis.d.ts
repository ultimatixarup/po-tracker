import type { AgCartesianAxisPosition, AgTimeInterval, AgTimeIntervalUnit } from 'ag-charts-types';
import type { AxisContext } from '../../module/axisContext';
import type { ModuleContext } from '../../module/moduleContext';
import { type FromToDiff } from '../../motion/fromToMotion';
import type { Scale } from '../../scale/scale';
import { BBox } from '../../scene/bbox';
import { TranslatableGroup } from '../../scene/group';
import { Selection } from '../../scene/selection';
import { Line } from '../../scene/shape/line';
import { Rect } from '../../scene/shape/rect';
import type { AxisPrimaryTickCount } from '../../util/secondaryAxisTicks';
import { StateMachine } from '../../util/stateMachine';
import { Caption } from '../caption';
import type { ChartAnimationPhase } from '../chartAnimationPhase';
import type { ChartLayout } from '../chartAxis';
import { ChartAxisDirection } from '../chartAxisDirection';
import type { AnimationManager } from '../interaction/animationManager';
import { Axis, type LabelNodeDatum } from './axis';
import { type AxisFillDatum, type AxisLineDatum, NiceMode, type TickDatum } from './axisUtil';
import { CartesianAxisLabel } from './cartesianAxisLabel';
type AxisAnimationState = 'empty' | 'ready';
type AxisAnimationEvent = {
    reset: undefined;
    resize: undefined;
    update: FromToDiff;
};
interface GeneratedTicks {
    ticks: TickDatum[];
    tickLines: AxisLineDatum[];
    gridLines: AxisLineDatum[];
    gridFills: AxisFillDatum[];
    labels: LabelNodeDatum[];
    spacing: number;
}
export type GridLineStyleTickDatum = Pick<TickDatum, 'index' | 'tickId' | 'translation'>;
export declare abstract class CartesianAxis<S extends Scale<D, number, any> = Scale<any, number, any>, D = any> extends Axis<S, D, GeneratedTicks> {
    static is(value: unknown): value is CartesianAxis<any>;
    thickness?: number;
    maxThicknessRatio: number;
    position: AgCartesianAxisPosition;
    protected animationManager: AnimationManager;
    protected readonly headingLabelGroup: TranslatableGroup;
    protected readonly lineNodeGroup: TranslatableGroup;
    protected readonly lineNode: Line;
    protected tickLineGroupSelection: Selection<Line, AxisLineDatum>;
    protected gridLineGroupSelection: Selection<Line, AxisLineDatum>;
    protected gridFillGroupSelection: Selection<Rect<any>, AxisFillDatum>;
    private readonly tempText;
    private readonly tempCaption;
    private readonly tickGenerator;
    protected readonly animationState: StateMachine<AxisAnimationState, AxisAnimationEvent>;
    protected get horizontal(): boolean;
    constructor(moduleCtx: ModuleContext, scale: S);
    protected onGridVisibilityChange(): void;
    resetAnimation(phase: ChartAnimationPhase): void;
    get direction(): ChartAxisDirection.X | ChartAxisDirection.Y;
    createAxisContext(): AxisContext;
    protected createLabel(): CartesianAxisLabel;
    protected updateDirection(): void;
    calculateLayout(primaryTickCount?: AxisPrimaryTickCount, chartLayout?: ChartLayout): {
        primaryTickCount?: AxisPrimaryTickCount | undefined;
        bbox?: BBox | undefined;
    };
    layoutCrossLines(): void;
    calculateTickLayout(domain: D[], niceMode: NiceMode, visibleRange: [number, number], initialPrimaryTickCount?: AxisPrimaryTickCount): {
        niceDomain: D[];
        tickDomain: D[];
        ticks: D[];
        rawTickCount: number | undefined;
        fractionDigits: number;
        timeInterval: AgTimeInterval | AgTimeIntervalUnit | undefined;
        bbox: BBox;
        layout: GeneratedTicks;
    };
    protected calculateGridLines(ticks: GridLineStyleTickDatum[], p1: number, p2: number): AxisLineDatum[];
    protected calculateGridLine({ index: tickIndex, tickId, translation: offset }: GridLineStyleTickDatum, _index: number, p1: number, p2: number, _ticks: GridLineStyleTickDatum[]): AxisLineDatum;
    protected calculateGridFills(ticks: GridLineStyleTickDatum[], p1: number, p2: number): AxisFillDatum[];
    protected calculateGridFill({ tickId, translation }: Pick<GridLineStyleTickDatum, 'tickId' | 'translation'>, index: number, gridFillIndex: number, p1: number, p2: number, ticks: GridLineStyleTickDatum[]): AxisFillDatum;
    protected calculateTickLines(ticks: TickDatum[], direction: number): AxisLineDatum[];
    protected calculateTickLine({ primary, tickId, translation: offset }: Pick<TickDatum, 'primary' | 'tickId' | 'translation'>, _index: number, direction: number, _ticks: TickDatum[]): AxisLineDatum;
    update(): void;
    private getAxisTransform;
    protected updatePosition(): void;
    private getAxisLineCoordinates;
    private getTickLineBBox;
    protected lineNodeBBox(): BBox;
    protected titleBBox(domain: D[], spacing: number): BBox;
    private tickBBox;
    protected titleProps(caption: Caption, domain: D[], spacing: number): {
        visible: boolean;
        text: string | undefined;
        textBaseline: "top" | "bottom";
        x: number;
        y: number;
        rotationCenterX: number;
        rotationCenterY: number;
        rotation: number;
    };
    private getLabelBorderOffset;
    private getTickLabelProps;
    protected updateSelections(): void;
    protected updateGridLines(): void;
    protected updateGridFills(): void;
    protected updateTickLines(): void;
    protected updateTitle(domain: D[], spacing: number): void;
    protected updateLabels(): void;
    private animateReadyUpdate;
    protected resetSelectionNodes(): void;
}
export {};
