var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/ag-charts-community/src/api/preset/presetModules.ts
import {
  and as and3,
  array as array2,
  boolean as boolean6,
  color as color3,
  date as date2,
  defined as defined2,
  greaterThan as greaterThan3,
  lessThan as lessThan3,
  lineDashOptionsDef as lineDashOptionsDef6,
  number as number6,
  or as or3,
  positiveNumber as positiveNumber4,
  ratio as ratio3,
  string as string6,
  strokeOptionsDef as strokeOptionsDef6,
  typeUnion as typeUnion2,
  undocumented as undocumented5,
  union as union4
} from "ag-charts-core";

// packages/ag-charts-community/src/chart/commonOptionsDefs.ts
import {
  ErrorType,
  ValidationError,
  and,
  array,
  arrayLength,
  arrayOf,
  arrayOfDefs,
  attachDescription,
  boolean,
  borderOptionsDef,
  callback,
  callbackDefs,
  callbackOf,
  color,
  colorUnion,
  date,
  defined,
  fillOptionsDef,
  fontOptionsDef,
  greaterThan,
  highlightOptionsDef,
  htmlElement,
  isValidNumberFormat,
  labelBoxOptionsDef,
  lessThan,
  lineDashOptionsDef,
  number,
  object,
  optionsDefs,
  or,
  padding,
  positiveNumber,
  ratio,
  required,
  shapeHighlightOptionsDef,
  string,
  strokeOptionsDef,
  typeUnion,
  undocumented,
  union,
  validate
} from "ag-charts-core";

// packages/ag-charts-types/src/chart/navigatorOptions.ts
var __MINI_CHART_SERIES_OPTIONS = void 0;
var __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;
__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;

// packages/ag-charts-types/src/chart/themeOptions.ts
var __THEME_OVERRIDES = void 0;
var __VERIFY_THEME_OVERRIDES = void 0;
__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;

// packages/ag-charts-types/src/presets/gauge/commonOptions.ts
var __THEMEABLE_OPTIONS = void 0;
var __VERIFY_THEMEABLE_OPTIONS = void 0;
__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;
var __AXIS_LABEL_OPTIONS = void 0;
var __VERIFY_AXIS_LABEL_OPTIONS = void 0;
__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;

// packages/ag-charts-community/src/chart/commonOptionsDefs.ts
var legendPlacementLiterals = [
  "top",
  "top-right",
  "top-left",
  "bottom",
  "bottom-right",
  "bottom-left",
  "right",
  "right-top",
  "right-bottom",
  "left",
  "left-top",
  "left-bottom"
];
var legendPositionOptionsDef = {
  floating: boolean,
  placement: union(...legendPlacementLiterals),
  xOffset: number,
  yOffset: number
};
var legendPositionValidator = attachDescription(
  (value, context) => {
    let result;
    if (typeof value === "string") {
      const allowedValues = legendPlacementLiterals;
      if (allowedValues.includes(value)) {
        result = true;
      } else {
        result = { valid: false, invalid: [], cleared: null };
        result.invalid.push(
          new ValidationError(
            ErrorType.Invalid,
            `a legend placement string: ["${legendPlacementLiterals.join('", "')}"]`,
            value,
            context.path
          )
        );
      }
    } else {
      const { cleared, invalid } = validate(value, legendPositionOptionsDef);
      result = { valid: invalid.length === 0, cleared, invalid };
    }
    return result;
  },
  `a legend position object or placement string`
);
var shapeValidator = or(
  union("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle"),
  callback
);
var textWrapValidator = union("never", "always", "hyphenate", "on-space");
var tooltipPlacementValidator = union(
  "top",
  "right",
  "bottom",
  "left",
  "top-right",
  "bottom-right",
  "bottom-left",
  "top-left",
  "center"
);
var rangeValidator = or(positiveNumber, union("exact", "nearest"));
var textOrSegments = or(
  string,
  arrayOfDefs(
    {
      text: required(string),
      ...fontOptionsDef
    },
    "text segments array"
  )
);
var zoomAnchorPoint = union("pointer", "start", "middle", "end");
var chartCaptionOptionsDefs = {
  enabled: boolean,
  text: textOrSegments,
  textAlign: union("left", "center", "right"),
  wrapping: union("never", "always", "hyphenate", "on-space"),
  spacing: positiveNumber,
  maxWidth: positiveNumber,
  maxHeight: positiveNumber,
  ...fontOptionsDef
};
chartCaptionOptionsDefs.padding = undocumented(positiveNumber);
var chartOverlayOptionsDefs = {
  enabled: boolean,
  text: textOrSegments,
  renderer: callbackOf(or(string, htmlElement))
};
var contextMenuItemLiterals = [
  "defaults",
  "download",
  "zoom-to-cursor",
  "pan-to-cursor",
  "reset-zoom",
  "toggle-series-visibility",
  "toggle-other-series",
  "separator"
];
var contextMenuItemObjectDef = {
  type: union("action", "separator"),
  showOn: union("always", "series-area", "series-node", "legend-item"),
  label: required(string),
  enabled: boolean,
  action: callback,
  items: (value, context) => contextMenuItemsArray(value, context)
};
contextMenuItemObjectDef.iconUrl = undocumented(string);
var contextMenuItemObjectValidator = optionsDefs(contextMenuItemObjectDef);
var contextMenuItemValidator = attachDescription(
  (value, context) => {
    let result;
    if (typeof value === "string") {
      const allowedValues = contextMenuItemLiterals;
      if (allowedValues.includes(value)) {
        result = true;
      } else {
        result = { valid: false, invalid: [], cleared: null };
        result.invalid.push(
          new ValidationError(
            ErrorType.Invalid,
            `a context menu item string alias: ["${contextMenuItemLiterals.join('", "')}"]`,
            value,
            context.path
          )
        );
      }
    } else {
      result = contextMenuItemObjectValidator(value, context);
    }
    return result;
  },
  `a context menu item object or string alias: [${contextMenuItemLiterals.join(", ")}]`
);
var contextMenuItemsArray = arrayOf(contextMenuItemValidator, "a menu items array", false);
var toolbarButtonOptionsDefs = {
  label: string,
  ariaLabel: string,
  tooltip: string,
  icon: union(
    "align-center",
    "align-left",
    "align-right",
    "arrow-drawing",
    "arrow-down-drawing",
    "arrow-up-drawing",
    "callout-annotation",
    "candlestick-series",
    "close",
    "comment-annotation",
    "date-range-drawing",
    "date-price-range-drawing",
    "delete",
    "disjoint-channel-drawing",
    "drag-handle",
    "fill-color",
    "line-style-solid",
    "line-style-dashed",
    "line-style-dotted",
    "high-low-series",
    "hlc-series",
    "hollow-candlestick-series",
    "horizontal-line-drawing",
    "line-color",
    "line-series",
    "line-with-markers-series",
    "locked",
    "measurer-drawing",
    "note-annotation",
    "ohlc-series",
    "pan-end",
    "pan-left",
    "pan-right",
    "pan-start",
    "parallel-channel-drawing",
    "position-bottom",
    "position-center",
    "position-top",
    "price-label-annotation",
    "price-range-drawing",
    "reset",
    "settings",
    "step-line-series",
    "text-annotation",
    "trend-line-drawing",
    "fibonacci-retracement-drawing",
    "fibonacci-retracement-trend-based-drawing",
    "unlocked",
    "vertical-line-drawing",
    "zoom-in",
    "zoom-out"
  )
};
var formatter = or(string, callbackOf(string));
var formatObjectValidator = optionsDefs({
  x: formatter,
  y: formatter,
  angle: formatter,
  radius: formatter,
  size: formatter,
  color: formatter,
  label: formatter,
  secondaryLabel: formatter,
  sectorLabel: formatter,
  calloutLabel: formatter,
  legendItem: formatter
});
var numberFormatValidator = attachDescription(isValidNumberFormat, "a valid number format string");
var commonChartOptionsDefs = {
  width: positiveNumber,
  height: positiveNumber,
  minWidth: positiveNumber,
  minHeight: positiveNumber,
  suppressFieldDotNotation: boolean,
  title: chartCaptionOptionsDefs,
  subtitle: chartCaptionOptionsDefs,
  footnote: chartCaptionOptionsDefs,
  padding: {
    top: positiveNumber,
    right: positiveNumber,
    bottom: positiveNumber,
    left: positiveNumber
  },
  seriesArea: {
    border: borderOptionsDef,
    clip: boolean,
    cornerRadius: number,
    padding
  },
  legend: {
    enabled: boolean,
    position: legendPositionValidator,
    orientation: union("horizontal", "vertical"),
    maxWidth: positiveNumber,
    maxHeight: positiveNumber,
    spacing: positiveNumber,
    border: borderOptionsDef,
    cornerRadius: number,
    padding,
    fill: colorUnion,
    fillOpacity: ratio,
    preventHidingAll: boolean,
    reverseOrder: boolean,
    toggleSeries: boolean,
    item: {
      marker: {
        size: positiveNumber,
        shape: shapeValidator,
        padding: positiveNumber,
        strokeWidth: positiveNumber
      },
      line: {
        length: positiveNumber,
        strokeWidth: positiveNumber
      },
      label: {
        maxLength: positiveNumber,
        formatter: callback,
        ...fontOptionsDef
      },
      maxWidth: positiveNumber,
      paddingX: positiveNumber,
      paddingY: positiveNumber,
      showSeriesStroke: boolean
    },
    pagination: {
      marker: {
        size: positiveNumber,
        shape: shapeValidator,
        padding: positiveNumber
      },
      activeStyle: {
        ...fillOptionsDef,
        ...strokeOptionsDef
      },
      inactiveStyle: {
        ...fillOptionsDef,
        ...strokeOptionsDef
      },
      highlightStyle: {
        ...fillOptionsDef,
        ...strokeOptionsDef
      },
      label: fontOptionsDef
    },
    listeners: {
      legendItemClick: callback,
      legendItemDoubleClick: callback
    }
  },
  gradientLegend: {
    enabled: boolean,
    position: legendPositionValidator,
    spacing: positiveNumber,
    reverseOrder: boolean,
    border: borderOptionsDef,
    cornerRadius: number,
    padding,
    fill: colorUnion,
    fillOpacity: ratio,
    gradient: {
      preferredLength: positiveNumber,
      thickness: positiveNumber
    },
    scale: {
      label: {
        ...fontOptionsDef,
        minSpacing: positiveNumber,
        format: numberFormatValidator,
        formatter: callback
      },
      padding: positiveNumber,
      interval: {
        step: number,
        values: array,
        minSpacing: and(positiveNumber, lessThan("maxSpacing")),
        maxSpacing: and(positiveNumber, greaterThan("minSpacing"))
      }
    }
  },
  listeners: {
    seriesNodeClick: callback,
    seriesNodeDoubleClick: callback,
    seriesVisibilityChange: callback,
    click: callback,
    doubleClick: callback,
    annotations: callback,
    zoom: callback
  },
  loadGoogleFonts: boolean,
  highlight: {
    range: union("tooltip", "node")
  },
  overlays: {
    loading: chartOverlayOptionsDefs,
    noData: chartOverlayOptionsDefs,
    noVisibleSeries: chartOverlayOptionsDefs,
    unsupportedBrowser: chartOverlayOptionsDefs
  },
  tooltip: {
    enabled: boolean,
    showArrow: boolean,
    pagination: boolean,
    delay: positiveNumber,
    range: rangeValidator,
    wrapping: textWrapValidator,
    mode: union("single", "shared", "compact"),
    position: {
      anchorTo: union("pointer", "node", "chart"),
      placement: or(tooltipPlacementValidator, arrayOf(tooltipPlacementValidator)),
      xOffset: number,
      yOffset: number
    }
  },
  animation: {
    enabled: boolean,
    duration: positiveNumber
  },
  contextMenu: {
    enabled: boolean,
    items: contextMenuItemsArray
  },
  context: () => true,
  dataSource: {
    getData: callback
  },
  keyboard: {
    enabled: boolean,
    tabIndex: number
  },
  touch: {
    dragAction: union("none", "drag", "hover")
  },
  ranges: {
    enabled: boolean,
    buttons: arrayOfDefs(
      {
        ...toolbarButtonOptionsDefs,
        value: or(number, and(arrayOf(or(number, date)), arrayLength(2, 2)), callback)
      },
      "range button options array"
    )
  },
  // modules
  locale: {
    localeText: object,
    getLocaleText: callbackOf(string)
  },
  background: {
    visible: boolean,
    fill: color,
    // enterprise
    image: {
      url: required(string),
      top: number,
      right: number,
      bottom: number,
      left: number,
      width: positiveNumber,
      height: positiveNumber,
      opacity: ratio
    }
  },
  styleNonce: string,
  sync: {
    enabled: boolean,
    groupId: string,
    axes: union("x", "y", "xy"),
    nodeInteraction: boolean,
    zoom: boolean
  },
  zoom: {
    enabled: boolean,
    enableAxisDragging: boolean,
    enableAxisScrolling: boolean,
    enableDoubleClickToReset: boolean,
    enablePanning: boolean,
    enableScrolling: boolean,
    enableSelecting: boolean,
    enableTwoFingerZoom: boolean,
    keepAspectRatio: boolean,
    anchorPointX: zoomAnchorPoint,
    anchorPointY: zoomAnchorPoint,
    axisDraggingMode: union("pan", "zoom"),
    axes: union("x", "y", "xy"),
    deceleration: or(union("off", "short", "long"), ratio),
    minVisibleItems: positiveNumber,
    panKey: union("alt", "ctrl", "meta", "shift"),
    scrollingStep: ratio,
    autoScaling: {
      enabled: boolean,
      padding: ratio
    },
    buttons: {
      enabled: boolean,
      buttons: arrayOfDefs(
        {
          ...toolbarButtonOptionsDefs,
          value: union("reset", "zoom-in", "zoom-out", "pan-left", "pan-right", "pan-start", "pan-end"),
          section: string
        },
        "zoom button options array"
      ),
      visible: union("always", "zoomed", "hover")
    }
  },
  formatter: or(callbackOf(string), formatObjectValidator)
};
commonChartOptionsDefs.dataSource.requestThrottle = undocumented(positiveNumber);
commonChartOptionsDefs.dataSource.updateThrottle = undocumented(positiveNumber);
commonChartOptionsDefs.dataSource.updateDuringInteraction = undocumented(boolean);
commonChartOptionsDefs.zoom.enableIndependentAxes = undocumented(boolean);
commonChartOptionsDefs.statusBar = undocumented(defined);
commonChartOptionsDefs.foreground = undocumented({
  visible: boolean,
  text: string,
  image: {
    url: string,
    top: number,
    right: number,
    bottom: number,
    left: number,
    width: positiveNumber,
    height: positiveNumber,
    opacity: ratio
  },
  ...fillOptionsDef
});
commonChartOptionsDefs.overrideDevicePixelRatio = undocumented(number);
commonChartOptionsDefs.sync.domainMode = undocumented(union("direction", "position", "key"));
var commonSeriesThemeableOptionsDefs = {
  cursor: string,
  context: () => true,
  showInLegend: boolean,
  nodeClickRange: rangeValidator,
  listeners: {
    seriesNodeClick: callback,
    seriesNodeDoubleClick: callback
  },
  // TODO Remove in next major version
  highlightStyle: {
    item: { ...fillOptionsDef, ...strokeOptionsDef },
    series: {
      enabled: boolean,
      dimOpacity: ratio,
      strokeWidth: positiveNumber
    }
  },
  highlight: highlightOptionsDef(shapeHighlightOptionsDef)
};
var commonSeriesOptionsDefs = {
  ...commonSeriesThemeableOptionsDefs,
  id: string,
  visible: boolean,
  context: () => true,
  data: array
};
commonSeriesOptionsDefs.seriesGrouping = undocumented(defined);
var markerOptionsDefs = {
  enabled: boolean,
  shape: shapeValidator,
  size: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    shape: shapeValidator,
    size: positiveNumber
  }),
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var seriesLabelOptionsDefs = {
  enabled: boolean,
  formatter: callback,
  format: numberFormatValidator,
  itemStyler: undocumented(
    callbackDefs({
      enabled: boolean,
      ...labelBoxOptionsDef,
      ...fontOptionsDef
    })
  ),
  ...labelBoxOptionsDef,
  ...fontOptionsDef
};
var autoSizedLabelOptionsDefs = {
  ...seriesLabelOptionsDefs,
  lineHeight: positiveNumber,
  minimumFontSize: positiveNumber,
  wrapping: textWrapValidator,
  overflowStrategy: union("ellipsis", "hide")
};
var errorBarThemeableOptionsDefs = {
  visible: boolean,
  cap: {
    visible: boolean,
    length: positiveNumber,
    lengthRatio: ratio,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var errorBarOptionsDefs = {
  ...errorBarThemeableOptionsDefs,
  xLowerKey: string,
  xUpperKey: string,
  yLowerKey: string,
  yUpperKey: string,
  xLowerName: string,
  xUpperName: string,
  yLowerName: string,
  yUpperName: string,
  itemStyler: callbackDefs({
    visible: boolean,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cap: {
      visible: boolean,
      length: positiveNumber,
      lengthRatio: ratio,
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }
  })
};
var tooltipOptionsDefs = {
  enabled: boolean,
  showArrow: boolean,
  range: rangeValidator,
  renderer: callbackOf(
    or(
      string,
      optionsDefs(
        {
          heading: string,
          title: string,
          data: arrayOfDefs({
            label: required(string),
            value: required(string)
          })
        },
        "tooltip renderer result object"
      )
    )
  ),
  position: {
    anchorTo: union("node", "pointer", "chart"),
    placement: or(tooltipPlacementValidator, arrayOf(tooltipPlacementValidator)),
    xOffset: number,
    yOffset: number
  },
  interaction: {
    enabled: boolean
  }
};
var shadowOptionsDefs = {
  enabled: boolean,
  xOffset: number,
  yOffset: number,
  blur: positiveNumber,
  color
};
var interpolationOptionsDefs = typeUnion(
  {
    linear: {},
    smooth: {
      tension: ratio
    },
    step: {
      position: union("start", "middle", "end")
    }
  },
  "interpolation line options"
);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesOptionsDef.ts
import {
  boolean as boolean2,
  constant,
  fillOptionsDef as fillOptionsDef2,
  lineDashOptionsDef as lineDashOptionsDef2,
  multiSeriesHighlightOptionsDef,
  number as number2,
  required as required2,
  shapeHighlightOptionsDef as shapeHighlightOptionsDef2,
  string as string2,
  strokeOptionsDef as strokeOptionsDef2
} from "ag-charts-core";
var highlight = multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef2, shapeHighlightOptionsDef2);
var areaSeriesThemeableOptionsDef = {
  showInMiniChart: boolean2,
  connectMissingData: boolean2,
  interpolation: interpolationOptionsDefs,
  label: seriesLabelOptionsDefs,
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef2,
  ...strokeOptionsDef2,
  ...lineDashOptionsDef2,
  highlight
};
var areaSeriesOptionsDef = {
  ...areaSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  highlight,
  type: required2(constant("area")),
  xKey: required2(string2),
  yKey: required2(string2),
  xName: string2,
  yName: string2,
  stacked: boolean2,
  stackGroup: string2,
  normalizedTo: number2
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesOptionsDef.ts
import {
  barHighlightOptionsDef,
  boolean as boolean3,
  callbackDefs as callbackDefs2,
  constant as constant2,
  fillOptionsDef as fillOptionsDef3,
  lineDashOptionsDef as lineDashOptionsDef3,
  multiSeriesHighlightOptionsDef as multiSeriesHighlightOptionsDef2,
  number as number3,
  positiveNumber as positiveNumber2,
  required as required3,
  string as string3,
  strokeOptionsDef as strokeOptionsDef3,
  undocumented as undocumented2,
  union as union2
} from "ag-charts-core";
var highlight2 = multiSeriesHighlightOptionsDef2(barHighlightOptionsDef, barHighlightOptionsDef);
var barSeriesThemeableOptionsDef = {
  direction: union2("horizontal", "vertical"),
  showInMiniChart: boolean3,
  cornerRadius: positiveNumber2,
  itemStyler: callbackDefs2({
    ...fillOptionsDef3,
    ...strokeOptionsDef3,
    ...lineDashOptionsDef3,
    cornerRadius: positiveNumber2
  }),
  crisp: boolean3,
  label: {
    ...seriesLabelOptionsDefs,
    placement: union2("inside-center", "inside-start", "inside-end", "outside-start", "outside-end"),
    spacing: positiveNumber2
  },
  errorBar: errorBarThemeableOptionsDefs,
  shadow: shadowOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  highlight: highlight2,
  ...fillOptionsDef3,
  ...strokeOptionsDef3,
  ...lineDashOptionsDef3
};
barSeriesThemeableOptionsDef.sparklineMode = undocumented2(boolean3);
var barSeriesOptionsDef = {
  ...barSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  highlight: highlight2,
  type: required3(constant2("bar")),
  xKey: required3(string3),
  yKey: required3(string3),
  xName: string3,
  yName: string3,
  direction: union2("horizontal", "vertical"),
  grouped: boolean3,
  stacked: boolean3,
  stackGroup: string3,
  normalizedTo: number3,
  legendItemName: string3,
  errorBar: errorBarOptionsDefs
};
barSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented2(boolean3);
barSeriesOptionsDef.focusPriority = undocumented2(number3);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesOptionsDef.ts
import {
  boolean as boolean4,
  constant as constant3,
  lineDashOptionsDef as lineDashOptionsDef4,
  lineHighlightOptionsDef,
  multiSeriesHighlightOptionsDef as multiSeriesHighlightOptionsDef3,
  number as number4,
  required as required4,
  shapeHighlightOptionsDef as shapeHighlightOptionsDef3,
  string as string4,
  strokeOptionsDef as strokeOptionsDef4,
  undocumented as undocumented3
} from "ag-charts-core";
var highlight3 = multiSeriesHighlightOptionsDef3(shapeHighlightOptionsDef3, lineHighlightOptionsDef);
var lineSeriesThemeableOptionsDef = {
  title: string4,
  showInMiniChart: boolean4,
  connectMissingData: boolean4,
  interpolation: interpolationOptionsDefs,
  label: seriesLabelOptionsDefs,
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  errorBar: errorBarThemeableOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...strokeOptionsDef4,
  ...lineDashOptionsDef4,
  highlight: highlight3
};
lineSeriesThemeableOptionsDef.sparklineMode = undocumented3(boolean4);
var lineSeriesOptionsDef = {
  ...lineSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  highlight: highlight3,
  type: required4(constant3("line")),
  xKey: required4(string4),
  yKey: required4(string4),
  xName: string4,
  yName: string4,
  stacked: boolean4,
  stackGroup: string4,
  normalizedTo: number4,
  legendItemName: string4,
  errorBar: errorBarOptionsDefs
};
lineSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented3(boolean4);
lineSeriesOptionsDef.focusPriority = undocumented3(number4);

// packages/ag-charts-community/src/util/object.ts
import { entries, isArray, isObject, isPlainObject } from "ag-charts-core";

// packages/ag-charts-community/src/util/decorator.ts
var BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
var CONFIG_KEY = "__decorator_config";
var ACCESSORS_KEY = "__decorator_accessors";
function addFakeTransformToInstanceProperty(target, propertyKeyOrSymbol) {
  initialiseConfig(target, propertyKeyOrSymbol).optional = true;
}
function initialiseConfig(target, propertyKeyOrSymbol) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, { value: {} });
  }
  if (Object.getOwnPropertyDescriptor(target, ACCESSORS_KEY) == null) {
    const parentAccessors = Object.getPrototypeOf(target)?.[ACCESSORS_KEY];
    const accessors = parentAccessors?.slice() ?? [];
    Object.defineProperty(target, ACCESSORS_KEY, { value: accessors });
  }
  const config = target[CONFIG_KEY];
  const propertyKey = propertyKeyOrSymbol.toString();
  if (config[propertyKey] != null) {
    return config[propertyKey];
  }
  config[propertyKey] = { setters: [], getters: [], observers: [] };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  let prevGet = descriptor?.get;
  let prevSet = descriptor?.set;
  if (prevGet == null || prevSet == null) {
    const accessors = target[ACCESSORS_KEY];
    let index = accessors.indexOf(propertyKeyOrSymbol);
    if (index === -1) {
      index = accessors.push(propertyKeyOrSymbol) - 1;
    }
    prevGet ?? (prevGet = function() {
      let accessorValues = this.__accessors;
      if (accessorValues == null) {
        accessorValues = accessors.slice().fill(void 0);
        Object.defineProperty(this, "__accessors", { value: accessorValues });
      }
      return accessorValues[index];
    });
    prevSet ?? (prevSet = function(value) {
      let accessorValues = this.__accessors;
      if (accessorValues == null) {
        accessorValues = accessors.slice().fill(void 0);
        Object.defineProperty(this, "__accessors", { value: accessorValues });
      }
      accessorValues[index] = value;
    });
  }
  const getter = function() {
    let value = prevGet.call(this);
    for (const transformFn of config[propertyKey].getters) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    return value;
  };
  const setter = function(value) {
    const { setters, observers } = config[propertyKey];
    let oldValue;
    if (setters.some((f) => f.length > 2)) {
      oldValue = prevGet.call(this);
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    prevSet.call(this, value);
    for (const observerFn of observers) {
      observerFn(this, value, oldValue);
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
  return (target, propertyKeyOrSymbol) => {
    const config = initialiseConfig(target, propertyKeyOrSymbol);
    config.setters.push(setTransform);
    if (getTransform) {
      config.getters.unshift(getTransform);
    }
    if (configMetadata) {
      Object.assign(config, configMetadata);
    }
  };
}
function addObserverToInstanceProperty(setObserver) {
  return (target, propertyKeyOrSymbol) => {
    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
  };
}
function isDecoratedObject(target) {
  return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
  const targets = /* @__PURE__ */ new Set();
  while (isDecoratedObject(target)) {
    targets.add(target?.[CONFIG_KEY]);
    target = Object.getPrototypeOf(target);
  }
  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));
}
function extractDecoratedProperties(target) {
  return listDecoratedProperties(target).reduce((result, key) => {
    result[String(key)] = target[key] ?? null;
    return result;
  }, {});
}

// packages/ag-charts-community/src/util/object.ts
function objectsEqual(a, b) {
  if (Array.isArray(a)) {
    if (!Array.isArray(b))
      return false;
    if (a.length !== b.length)
      return false;
    return a.every((av, i) => objectsEqual(av, b[i]));
  } else if (isPlainObject(a)) {
    if (!isPlainObject(b))
      return false;
    return objectsEqualWith(a, b, objectsEqual);
  }
  return a === b;
}
function objectsEqualWith(a, b, cmp2) {
  if (Object.is(a, b))
    return true;
  for (const key of Object.keys(b)) {
    if (!(key in a))
      return false;
  }
  for (const key of Object.keys(a)) {
    if (!(key in b))
      return false;
    if (!cmp2(a[key], b[key]))
      return false;
  }
  return true;
}
function mergeDefaults(...sources) {
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = mergeDefaults(target[key], source[key]);
      } else {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function merge(...sources) {
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = merge(target[key], source[key]);
      } else if (!(key in target)) {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function mergeArrayDefaults(dataArray, ...itemDefaults) {
  if (itemDefaults && isArray(dataArray)) {
    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));
  }
  return dataArray;
}
function without(object3, keys) {
  const clone2 = { ...object3 };
  for (const key of keys) {
    delete clone2[key];
  }
  return clone2;
}
function getPath(object3, path) {
  const pathArray = isArray(path) ? path : path.split(".");
  return pathArray.reduce((value, pathKey) => value[pathKey], object3);
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function setPath(object3, path, newValue) {
  const pathArray = isArray(path) ? path.slice() : path.split(".");
  const lastKey = pathArray.pop();
  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))
    return;
  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object3);
  lastObject[lastKey] = newValue;
  return lastObject[lastKey];
}
function partialAssign(keysToCopy, target, source) {
  if (source === void 0) {
    return target;
  }
  for (const key of keysToCopy) {
    const value = source[key];
    if (value !== void 0) {
      target[key] = value;
    }
  }
  return target;
}
function deepFreeze(obj) {
  if (obj == null || typeof obj !== "object" || !isPlainObject(obj)) {
    return obj;
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach((prop) => {
    const value = obj[prop];
    if (value !== null && (typeof value === "object" || typeof value === "function") && !Object.isFrozen(value)) {
      deepFreeze(value);
    }
  });
  return obj;
}

// packages/ag-charts-community/src/api/preset/presetUtils.ts
var IGNORED_PROP = Symbol("IGNORED_PROP");
function pickProps(opts, values) {
  const out = {};
  for (const key of Object.keys(values)) {
    const value = values[key];
    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {
      out[key] = value;
    }
  }
  return out;
}

// packages/ag-charts-community/src/api/preset/gauge.ts
function tooltipOptions(opts) {
  const { enabled, mode, showArrow, range: range3, position, pagination, delay, wrapping, interaction, renderer, ...rest } = opts;
  const seriesTooltipOptions = pickProps(opts, {
    enabled,
    showArrow,
    range: range3,
    position,
    interaction,
    renderer,
    ...rest
  });
  const chartTooltipOptions = pickProps(opts, {
    enabled: IGNORED_PROP,
    showArrow: IGNORED_PROP,
    range: IGNORED_PROP,
    position: IGNORED_PROP,
    mode,
    pagination,
    delay,
    wrapping,
    ...rest
  });
  return { chartTooltipOptions, seriesTooltipOptions };
}
function radialGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    width: width2,
    type,
    cursor,
    nodeClickRange,
    tooltip = {},
    value,
    scale: scale2 = {},
    startAngle,
    endAngle,
    // eslint-disable-next-line sonarjs/deprecation
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    needle,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  } = opts;
  const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    tooltip: chartTooltipOptions,
    width: width2
  });
  const seriesOpts = pickProps(opts, {
    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,
    startAngle,
    endAngle,
    scale: scale2,
    type,
    cursor,
    context,
    nodeClickRange,
    tooltip: seriesTooltipOptions,
    value,
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  });
  return {
    ...chartOpts,
    series: [seriesOpts]
  };
}
function linearGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    width: width2,
    type,
    cursor,
    nodeClickRange,
    tooltip = {},
    value,
    scale: scale2 = {},
    direction = "vertical",
    thickness,
    // eslint-disable-next-line sonarjs/deprecation
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  } = opts;
  const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    tooltip: chartTooltipOptions,
    width: width2
  });
  const seriesOpts = pickProps(opts, {
    scale: scale2,
    type,
    cursor,
    context,
    nodeClickRange,
    tooltip: seriesTooltipOptions,
    value,
    direction,
    thickness,
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  });
  return {
    ...chartOpts,
    series: [seriesOpts]
  };
}
function applyThemeDefaults(opts, presetTheme) {
  if (presetTheme == null)
    return opts;
  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;
  opts = mergeDefaults(opts, gaugeTheme);
  if (opts.targets != null && targetsTheme != null) {
    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);
  }
  return opts;
}
function gauge(opts, presetTheme) {
  switch (opts.type) {
    case "radial-gauge":
      return radialGaugeOptions(applyThemeDefaults(opts, presetTheme));
    case "linear-gauge":
      return linearGaugeOptions(applyThemeDefaults(opts, presetTheme));
    default:
      return {};
  }
}

// packages/ag-charts-community/src/api/preset/gaugeOptionsDefs.ts
import {
  and as and2,
  arrayLength as arrayLength2,
  arrayOf as arrayOf2,
  arrayOfDefs as arrayOfDefs2,
  boolean as boolean5,
  callback as callback2,
  color as color2,
  colorStopsOrderValidator,
  constant as constant4,
  fillOptionsDef as fillOptionsDef4,
  fontOptionsDef as fontOptionsDef2,
  greaterThan as greaterThan2,
  lessThan as lessThan2,
  lineDashOptionsDef as lineDashOptionsDef5,
  number as number5,
  optionsDefs as optionsDefs2,
  or as or2,
  positiveNumber as positiveNumber3,
  ratio as ratio2,
  required as required5,
  string as string5,
  strokeOptionsDef as strokeOptionsDef5,
  undocumented as undocumented4,
  union as union3
} from "ag-charts-core";
var fillsOptionsDef = {
  fills: and2(
    arrayLength2(2),
    arrayOf2(optionsDefs2({ color: color2, stop: number5 }, "")),
    colorStopsOrderValidator
  ),
  fillMode: union3("continuous", "discrete")
};
var linearGaugeTargetOptionsDef = {
  value: required5(number5),
  text: string5,
  shape: or2(
    union3("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"),
    callback2
  ),
  placement: union3("before", "after", "middle"),
  spacing: positiveNumber3,
  size: positiveNumber3,
  rotation: number5,
  ...fillOptionsDef4,
  ...strokeOptionsDef5,
  ...lineDashOptionsDef5
};
var radialGaugeTargetOptionsDef = {
  value: required5(number5),
  text: string5,
  shape: or2(
    union3("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"),
    callback2
  ),
  placement: union3("inside", "outside", "middle"),
  spacing: positiveNumber3,
  size: positiveNumber3,
  rotation: number5,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: positiveNumber3
  },
  ...fillOptionsDef4,
  ...strokeOptionsDef5,
  ...lineDashOptionsDef5
};
var linearGaugeSeriesThemeableOptionsDef = {
  direction: union3("horizontal", "vertical"),
  cornerMode: union3("container", "item"),
  cornerRadius: positiveNumber3,
  thickness: positiveNumber3,
  segmentation: {
    enabled: boolean5,
    spacing: positiveNumber3,
    interval: {
      values: arrayOf2(number5),
      step: number5,
      count: number5
    }
  },
  bar: {
    enabled: boolean5,
    thickness: positiveNumber3,
    thicknessRatio: ratio2,
    ...fillsOptionsDef,
    ...fillOptionsDef4,
    ...strokeOptionsDef5,
    ...lineDashOptionsDef5
  },
  label: {
    ...autoSizedLabelOptionsDefs,
    text: string5,
    spacing: positiveNumber3,
    avoidCollisions: boolean5,
    placement: union3(
      "inside-start",
      "outside-start",
      "inside-end",
      "outside-end",
      "inside-center",
      "bar-inside",
      "bar-inside-end",
      "bar-outside-end",
      "bar-end"
    )
  },
  tooltip: tooltipOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["listeners"])
};
var linearGaugeSeriesOptionsDef = {
  ...linearGaugeSeriesThemeableOptionsDef,
  ...without(commonSeriesOptionsDefs, ["listeners"]),
  type: required5(constant4("linear-gauge")),
  value: required5(number5),
  scale: {
    min: and2(number5, lessThan2("max")),
    max: and2(number5, greaterThan2("min")),
    label: {
      enabled: boolean5,
      formatter: callback2,
      rotation: number5,
      spacing: positiveNumber3,
      minSpacing: positiveNumber3,
      placement: union3("before", "after"),
      avoidCollisions: boolean5,
      format: numberFormatValidator,
      ...fontOptionsDef2
    },
    interval: {
      values: arrayOf2(number5),
      step: number5
    },
    ...fillsOptionsDef,
    ...fillOptionsDef4,
    ...strokeOptionsDef5,
    ...lineDashOptionsDef5
  },
  targets: arrayOfDefs2(linearGaugeTargetOptionsDef, "target options array")
};
linearGaugeSeriesOptionsDef.margin = undocumented4(number5);
linearGaugeSeriesOptionsDef.defaultColorRange = undocumented4(arrayOf2(color2));
linearGaugeSeriesOptionsDef.defaultTarget = undocumented4({
  ...linearGaugeTargetOptionsDef,
  value: number5,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: number5
  }
});
linearGaugeSeriesOptionsDef.defaultScale = undocumented4(linearGaugeSeriesOptionsDef.scale);
linearGaugeSeriesOptionsDef.scale.defaultFill = undocumented4(color2);
var radialGaugeSeriesThemeableOptionsDef = {
  outerRadius: positiveNumber3,
  innerRadius: positiveNumber3,
  outerRadiusRatio: ratio2,
  innerRadiusRatio: ratio2,
  startAngle: number5,
  endAngle: number5,
  spacing: positiveNumber3,
  cornerMode: union3("container", "item"),
  cornerRadius: positiveNumber3,
  scale: {
    min: and2(number5, lessThan2("max")),
    max: and2(number5, greaterThan2("min")),
    label: {
      enabled: boolean5,
      formatter: callback2,
      rotation: number5,
      spacing: positiveNumber3,
      minSpacing: positiveNumber3,
      avoidCollisions: boolean5,
      format: numberFormatValidator,
      ...fontOptionsDef2
    },
    interval: {
      values: arrayOf2(number5),
      step: number5
    },
    ...fillsOptionsDef,
    ...fillOptionsDef4,
    ...strokeOptionsDef5,
    ...lineDashOptionsDef5
  },
  segmentation: {
    enabled: boolean5,
    spacing: positiveNumber3,
    interval: {
      values: arrayOf2(number5),
      step: number5,
      count: number5
    }
  },
  bar: {
    enabled: boolean5,
    ...fillsOptionsDef,
    ...fillOptionsDef4,
    ...strokeOptionsDef5,
    ...lineDashOptionsDef5
  },
  needle: {
    enabled: boolean5,
    spacing: positiveNumber3,
    radiusRatio: ratio2,
    ...fillOptionsDef4,
    ...strokeOptionsDef5,
    ...lineDashOptionsDef5
  },
  label: {
    text: string5,
    spacing: positiveNumber3,
    ...autoSizedLabelOptionsDefs
  },
  secondaryLabel: {
    text: string5,
    ...autoSizedLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs
};
var radialGaugeSeriesOptionsDef = {
  ...radialGaugeSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required5(constant4("radial-gauge")),
  value: required5(number5),
  targets: arrayOfDefs2(radialGaugeTargetOptionsDef, "target options array")
};
radialGaugeSeriesOptionsDef.defaultColorRange = undocumented4(arrayOf2(color2));
radialGaugeSeriesOptionsDef.defaultTarget = undocumented4({
  ...radialGaugeTargetOptionsDef,
  value: number5,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: number5
  }
});
radialGaugeSeriesOptionsDef.scale.defaultFill = undocumented4(color2);

// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
import { Logger } from "ag-charts-core";

// packages/ag-charts-community/src/chart/themes/symbols.ts
var IS_DARK_THEME = Symbol("is-dark-theme");
var DEFAULT_SEPARATION_LINES_COLOUR = Symbol("default-separation-lines-colour");
var DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
var DEFAULT_CAPTION_LAYOUT_STYLE = Symbol("default-caption-layout-style");
var DEFAULT_CAPTION_ALIGNMENT = Symbol("default-caption-alignment");
var PALETTE_UP_STROKE = Symbol("palette-up-stroke");
var PALETTE_DOWN_STROKE = Symbol("palette-down-stroke");
var PALETTE_UP_FILL = Symbol("palette-up-fill");
var PALETTE_DOWN_FILL = Symbol("palette-down-fill");
var PALETTE_NEUTRAL_STROKE = Symbol("palette-neutral-stroke");
var PALETTE_NEUTRAL_FILL = Symbol("palette-neutral-fill");
var PALETTE_ALT_UP_STROKE = Symbol("palette-alt-up-stroke");
var PALETTE_ALT_DOWN_STROKE = Symbol("palette-alt-down-stroke");
var PALETTE_ALT_UP_FILL = Symbol("palette-alt-up-fill");
var PALETTE_ALT_DOWN_FILL = Symbol("palette-alt-down-fill");
var PALETTE_ALT_NEUTRAL_FILL = Symbol("palette-gray-fill");
var PALETTE_ALT_NEUTRAL_STROKE = Symbol("palette-gray-stroke");
var DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
var DEFAULT_SPARKLINE_CROSSHAIR_STROKE = Symbol("default-sparkline-crosshair-stroke");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR = Symbol(
  "default-financial-charts-annotation-stroke"
);
var DEFAULT_FIBONACCI_STROKES = Symbol("default-hierarchy-strokes");
var DEFAULT_TEXT_ANNOTATION_COLOR = Symbol("default-text-annotation-color");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL = Symbol(
  "default-financial-charts-annotation-background-fill"
);
var DEFAULT_ANNOTATION_HANDLE_FILL = Symbol("default-annotation-handle-fill");
var DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol("default-annotation-statistics-fill");
var DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol("default-annotation-statistics-stroke");
var DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol("default-annotation-statistics-color");
var DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(
  "default-annotation-statistics-divider-stroke"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(
  "default-annotation-statistics-fill"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(
  "default-annotation-statistics-stroke"
);
var DEFAULT_TEXTBOX_FILL = Symbol("default-textbox-fill");
var DEFAULT_TEXTBOX_STROKE = Symbol("default-textbox-stroke");
var DEFAULT_TEXTBOX_COLOR = Symbol("default-textbox-color");
var DEFAULT_TOOLBAR_POSITION = Symbol("default-toolbar-position");
var DEFAULT_GRIDLINE_ENABLED = Symbol("default-gridline-enabled");

// packages/ag-charts-community/src/util/color.ts
import { clamp } from "ag-charts-core";
var lerp = (x, y, t) => x * (1 - t) + y * t;
var srgbToLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs <= 0.04045)
    return value / 12.92;
  return sign * ((abs + 0.055) / 1.055) ** 2.4;
};
var srgbFromLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs > 31308e-7) {
    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
  }
  return 12.92 * value;
};
var _Color = class _Color {
  /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */
  constructor(r, g, b, a = 1) {
    this.r = clamp(0, r || 0, 1);
    this.g = clamp(0, g || 0, 1);
    this.b = clamp(0, b || 0, 1);
    this.a = clamp(0, a || 0, 1);
  }
  /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */
  static validColorString(str) {
    if (str.indexOf("#") >= 0) {
      return !!_Color.parseHex(str);
    }
    if (str.indexOf("rgb") >= 0) {
      return !!_Color.stringToRgba(str);
    }
    return _Color.nameToHex.has(str.toLowerCase());
  }
  /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */
  static fromString(str) {
    if (str.indexOf("#") >= 0) {
      return _Color.fromHexString(str);
    }
    const hex = _Color.nameToHex.get(str.toLowerCase());
    if (hex) {
      return _Color.fromHexString(hex);
    }
    if (str.indexOf("rgb") >= 0) {
      return _Color.fromRgbaString(str);
    }
    throw new Error(`Invalid color string: '${str}'`);
  }
  // See https://drafts.csswg.org/css-color/#hex-notation
  static parseHex(input) {
    input = input.replace(/ /g, "").slice(1);
    let parts;
    switch (input.length) {
      case 6:
      case 8:
        parts = [];
        for (let i = 0; i < input.length; i += 2) {
          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
        }
        break;
      case 3:
      case 4:
        parts = input.split("").map((p) => parseInt(p, 16)).map((p) => p + p * 16);
        break;
    }
    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {
      if (parts.length === 3) {
        parts.push(255);
      }
      return parts;
    }
  }
  static fromHexString(str) {
    const values = _Color.parseHex(str);
    if (values) {
      const [r, g, b, a] = values;
      return new _Color(r / 255, g / 255, b / 255, a / 255);
    }
    throw new Error(`Malformed hexadecimal color string: '${str}'`);
  }
  static stringToRgba(str) {
    let po = -1;
    let pc = -1;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (po === -1 && c === "(") {
        po = i;
      } else if (c === ")") {
        pc = i;
        break;
      }
    }
    if (po === -1 || pc === -1)
      return;
    const contents = str.substring(po + 1, pc);
    const parts = contents.split(",");
    const rgba = [];
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      let value = parseFloat(part);
      if (!Number.isFinite(value)) {
        return;
      }
      if (part.indexOf("%") >= 0) {
        value = clamp(0, value, 100);
        value /= 100;
      } else if (i === 3) {
        value = clamp(0, value, 1);
      } else {
        value = clamp(0, value, 255);
        value /= 255;
      }
      rgba.push(value);
    }
    return rgba;
  }
  static fromRgbaString(str) {
    const rgba = _Color.stringToRgba(str);
    if (rgba) {
      if (rgba.length === 3) {
        return new _Color(rgba[0], rgba[1], rgba[2]);
      } else if (rgba.length === 4) {
        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
    }
    throw new Error(`Malformed rgb/rgba color string: '${str}'`);
  }
  static fromArray(arr) {
    if (arr.length === 4) {
      return new _Color(arr[0], arr[1], arr[2], arr[3]);
    }
    if (arr.length === 3) {
      return new _Color(arr[0], arr[1], arr[2]);
    }
    throw new Error("The given array should contain 3 or 4 color components (numbers).");
  }
  static fromHSB(h, s, b, alpha = 1) {
    const rgb = _Color.HSBtoRGB(h, s, b);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromHSL(h, s, l, alpha = 1) {
    const rgb = _Color.HSLtoRGB(h, s, l);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromOKLCH(l, c, h, alpha = 1) {
    const rgb = _Color.OKLCHtoRGB(l, c, h);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static padHex(str) {
    return str.length === 1 ? "0" + str : str;
  }
  toHexString() {
    let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
    if (this.a < 1) {
      hex += _Color.padHex(Math.round(this.a * 255).toString(16));
    }
    return hex;
  }
  toRgbaString(fractionDigits = 3) {
    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
    const k = Math.pow(10, fractionDigits);
    if (this.a !== 1) {
      components.push(Math.round(this.a * k) / k);
      return `rgba(${components.join(", ")})`;
    }
    return `rgb(${components.join(", ")})`;
  }
  toString() {
    if (this.a === 1) {
      return this.toHexString();
    }
    return this.toRgbaString();
  }
  toHSB() {
    return _Color.RGBtoHSB(this.r, this.g, this.b);
  }
  static RGBtoOKLCH(r, g, b) {
    const LSRGB0 = srgbToLinear(r);
    const LSRGB1 = srgbToLinear(g);
    const LSRGB2 = srgbToLinear(b);
    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
    const OKLCH0 = OKLAB0;
    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
    const OKLCH2 = hue >= 0 ? hue : hue + 360;
    return [OKLCH0, OKLCH1, OKLCH2];
  }
  static OKLCHtoRGB(l, c, h) {
    const OKLAB0 = l;
    const OKLAB1 = c * Math.cos(h * Math.PI / 180);
    const OKLAB2 = c * Math.sin(h * Math.PI / 180);
    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;
    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;
    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;
    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
    const SRGB0 = srgbFromLinear(LSRGB0);
    const SRGB1 = srgbFromLinear(LSRGB1);
    const SRGB2 = srgbFromLinear(LSRGB2);
    return [SRGB0, SRGB1, SRGB2];
  }
  static RGBtoHSL(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const l = (max + min) / 2;
    let h;
    let s;
    if (max === min) {
      h = 0;
      s = 0;
    } else {
      const delta3 = max - min;
      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);
      if (max === r) {
        h = (g - b) / delta3 + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / delta3 + 2;
      } else {
        h = (r - g) / delta3 + 4;
      }
      h *= 360 / 6;
    }
    return [h, s, l];
  }
  static HSLtoRGB(h, s, l) {
    h = (h % 360 + 360) % 360;
    if (s === 0) {
      return [l, l, l];
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    function hueToRgb(t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    const r = hueToRgb(h / 360 + 1 / 3);
    const g = hueToRgb(h / 360);
    const b = hueToRgb(h / 360 - 1 / 3);
    return [r, g, b];
  }
  /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   */
  static RGBtoHSB(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const S = max === 0 ? 0 : (max - min) / max;
    let H = 0;
    if (min !== max) {
      const delta3 = max - min;
      const rc = (max - r) / delta3;
      const gc = (max - g) / delta3;
      const bc = (max - b) / delta3;
      if (r === max) {
        H = bc - gc;
      } else if (g === max) {
        H = 2 + rc - bc;
      } else {
        H = 4 + gc - rc;
      }
      H /= 6;
      if (H < 0) {
        H = H + 1;
      }
    }
    return [H * 360, S, max];
  }
  /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */
  static HSBtoRGB(H, S, B) {
    H = (H % 360 + 360) % 360 / 360;
    let r = 0;
    let g = 0;
    let b = 0;
    if (S === 0) {
      r = g = b = B;
    } else {
      const h = (H - Math.floor(H)) * 6;
      const f = h - Math.floor(h);
      const p = B * (1 - S);
      const q = B * (1 - S * f);
      const t = B * (1 - S * (1 - f));
      switch (h >> 0) {
        case 0:
          r = B;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = B;
          b = p;
          break;
        case 2:
          r = p;
          g = B;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = B;
          break;
        case 4:
          r = t;
          g = p;
          b = B;
          break;
        case 5:
          r = B;
          g = p;
          b = q;
          break;
      }
    }
    return [r, g, b];
  }
  static mix(c0, c1, t) {
    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));
  }
  static lighten(c, t) {
    const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
    return _Color.fromOKLCH(clamp(0, oklch[0] + t, 1), oklch[1], oklch[2]);
  }
  static darken(c, t) {
    const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
    return _Color.fromOKLCH(clamp(0, oklch[0] - t, 1), oklch[1], oklch[2]);
  }
  static interpolate(colors, count) {
    const step = 1 / (colors.length - 1);
    const oklchColors = colors.map((c) => _Color.RGBtoOKLCH(c.r, c.g, c.b));
    return Array.from({ length: count }, (_, i) => {
      const t = i / (count - 1);
      const index = colors.length <= 2 ? 0 : Math.min(Math.floor(t * (colors.length - 1)), colors.length - 2);
      const q = (t - index * step) / step;
      const c0 = oklchColors[index];
      const c1 = oklchColors[index + 1];
      return _Color.fromOKLCH(lerp(c0[0], c1[0], q), lerp(c0[1], c1[1], q), lerp(c0[2], c1[2], q));
    });
  }
};
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */
_Color.nameToHex = /* @__PURE__ */ new Map([
  ["aliceblue", "#F0F8FF"],
  ["antiquewhite", "#FAEBD7"],
  ["aqua", "#00FFFF"],
  ["aquamarine", "#7FFFD4"],
  ["azure", "#F0FFFF"],
  ["beige", "#F5F5DC"],
  ["bisque", "#FFE4C4"],
  ["black", "#000000"],
  ["blanchedalmond", "#FFEBCD"],
  ["blue", "#0000FF"],
  ["blueviolet", "#8A2BE2"],
  ["brown", "#A52A2A"],
  ["burlywood", "#DEB887"],
  ["cadetblue", "#5F9EA0"],
  ["chartreuse", "#7FFF00"],
  ["chocolate", "#D2691E"],
  ["coral", "#FF7F50"],
  ["cornflowerblue", "#6495ED"],
  ["cornsilk", "#FFF8DC"],
  ["crimson", "#DC143C"],
  ["cyan", "#00FFFF"],
  ["darkblue", "#00008B"],
  ["darkcyan", "#008B8B"],
  ["darkgoldenrod", "#B8860B"],
  ["darkgray", "#A9A9A9"],
  ["darkgreen", "#006400"],
  ["darkgrey", "#A9A9A9"],
  ["darkkhaki", "#BDB76B"],
  ["darkmagenta", "#8B008B"],
  ["darkolivegreen", "#556B2F"],
  ["darkorange", "#FF8C00"],
  ["darkorchid", "#9932CC"],
  ["darkred", "#8B0000"],
  ["darksalmon", "#E9967A"],
  ["darkseagreen", "#8FBC8F"],
  ["darkslateblue", "#483D8B"],
  ["darkslategray", "#2F4F4F"],
  ["darkslategrey", "#2F4F4F"],
  ["darkturquoise", "#00CED1"],
  ["darkviolet", "#9400D3"],
  ["deeppink", "#FF1493"],
  ["deepskyblue", "#00BFFF"],
  ["dimgray", "#696969"],
  ["dimgrey", "#696969"],
  ["dodgerblue", "#1E90FF"],
  ["firebrick", "#B22222"],
  ["floralwhite", "#FFFAF0"],
  ["forestgreen", "#228B22"],
  ["fuchsia", "#FF00FF"],
  ["gainsboro", "#DCDCDC"],
  ["ghostwhite", "#F8F8FF"],
  ["gold", "#FFD700"],
  ["goldenrod", "#DAA520"],
  ["gray", "#808080"],
  ["green", "#008000"],
  ["greenyellow", "#ADFF2F"],
  ["grey", "#808080"],
  ["honeydew", "#F0FFF0"],
  ["hotpink", "#FF69B4"],
  ["indianred", "#CD5C5C"],
  ["indigo", "#4B0082"],
  ["ivory", "#FFFFF0"],
  ["khaki", "#F0E68C"],
  ["lavender", "#E6E6FA"],
  ["lavenderblush", "#FFF0F5"],
  ["lawngreen", "#7CFC00"],
  ["lemonchiffon", "#FFFACD"],
  ["lightblue", "#ADD8E6"],
  ["lightcoral", "#F08080"],
  ["lightcyan", "#E0FFFF"],
  ["lightgoldenrodyellow", "#FAFAD2"],
  ["lightgray", "#D3D3D3"],
  ["lightgreen", "#90EE90"],
  ["lightgrey", "#D3D3D3"],
  ["lightpink", "#FFB6C1"],
  ["lightsalmon", "#FFA07A"],
  ["lightseagreen", "#20B2AA"],
  ["lightskyblue", "#87CEFA"],
  ["lightslategray", "#778899"],
  ["lightslategrey", "#778899"],
  ["lightsteelblue", "#B0C4DE"],
  ["lightyellow", "#FFFFE0"],
  ["lime", "#00FF00"],
  ["limegreen", "#32CD32"],
  ["linen", "#FAF0E6"],
  ["magenta", "#FF00FF"],
  ["maroon", "#800000"],
  ["mediumaquamarine", "#66CDAA"],
  ["mediumblue", "#0000CD"],
  ["mediumorchid", "#BA55D3"],
  ["mediumpurple", "#9370DB"],
  ["mediumseagreen", "#3CB371"],
  ["mediumslateblue", "#7B68EE"],
  ["mediumspringgreen", "#00FA9A"],
  ["mediumturquoise", "#48D1CC"],
  ["mediumvioletred", "#C71585"],
  ["midnightblue", "#191970"],
  ["mintcream", "#F5FFFA"],
  ["mistyrose", "#FFE4E1"],
  ["moccasin", "#FFE4B5"],
  ["navajowhite", "#FFDEAD"],
  ["navy", "#000080"],
  ["oldlace", "#FDF5E6"],
  ["olive", "#808000"],
  ["olivedrab", "#6B8E23"],
  ["orange", "#FFA500"],
  ["orangered", "#FF4500"],
  ["orchid", "#DA70D6"],
  ["palegoldenrod", "#EEE8AA"],
  ["palegreen", "#98FB98"],
  ["paleturquoise", "#AFEEEE"],
  ["palevioletred", "#DB7093"],
  ["papayawhip", "#FFEFD5"],
  ["peachpuff", "#FFDAB9"],
  ["peru", "#CD853F"],
  ["pink", "#FFC0CB"],
  ["plum", "#DDA0DD"],
  ["powderblue", "#B0E0E6"],
  ["purple", "#800080"],
  ["rebeccapurple", "#663399"],
  ["red", "#FF0000"],
  ["rosybrown", "#BC8F8F"],
  ["royalblue", "#4169E1"],
  ["saddlebrown", "#8B4513"],
  ["salmon", "#FA8072"],
  ["sandybrown", "#F4A460"],
  ["seagreen", "#2E8B57"],
  ["seashell", "#FFF5EE"],
  ["sienna", "#A0522D"],
  ["silver", "#C0C0C0"],
  ["skyblue", "#87CEEB"],
  ["slateblue", "#6A5ACD"],
  ["slategray", "#708090"],
  ["slategrey", "#708090"],
  ["snow", "#FFFAFA"],
  ["springgreen", "#00FF7F"],
  ["steelblue", "#4682B4"],
  ["tan", "#D2B48C"],
  ["teal", "#008080"],
  ["thistle", "#D8BFD8"],
  ["tomato", "#FF6347"],
  ["transparent", "#00000000"],
  ["turquoise", "#40E0D0"],
  ["violet", "#EE82EE"],
  ["wheat", "#F5DEB3"],
  ["white", "#FFFFFF"],
  ["whitesmoke", "#F5F5F5"],
  ["yellow", "#FFFF00"],
  ["yellowgreen", "#9ACD32"]
]);
var Color = _Color;

// packages/ag-charts-community/src/chart/themes/constants.ts
var BASE_FONT_SIZE = 12 /* SMALL */;
var FONT_SIZE_RATIO = ((FONT_SIZE_RATIO2) => {
  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["SMALLEST"] = 8 /* SMALLEST */ / BASE_FONT_SIZE] = "SMALLEST";
  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["SMALLER"] = 10 /* SMALLER */ / BASE_FONT_SIZE] = "SMALLER";
  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["SMALL"] = 12 /* SMALL */ / BASE_FONT_SIZE] = "SMALL";
  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["MEDIUM"] = 13 /* MEDIUM */ / BASE_FONT_SIZE] = "MEDIUM";
  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["LARGE"] = 14 /* LARGE */ / BASE_FONT_SIZE] = "LARGE";
  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["LARGEST"] = 17 /* LARGEST */ / BASE_FONT_SIZE] = "LARGEST";
  return FONT_SIZE_RATIO2;
})(FONT_SIZE_RATIO || {});

// packages/ag-charts-community/src/chart/themes/util.ts
var DIRECTION_SWAP_AXES = [
  {
    type: "number" /* NUMBER */,
    position: {
      $if: [
        { $eq: [{ $path: ["/series/0/direction", void 0] }, "horizontal"] },
        "bottom" /* BOTTOM */,
        "left" /* LEFT */
      ]
    }
  },
  {
    type: "category" /* CATEGORY */,
    position: {
      $if: [
        { $eq: [{ $path: ["/series/0/direction", void 0] }, "horizontal"] },
        "left" /* LEFT */,
        "bottom" /* BOTTOM */
      ]
    }
  }
];
var SAFE_STROKE_FILL_OPERATION = {
  $if: [
    { $isGradient: { $palette: "fill" } },
    { $palette: "fillFallback" },
    {
      $if: [
        { $isPattern: { $palette: "fill" } },
        { $path: ["/stroke", { $palette: "fillFallback" }, { $palette: "fill" }] },
        { $palette: "fill" }
      ]
    }
  ]
};
var FILL_GRADIENT_LINEAR_DEFAULTS = {
  type: "gradient",
  gradient: "linear",
  bounds: "item",
  colorStops: { $palette: "gradient" },
  rotation: 0,
  reverse: false
};
var FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS = {
  ...FILL_GRADIENT_LINEAR_DEFAULTS,
  colorStops: [
    {
      $mix: [{ $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] }, "black", 0.15]
    },
    {
      $mix: [{ $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] }, "white", 0.15]
    }
  ]
};
var FILL_GRADIENT_RADIAL_DEFAULTS = {
  type: "gradient",
  gradient: "radial",
  bounds: "item",
  colorStops: { $palette: "gradient" },
  rotation: 0,
  reverse: false
};
var FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS = {
  ...FILL_GRADIENT_RADIAL_DEFAULTS,
  reverse: true
};
var FILL_GRADIENT_RADIAL_SERIES_DEFAULTS = {
  ...FILL_GRADIENT_RADIAL_DEFAULTS,
  bounds: "series"
};
var FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS = {
  ...FILL_GRADIENT_RADIAL_DEFAULTS,
  bounds: "series",
  reverse: true
};
var FILL_PATTERN_DEFAULTS = {
  type: "pattern",
  pattern: "forward-slanted-lines",
  width: 10,
  height: 10,
  padding: 2,
  fill: {
    $if: [
      { $or: [{ $isGradient: { $palette: "fill" } }, { $isImage: { $palette: "fill" } }] },
      { $palette: "fillFallback" },
      {
        $if: [
          { $isPattern: { $palette: "fill" } },
          { $path: ["/fill", { $palette: "fillFallback" }, { $palette: "fill" }] },
          { $palette: "fill" }
        ]
      }
    ]
  },
  fillOpacity: 1,
  stroke: SAFE_STROKE_FILL_OPERATION,
  strokeOpacity: 1,
  strokeWidth: 4,
  backgroundFill: "none",
  backgroundFillOpacity: 1,
  rotation: 0,
  scale: 1
};
var FILL_PATTERN_HIERARCHY_DEFAULTS = {
  ...FILL_PATTERN_DEFAULTS,
  fill: { $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] },
  stroke: { $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] }
};
var FILL_IMAGE_DEFAULTS = {
  type: "image",
  backgroundFill: { $palette: "fillFallback" },
  backgroundFillOpacity: 1,
  repeat: "no-repeat",
  fit: "contain",
  rotation: 0
};
var ITEM_HIGHLIGHT_BASE_STYLE = {
  stroke: { $path: ["../../highlightStyle/item/stroke", `rgba(0, 0, 0, 0.4)`] },
  strokeWidth: { $path: ["../../highlightStyle/item/strokeWidth", 2] },
  strokeOpacity: { $path: ["../../highlightStyle/item/strokeOpacity", void 0] },
  opacity: { $path: ["../../highlightStyle/item/opacity", 1] }
};
var ITEM_HIGHLIGHT_STYLE = {
  ...ITEM_HIGHLIGHT_BASE_STYLE,
  fill: { $path: ["../../highlightStyle/item/fill", `rgba(255,255,255, 0.33)`] },
  fillOpacity: { $path: ["../../highlightStyle/item/fillOpacity", void 0] }
};
var LABEL_BOXING_DEFAULTS = {
  padding: 8,
  cornerRadius: 4,
  fill: {
    $if: [
      {
        $and: [
          { $eq: [{ $path: "./fill/type" }, "image"] },
          { $isUserOption: ["./fill/backgroundFill", false, true] }
        ]
      },
      { backgroundFill: "transparent" },
      void 0
    ]
  },
  border: {
    enabled: { $isUserOption: ["../border", true, false] },
    strokeWidth: 1,
    stroke: { $foregroundOpacity: 0.08 }
  }
};
function multiSeriesHighlightStyle(hasFill = true) {
  return {
    enabled: true,
    highlightedItem: hasFill ? ITEM_HIGHLIGHT_STYLE : ITEM_HIGHLIGHT_BASE_STYLE,
    unhighlightedItem: {
      strokeWidth: { $path: ["../../highlightStyle/series/strokeWidth", void 0] }
    },
    highlightedSeries: {
      strokeWidth: { $path: ["../../highlightStyle/series/strokeWidth", void 0] }
    },
    unhighlightedSeries: {
      opacity: { $path: ["../../highlightStyle/series/dimOpacity", void 0] }
    }
  };
}

// packages/ag-charts-community/src/api/preset/priceVolumePresetTheme.ts
var stroke = {
  stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var handle = {
  fill: DEFAULT_ANNOTATION_HANDLE_FILL
};
var axisLabel = {
  color: "white",
  fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var lineText = {
  color: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var font = {
  color: DEFAULT_TEXT_ANNOTATION_COLOR,
  fontSize: { $rem: FONT_SIZE_RATIO.LARGE },
  fontFamily: { $ref: "fontFamily" }
};
var measurerStatistics = {
  ...font,
  fontSize: { $ref: "fontSize" },
  color: DEFAULT_ANNOTATION_STATISTICS_COLOR,
  fill: DEFAULT_ANNOTATION_STATISTICS_FILL,
  stroke: DEFAULT_ANNOTATION_STATISTICS_STROKE,
  strokeWidth: 1,
  divider: {
    stroke: DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
    strokeWidth: 1,
    strokeOpacity: 0.5
  }
};
var measurer = {
  ...stroke,
  background: {
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    fillOpacity: 0.2
  },
  handle: { ...handle },
  text: { ...lineText },
  statistics: { ...measurerStatistics }
};
var annotationsTheme = {
  // Lines
  line: {
    ...stroke,
    handle: { ...handle },
    text: { ...lineText }
  },
  "horizontal-line": {
    ...stroke,
    handle: { ...handle },
    axisLabel: { ...axisLabel },
    text: { ...lineText }
  },
  "vertical-line": {
    ...stroke,
    handle: { ...handle },
    axisLabel: { ...axisLabel },
    text: { ...lineText }
  },
  // Channels
  "disjoint-channel": {
    ...stroke,
    background: {
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2
    },
    handle: { ...handle },
    text: { ...lineText }
  },
  "parallel-channel": {
    ...stroke,
    background: {
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2
    },
    handle: { ...handle },
    text: { ...lineText }
  },
  // Fibonnaccis
  "fibonacci-retracement": {
    ...stroke,
    strokes: DEFAULT_FIBONACCI_STROKES,
    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    handle: { ...handle },
    text: { ...lineText, position: "center" },
    label: {
      ...font,
      color: void 0,
      fontSize: { $rem: FONT_SIZE_RATIO.SMALLER }
    }
  },
  "fibonacci-retracement-trend-based": {
    ...stroke,
    strokes: DEFAULT_FIBONACCI_STROKES,
    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    handle: { ...handle },
    text: { ...lineText, position: "center" },
    label: {
      ...font,
      color: void 0,
      fontSize: { $rem: FONT_SIZE_RATIO.SMALLER }
    }
  },
  // Texts
  callout: {
    ...stroke,
    ...font,
    color: { $ref: "textColor" },
    handle: { ...handle },
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    fillOpacity: 0.2
  },
  comment: {
    ...font,
    color: "white",
    fontWeight: 700,
    handle: { ...handle },
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
  },
  note: {
    ...font,
    color: DEFAULT_TEXTBOX_COLOR,
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    stroke: { $ref: "chartBackgroundColor" },
    strokeWidth: 1,
    strokeOpacity: 1,
    handle: { ...handle },
    background: {
      fill: DEFAULT_TEXTBOX_FILL,
      stroke: DEFAULT_TEXTBOX_STROKE,
      strokeWidth: 1
    }
  },
  text: {
    ...font,
    handle: { ...handle }
  },
  // Shapes
  arrow: {
    ...stroke,
    handle: { ...handle },
    text: { ...lineText }
  },
  "arrow-up": {
    fill: { $palette: "up.fill" },
    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }
  },
  "arrow-down": {
    fill: { $palette: "down.fill" },
    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }
  },
  // Measurers
  "date-range": {
    ...measurer
  },
  "price-range": {
    ...measurer
  },
  "date-price-range": {
    ...measurer
  },
  "quick-date-price-range": {
    up: {
      ...stroke,
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2,
      handle: { ...handle },
      statistics: {
        ...measurerStatistics,
        color: "#fff",
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    },
    down: {
      ...stroke,
      stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
      fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
      fillOpacity: 0.2,
      handle: {
        ...handle,
        stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE
      },
      statistics: {
        ...measurerStatistics,
        color: "#fff",
        fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    }
  },
  axesButtons: {
    enabled: true
  }
};

// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
var chartTypes = ["ohlc", "line", "step-line", "hlc", "high-low", "candlestick", "hollow-candlestick"];
var toolbarButtons = [
  {
    icon: "trend-line-drawing",
    tooltip: "toolbarAnnotationsLineAnnotations",
    value: "line-menu"
  },
  {
    icon: "fibonacci-retracement-drawing",
    tooltip: "toolbarAnnotationsFibonacciAnnotations",
    value: "fibonacci-menu"
  },
  {
    icon: "text-annotation",
    tooltip: "toolbarAnnotationsTextAnnotations",
    value: "text-menu"
  },
  {
    icon: "arrow-drawing",
    tooltip: "toolbarAnnotationsShapeAnnotations",
    value: "shape-menu"
  },
  {
    icon: "measurer-drawing",
    tooltip: "toolbarAnnotationsMeasurerAnnotations",
    value: "measurer-menu"
  },
  {
    icon: "delete",
    tooltip: "toolbarAnnotationsClearAll",
    value: "clear"
  }
];
function priceVolume(opts, _presetTheme, getTheme) {
  const {
    dateKey = "date",
    highKey = "high",
    openKey = "open",
    lowKey = "low",
    closeKey = "close",
    volumeKey = "volume",
    chartType = "candlestick",
    navigator = false,
    volume = true,
    rangeButtons = true,
    statusBar = true,
    toolbar = true,
    zoom = true,
    sync = false,
    theme,
    data,
    formatter: formatter2,
    ...unusedOpts
  } = opts;
  const priceSeries = createPriceSeries(chartType, dateKey, highKey, lowKey, openKey, closeKey);
  const volumeSeries = createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey);
  const miniChart = volume ? {
    miniChart: {
      enabled: navigator,
      series: [
        {
          type: "line",
          xKey: dateKey,
          yKey: volumeKey,
          stroke: SAFE_STROKE_FILL_OPERATION,
          marker: { enabled: false }
        }
      ]
    },
    height: 40,
    minHandle: {
      height: 46
    },
    maxHandle: {
      height: 46
    }
  } : null;
  const navigatorOpts = {
    navigator: {
      enabled: navigator,
      ...miniChart
    }
  };
  const annotationOpts = {
    annotations: {
      enabled: toolbar,
      optionsToolbar: {
        enabled: toolbar
      },
      // @ts-expect-error undocumented option
      snap: true,
      toolbar: {
        enabled: toolbar,
        buttons: toolbarButtons,
        padding: 0
      },
      data,
      xKey: dateKey,
      volumeKey: volume ? volumeKey : void 0
    }
  };
  const statusBarOpts = statusBar ? {
    statusBar: {
      enabled: true,
      data,
      highKey,
      openKey,
      lowKey,
      closeKey,
      volumeKey: volume ? volumeKey : void 0
    }
  } : null;
  const zoomOpts = {
    zoom: {
      enabled: zoom,
      autoScaling: {
        enabled: true
      },
      // @ts-expect-error undocumented option
      enableIndependentAxes: true
    }
  };
  const toolbarOpts = {
    ranges: {
      enabled: rangeButtons
    }
  };
  const syncGroup = sync ? {
    sync: {
      enabled: sync,
      nodeInteraction: true,
      zoom: true
    }
  } : null;
  const volumeAxis = volume ? [
    {
      type: "number",
      position: "left",
      keys: [volumeKey],
      label: { enabled: false },
      crosshair: { enabled: false },
      gridLine: { enabled: false },
      nice: false,
      // @ts-expect-error undocumented option
      layoutConstraints: {
        stacked: false,
        width: 20,
        unit: "percent",
        align: "end"
      }
    }
  ] : [];
  return {
    theme: {
      baseTheme: typeof theme === "string" ? theme : "ag-financial",
      ...mergeDefaults(typeof theme === "object" ? theme : null, {
        overrides: {
          common: {
            title: { padding: 4 },
            padding: {
              top: 6,
              right: 8,
              bottom: 6
            },
            chartToolbar: {
              enabled: toolbar
            },
            annotations: { ...annotationsTheme },
            axes: {
              number: {
                interval: { maxSpacing: 45 },
                label: { format: ".2f" }
              }
            }
          },
          bar: {
            series: {
              fillOpacity: 0.5
            }
          },
          line: {
            series: {
              marker: { enabled: false },
              ...inlineSwitch(chartType, {
                hlc: {
                  stroke: { $palette: "altNeutral.stroke" },
                  strokeWidth: 2
                },
                line: {
                  stroke: { $palette: "neutral.stroke" }
                },
                "step-line": {
                  stroke: { $palette: "neutral.stroke" },
                  interpolation: { type: "step" }
                }
              })
            }
          },
          candlestick: {
            series: {
              ...inlineSwitch(chartType, {
                "hollow-candlestick": {
                  item: {
                    up: { fill: "transparent" }
                  }
                }
              })
            }
          },
          "range-area": {
            series: {
              fillOpacity: 0.3,
              strokeWidth: 2
            }
          }
        }
      })
    },
    animation: { enabled: false },
    legend: { enabled: false },
    series: [...volumeSeries, ...priceSeries],
    axes: [
      {
        type: "number",
        position: "right",
        keys: [openKey, closeKey, highKey, lowKey],
        crosshair: {
          enabled: true,
          snap: false
        },
        // @ts-expect-error undocumented option
        layoutConstraints: {
          stacked: false,
          width: 100,
          unit: "percent",
          align: "start"
        }
      },
      ...volumeAxis,
      {
        type: "ordinal-time",
        position: "bottom",
        line: {
          enabled: false
        },
        label: {
          enabled: true
        },
        crosshair: {
          enabled: true
        }
      }
    ],
    tooltip: { enabled: false },
    data,
    formatter: formatter2,
    ...annotationOpts,
    ...navigatorOpts,
    ...statusBarOpts,
    ...zoomOpts,
    ...toolbarOpts,
    ...syncGroup,
    ...unusedOpts
  };
}
function createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey) {
  if (!volume)
    return [];
  return [
    {
      type: "bar",
      xKey: "date",
      yKey: volumeKey,
      tooltip: { enabled: false },
      itemStyler({ datum }) {
        const { up, down } = getTheme().palette;
        return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };
      },
      // @ts-expect-error undocumented option
      focusPriority: 1,
      highlight: { enabled: false }
    }
  ];
}
var RANGE_AREA_TYPE = "range-area";
function createPriceSeries(chartType, xKey, highKey, lowKey, openKey, closeKey) {
  const keys = {
    xKey,
    openKey,
    closeKey,
    highKey,
    lowKey
  };
  const singleKeys = {
    xKey,
    yKey: closeKey
  };
  const common = {
    pickOutsideVisibleMinorAxis: true
  };
  switch (chartType ?? "candlestick") {
    case "ohlc":
      return createPriceSeriesOHLC(common, keys);
    case "line":
    case "step-line":
      return createPriceSeriesLine(common, singleKeys);
    case "hlc":
      return createPriceSeriesHLC(common, singleKeys, keys);
    case "high-low":
      return createPriceSeriesHighLow(common, keys);
    case "candlestick":
    case "hollow-candlestick":
      return createPriceSeriesCandlestick(common, keys);
    default:
      Logger.warnOnce(`unknown chart type: ${chartType}; expected one of: ${chartTypes.join(", ")}`);
      return createPriceSeriesCandlestick(common, keys);
  }
}
function createPriceSeriesOHLC(common, keys) {
  return [
    {
      type: "ohlc",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...keys
    }
  ];
}
function createPriceSeriesLine(common, singleKeys) {
  return [
    {
      type: "line",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...singleKeys
    }
  ];
}
function createPriceSeriesHLC(common, singleKeys, { xKey, highKey, closeKey, lowKey }) {
  return [
    {
      type: RANGE_AREA_TYPE,
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      xKey,
      yHighKey: highKey,
      yLowKey: closeKey,
      fill: PALETTE_UP_FILL,
      stroke: PALETTE_UP_STROKE
    },
    {
      type: RANGE_AREA_TYPE,
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      xKey,
      yHighKey: closeKey,
      yLowKey: lowKey,
      fill: PALETTE_DOWN_FILL,
      stroke: PALETTE_DOWN_STROKE
    },
    {
      type: "line",
      ...common,
      ...singleKeys
    }
  ];
}
function createPriceSeriesHighLow(common, { xKey, highKey, lowKey }) {
  return [
    {
      type: "range-bar",
      ...common,
      xKey,
      yHighKey: highKey,
      yLowKey: lowKey,
      fill: PALETTE_NEUTRAL_FILL,
      stroke: PALETTE_NEUTRAL_STROKE,
      tooltip: {
        range: "nearest"
      },
      // @ts-expect-error undocumented option
      focusPriority: 0
    }
  ];
}
function createPriceSeriesCandlestick(common, keys) {
  return [
    {
      type: "candlestick",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...keys
    }
  ];
}
function inlineSwitch(caseName, switchCases) {
  return switchCases[caseName] ?? switchCases.default;
}

// packages/ag-charts-community/src/util/memo.ts
var memorizedFns = /* @__PURE__ */ new WeakMap();
function memo(params, fnGenerator) {
  const serialisedParams = JSON.stringify(params, null, 0);
  if (!memorizedFns.has(fnGenerator)) {
    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
  }
  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {
    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));
  }
  return memorizedFns.get(fnGenerator)?.get(serialisedParams);
}
var MemoizeNode = class {
  constructor() {
    this.weak = /* @__PURE__ */ new WeakMap();
    this.strong = /* @__PURE__ */ new Map();
    this.set = false;
    this.value = void 0;
  }
};
function simpleMemorize2(fn, cacheCallback) {
  let root = new MemoizeNode();
  const memoised = (...p) => {
    let current = root;
    for (const param of p) {
      const target = typeof param === "object" || typeof param === "symbol" ? current.weak : current.strong;
      let next = target.get(param);
      if (next == null) {
        next = new MemoizeNode();
        target.set(param, next);
      }
      current = next;
    }
    if (current.set) {
      cacheCallback?.("hit", fn, p);
      return current.value;
    } else {
      const out = fn(...p);
      current.set = true;
      current.value = out;
      cacheCallback?.("miss", fn, p);
      return out;
    }
  };
  memoised.reset = () => {
    root = new MemoizeNode();
  };
  return memoised;
}
function simpleMemorize(fn, cacheCallback) {
  const primitiveCache = /* @__PURE__ */ new Map();
  const paramsToKeys = (...params) => {
    return params.map((v) => {
      if (typeof v === "object")
        return v;
      if (typeof v === "symbol")
        return v;
      if (!primitiveCache.has(v)) {
        primitiveCache.set(v, { v });
      }
      return primitiveCache.get(v);
    });
  };
  const empty = {};
  const cache = /* @__PURE__ */ new WeakMap();
  return (...p) => {
    const keys = p.length === 0 ? [empty] : paramsToKeys(...p);
    let currentCache = cache;
    for (const key of keys.slice(0, -1)) {
      if (!currentCache.has(key)) {
        currentCache.set(key, /* @__PURE__ */ new WeakMap());
      }
      currentCache = currentCache.get(key);
    }
    const finalKey = keys.at(-1);
    let cachedValue = currentCache.get(finalKey);
    if (cachedValue) {
      cacheCallback?.("hit", fn, p);
    } else {
      cachedValue = fn(...p);
      currentCache.set(finalKey, cachedValue);
      cacheCallback?.("miss", fn, p);
    }
    return cachedValue;
  };
}

// packages/ag-charts-community/src/api/preset/sparkline.ts
var commonAxisProperties = {
  title: {
    enabled: false
  },
  label: {
    enabled: false
  },
  line: {
    enabled: false
  },
  gridLine: {
    enabled: false
  },
  crosshair: {
    enabled: false,
    stroke: DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
    lineDash: [0],
    label: {
      enabled: false
    }
  }
};
var numericAxisProperties = {
  ...commonAxisProperties,
  nice: false
};
var chartTooltipDefaults = {
  mode: "compact",
  position: {
    anchorTo: "node",
    placement: ["right", "left"]
  },
  showArrow: false
};
var barGridLineDefaults = {
  style: [{ stroke: { $ref: "gridLineColor" } }],
  width: 2
};
var barAxisDefaults = {
  number: {
    gridLine: barGridLineDefaults
  },
  time: {
    gridLine: barGridLineDefaults
  },
  category: {
    gridLine: barGridLineDefaults
  }
};
var SPARKLINE_THEME = {
  overrides: {
    common: {
      animation: { enabled: false },
      contextMenu: { enabled: false },
      keyboard: { enabled: false },
      background: { visible: false },
      navigator: {
        enabled: false
      },
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      axes: {
        number: {
          ...numericAxisProperties,
          interval: {
            values: [0]
          }
        },
        log: {
          ...numericAxisProperties
        },
        time: {
          ...numericAxisProperties
        },
        category: {
          ...commonAxisProperties
        }
      }
    },
    bar: {
      series: {
        crisp: false,
        label: {
          placement: "inside-end",
          padding: 4
        },
        // @ts-expect-error undocumented option
        sparklineMode: true
      },
      tooltip: {
        ...chartTooltipDefaults,
        position: {
          ...chartTooltipDefaults.position,
          anchorTo: "pointer"
        },
        range: "nearest"
      },
      axes: barAxisDefaults
    },
    line: {
      seriesArea: {
        padding: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2
        }
      },
      series: {
        // @ts-expect-error undocumented option
        sparklineMode: true,
        strokeWidth: 1,
        marker: {
          enabled: false,
          size: 3
        }
      },
      tooltip: chartTooltipDefaults
    },
    area: {
      seriesArea: {
        padding: {
          top: 1,
          right: 0,
          bottom: 1,
          left: 0
        }
      },
      series: {
        strokeWidth: 1,
        fillOpacity: 0.4
      },
      tooltip: chartTooltipDefaults
    }
  }
};
var setInitialBaseTheme = simpleMemorize(createInitialBaseTheme);
function createInitialBaseTheme(baseTheme, initialBaseTheme) {
  if (typeof baseTheme === "string") {
    return {
      ...initialBaseTheme,
      baseTheme
    };
  }
  if (baseTheme != null) {
    return {
      ...baseTheme,
      // @ts-expect-error internal implementation
      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)
    };
  }
  return initialBaseTheme;
}
function sparklineDataPreset(data) {
  if (Array.isArray(data) && data.length !== 0) {
    const firstItem = data.find((v) => v != null);
    if (typeof firstItem === "number") {
      const mappedData = data.map((y, x) => ({ x, y }));
      return { data: mappedData, series: [{ xKey: "x", yKey: "y" }], datumKey: "y" };
    } else if (Array.isArray(firstItem)) {
      const mappedData = data.map((datum) => ({ x: datum?.[0], y: datum?.[1], datum }));
      return { data: mappedData, series: [{ xKey: "x", yKey: "y" }], datumKey: "datum" };
    }
  } else if (data?.length === 0) {
    return { data, series: [{ xKey: "x", yKey: "y" }], datumKey: "y" };
  }
  return { data };
}
function axisPreset(opts) {
  switch (opts?.type) {
    case "number": {
      const { type, min, max, reverse } = opts;
      return pickProps(opts, {
        type,
        reverse,
        min,
        max
      });
    }
    case "time": {
      const { type, min, max, reverse } = opts;
      return pickProps(opts, {
        type,
        reverse,
        min,
        max
      });
    }
    case "category":
    default: {
      const { paddingInner, paddingOuter, reverse } = opts ?? {};
      return pickProps(
        { ...opts, type: "category" },
        {
          type: "category",
          reverse,
          paddingInner,
          paddingOuter
        }
      );
    }
  }
}
function gridLinePreset(opts, defaultEnabled, sparkOpts) {
  const gridLineOpts = {};
  if (opts?.stroke != null) {
    gridLineOpts.style = [{ stroke: opts?.stroke }];
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (opts?.strokeWidth != null) {
    gridLineOpts.width = opts?.strokeWidth;
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (sparkOpts.type === "bar" && sparkOpts.direction !== "horizontal") {
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (opts?.visible != null) {
    gridLineOpts.enabled = opts.visible;
  }
  gridLineOpts.enabled ?? (gridLineOpts.enabled = defaultEnabled);
  return gridLineOpts;
}
var tooltipRendererFn = simpleMemorize((context, tooltip, datumKey) => {
  return (params) => {
    const xValue = params.datum[params.xKey];
    const yValue = params.datum[params.yKey];
    const datum = datumKey != null ? params.datum[datumKey] : params.datum;
    const userContent = tooltip?.renderer?.({ context, datum, xValue, yValue });
    if (typeof userContent === "string")
      return userContent;
    const content = userContent?.content ?? yValue.toFixed(2);
    return userContent?.title ? {
      heading: void 0,
      title: void 0,
      data: [{ label: userContent.title, value: content }]
    } : {
      heading: void 0,
      title: content,
      data: []
    };
  };
});
function sparkline(opts) {
  const {
    background,
    container,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    width: width2,
    theme: baseTheme,
    data: baseData,
    crosshair,
    axis,
    min,
    max,
    tooltip,
    context,
    styleNonce,
    ...optsRest
  } = opts;
  const chartOpts = pickProps(opts, {
    background,
    container,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    width: width2,
    styleNonce,
    tooltip: IGNORED_PROP,
    context: IGNORED_PROP,
    data: IGNORED_PROP,
    crosshair: IGNORED_PROP,
    axis: IGNORED_PROP,
    min: IGNORED_PROP,
    max: IGNORED_PROP,
    theme: IGNORED_PROP
  });
  const { data, series: [seriesOverrides] = [], datumKey } = sparklineDataPreset(baseData);
  const seriesOptions = optsRest;
  if (seriesOverrides != null)
    Object.assign(seriesOptions, seriesOverrides);
  seriesOptions.tooltip = {
    ...tooltip,
    renderer: tooltipRendererFn(context, tooltip, datumKey)
  };
  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);
  chartOpts.data = data;
  chartOpts.series = [seriesOptions];
  const swapAxes = seriesOptions.type !== "bar" || seriesOptions.direction !== "horizontal";
  const [xAxisPosition, yAxisPosition] = swapAxes ? ["bottom", "left"] : ["left", "bottom"];
  const xAxis = {
    ...axisPreset(axis),
    position: xAxisPosition,
    ...pickProps(opts, { crosshair })
  };
  const yAxis = {
    type: "number",
    gridLine: gridLinePreset(axis, false, opts),
    position: yAxisPosition,
    ...pickProps(opts, { min, max })
  };
  chartOpts.axes = swapAxes ? [yAxis, xAxis] : [xAxis, yAxis];
  return chartOpts;
}

// packages/ag-charts-community/src/api/preset/presetModules.ts
var priceVolumeOptionsDef = {
  chartType: union4("candlestick", "hollow-candlestick", "ohlc", "line", "step-line", "hlc", "high-low"),
  dateKey: string6,
  openKey: string6,
  highKey: string6,
  lowKey: string6,
  closeKey: string6,
  volumeKey: string6,
  navigator: boolean6,
  volume: boolean6,
  rangeButtons: boolean6,
  statusBar: boolean6,
  toolbar: boolean6,
  zoom: boolean6,
  sync: boolean6,
  // Valid pass-through options
  theme: defined2,
  container: defined2,
  width: defined2,
  height: defined2,
  minWidth: defined2,
  minHeight: defined2,
  listeners: defined2,
  initialState: defined2,
  title: defined2,
  data: array2,
  formatter: defined2
};
var commonGaugeOptions = {
  // Valid pass-through options
  theme: defined2,
  container: defined2,
  animation: defined2,
  background: defined2,
  contextMenu: defined2,
  context: () => true,
  listeners: defined2,
  locale: defined2,
  width: defined2,
  height: defined2,
  minWidth: defined2,
  minHeight: defined2,
  title: defined2,
  subtitle: defined2,
  footnote: defined2,
  padding: defined2,
  tooltip: {
    ...tooltipOptionsDefs,
    ...commonChartOptionsDefs.tooltip
  }
};
commonGaugeOptions.overrideDevicePixelRatio = undocumented5(positiveNumber4);
var commonSparklineOmit = [
  "showInLegend",
  "showInMiniChart",
  "grouped",
  "stacked",
  "stackGroup",
  "tooltip",
  "listeners",
  "errorBar",
  "xKey",
  "yKey",
  "type"
];
var commonSparklineAxisOptionsDef = {
  visible: boolean6,
  reverse: boolean6,
  stroke: color3,
  strokeWidth: positiveNumber4
};
var commonSparklineOptionsDef = {
  context: () => true,
  tooltip: defined2,
  theme: defined2,
  background: defined2,
  container: defined2,
  width: defined2,
  height: defined2,
  minWidth: defined2,
  minHeight: defined2,
  padding: defined2,
  listeners: defined2,
  locale: defined2,
  data: defined2,
  styleNonce: string6,
  axis: typeUnion2(
    {
      number: {
        ...commonSparklineAxisOptionsDef,
        min: and3(number6, lessThan3("max")),
        max: and3(number6, greaterThan3("min"))
      },
      category: {
        ...commonSparklineAxisOptionsDef,
        paddingInner: ratio3,
        paddingOuter: ratio3
      },
      time: {
        ...commonSparklineAxisOptionsDef,
        min: and3(or3(number6, date2), lessThan3("max")),
        max: and3(or3(number6, date2), greaterThan3("min"))
      }
    },
    "axis options",
    "category"
    // AG-14799 - Contrary to the AgSparklineAxisOptions interface, type is optional and defaults to 'category'.
  ),
  min: and3(number6, lessThan3("max")),
  max: and3(number6, greaterThan3("min")),
  crosshair: {
    enabled: boolean6,
    snap: boolean6,
    ...strokeOptionsDef6,
    ...lineDashOptionsDef6
  },
  xKey: string6,
  yKey: string6
};
var PriceVolumePresetModule = {
  type: "preset",
  name: "price-volume",
  enterprise: true,
  options: priceVolumeOptionsDef,
  create: priceVolume
};
var GaugePresetModule = {
  type: "preset",
  name: "gauge-preset",
  enterprise: true,
  options: typeUnion2(
    {
      "linear-gauge": {
        ...without(linearGaugeSeriesOptionsDef, ["type"]),
        ...commonGaugeOptions
      },
      "radial-gauge": {
        ...without(radialGaugeSeriesOptionsDef, ["type"]),
        ...commonGaugeOptions
      }
    },
    "gauge options"
  ),
  create: gauge
};
var SparklinePresetModule = {
  type: "preset",
  name: "sparkline",
  options: typeUnion2(
    {
      area: {
        ...commonSparklineOptionsDef,
        ...without(areaSeriesOptionsDef, commonSparklineOmit)
      },
      bar: {
        ...commonSparklineOptionsDef,
        ...without(barSeriesOptionsDef, commonSparklineOmit)
      },
      line: {
        ...commonSparklineOptionsDef,
        ...without(lineSeriesOptionsDef, commonSparklineOmit)
      }
    },
    "sparkline options"
  ),
  create: sparkline,
  processData: sparklineDataPreset
};

// packages/ag-charts-community/src/chart/cartesianChartModule.ts
import { ValidationError as ValidationError2, isObject as isObject7, validate as validate3 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/cartesianChart.ts
import { Logger as Logger34, entries as entries6, groupBy as groupBy2 } from "ag-charts-core";

// packages/ag-charts-community/src/motion/animation.ts
import { clamp as clamp3, isPlainObject as isPlainObject2 } from "ag-charts-core";

// packages/ag-charts-community/src/scene/node.ts
import { Logger as Logger2, createId, createSvgElement } from "ag-charts-core";

// packages/ag-charts-community/src/scene/bbox.ts
import { boxContains, boxesEqual, clamp as clamp2 } from "ag-charts-core";

// packages/ag-charts-community/src/util/interpolating.ts
var interpolate = Symbol("interpolate");
var isInterpolating = (x) => x[interpolate] != null;

// packages/ag-charts-community/src/util/nearest.ts
function nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const obj of objects) {
    const thisDistance = obj.distanceSquared(x, y);
    if (thisDistance === 0) {
      return { nearest: obj, distanceSquared: 0 };
    } else if (thisDistance < result.distanceSquared) {
      result.nearest = obj;
      result.distanceSquared = thisDistance;
    }
  }
  return result;
}

// packages/ag-charts-community/src/scene/bbox.ts
var _BBox = class _BBox {
  constructor(x, y, width2, height2) {
    this.x = x;
    this.y = y;
    this.width = width2;
    this.height = height2;
  }
  static fromDOMRect({ x, y, width: width2, height: height2 }) {
    return new _BBox(x, y, width2, height2);
  }
  static merge(boxes) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (const box of boxes) {
      if (box.x < left) {
        left = box.x;
      }
      if (box.y < top) {
        top = box.y;
      }
      if (box.x + box.width > right) {
        right = box.x + box.width;
      }
      if (box.y + box.height > bottom) {
        bottom = box.y + box.height;
      }
    }
    return new _BBox(left, top, right - left, bottom - top);
  }
  static nearestBox(x, y, boxes) {
    return nearestSquared(x, y, boxes);
  }
  toDOMRect() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.y,
      left: this.x,
      right: this.x + this.width,
      bottom: this.y + this.height,
      toJSON() {
        return {};
      }
    };
  }
  clone() {
    const { x, y, width: width2, height: height2 } = this;
    return new _BBox(x, y, width2, height2);
  }
  equals(other) {
    return boxesEqual(this, other);
  }
  containsPoint(x, y) {
    return boxContains(this, x, y);
  }
  intersection(other) {
    if (!this.collidesBBox(other))
      return;
    const newX1 = clamp2(other.x, this.x, other.x + other.width);
    const newY1 = clamp2(other.y, this.y, other.y + other.height);
    const newX2 = clamp2(other.x, this.x + this.width, other.x + other.width);
    const newY2 = clamp2(other.y, this.y + this.height, other.y + other.height);
    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);
  }
  collidesBBox(other) {
    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
  }
  computeCenter() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  isFinite() {
    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);
  }
  distanceSquared(x, y) {
    if (this.containsPoint(x, y)) {
      return 0;
    }
    const dx = x - clamp2(this.x, x, this.x + this.width);
    const dy = y - clamp2(this.y, y, this.y + this.height);
    return dx * dx + dy * dy;
  }
  shrink(amount, position) {
    if (typeof amount === "number") {
      this.applyMargin(amount, position);
    } else {
      for (const key of Object.keys(amount)) {
        const value = amount[key];
        if (typeof value === "number") {
          this.applyMargin(value, key);
        }
      }
    }
    if (this.width < 0) {
      this.width = 0;
    }
    if (this.height < 0) {
      this.height = 0;
    }
    return this;
  }
  grow(amount, position) {
    if (typeof amount === "number") {
      this.applyMargin(-amount, position);
    } else {
      for (const key of Object.keys(amount)) {
        const value = amount[key];
        if (typeof value === "number") {
          this.applyMargin(-value, key);
        }
      }
    }
    return this;
  }
  applyMargin(value, position) {
    switch (position) {
      case "top":
        this.y += value;
      case "bottom":
        this.height -= value;
        break;
      case "left":
        this.x += value;
      case "right":
        this.width -= value;
        break;
      case "vertical":
        this.y += value;
        this.height -= value * 2;
        break;
      case "horizontal":
        this.x += value;
        this.width -= value * 2;
        break;
      case void 0:
        this.x += value;
        this.y += value;
        this.width -= value * 2;
        this.height -= value * 2;
        break;
    }
  }
  translate(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  [interpolate](other, d) {
    return new _BBox(
      this.x * (1 - d) + other.x * d,
      this.y * (1 - d) + other.y * d,
      this.width * (1 - d) + other.width * d,
      this.height * (1 - d) + other.height * d
    );
  }
};
_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));
_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));
var BBox = _BBox;

// packages/ag-charts-community/src/scene/changeDetectable.ts
import { arraysEqual } from "ag-charts-core";
var TRIPLE_EQ = (lhs, rhs) => lhs === rhs;
function SceneChangeDetection(opts) {
  return function(target, key) {
    const privateKey = `__${key}`;
    if (target[key])
      return;
    prepareGetSet(target, key, privateKey, opts);
  };
}
function SceneRefChangeDetection(opts) {
  return SceneChangeDetection(opts);
}
function SceneObjectChangeDetection(opts) {
  return SceneChangeDetection(opts);
}
function SceneArrayChangeDetection(opts) {
  const baseOpts = opts ?? {};
  baseOpts.equals = arraysEqual;
  return SceneChangeDetection(opts);
}
function prepareGetSet(target, key, privateKey, opts) {
  const { changeCb, convertor, checkDirtyOnAssignment = false } = opts ?? {};
  const requiredOpts = { changeCb, checkDirtyOnAssignment, convertor };
  const setter = buildCheckDirtyChain(
    privateKey,
    buildChangeCallbackChain(
      buildConvertorChain(buildSetter(privateKey, requiredOpts), requiredOpts),
      requiredOpts
    ),
    requiredOpts
  );
  const getter = function() {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
function buildConvertorChain(setterFn, opts) {
  const { convertor } = opts;
  if (convertor) {
    return function(value) {
      setterFn.call(this, convertor(value));
    };
  }
  return setterFn;
}
var NO_CHANGE = Symbol("no-change");
function buildChangeCallbackChain(setterFn, opts) {
  const { changeCb } = opts;
  if (changeCb) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (change !== NO_CHANGE) {
        changeCb.call(this, this);
      }
      return change;
    };
  }
  return setterFn;
}
function buildCheckDirtyChain(privateKey, setterFn, opts) {
  const { checkDirtyOnAssignment } = opts;
  if (checkDirtyOnAssignment) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (value?._dirty === true) {
        this.markDirty(privateKey);
      }
      return change;
    };
  }
  return setterFn;
}
function buildSetter(privateKey, opts) {
  const { equals = TRIPLE_EQ } = opts;
  return function(value) {
    const oldValue = this[privateKey];
    if (!equals(value, oldValue)) {
      this[privateKey] = value;
      this.onChangeDetection(privateKey);
      return value;
    }
    return NO_CHANGE;
  };
}

// packages/ag-charts-community/src/scene/zIndex.ts
var cmp = (a, b) => Math.sign(a - b);
function compareZIndex(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return cmp(a, b);
  }
  const aArray = typeof a === "number" ? [a] : a;
  const bArray = typeof b === "number" ? [b] : b;
  const length = Math.min(aArray.length, bArray.length);
  for (let i = 0; i < length; i += 1) {
    const diff2 = cmp(aArray[i], bArray[i]);
    if (diff2 !== 0)
      return diff2;
  }
  return cmp(aArray.length, bArray.length);
}

// packages/ag-charts-community/src/scene/node.ts
var MAX_ERROR_COUNT = 5;
var _Node = class _Node {
  constructor(options) {
    /** Unique number to allow creation order to be easily determined. */
    this.serialNumber = _Node._nextSerialNumber++;
    this.childNodeCounts = { groups: 0, nonGroups: 0, thisComplexity: 0, complexity: 0 };
    /** Unique node ID in the form `ClassName-NaturalNumber`. */
    this.id = createId(this);
    this.name = void 0;
    this.transitionOut = void 0;
    this.pointerEvents = 0 /* All */;
    this._datum = void 0;
    this._previousDatum = void 0;
    this.scene = void 0;
    this._debugDirtyProperties = void 0;
    this.parentNode = void 0;
    this.cachedBBox = void 0;
    /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */
    this.isContainerNode = false;
    this.visible = true;
    this.zIndex = 0;
    this.batchLevel = 0;
    this.batchDirty = false;
    this.name = options?.name;
    this.tag = options?.tag ?? NaN;
    this.zIndex = options?.zIndex ?? 0;
    this.scene = options?.scene;
    if (options?.debugDirty ?? _Node._debugEnabled) {
      this._debugDirtyProperties = /* @__PURE__ */ new Map([["__first__", []]]);
    }
  }
  static toSVG(node, width2, height2) {
    const svg = node?.toSVG();
    if (svg == null || !svg.elements.length && !svg.defs?.length)
      return;
    const root = createSvgElement("svg");
    root.setAttribute("width", String(width2));
    root.setAttribute("height", String(height2));
    root.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    root.setAttribute("overflow", "visible");
    if (svg.defs?.length) {
      const defs = createSvgElement("defs");
      defs.append(...svg.defs);
      root.append(defs);
    }
    root.append(...svg.elements);
    return root.outerHTML;
  }
  static *extractBBoxes(nodes, skipInvisible) {
    for (const n of nodes) {
      if (!skipInvisible || n.visible && !n.transitionOut) {
        const bbox = n.getBBox();
        if (bbox)
          yield bbox;
      }
    }
  }
  /**
   * Some arbitrary data bound to the node.
   */
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    if (this._datum !== datum) {
      this._previousDatum = this._datum;
      this._datum = datum;
    }
  }
  get previousDatum() {
    return this._previousDatum;
  }
  get layerManager() {
    return this.scene?.layersManager;
  }
  get imageLoader() {
    return this.scene?.imageLoader;
  }
  closestDatum() {
    for (const { datum } of this.traverseUp(true)) {
      if (datum != null) {
        return datum;
      }
    }
  }
  /** Perform any pre-rendering initialization. */
  preRender(_renderCtx, thisComplexity = 1) {
    this.childNodeCounts.groups = 0;
    this.childNodeCounts.nonGroups = 1;
    this.childNodeCounts.complexity = thisComplexity;
    this.childNodeCounts.thisComplexity = thisComplexity;
    if (this.batchLevel > 0 || this.batchDirty) {
      throw new Error("AG Charts - illegal rendering state; batched update in progress");
    }
    return this.childNodeCounts;
  }
  /** Guaranteed isolated render - if there is any failure, the Cavans2D context is returned to its prior state. */
  isolatedRender(renderCtx) {
    renderCtx.ctx.save();
    try {
      this.render(renderCtx);
    } catch (e) {
      const errorCount = e.errorCount ?? 1;
      if (errorCount >= MAX_ERROR_COUNT) {
        e.errorCount = errorCount;
        throw e;
      }
      Logger2.warnOnce("Error during rendering", e, e.stack);
    } finally {
      renderCtx.ctx.restore();
    }
  }
  render(renderCtx) {
    const { stats } = renderCtx;
    this.debugDirtyProperties();
    if (renderCtx.debugNodeSearch) {
      const idOrName = this.name ?? this.id;
      if (renderCtx.debugNodeSearch.some((v) => typeof v === "string" ? v === idOrName : v.test(idOrName))) {
        renderCtx.debugNodes[this.name ?? this.id] = this;
      }
    }
    if (stats) {
      stats.nodesRendered++;
      stats.opsPerformed += this.childNodeCounts.thisComplexity;
    }
  }
  setScene(scene) {
    this.scene = scene;
  }
  *traverseUp(includeSelf) {
    let node = this;
    if (includeSelf) {
      yield node;
    }
    while (node = node.parentNode) {
      yield node;
    }
  }
  /**
   * Checks if the node is the root (has no parent).
   */
  isRoot() {
    return !this.parentNode;
  }
  removeChild(node) {
    throw new Error(
      `AG Charts - internal error, unknown child node ${node.name ?? node.id} in $${this.name ?? this.id}`
    );
  }
  remove() {
    this.parentNode?.removeChild(this);
  }
  destroy() {
    this.parentNode?.removeChild(this);
  }
  batchedUpdate(fn) {
    this.batchLevel++;
    fn();
    this.batchLevel--;
    if (this.batchLevel === 0 && this.batchDirty) {
      this.markDirty();
      this.batchDirty = false;
    }
  }
  setProperties(styles) {
    this.batchLevel++;
    Object.assign(this, styles);
    this.batchLevel--;
    if (this.batchLevel === 0 && this.batchDirty) {
      this.markDirty();
      this.batchDirty = false;
    }
    return this;
  }
  containsPoint(_x, _y) {
    return false;
  }
  pickNode(x, y) {
    if (this.containsPoint(x, y)) {
      return this;
    }
  }
  pickNodes(x, y, into = []) {
    if (this.containsPoint(x, y)) {
      into.push(this);
    }
    return into;
  }
  getBBox() {
    this.cachedBBox ?? (this.cachedBBox = Object.freeze(this.computeBBox()));
    return this.cachedBBox;
  }
  computeBBox() {
    return;
  }
  onChangeDetection(property) {
    this.markDirty(property);
  }
  markDirtyChildrenOrder() {
    this.cachedBBox = void 0;
  }
  markDirty(property) {
    if (this.batchLevel > 0) {
      this.batchDirty = true;
      return;
    }
    if (property != null && this._debugDirtyProperties) {
      this.markDebugProperties(property);
    }
    this.cachedBBox = void 0;
    this.parentNode?.markDirty();
  }
  markDebugProperties(property) {
    const sources = this._debugDirtyProperties?.get(property) ?? [];
    const caller = new Error().stack?.split("\n").filter((line) => {
      return line !== "Error" && !line.includes(".markDebugProperties") && !line.includes(".markDirty") && !line.includes("Object.assign ") && !line.includes(`${this.constructor.name}.`);
    }) ?? "unknown";
    sources.push(caller[0].replace(" at ", "").trim());
    this._debugDirtyProperties?.set(property, sources);
  }
  debugDirtyProperties() {
    if (this._debugDirtyProperties == null)
      return;
    if (!this._debugDirtyProperties.has("__first__")) {
      this._debugDirtyProperties.forEach((sources, property) => {
        if (sources.length > 1) {
          console.groupCollapsed(
            `Property changed multiple times before render: ${this.constructor.name}.${property} (${sources.length}x)`
          );
          sources.forEach((source) => console.log(source));
          console.groupEnd();
        }
      });
    }
    this._debugDirtyProperties.clear();
  }
  onZIndexChange() {
    this.parentNode?.markDirtyChildrenOrder();
  }
  toSVG() {
    return;
  }
};
_Node._nextSerialNumber = 0;
// eslint-disable-next-line sonarjs/public-static-readonly
_Node._debugEnabled = false;
__decorateClass([
  SceneChangeDetection()
], _Node.prototype, "visible", 2);
__decorateClass([
  SceneObjectChangeDetection({
    equals: objectsEqual,
    changeCb: (target) => target.onZIndexChange()
  })
], _Node.prototype, "zIndex", 2);
var Node2 = _Node;

// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
  return (d) => Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
  if (typeof a === "string") {
    try {
      a = Color.fromString(a);
    } catch {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === "string") {
    try {
      b = Color.fromString(b);
    } catch {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  return (d) => Color.mix(a, b, d).toRgbaString();
}

// packages/ag-charts-community/src/motion/easing.ts
var linear = (n) => n;
var easeOut = (n) => Math.sin(n * Math.PI / 2);
var inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;

// packages/ag-charts-community/src/motion/animation.ts
var QUICK_TRANSITION = 0.2;
var PHASE_ORDER = ["initial", "remove", "update", "add", "trailing", "end", "none"];
var PHASE_METADATA = {
  initial: {
    animationDuration: 1,
    animationDelay: 0
  },
  add: {
    animationDuration: 0.25,
    animationDelay: 0.75
  },
  remove: {
    animationDuration: 0.25,
    animationDelay: 0
  },
  update: {
    animationDuration: 0.5,
    animationDelay: 0.25
  },
  trailing: {
    animationDuration: QUICK_TRANSITION,
    animationDelay: 1,
    skipIfNoEarlierAnimations: true
  },
  end: {
    animationDelay: 1 + QUICK_TRANSITION,
    animationDuration: 0,
    skipIfNoEarlierAnimations: true
  },
  none: {
    animationDuration: 0,
    animationDelay: 0
  }
};
function isNodeArray(array4) {
  return array4.every((n) => n instanceof Node2);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };
}
function animationValuesEqual(a, b) {
  if (a === b) {
    return true;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));
  } else if (isInterpolating(a) && isInterpolating(b)) {
    return a.equals(b);
  } else if (isPlainObject2(a) && isPlainObject2(b)) {
    return objectsEqualWith(a, b, animationValuesEqual);
  }
  return false;
}
var Animation = class {
  constructor(opts) {
    this.isComplete = false;
    this.elapsed = 0;
    this.iteration = 0;
    this.isPlaying = false;
    this.isReverse = false;
    this.id = opts.id;
    this.groupId = opts.groupId;
    this.autoplay = opts.autoplay ?? true;
    this.ease = opts.ease ?? linear;
    this.phase = opts.phase;
    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;
    this.duration = durationProportion * opts.defaultDuration;
    this.delay = (opts.delay ?? 0) * opts.defaultDuration;
    this.onComplete = opts.onComplete;
    this.onPlay = opts.onPlay;
    this.onStop = opts.onStop;
    this.onUpdate = opts.onUpdate;
    this.interpolate = this.createInterpolator(opts.from, opts.to);
    this.from = opts.from;
    if (opts.skip === true) {
      this.onUpdate?.(opts.to, false, this);
      this.onStop?.(this);
      this.onComplete?.(this);
      this.isComplete = true;
    }
    if (opts.collapsable !== false) {
      this.duration = this.checkCollapse(opts, this.duration);
    }
  }
  checkCollapse(opts, calculatedDuration) {
    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;
  }
  play(initialUpdate = false) {
    if (this.isPlaying || this.isComplete)
      return;
    this.isPlaying = true;
    this.onPlay?.(this);
    if (!this.autoplay)
      return;
    this.autoplay = false;
    if (!initialUpdate)
      return;
    this.onUpdate?.(this.from, true, this);
  }
  stop() {
    this.isPlaying = false;
    if (!this.isComplete) {
      this.isComplete = true;
      this.onStop?.(this);
    }
  }
  update(time2) {
    if (this.isComplete)
      return time2;
    if (!this.isPlaying && this.autoplay) {
      this.play(true);
    }
    const previousElapsed = this.elapsed;
    this.elapsed += time2;
    if (this.delay > this.elapsed)
      return 0;
    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
    this.onUpdate?.(value, false, this);
    const totalDuration = this.delay + this.duration;
    if (this.elapsed >= totalDuration) {
      this.stop();
      this.isComplete = true;
      this.onComplete?.(this);
      return time2 - (totalDuration - previousElapsed);
    }
    return 0;
  }
  get delta() {
    return this.ease(clamp3(0, (this.elapsed - this.delay) / this.duration, 1));
  }
  createInterpolator(from2, to) {
    if (typeof to !== "object" || isInterpolating(to)) {
      return this.interpolateValue(from2, to);
    }
    const interpolatorEntries = [];
    for (const key of Object.keys(to)) {
      const interpolator = this.interpolateValue(from2[key], to[key]);
      if (interpolator != null) {
        interpolatorEntries.push([key, interpolator]);
      }
    }
    return (d) => {
      const result = {};
      for (const [key, interpolator] of interpolatorEntries) {
        result[key] = interpolator(d);
      }
      return result;
    };
  }
  interpolateValue(a, b) {
    if (a == null || b == null) {
      return;
    } else if (isInterpolating(a)) {
      return (d) => a[interpolate](b, d);
    }
    try {
      switch (typeof a) {
        case "number":
          return interpolateNumber(a, b);
        case "string":
          return interpolateColor(a, b);
        case "boolean":
          if (a === b) {
            return () => a;
          }
          break;
        case "object":
          return () => a;
        default:
          throw new Error(`Unable to interpolate values: ${a}, ${b}`);
      }
    } catch {
    }
    throw new Error(`Unable to interpolate values: ${a}, ${b}`);
  }
};

// packages/ag-charts-community/src/motion/fromToMotion.ts
var NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
  added: "add",
  updated: "update",
  removed: "remove",
  unknown: "initial",
  "no-op": "none"
};
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {
  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const processNodes = (liveNodes, subNodes) => {
    let prevFromProps;
    let liveNodeIndex = 0;
    let nodeIndex = 0;
    for (const node of subNodes) {
      const isLive = liveNodes[liveNodeIndex] === node;
      const ctx = {
        last: nodeIndex >= subNodes.length - 1,
        lastLive: liveNodeIndex >= liveNodes.length - 1,
        prev: subNodes[nodeIndex - 1],
        prevFromProps,
        prevLive: liveNodes[liveNodeIndex - 1],
        next: subNodes[nodeIndex + 1],
        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
      };
      const animationId = `${groupId}_${subId}_${node.id}`;
      animationManager.stopByAnimationId(animationId);
      let status = "unknown";
      if (!isLive) {
        status = "removed";
      } else if (getDatumId && diff2) {
        status = calculateStatus(node, node.datum, getDatumId, diff2);
      }
      node.transitionOut = status === "removed";
      const { phase, start: start2, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);
      const {
        phase: toPhase,
        start: toStart,
        finish: toFinish,
        delay: toDelay,
        duration: toDuration,
        ...to
      } = toFn(node, node.datum, status, ctx);
      const collapsable = finish == null;
      animationManager.animate({
        id: animationId,
        groupId,
        phase: phase ?? toPhase ?? "update",
        duration: duration ?? toDuration,
        delay: delay ?? toDelay,
        from: from2,
        to,
        ease: easeOut,
        collapsable,
        onPlay: () => {
          const startProps = { ...start2, ...toStart, ...from2 };
          applyFn(node, startProps, "start");
        },
        onUpdate(props) {
          applyFn(node, props, "update");
        },
        onStop: () => {
          const endProps = {
            ...start2,
            ...toStart,
            ...from2,
            ...to,
            ...finish,
            ...toFinish
          };
          applyFn(node, endProps, "end");
        }
      });
      if (isLive) {
        liveNodeIndex++;
      }
      nodeIndex++;
      prevFromProps = from2;
    }
  };
  let selectionIndex = 0;
  for (const selection of selections) {
    const selectionNodes = selection.nodes();
    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));
    processNodes(liveNodes, selectionNodes);
    animationManager.animate({
      id: `${groupId}_${subId}_selection_${selectionIndex}`,
      groupId,
      phase: "end",
      from: 0,
      to: 1,
      ease: easeOut,
      onStop() {
        selection.cleanup();
      }
    });
    selectionIndex++;
  }
  processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const { start: start2, finish, phase } = extraOpts;
  animationManager.animate({
    id: `${groupId}_${subId}`,
    groupId,
    phase: phase ?? "update",
    from: from2,
    to,
    ease: easeOut,
    onPlay: () => {
      if (!start2)
        return;
      for (const node of nodes) {
        node.setProperties(start2);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(start2);
        }
      }
    },
    onUpdate(props) {
      for (const node of nodes) {
        node.setProperties(props);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(props);
        }
      }
    },
    onStop: () => {
      for (const node of nodes) {
        node.setProperties({ ...to, ...finish });
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties({ ...to, ...finish });
        }
        selection.cleanup();
      }
    }
  });
}
function calculateStatus(node, datum, getDatumId, diff2) {
  const id = getDatumId(node, datum);
  if (diff2.added.has(id)) {
    return "added";
  }
  if (diff2.removed.has(id)) {
    return "removed";
  }
  if (node.previousDatum == null && node.datum != null) {
    return "added";
  }
  if (node.previousDatum != null && node.datum == null) {
    return "removed";
  }
  return "updated";
}

// packages/ag-charts-community/src/util/ticks.ts
import { Logger as Logger3, clamp as clamp4, countFractionDigits, createNumberFormatter, parseNumberFormat } from "ag-charts-core";

// packages/ag-charts-community/src/util/time/duration.ts
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// packages/ag-charts-community/src/util/time/encoding.ts
var tzOffset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
var unitEncoding = {
  millisecond: {
    milliseconds: 1,
    hierarchy: "day",
    encode(date5) {
      return date5.getTime();
    },
    decode(encoded) {
      return new Date(encoded);
    }
  },
  second: {
    milliseconds: durationSecond,
    hierarchy: "day",
    encode(date5, utc) {
      const offset = utc ? 0 : tzOffset;
      return Math.floor((date5.getTime() - offset) / durationSecond);
    },
    decode(encoded, utc) {
      const offset = utc ? 0 : tzOffset;
      return new Date(offset + encoded * durationSecond);
    }
  },
  minute: {
    milliseconds: durationMinute,
    hierarchy: "day",
    encode(date5, utc) {
      const offset = utc ? 0 : tzOffset;
      return Math.floor((date5.getTime() - offset) / durationMinute);
    },
    decode(encoded, utc) {
      const offset = utc ? 0 : tzOffset;
      return new Date(offset + encoded * durationMinute);
    }
  },
  hour: {
    milliseconds: durationHour,
    hierarchy: "day",
    encode(date5, utc) {
      const offset = utc ? 0 : tzOffset;
      return Math.floor((date5.getTime() - offset) / durationHour);
    },
    decode(encoded, utc) {
      const offset = utc ? 0 : tzOffset;
      return new Date(offset + encoded * durationHour);
    }
  },
  day: {
    milliseconds: durationDay,
    hierarchy: "month",
    encode(date5, utc) {
      const tzOffsetMs = utc ? 0 : date5.getTimezoneOffset() * durationMinute;
      return Math.floor((date5.getTime() - tzOffsetMs) / durationDay);
    },
    decode(encoded, utc) {
      let d;
      if (utc) {
        d = /* @__PURE__ */ new Date(0);
        d.setUTCDate(d.getUTCDate() + encoded);
        d.setUTCHours(0, 0, 0, 0);
      } else {
        d = new Date(1970, 0, 1);
        d.setDate(d.getDate() + encoded);
      }
      return d;
    }
  },
  month: {
    milliseconds: durationMonth,
    hierarchy: "year",
    encode(date5, utc) {
      if (utc) {
        return date5.getUTCFullYear() * 12 + date5.getUTCMonth();
      } else {
        return date5.getFullYear() * 12 + date5.getMonth();
      }
    },
    decode(encoded, utc) {
      if (utc) {
        const year = Math.floor(encoded / 12);
        const m = encoded - year * 12;
        return new Date(Date.UTC(year, m, 1));
      } else {
        const y = Math.floor(encoded / 12);
        const month = encoded - y * 12;
        return new Date(y, month, 1);
      }
    }
  },
  year: {
    milliseconds: durationYear,
    hierarchy: void 0,
    encode(date5, utc) {
      if (utc) {
        return date5.getUTCFullYear();
      } else {
        return date5.getFullYear();
      }
    },
    decode(encoded, utc) {
      let d;
      if (utc) {
        d = /* @__PURE__ */ new Date();
        d.setUTCFullYear(encoded);
        d.setUTCMonth(0, 1);
        d.setUTCHours(0, 0, 0, 0);
      } else {
        d = new Date(encoded, 0, 1, 0, 0, 0, 0);
      }
      return d;
    }
  }
};

// packages/ag-charts-community/src/util/time/range.ts
function timeInterval(interval) {
  return typeof interval === "string" ? { unit: interval, step: 1, epoch: void 0, utc: false } : {
    unit: interval.unit,
    step: interval.step ?? 1,
    epoch: interval.epoch,
    utc: interval.utc ?? false
  };
}
function getOffset(unit, step, epoch, utc) {
  if (epoch == null)
    return 0;
  const encoding = unitEncoding[unit];
  return Math.floor(encoding.encode(new Date(epoch), utc)) % step;
}
function encode(d, unit, step, utc, offset) {
  const encoding = unitEncoding[unit];
  return Math.floor((encoding.encode(new Date(d), utc) - offset) / step);
}
function decode(encoded, unit, step, utc, offset) {
  const encoding = unitEncoding[unit];
  return encoding.decode(encoded * step + offset, utc);
}
function encodingFloor(date5, unit, step, utc, offset) {
  const d = new Date(date5);
  const e = encode(d, unit, step, utc, offset);
  return decode(e, unit, step, utc, offset);
}
function encodingCeil(date5, unit, step, utc, offset) {
  const d = new Date(Number(date5) - 1);
  const e = encode(d, unit, step, utc, offset);
  return decode(e + 1, unit, step, utc, offset);
}
function intervalFloor(interval, date5) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return encodingFloor(date5, unit, step, utc, offset);
}
function intervalCeil(interval, date5) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return encodingCeil(date5, unit, step, utc, offset);
}
function intervalPrevious(interval, date5) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return decode(
    encode(encodingCeil(date5, unit, step, utc, offset), unit, step, utc, offset) - 1,
    unit,
    step,
    utc,
    offset
  );
}
function intervalNext(interval, date5) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return decode(
    encode(encodingFloor(date5, unit, step, utc, offset), unit, step, utc, offset) + 1,
    unit,
    step,
    utc,
    offset
  );
}
function intervalExtent(start2, stop, visibleRange) {
  if (start2.valueOf() > stop.valueOf()) {
    [start2, stop] = [stop, start2];
    if (visibleRange != null) {
      visibleRange = [1 - visibleRange[1], 1 - visibleRange[0]];
    }
  }
  if (visibleRange != null) {
    const delta3 = stop.valueOf() - start2.valueOf();
    const t0 = start2.valueOf();
    start2 = new Date(t0 + visibleRange[0] * delta3);
    stop = new Date(t0 + visibleRange[1] * delta3);
  }
  return [new Date(start2), new Date(stop)];
}
function rangeData(interval, start2, stop, { extend = false, visibleRange = [0, 1], limit, defaultAlignment = "start" } = {}) {
  const params = timeInterval(interval);
  const { unit, step, utc } = params;
  let epoch;
  if (params.epoch != null) {
    epoch = params.epoch;
  } else if (defaultAlignment === "interval") {
    epoch = void 0;
  } else if (start2.valueOf() > stop.valueOf()) {
    epoch = stop;
  } else {
    epoch = start2;
  }
  const offset = getOffset(params.unit, params.step, epoch, params.utc);
  let [d0, d1] = intervalExtent(start2, stop, visibleRange);
  d0 = extend ? encodingFloor(d0, unit, step, utc, offset) : encodingCeil(d0, unit, step, utc, offset);
  d1 = extend ? encodingCeil(d1, unit, step, utc, offset) : encodingFloor(d1, unit, step, utc, offset);
  const e0 = encode(d0, unit, step, utc, offset);
  let e1 = encode(d1, unit, step, utc, offset);
  if (limit != null && e1 - e0 > limit) {
    e1 = e0 + limit;
  }
  return {
    range: [e0, e1],
    unit,
    step,
    utc,
    offset
  };
}
function intervalRangeCount(interval, start2, stop, params) {
  const {
    range: [e0, e1]
  } = rangeData(interval, start2, stop, params);
  return Math.abs(e1 - e0);
}
function intervalRange(interval, start2, stop, params) {
  const {
    range: [e0, e1],
    unit,
    step,
    utc,
    offset
  } = rangeData(interval, start2, stop, params);
  const values = [];
  for (let e = e0; e <= e1; e += 1) {
    const d = decode(e, unit, step, utc, offset);
    values.push(d);
  }
  return values;
}
function intervalRangeStartIndex(interval, start2, stop, { extend, visibleRange, limit, defaultAlignment } = {}) {
  const {
    range: [s]
  } = rangeData(interval, start2, stop, { extend, visibleRange, limit, defaultAlignment });
  const {
    range: [s0]
  } = rangeData(interval, start2, stop, { extend, limit, defaultAlignment });
  return s - s0;
}

// packages/ag-charts-community/src/util/time/index.ts
function intervalUnit(interval) {
  return typeof interval === "string" ? interval : interval.unit;
}
function intervalStep(interval) {
  return typeof interval === "string" ? 1 : interval.step ?? 1;
}
function intervalEpoch(interval) {
  return typeof interval === "string" ? void 0 : interval.epoch;
}
function intervalHierarchy(interval) {
  return unitEncoding[intervalUnit(interval)].hierarchy;
}
function intervalMilliseconds(interval) {
  const step = intervalStep(interval);
  return step * unitEncoding[intervalUnit(interval)].milliseconds;
}

// packages/ag-charts-community/src/util/ticks.ts
var tInterval = (timeInterval3, step) => ({
  duration: intervalMilliseconds(timeInterval3) * step,
  timeInterval: timeInterval3,
  step
});
var TickIntervals = [
  tInterval({ unit: "second" }, 1),
  tInterval({ unit: "second" }, 5),
  tInterval({ unit: "second" }, 15),
  tInterval({ unit: "second" }, 30),
  tInterval({ unit: "minute" }, 1),
  tInterval({ unit: "minute" }, 5),
  tInterval({ unit: "minute" }, 15),
  tInterval({ unit: "minute" }, 30),
  tInterval({ unit: "hour" }, 1),
  tInterval({ unit: "hour" }, 3),
  tInterval({ unit: "hour" }, 6),
  tInterval({ unit: "hour" }, 12),
  tInterval({ unit: "day" }, 1),
  tInterval({ unit: "day" }, 2),
  tInterval({ unit: "day", step: 7 }, 1),
  tInterval({ unit: "day", step: 7 }, 2),
  tInterval({ unit: "day", step: 7 }, 3),
  tInterval({ unit: "month" }, 1),
  tInterval({ unit: "month" }, 2),
  tInterval({ unit: "month" }, 3),
  tInterval({ unit: "month" }, 4),
  tInterval({ unit: "month" }, 6),
  tInterval({ unit: "year" }, 1)
];
var TickMultipliers = [1, 2, 5, 10];
function isCloseToInteger(n, delta3) {
  return Math.abs(Math.round(n) - n) < delta3;
}
function countTicks(d0, d1, step) {
  const extent2 = Math.abs(d1 - d0);
  return extent2 >= step ? Math.abs(d1 - d0) / step + 1 : 1;
}
function createTicks(start2, stop, count, minCount, maxCount, visibleRange) {
  if (start2 === stop)
    return { ticks: [start2], count: 1, firstTickIndex: 0 };
  if (count < 2)
    return { ticks: [start2, stop], count: 2, firstTickIndex: 0 };
  const step = tickStep(start2, stop, count, minCount, maxCount);
  if (!Number.isFinite(step))
    return { ticks: [], count: 0, firstTickIndex: void 0 };
  let d0 = start2;
  let d1 = stop;
  if (!isCloseToInteger(d0 / step, 1e-12)) {
    d0 = Math.ceil(d0 / step) * step;
  }
  if (!isCloseToInteger(d1 / step, 1e-12)) {
    d1 = Math.floor(d1 / step) * step;
  }
  if (visibleRange != null) {
    const dr = d1 - d0;
    const vr = stop - start2;
    const vd0 = start2 + vr * visibleRange[0];
    const vd1 = start2 + vr * visibleRange[1];
    visibleRange = [(vd0 - d0) / dr, (vd1 - d0) / dr];
  }
  const { ticks } = range(d0, d1, step, visibleRange);
  const firstTick = ticks.at(0);
  return {
    ticks,
    count: countTicks(d0, d1, step),
    firstTickIndex: firstTick == null ? void 0 : Math.round((firstTick - d0) / step)
  };
}
var minPrimaryTickRatio = Math.floor(2 * durationWeek / durationMonth * 10) / 10;
function isPrimaryTickInterval({ timeInterval: timeInterval3, step }) {
  const milliseconds = intervalMilliseconds(timeInterval3) * step;
  const hierarchy = intervalHierarchy(timeInterval3);
  const hierarchyMilliseconds = hierarchy ? intervalMilliseconds(hierarchy) : void 0;
  return milliseconds <= (hierarchyMilliseconds ?? Infinity) * minPrimaryTickRatio;
}
function defaultEpoch(timeInterval3, { weekStart }) {
  if (timeInterval3.unit === "day" && timeInterval3.step === 7) {
    return weekStart;
  }
}
function getTickTimeInterval(start2, stop, count, minCount, maxCount, {
  weekStart,
  primaryOnly = false,
  targetInterval
}) {
  if (count <= 0)
    return;
  const target = targetInterval ?? Math.abs(stop - start2) / Math.max(count, 1);
  const i0 = TickIntervals.findLast((t) => (!primaryOnly || isPrimaryTickInterval(t)) && target > t.duration);
  const i1 = TickIntervals.find((t) => (!primaryOnly || isPrimaryTickInterval(t)) && target <= t.duration);
  if (i0 == null) {
    const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);
    return { unit: "millisecond", step: step2 };
  } else if (i1 == null) {
    const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;
    return { unit: "year", step: step2 };
  }
  const { timeInterval: timeInterval3, step } = target - i0.duration < i1.duration - target ? i0 : i1;
  return {
    unit: timeInterval3.unit,
    step: intervalStep(timeInterval3) * step,
    epoch: defaultEpoch(timeInterval3, { weekStart })
  };
}
function tickStep(start2, end2, count, minCount = 0, maxCount = Infinity) {
  if (start2 === end2) {
    return clamp4(1, minCount, maxCount);
  } else if (count < 1) {
    return NaN;
  }
  const extent2 = Math.abs(end2 - start2);
  const step = 10 ** Math.floor(Math.log10(extent2 / count));
  let m = NaN, minDiff = Infinity, isInBounds = false;
  for (const multiplier of TickMultipliers) {
    const c = Math.ceil(extent2 / (multiplier * step));
    const validBounds = c >= minCount && c <= maxCount;
    if (isInBounds && !validBounds)
      continue;
    const diffCount = Math.abs(c - count);
    if (minDiff > diffCount || isInBounds !== validBounds) {
      isInBounds || (isInBounds = validBounds);
      minDiff = diffCount;
      m = multiplier;
    }
  }
  return m * step;
}
function decimalPlaces(decimal) {
  for (let i = decimal.length - 1; i >= 0; i -= 1) {
    if (decimal[i] !== "0") {
      return i + 1;
    }
  }
  return 0;
}
function tickFormat(ticks, format) {
  const options = parseNumberFormat(format ?? ",f");
  if (options == null)
    return;
  if (options.precision == null || isNaN(options.precision)) {
    if (!options.type || "eEFgGnprs".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x))
            return 0;
          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/[.e]/g);
          return (integer !== "1" && integer !== "-1" ? 1 : 0) + decimalPlaces(decimal) + 1;
        })
      );
    } else if ("f%".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x) || x === 0)
            return 0;
          const l = Math.floor(Math.log10(Math.abs(x)));
          const digits = options.type ? 6 : 12;
          const decimal = x.toExponential(digits - 1).split(/[.e]/g)[1];
          const decimalLength = decimalPlaces(decimal);
          return Math.max(0, decimalLength - l);
        })
      );
    }
  }
  const formatter2 = createNumberFormatter(options);
  return (n) => formatter2(Number(n));
}
function range(start2, end2, step, visibleRange) {
  if (!Number.isFinite(step) || step <= 0) {
    return { ticks: [], count: 0, firstTickIndex: void 0 };
  } else if (start2 === end2) {
    return { ticks: [start2], count: 1, firstTickIndex: 0 };
  }
  const f = 10 ** countFractionDigits(step);
  const d0 = Math.min(start2, end2);
  const d1 = Math.max(start2, end2);
  let vd0;
  let vd1;
  if (visibleRange != null && (visibleRange[0] !== 0 || visibleRange[1] !== 1)) {
    const rangeExtent = end2 - start2;
    const adjustedStart = start2 + rangeExtent * visibleRange[0];
    const adjustedEnd = end2 - rangeExtent * (1 - visibleRange[1]);
    vd0 = Math.min(adjustedStart, adjustedEnd);
    vd1 = Math.max(adjustedStart, adjustedEnd);
  } else {
    vd0 = d0;
    vd1 = d1;
  }
  vd0 = Math.floor(vd0 * f) / f;
  vd1 = Math.ceil(vd1 * f) / f;
  const ticks = [];
  for (let i = 0; ; i += 1) {
    const p = Math.round((d0 + step * i) * f) / f;
    if (p > d1)
      break;
    if (p >= vd0 && p <= vd1) {
      ticks.push(p);
    }
  }
  const firstTick = ticks.at(0);
  return {
    ticks,
    count: countTicks(d0, d1, step),
    firstTickIndex: firstTick == null ? void 0 : Math.round((firstTick - d0) / step)
  };
}
function isDenseInterval(count, availableRange) {
  if (count >= availableRange) {
    Logger3.warnOnce(
      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`
    );
    return true;
  }
  return false;
}
function niceTicksDomain(start2, end2) {
  const extent2 = Math.abs(end2 - start2);
  const step = 10 ** Math.floor(Math.log10(extent2));
  let minError = Infinity, ticks = [start2, end2];
  for (const multiplier of TickMultipliers) {
    const m = multiplier * step;
    const d0 = Math.floor(start2 / m) * m;
    const d1 = Math.ceil(end2 / m) * m;
    const error = 1 - extent2 / Math.abs(d1 - d0);
    if (minError > error) {
      minError = error;
      ticks = [d0, d1];
    }
  }
  return ticks;
}
function estimateTickCount(rangeExtent, zoomExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {
  if (rangeExtent <= 0) {
    return { minTickCount: 0, maxTickCount: 0, tickCount: 0 };
  }
  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));
  minSpacing ?? (minSpacing = defaultMinSpacing);
  maxSpacing ?? (maxSpacing = rangeExtent);
  if (minSpacing > maxSpacing) {
    if (minSpacing === defaultMinSpacing) {
      minSpacing = maxSpacing;
    } else {
      maxSpacing = minSpacing;
    }
  }
  minSpacing = Math.max(minSpacing, 1);
  const maxTickCount = Math.max(1, Math.floor(rangeExtent / (zoomExtent * minSpacing)));
  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / (zoomExtent * maxSpacing)));
  const tickCount = clamp4(minTickCount, Math.floor(defaultTickCount / zoomExtent), maxTickCount);
  return { minTickCount, maxTickCount, tickCount };
}

// packages/ag-charts-community/src/util/number.ts
import { clamp as clamp5 } from "ag-charts-core";
function clampArray(value, array4) {
  const [min, max] = findMinMax(array4);
  return clamp5(min, value, max);
}
function findMinMax(array4) {
  if (array4.length === 0)
    return [];
  const result = [Infinity, -Infinity];
  for (const val of array4) {
    if (val < result[0])
      result[0] = val;
    if (val > result[1])
      result[1] = val;
  }
  return result;
}
function findRangeExtent(array4) {
  const [min, max] = findMinMax(array4);
  return max - min;
}
function previousPowerOf2(value) {
  value = value | 0;
  if (value <= 0)
    return 0;
  if (value === 1)
    return 1;
  return 1 << 31 - Math.clz32(value);
}

// packages/ag-charts-community/src/scale/abstractScale.ts
var AbstractScale = class {
  ticks(_ticks, _domain, _visibleRange) {
    return void 0;
  }
  niceDomain(_ticks, domain = this.domain) {
    return domain;
  }
  get bandwidth() {
    return void 0;
  }
  get step() {
    return void 0;
  }
  get inset() {
    return void 0;
  }
};

// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale = class _ContinuousScale extends AbstractScale {
  constructor(domain = [], range3 = []) {
    super();
    this.domain = domain;
    this.range = range3;
    this.defaultTickCount = _ContinuousScale.defaultTickCount;
    this.defaultClamp = false;
  }
  static is(value) {
    return value instanceof _ContinuousScale;
  }
  normalizeDomains(...domains) {
    return normalizeContinuousDomains(...domains);
  }
  calcBandwidth(smallestInterval = 1, minWidth = 1) {
    const { domain } = this;
    const rangeDistance = this.getPixelRange();
    if (domain.length === 0)
      return rangeDistance;
    const intervals = Math.abs(domain[1].valueOf() - domain[0].valueOf()) / smallestInterval + 1;
    let bands = intervals;
    if (minWidth !== 0) {
      const maxBands = Math.floor(rangeDistance);
      bands = Math.min(bands, maxBands);
    }
    return rangeDistance / Math.max(1, bands);
  }
  convert(value, options) {
    const { domain } = this;
    if (!domain || domain.length < 2 || value == null) {
      return NaN;
    }
    const { range: range3 } = this;
    const clamp21 = options?.clamp ?? this.defaultClamp;
    let d0 = domain[0].valueOf();
    let d1 = domain[1].valueOf();
    let x = value.valueOf();
    if (this.transform) {
      d0 = this.transform(d0);
      d1 = this.transform(d1);
      x = this.transform(x);
    }
    if (clamp21) {
      const [start2, stop] = findMinMax([d0, d1]);
      if (x < start2) {
        return range3[0];
      } else if (x > stop) {
        return range3[1];
      }
    }
    if (d0 === d1) {
      return (range3[0] + range3[1]) / 2;
    } else if (x === d0) {
      return range3[0];
    } else if (x === d1) {
      return range3[1];
    }
    const r0 = range3[0];
    return r0 + (x - d0) / (d1 - d0) * (range3[1] - r0);
  }
  invert(x, _nearest) {
    const { domain } = this;
    if (domain.length < 2)
      return;
    let d0 = domain[0].valueOf();
    let d1 = domain[1].valueOf();
    if (this.transform) {
      d0 = this.transform(d0);
      d1 = this.transform(d1);
    }
    const { range: range3 } = this;
    const [r0, r1] = range3;
    let d;
    if (r0 === r1) {
      d = this.toDomain((d0 + d1) / 2);
    } else {
      d = this.toDomain(d0 + (x - r0) / (r1 - r0) * (d1 - d0));
    }
    return this.transformInvert ? this.transformInvert(d) : d;
  }
  getPixelRange() {
    const [a, b] = this.range;
    return Math.abs(b - a);
  }
};
_ContinuousScale.defaultTickCount = 5;
var ContinuousScale = _ContinuousScale;
function normalizeContinuousDomains(...domains) {
  let min;
  let minValue = Infinity;
  let max;
  let maxValue = -Infinity;
  for (const domain of domains) {
    for (const d of domain) {
      const value = d.valueOf();
      if (value < minValue) {
        minValue = value;
        min = d;
      }
      if (value > maxValue) {
        maxValue = value;
        max = d;
      }
    }
  }
  if (min != null && max != null) {
    const domain = [min, max];
    return { domain, animatable: true };
  } else {
    return { domain: [], animatable: false };
  }
}

// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super([0, 1], [0, 1]);
    this.type = "number";
  }
  static is(value) {
    return value instanceof _LinearScale;
  }
  static getTickStep(start2, stop, ticks) {
    const { interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = ticks;
    return interval ?? tickStep(start2, stop, tickCount, minTickCount, maxTickCount);
  }
  toDomain(d) {
    return d;
  }
  ticks({ interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount }, domain = this.domain, visibleRange) {
    if (!domain || domain.length < 2 || tickCount < 1 || !domain.every(isFinite)) {
      return { ticks: [], count: 0, firstTickIndex: 0 };
    }
    const [d0, d1] = domain;
    if (interval) {
      const step = Math.abs(interval);
      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {
        return range(d0, d1, step, visibleRange);
      }
    }
    return createTicks(d0, d1, tickCount, minTickCount, maxTickCount, visibleRange);
  }
  niceDomain(ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    const { tickCount = ContinuousScale.defaultTickCount } = ticks;
    let [start2, stop] = domain;
    if (tickCount === 1) {
      [start2, stop] = niceTicksDomain(start2, stop);
    } else if (tickCount > 1) {
      const roundStart = start2 > stop ? Math.ceil : Math.floor;
      const roundStop = start2 > stop ? Math.floor : Math.ceil;
      const maxAttempts = 4;
      for (let i = 0; i < maxAttempts; i++) {
        const prev0 = start2;
        const prev1 = stop;
        const step = _LinearScale.getTickStep(start2, stop, ticks);
        const [d0, d1] = domain;
        start2 = roundStart(d0 / step) * step;
        stop = roundStop(d1 / step) * step;
        if (start2 === prev0 && stop === prev1)
          break;
      }
    }
    return [start2, stop];
  }
};

// packages/ag-charts-community/src/util/extent.ts
function extent(values) {
  if (values.length === 0) {
    return null;
  }
  let min = Infinity;
  let max = -Infinity;
  for (const n of values) {
    const v = n instanceof Date ? n.getTime() : n;
    if (typeof v !== "number")
      continue;
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
  }
  const result = [min, max];
  return result.every(isFinite) ? result : null;
}
function normalisedExtentWithMetadata(d, min, max) {
  let clipped = false;
  const de = extent(d);
  if (de == null) {
    return { extent: min != null && max != null && min <= max ? [min, max] : [], clipped: false };
  }
  let [d0, d1] = de;
  if (min != null) {
    clipped || (clipped = min > d0);
    d0 = min;
  }
  if (max != null) {
    clipped || (clipped = max < d1);
    d1 = max;
  }
  if (d0 > d1) {
    return { extent: [], clipped: false };
  }
  return { extent: [d0, d1], clipped };
}

// packages/ag-charts-community/src/util/properties.ts
import { Logger as Logger4, isArray as isArray2, isPlainObject as isPlainObject3 } from "ag-charts-core";
var Property = addFakeTransformToInstanceProperty;
var BaseProperties = class {
  handleUnknownProperties(_unknownKeys, _properties) {
  }
  set(properties) {
    const { className = this.constructor.name } = this.constructor;
    if (properties == null) {
      this.clear();
      return this;
    }
    if (typeof properties !== "object") {
      Logger4.warn(`unable to set ${className} - expecting a properties object`);
      return this;
    }
    const keys = new Set(Object.keys(properties));
    for (const propertyKey of listDecoratedProperties(this)) {
      if (keys.has(propertyKey)) {
        const value = properties[propertyKey];
        const self = this;
        if (isProperties(self[propertyKey])) {
          if (self[propertyKey] instanceof PropertiesArray) {
            const array4 = self[propertyKey].reset(value);
            if (array4 == null) {
              Logger4.warn(`unable to set [${String(propertyKey)}] - expecting a properties array`);
            } else {
              self[propertyKey] = array4;
            }
          } else {
            self[propertyKey].set(value);
          }
        } else if (isPlainObject3(value)) {
          self[propertyKey] = merge(value, self[propertyKey] ?? {});
        } else {
          self[propertyKey] = value;
        }
        keys.delete(propertyKey);
      }
    }
    this.handleUnknownProperties(keys, properties);
    for (const unknownKey of keys) {
      Logger4.warn(`unable to set [${String(unknownKey)}] in ${className} - property is unknown`);
    }
    return this;
  }
  clear() {
    for (const propertyKey of listDecoratedProperties(this)) {
      const currentValue = this[propertyKey];
      if (isProperties(currentValue)) {
        currentValue.clear();
      } else {
        this[propertyKey] = void 0;
      }
    }
    return this;
  }
  toJson() {
    return listDecoratedProperties(this).reduce((object3, propertyKey) => {
      const propertyValue = this[propertyKey];
      object3[String(propertyKey)] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
      return object3;
    }, {});
  }
};
var PropertiesArray = class _PropertiesArray extends Array {
  constructor(itemFactory, ...properties) {
    super(properties.length);
    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);
    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;
    Object.defineProperty(this, "itemFactory", { value, enumerable: false, configurable: false });
    this.set(properties);
  }
  set(properties) {
    if (isArray2(properties)) {
      this.length = properties.length;
      for (let i = 0; i < properties.length; i++) {
        this[i] = this.itemFactory(properties[i]);
      }
    }
    return this;
  }
  reset(properties) {
    if (Array.isArray(properties)) {
      return new _PropertiesArray(this.itemFactory, ...properties);
    }
  }
  toJson() {
    return this.map((value) => value?.toJson?.() ?? value);
  }
};
function isProperties(value) {
  return value instanceof BaseProperties || value instanceof PropertiesArray;
}

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
import { arraysEqual as arraysEqual2, countLines, diffArrays, isPlainObject as isPlainObject8 } from "ag-charts-core";

// packages/ag-charts-community/src/motion/resetMotion.ts
function resetMotion(selectionsOrNodes, propsFn) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  for (const selection of selections) {
    for (const node of selection.nodes()) {
      const from2 = propsFn(node, node.datum);
      node.setProperties(from2);
    }
    selection.cleanup();
  }
  for (const node of nodes) {
    const from2 = propsFn(node, node.datum);
    node.setProperties(from2);
  }
}

// packages/ag-charts-community/src/scale/discreteTimeScale.ts
import { findMaxIndex, findMinIndex } from "ag-charts-core";

// packages/ag-charts-community/src/scale/bandScale.ts
import { Logger as Logger5, clamp as clamp6 } from "ag-charts-core";

// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating = (target, propertyKey) => {
  const mappedProperty = Symbol(String(propertyKey));
  target[mappedProperty] = void 0;
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[mappedProperty];
    },
    set(newValue) {
      const oldValue = this[mappedProperty];
      if (oldValue !== newValue) {
        this[mappedProperty] = newValue;
        this.invalid = true;
      }
    },
    enumerable: true,
    configurable: false
  });
};

// packages/ag-charts-community/src/scale/bandScale.ts
var _BandScale = class _BandScale extends AbstractScale {
  constructor() {
    super(...arguments);
    this.invalid = true;
    this.range = [0, 1];
    this.round = false;
    this._bandwidth = 1;
    this._step = 1;
    this._inset = 1;
    this._rawBandwidth = 1;
    /**
     * The ratio of the range that is reserved for space between bands.
     */
    this._paddingInner = 0;
    /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */
    this._paddingOuter = 0;
  }
  static is(value) {
    return value instanceof _BandScale;
  }
  get bandwidth() {
    this.refresh();
    return this._bandwidth;
  }
  get step() {
    this.refresh();
    return this._step;
  }
  get inset() {
    this.refresh();
    return this._inset;
  }
  get rawBandwidth() {
    this.refresh();
    return this._rawBandwidth;
  }
  set padding(value) {
    value = clamp6(0, value, 1);
    this._paddingInner = value;
    this._paddingOuter = value;
  }
  get padding() {
    return this._paddingInner;
  }
  set paddingInner(value) {
    this.invalid = true;
    this._paddingInner = clamp6(0, value, 1);
  }
  get paddingInner() {
    return this._paddingInner;
  }
  set paddingOuter(value) {
    this.invalid = true;
    this._paddingOuter = clamp6(0, value, 1);
  }
  get paddingOuter() {
    return this._paddingOuter;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger5.warnOnce("Expected update to not invalidate scale");
    }
  }
  convert(d, options) {
    this.refresh();
    const i = this.findIndex(d, options?.alignment);
    if (i == null || i < 0 || i >= this.bands.length) {
      return NaN;
    }
    return this.ordinalRange(i);
  }
  invertNearestIndex(position) {
    this.refresh();
    const bandCount = this.bands.length;
    if (bandCount === 0)
      return -1;
    let low = 0;
    let high = bandCount - 1;
    let closestDistance = Infinity;
    let closestIndex = 0;
    while (low <= high) {
      const mid = (high + low) / 2 | 0;
      const p = this.ordinalRange(mid);
      const distance = Math.abs(p - position);
      if (distance === 0)
        return mid;
      if (distance < closestDistance) {
        closestDistance = distance;
        closestIndex = mid;
      }
      if (p < position) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return closestIndex;
  }
  update() {
    const [r0, r1] = this.range;
    let { _paddingInner: paddingInner } = this;
    const { _paddingOuter: paddingOuter, round: round2, bands } = this;
    const bandCount = bands.length;
    if (bandCount === 0)
      return;
    const rangeDistance = r1 - r0;
    let rawStep;
    if (bandCount === 1) {
      paddingInner = 0;
      rawStep = rangeDistance * (1 - paddingOuter * 2);
    } else {
      rawStep = rangeDistance / Math.max(1, bandCount - paddingInner + paddingOuter * 2);
    }
    const step = round2 ? Math.floor(rawStep) : rawStep;
    let inset = r0 + (rangeDistance - step * (bandCount - paddingInner)) / 2;
    let bandwidth = step * (1 - paddingInner);
    if (round2) {
      inset = Math.round(inset);
      bandwidth = Math.round(bandwidth);
    }
    this._step = step;
    this._inset = inset;
    this._bandwidth = bandwidth;
    this._rawBandwidth = rawStep * (1 - paddingInner);
  }
  ordinalRange(i) {
    const { _inset: inset, _step: step, range: range3 } = this;
    const min = Math.min(range3[0], range3[1]);
    const max = Math.max(range3[0], range3[1]);
    return clamp6(min, inset + step * i, max);
  }
};
__decorateClass([
  Invalidating
], _BandScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], _BandScale.prototype, "round", 2);
var BandScale = _BandScale;

// packages/ag-charts-community/src/scale/discreteTimeScale.ts
var DiscreteTimeScale = class _DiscreteTimeScale extends BandScale {
  static is(value) {
    return value instanceof _DiscreteTimeScale;
  }
  toDomain(value) {
    return new Date(value);
  }
  convert(value, options) {
    if (!(value instanceof Date))
      value = new Date(value);
    const { domain, bands } = this;
    if (domain.length <= 0)
      return NaN;
    const r0 = this.ordinalRange(0);
    const r1 = this.ordinalRange(bands.length - 1);
    if (bands.length === 0)
      return r0;
    if (options?.clamp === true) {
      const { range: range3 } = this;
      if (value < bands[0])
        return range3[0];
      if (value > bands[bands.length - 1])
        return range3[1];
    }
    const alignment = options?.alignment ?? 0 /* Leading */;
    const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
    if (alignment !== 2 /* Interpolate */) {
      const r2 = super.convert(value, options);
      return reversed ? r1 - (r2 - r0) : r2;
    }
    const v = value.valueOf();
    let bandIndex = this.findIndex(value) ?? 0;
    let dIndex;
    if (reversed) {
      bandIndex = Math.min(Math.max(bandIndex, 1), bands.length - 1);
      dIndex = -1;
    } else {
      bandIndex = Math.min(Math.max(bandIndex, 0), bands.length - 2);
      dIndex = 1;
    }
    const v0 = bands[bandIndex].valueOf();
    const v1 = bands[bandIndex + dIndex].valueOf();
    const vr0 = this.ordinalRange(bandIndex);
    const vr1 = this.ordinalRange(bandIndex + dIndex);
    const ratio8 = (v - v0) / (v1 - v0);
    const r = ratio8 * (vr1 - vr0) + vr0;
    return reversed ? r1 - (r - r0) : r;
  }
  invert(position, nearest = false) {
    this.refresh();
    const { domain, bands } = this;
    if (domain.length <= 0)
      return;
    const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
    let index;
    if (nearest) {
      index = this.invertNearestIndex(position - this.bandwidth / 2);
    } else {
      const closestIndex = findMinIndex(0, bands.length - 1, (i) => {
        const p = this.ordinalRange(i);
        return p >= position;
      });
      index = closestIndex ?? bands.length - 1;
    }
    return bands[reversed ? bands.length - 1 - index : index];
  }
  findIndex(value, alignment = 0 /* Leading */) {
    const { bands } = this;
    const target = value.valueOf();
    if (alignment === 1 /* Trailing */) {
      return findMinIndex(0, bands.length - 1, (index) => bands[index].valueOf() >= target);
    }
    return findMaxIndex(0, bands.length - 1, (index) => bands[index].valueOf() <= target);
  }
};

// packages/ag-charts-community/src/scene/group.ts
import { clamp as clamp9, toIterable } from "ag-charts-core";

// packages/ag-charts-community/src/util/debug.ts
import { Logger as Logger6, getWindow, toArray } from "ag-charts-core";
var LONG_TIME_PERIOD_THRESHOLD = 2e3;
var timeOfLastLog = Date.now();
var logTimeGap = () => {
  const timeSinceLastLog = Date.now() - timeOfLastLog;
  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
    Logger6.log(`**** ${prettyDuration}s since last log message ****`);
  }
  timeOfLastLog = Date.now();
};
var Debug = {
  create(...debugSelectors) {
    const resultFn = (...logContent) => {
      if (Debug.check(...debugSelectors)) {
        if (typeof logContent[0] === "function") {
          logContent = toArray(logContent[0]());
        }
        logTimeGap();
        Logger6.log(...logContent);
      }
    };
    return Object.assign(resultFn, {
      check: () => Debug.check(...debugSelectors),
      group: (name, cb) => {
        if (Debug.check(...debugSelectors)) {
          return Logger6.logGroup(name, cb);
        }
        return cb();
      }
    });
  },
  check(...debugSelectors) {
    if (debugSelectors.length === 0) {
      debugSelectors.push(true);
    }
    const chartDebug = toArray(getWindow("agChartsDebug"));
    return chartDebug.some((selector) => debugSelectors.includes(selector));
  },
  inDevelopmentMode(fn) {
    if (Debug.check("dev")) {
      return fn();
    }
  }
};

// packages/ag-charts-community/src/scene/canvas/canvasUtil.ts
function clearContext({
  context,
  pixelRatio,
  width: width2,
  height: height2
}) {
  context.save();
  try {
    context.resetTransform();
    context.clearRect(0, 0, Math.ceil(width2 * pixelRatio), Math.ceil(height2 * pixelRatio));
  } finally {
    context.restore();
  }
}
function debugContext(ctx) {
  if (Debug.check("canvas")) {
    const save = ctx.save.bind(ctx);
    const restore = ctx.restore.bind(ctx);
    let depth = 0;
    Object.assign(ctx, {
      save() {
        save();
        depth++;
      },
      restore() {
        if (depth === 0) {
          throw new Error("AG Charts - Unable to restore() past depth 0");
        }
        restore();
        depth--;
      },
      verifyDepthZero() {
        if (depth !== 0) {
          throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);
        }
      }
    });
  }
}

// packages/ag-charts-community/src/scene/canvas/hdpiOffscreenCanvas.ts
function canvasDimensions(width2, height2, pixelRatio) {
  return [Math.floor(width2 * pixelRatio), Math.floor(height2 * pixelRatio)];
}
var HdpiOffscreenCanvas = class {
  constructor(options) {
    const { width: width2, height: height2, pixelRatio, willReadFrequently = false } = options;
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
    const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
    this.canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    this.context = this.canvas.getContext("2d", { willReadFrequently });
    this.context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    debugContext(this.context);
  }
  drawImage(context, dx = 0, dy = 0) {
    return context.drawImage(this.canvas, dx, dy);
  }
  transferToImageBitmap() {
    return this.canvas.transferToImageBitmap();
  }
  resize(width2, height2, pixelRatio) {
    if (!(width2 > 0 && height2 > 0))
      return;
    const { canvas, context } = this;
    if (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio) {
      const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
    }
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
  }
  clear() {
    clearContext(this);
  }
  destroy() {
    this.canvas.width = 0;
    this.canvas.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    this.canvas = null;
    this.context = null;
    Object.freeze(this);
  }
};

// packages/ag-charts-community/src/scene/shape/shape.ts
import { boxesEqual as boxesEqual2, clamp as clamp8, generateUUID, isString } from "ag-charts-core";

// packages/ag-charts-community/src/scene/gradient/conicGradient.ts
import { createSvgElement as createSvgElement3 } from "ag-charts-core";

// packages/ag-charts-community/src/util/angle.ts
var twoPi = Math.PI * 2;
var halfPi = Math.PI / 2;
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function isBetweenAngles(targetAngle, startAngle, endAngle) {
  const t = normalizeAngle360(targetAngle);
  const a0 = normalizeAngle360(startAngle);
  const a1 = normalizeAngle360(endAngle);
  if (a0 < a1) {
    return a0 <= t && t <= a1;
  } else if (a0 > a1) {
    return a0 <= t || t <= a1;
  } else {
    return startAngle !== endAngle;
  }
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function angleBetween(angle0, angle1) {
  angle0 = normalizeAngle360(angle0);
  angle1 = normalizeAngle360(angle1);
  return angle1 - angle0 + (angle0 > angle1 ? twoPi : 0);
}
function getAngleRatioRadians(angle) {
  const normalizedAngle = normalizeAngle360(angle);
  if (normalizedAngle <= halfPi) {
    return normalizedAngle / halfPi;
  } else if (normalizedAngle <= Math.PI) {
    return (Math.PI - normalizedAngle) / halfPi;
  } else if (normalizedAngle <= 1.5 * Math.PI) {
    return (normalizedAngle - Math.PI) / halfPi;
  } else {
    return (twoPi - normalizedAngle) / halfPi;
  }
}
function angularPadding(hPadding, vPadding, angle) {
  const angleRatio = getAngleRatioRadians(angle);
  return hPadding * angleRatio + vPadding * Math.abs(1 - angleRatio);
}
function normalizeAngle360FromDegrees(degrees) {
  return degrees ? normalizeAngle360(toRadians(degrees)) : 0;
}

// packages/ag-charts-community/src/scene/gradient/gradient.ts
import { createSvgElement as createSvgElement2 } from "ag-charts-core";

// packages/ag-charts-community/src/scale/colorScale.ts
import { Logger as Logger7, clamp as clamp7 } from "ag-charts-core";
var convertColorStringToOklcha = (v) => {
  const color7 = Color.fromString(v);
  const [l, c, h] = Color.RGBtoOKLCH(color7.r, color7.g, color7.b);
  return { l, c, h, a: color7.a };
};
var delta = 1e-6;
var isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;
var interpolateOklch = (x, y, d) => {
  d = clamp7(0, d, 1);
  let h;
  if (isAchromatic(x)) {
    h = y.h;
  } else if (isAchromatic(y)) {
    h = x.h;
  } else {
    const xH = x.h;
    let yH = y.h;
    const deltaH = y.h - x.h;
    if (deltaH > 180) {
      yH -= 360;
    } else if (deltaH < -180) {
      yH += 360;
    }
    h = xH * (1 - d) + yH * d;
  }
  const c = x.c * (1 - d) + y.c * d;
  const l = x.l * (1 - d) + y.l * d;
  const a = x.a * (1 - d) + y.a * d;
  return Color.fromOKLCH(l, c, h, a);
};
var ColorScale = class extends AbstractScale {
  constructor() {
    super(...arguments);
    this.type = "color";
    this.defaultTickCount = 0;
    this.invalid = true;
    this.domain = [0, 1];
    this.range = ["red", "blue"];
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  update() {
    const { domain, range: range3 } = this;
    if (domain.length < 2) {
      Logger7.warnOnce("`colorDomain` should have at least 2 values.");
      if (domain.length === 0) {
        domain.push(0, 1);
      } else if (domain.length === 1) {
        domain.push(domain[0] + 1);
      }
    }
    for (let i = 1; i < domain.length; i++) {
      const a = domain[i - 1];
      const b = domain[i];
      if (a > b) {
        Logger7.warnOnce("`colorDomain` values should be supplied in ascending order.");
        domain.sort((a2, b2) => a2 - b2);
        break;
      }
    }
    if (range3.length < domain.length) {
      for (let i = range3.length; i < domain.length; i++) {
        range3.push(range3.length > 0 ? range3[0] : "black");
      }
    }
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  normalizeDomains(...domains) {
    return { domain: domains.flat(), animatable: true };
  }
  toDomain() {
    return;
  }
  convert(x) {
    this.refresh();
    const { domain, range: range3, parsedRange } = this;
    const d0 = domain[0];
    const d1 = domain.at(-1);
    const r0 = range3[0];
    const r1 = range3[range3.length - 1];
    if (x <= d0) {
      return r0;
    }
    if (x >= d1) {
      return r1;
    }
    let index;
    let q;
    if (domain.length === 2) {
      const t = (x - d0) / (d1 - d0);
      const step = 1 / (range3.length - 1);
      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);
      q = (t - index * step) / step;
    } else {
      for (index = 0; index < domain.length - 2; index++) {
        if (x < domain[index + 1]) {
          break;
        }
      }
      const a = domain[index];
      const b = domain[index + 1];
      q = (x - a) / (b - a);
    }
    const c0 = parsedRange[index];
    const c1 = parsedRange[index + 1];
    return interpolateOklch(c0, c1, q).toRgbaString();
  }
  invert() {
    return;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger7.warnOnce("Expected update to not invalidate scale");
    }
  }
};
__decorateClass([
  Invalidating
], ColorScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], ColorScale.prototype, "range", 2);

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient = class {
  constructor(colorSpace, stops = [], bbox) {
    this.colorSpace = colorSpace;
    this.stops = stops;
    this.bbox = bbox;
    this._cache = void 0;
  }
  createGradient(ctx, shapeBbox, params) {
    const bbox = this.bbox ?? shapeBbox;
    if (!bbox.isFinite()) {
      return;
    }
    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {
      return this._cache.gradient;
    }
    const { stops, colorSpace } = this;
    if (stops.length === 0)
      return;
    if (stops.length === 1)
      return stops[0].color;
    let gradient = this.createCanvasGradient(ctx, bbox, params);
    if (gradient == null)
      return;
    const isOkLch = colorSpace === "oklch";
    const step = 0.05;
    let c0 = stops[0];
    gradient.addColorStop(c0.stop, c0.color);
    for (let i = 1; i < stops.length; i += 1) {
      const c1 = stops[i];
      if (isOkLch) {
        const scale2 = new ColorScale();
        scale2.domain = [c0.stop, c1.stop];
        scale2.range = [c0.color, c1.color];
        for (let stop = c0.stop + step; stop < c1.stop; stop += step) {
          gradient.addColorStop(stop, scale2.convert(stop));
        }
      }
      gradient.addColorStop(c1.stop, c1.color);
      c0 = c1;
    }
    if ("createPattern" in gradient) {
      gradient = gradient.createPattern();
    }
    this._cache = { ctx, bbox, gradient };
    return gradient;
  }
  toSvg(shapeBbox) {
    const bbox = this.bbox ?? shapeBbox;
    const gradient = this.createSvgGradient(bbox);
    this.stops.forEach(({ stop: offset, color: color7 }) => {
      const stop = createSvgElement2("stop");
      stop.setAttribute("offset", `${offset}`);
      stop.setAttribute("stop-color", `${color7}`);
      gradient.appendChild(stop);
    });
    return gradient;
  }
};

// packages/ag-charts-community/src/scene/gradient/conicGradient.ts
var ConicGradient = class extends Gradient {
  constructor(colorSpace, stops, angle = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle;
  }
  createCanvasGradient(ctx, bbox, params) {
    const angleOffset = -90;
    const { angle } = this;
    const radians = normalizeAngle360FromDegrees(angle + angleOffset);
    const cx = params?.centerX ?? bbox.x + bbox.width * 0.5;
    const cy = params?.centerY ?? bbox.y + bbox.height * 0.5;
    return ctx.createConicGradient(radians, cx, cy);
  }
  createSvgGradient(_bbox) {
    return createSvgElement3("linearGradient");
  }
};

// packages/ag-charts-community/src/scene/gradient/linearGradient.ts
import { createSvgElement as createSvgElement4 } from "ag-charts-core";
var LinearGradient = class extends Gradient {
  constructor(colorSpace, stops, angle = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle;
  }
  getGradientPoints(bbox) {
    const angleOffset = 90;
    const { angle } = this;
    const radians = normalizeAngle360FromDegrees(angle + angleOffset);
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const w = bbox.width;
    const h = bbox.height;
    const cx = bbox.x + w * 0.5;
    const cy = bbox.y + h * 0.5;
    const diagonal = Math.sqrt(h * h + w * w) / 2;
    const diagonalAngle = Math.atan2(h, w);
    let quarteredAngle;
    if (radians < Math.PI / 2) {
      quarteredAngle = radians;
    } else if (radians < Math.PI) {
      quarteredAngle = Math.PI - radians;
    } else if (radians < 1.5 * Math.PI) {
      quarteredAngle = radians - Math.PI;
    } else {
      quarteredAngle = 2 * Math.PI - radians;
    }
    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
    return { x0: cx + cos * l, y0: cy + sin * l, x1: cx - cos * l, y1: cy - sin * l };
  }
  createCanvasGradient(ctx, bbox) {
    const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
    if (isNaN(x0) || isNaN(y0) || isNaN(x1) || isNaN(y1)) {
      return void 0;
    }
    return ctx.createLinearGradient(x0, y0, x1, y1);
  }
  createSvgGradient(bbox) {
    const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
    const gradient = createSvgElement4("linearGradient");
    gradient.setAttribute("x1", String(x0));
    gradient.setAttribute("y1", String(y0));
    gradient.setAttribute("x2", String(x1));
    gradient.setAttribute("y2", String(y1));
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    return gradient;
  }
};

// packages/ag-charts-community/src/scene/gradient/radialGradient.ts
import { createSvgElement as createSvgElement5 } from "ag-charts-core";
var RadialGradient = class extends Gradient {
  constructor(colorSpace, stops, bbox) {
    super(colorSpace, stops, bbox);
  }
  createCanvasGradient(ctx, bbox, params) {
    const cx = params?.centerX ?? bbox.x + bbox.width * 0.5;
    const cy = params?.centerY ?? bbox.y + bbox.height * 0.5;
    const innerRadius = params?.innerRadius ?? 0;
    const outerRadius = params?.outerRadius ?? Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2;
    return ctx.createRadialGradient(cx, cy, innerRadius, cx, cy, outerRadius);
  }
  createSvgGradient(bbox) {
    const cx = bbox.x + bbox.width * 0.5;
    const cy = bbox.y + bbox.height * 0.5;
    const gradient = createSvgElement5("radialGradient");
    gradient.setAttribute("cx", String(cx));
    gradient.setAttribute("cy", String(cy));
    gradient.setAttribute("r", String(Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2));
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    return gradient;
  }
};

// packages/ag-charts-community/src/scene/gradient/stops.ts
import { Logger as Logger8 } from "ag-charts-core";
var StopProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Property
], StopProperties.prototype, "stop", 2);
__decorateClass([
  Property
], StopProperties.prototype, "color", 2);
function stopsAreAscending(fills) {
  let currentStop;
  for (const fill of fills) {
    if (fill?.stop == null)
      continue;
    if (currentStop != null && fill.stop < currentStop) {
      return false;
    }
    currentStop = fill.stop;
  }
  return true;
}
function discreteColorStops(colorStops) {
  return colorStops.flatMap((colorStop, i) => {
    const { stop } = colorStop;
    const nextColor = colorStops.at(i + 1)?.color;
    return nextColor != null ? [colorStop, { stop, color: nextColor }] : [colorStop];
  });
}
function getDefaultColorStops(defaultColorStops, fillMode) {
  const stopOffset = fillMode === "discrete" ? 1 : 0;
  const colorStops = defaultColorStops.map(
    (color7, index, { length }) => ({
      stop: (index + stopOffset) / (length - 1 + stopOffset),
      color: color7
    })
  );
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}
function getColorStops(baseFills, defaultColorStops, domain, fillMode = "continuous") {
  const fills = baseFills.map((fill) => typeof fill === "string" ? { color: fill } : fill);
  if (fills.length === 0) {
    return getDefaultColorStops(defaultColorStops, fillMode);
  } else if (!stopsAreAscending(fills)) {
    Logger8.warnOnce(`[fills] must have the stops defined in ascending order`);
    return [];
  }
  const d0 = Math.min(...domain);
  const d1 = Math.max(...domain);
  const isDiscrete = fillMode === "discrete";
  const stops = new Float64Array(fills.length);
  let previousDefinedStopIndex = 0;
  let nextDefinedStopIndex = -1;
  for (let i = 0; i < fills.length; i += 1) {
    const colorStop = fills[i];
    if (i >= nextDefinedStopIndex) {
      nextDefinedStopIndex = fills.length - 1;
      for (let j = i + 1; j < fills.length; j += 1) {
        if (fills[j]?.stop != null) {
          nextDefinedStopIndex = j;
          break;
        }
      }
    }
    let stop = colorStop?.stop;
    if (stop == null) {
      const stop0 = fills[previousDefinedStopIndex]?.stop;
      const stop1 = fills[nextDefinedStopIndex]?.stop;
      const value0 = stop0 ?? d0;
      const value1 = stop1 ?? d1;
      const stopOffset = isDiscrete && stop0 == null ? 1 : 0;
      stop = value0 + (value1 - value0) * (i - previousDefinedStopIndex + stopOffset) / (nextDefinedStopIndex - previousDefinedStopIndex + stopOffset);
    } else {
      previousDefinedStopIndex = i;
    }
    stops[i] = Math.max(0, Math.min(1, (stop - d0) / (d1 - d0)));
  }
  let lastDefinedColor = fills.find((c) => c.color != null)?.color;
  let colorScale;
  const colorStops = fills.map((fill, i) => {
    let color7 = fill?.color;
    const stop = stops[i];
    if (color7 != null) {
      lastDefinedColor = color7;
    } else if (lastDefinedColor != null) {
      color7 = lastDefinedColor;
    } else {
      if (colorScale == null) {
        colorScale = new ColorScale();
        colorScale.domain = [0, 1];
        colorScale.range = defaultColorStops;
      }
      color7 = colorScale.convert(stop);
    }
    return { stop, color: color7 };
  });
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}

// packages/ag-charts-community/src/scene/image/image.ts
import { Logger as Logger9, createSvgElement as createSvgElement6 } from "ag-charts-core";
var Image2 = class {
  constructor(imageLoader, imageOptions) {
    this.imageLoader = imageLoader;
    this._cache = void 0;
    this.url = imageOptions.url;
    this.backgroundFill = imageOptions.backgroundFill ?? "black";
    this.backgroundFillOpacity = imageOptions.backgroundFillOpacity ?? 1;
    this.repeat = imageOptions.repeat ?? "no-repeat";
    this.width = imageOptions.width;
    this.height = imageOptions.height;
    this.fit = imageOptions.fit ?? "stretch";
    this.rotation = imageOptions.rotation ?? 0;
  }
  createCanvasImage(ctx, image, width2, height2) {
    if (!image)
      return null;
    const [renderedWidth, renderedHeight] = this.getSize(image.width, image.height, width2, height2);
    if (renderedWidth < 1 || renderedHeight < 1) {
      Logger9.warnOnce("Image fill is too small to render, ignoring.");
      return null;
    }
    return ctx.createPattern(image, this.repeat);
  }
  getSize(imageWidth, imageHeight, width2, height2) {
    const { fit } = this;
    let dw = imageWidth;
    let dh = imageHeight;
    let scale2 = 1;
    const shapeAspectRatio = width2 / height2;
    const imageAspectRatio = imageWidth / imageHeight;
    if (fit === "stretch" || imageWidth === 0 || imageHeight === 0) {
      dw = width2;
      dh = height2;
    } else if (fit === "contain") {
      scale2 = imageAspectRatio > shapeAspectRatio ? width2 / imageWidth : height2 / imageHeight;
    } else if (fit === "cover") {
      scale2 = imageAspectRatio > shapeAspectRatio ? height2 / imageHeight : width2 / imageWidth;
    }
    return [Math.max(1, dw * scale2), Math.max(1, dh * scale2)];
  }
  setImageTransform(pattern, bbox) {
    if (typeof pattern === "string")
      return;
    const { url, rotation, width: width2, height: height2 } = this;
    const image = this.imageLoader?.loadImage(url);
    if (!image) {
      return;
    }
    const angle = normalizeAngle360FromDegrees(rotation);
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const [renderedWidth, renderedHeight] = this.getSize(
      image.width,
      image.height,
      width2 ?? bbox.width,
      height2 ?? bbox.height
    );
    const widthScale = renderedWidth / image.width;
    const heightScale = renderedHeight / image.height;
    const bboxCenterX = bbox.x + bbox.width / 2;
    const bboxCenterY = bbox.y + bbox.height / 2;
    const rotatedW = cos * renderedWidth - sin * renderedHeight;
    const rotatedH = sin * renderedWidth + cos * renderedHeight;
    const shapeCenterX = rotatedW / 2;
    const shapeCenterY = rotatedH / 2;
    pattern?.setTransform(
      new DOMMatrix([
        cos * widthScale,
        sin * heightScale,
        -sin * widthScale,
        cos * heightScale,
        bboxCenterX - shapeCenterX,
        bboxCenterY - shapeCenterY
      ])
    );
  }
  createPattern(ctx, shapeWidth, shapeHeight, node) {
    const width2 = this.width ?? shapeWidth;
    const height2 = this.height ?? shapeHeight;
    const cache = this._cache;
    if (cache != null && cache.ctx === ctx && cache.width === width2 && cache.height === height2) {
      return cache.pattern;
    }
    const image = this.imageLoader?.loadImage(this.url, node);
    const pattern = this.createCanvasImage(ctx, image, width2, height2);
    if (pattern == null)
      return;
    this._cache = { ctx, pattern, width: width2, height: height2 };
    return pattern;
  }
  toSvg(bbox, pixelRatio) {
    const { url, rotation, backgroundFill, backgroundFillOpacity } = this;
    const { x, y, width: width2, height: height2 } = bbox;
    const pattern = createSvgElement6("pattern");
    pattern.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    pattern.setAttribute("x", String(x));
    pattern.setAttribute("y", String(y));
    pattern.setAttribute("width", String(width2));
    pattern.setAttribute("height", String(height2));
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    const rect = createSvgElement6("rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width2));
    rect.setAttribute("height", String(height2));
    rect.setAttribute("fill", backgroundFill);
    rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
    pattern.appendChild(rect);
    const image = createSvgElement6("image");
    image.setAttribute("href", url);
    image.setAttribute("x", "0");
    image.setAttribute("y", "0");
    image.setAttribute("width", String(width2));
    image.setAttribute("height", String(height2));
    image.setAttribute("preserveAspectRatio", "none");
    image.setAttribute("transform", `scale(${1 / pixelRatio}) rotate(${rotation}, ${width2 / 2}, ${height2 / 2})`);
    pattern.appendChild(image);
    return pattern;
  }
};

// packages/ag-charts-community/src/scene/pattern/pattern.ts
import {
  Logger as Logger11,
  createSvgElement as createSvgElement7
} from "ag-charts-core";

// packages/ag-charts-community/src/util/distance.ts
function pointsDistanceSquared(x1, y1, x2, y2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  return dx * dx + dy * dy;
}
function lineDistanceSquared(x, y, x1, y1, x2, y2, best) {
  if (x1 === x2 && y1 === y2) {
    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));
  }
  const dx = x2 - x1;
  const dy = y2 - y1;
  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));
  const ix = x1 + t * dx;
  const iy = y1 + t * dy;
  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));
}

// packages/ag-charts-community/src/util/svg.ts
import { Logger as Logger10 } from "ag-charts-core";
var commandEx = /^[\t\n\f\r ]*([achlmqstvz])[\t\n\f\r ]*/i;
var coordinateEx = /^[+-]?((\d*\.\d+)|(\d+\.)|(\d+))(e[+-]?\d+)?/i;
var commaEx = /[\t\n\f\r ]*,?[\t\n\f\r ]*/;
var flagEx = /^[01]/;
var pathParams = {
  z: [],
  h: [coordinateEx],
  v: [coordinateEx],
  m: [coordinateEx, coordinateEx],
  l: [coordinateEx, coordinateEx],
  t: [coordinateEx, coordinateEx],
  s: [coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  q: [coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  c: [coordinateEx, coordinateEx, coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  a: [coordinateEx, coordinateEx, coordinateEx, flagEx, flagEx, coordinateEx, coordinateEx]
};
function parseSvg(d) {
  if (!d)
    return;
  const segments = [];
  let i = 0;
  let currentCommand;
  while (i < d.length) {
    const commandMatch = commandEx.exec(d.slice(i));
    let command;
    if (commandMatch == null) {
      if (!currentCommand) {
        Logger10.warnOnce(`Invalid SVG path, error at index ${i}: Missing command.`);
        return;
      }
      command = currentCommand;
    } else {
      command = commandMatch[1];
      i += commandMatch[0].length;
    }
    const segment = parseSegment(command, d, i);
    if (!segment)
      return;
    i = segment[0];
    currentCommand = command;
    segments.push(segment[1]);
  }
  return segments;
}
function parseSegment(command, d, index) {
  const params = pathParams[command.toLocaleLowerCase()];
  const pathSeg = { command, params: [] };
  for (const regex of params) {
    const segment = d.slice(index);
    const match = regex.exec(segment);
    if (match != null) {
      pathSeg.params.push(parseFloat(match[0]));
      index += match[0].length;
      const next = commaEx.exec(segment.slice(match[0].length));
      if (next != null) {
        index += next[0].length;
      }
    } else if (pathSeg.params.length === 1) {
      return [index, pathSeg];
    } else {
      Logger10.warnOnce(
        `Invalid SVG path, error at index ${index}: No path segment parameters for command [${command}]`
      );
      return;
    }
  }
  return [index, pathSeg];
}

// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function quadraticRoots(a, b, c, delta3 = 1e-6) {
  if (Math.abs(a) < delta3) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c;
  const roots = [];
  if (Math.abs(D) < delta3) {
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  return roots;
}
function cubicRoots(a, b, c, d, delta3 = 1e-6) {
  if (Math.abs(a) < delta3) {
    return quadraticRoots(b, c, d, delta3);
  }
  const A = b / a;
  const B = c / a;
  const C2 = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C2 - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R;
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
    const t = -third * A + (S + T);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Math.abs(Im) < delta3) {
      const t2 = -third * A - (S + T) / 2;
      if (t2 >= 0 && t2 <= 1) {
        roots.push(t2);
      }
    }
  } else {
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}

// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    return 0;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return 1;
  }
  return 0;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  let intersections = 0;
  const A = y1 - y2;
  const B = x2 - x1;
  const C2 = x1 * (y2 - y1) - y1 * (x2 - x1);
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0];
  const b = A * bx[1] + B * by[1];
  const c = A * bx[2] + B * by[2];
  const d = A * bx[3] + B * by[3] + C2;
  const roots = cubicRoots(a, b, c, d);
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    let s;
    if (x1 === x2) {
      s = (y - y1) / (y2 - y1);
    } else {
      s = (x - x1) / (x2 - x1);
    }
    if (s >= 0 && s <= 1) {
      intersections++;
    }
  }
  return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
  return [
    // Bézier expressed as matrix operations:
    //                 |-1  3 -3  1| |P1|
    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
    //                 |-3  3  0  0| |P3|
    //                 | 1  0  0  0| |P4|
    -P1 + 3 * P2 - 3 * P3 + P4,
    3 * P1 - 6 * P2 + 3 * P3,
    -3 * P1 + 3 * P2,
    P1
  ];
}

// packages/ag-charts-community/src/scene/util/bezier.ts
import { insertListItemsSorted } from "ag-charts-core";
function evaluateBezier(p0, p1, p2, p3, t) {
  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;
}
function solveBezier(p0, p1, p2, p3, value) {
  if (value <= Math.min(p0, p3)) {
    return p0 < p3 ? 0 : 1;
  } else if (value >= Math.max(p0, p3)) {
    return p0 < p3 ? 1 : 0;
  }
  let t0 = 0;
  let t1 = 1;
  let t = NaN;
  for (let i = 0; i < 12; i += 1) {
    t = (t0 + t1) / 2;
    const curveValue = evaluateBezier(p0, p1, p2, p3, t);
    if (curveValue < value) {
      t0 = t;
    } else {
      t1 = t;
    }
  }
  return t;
}
function splitBezier2D(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {
  const x01 = (1 - t) * p0x + t * p1x;
  const y01 = (1 - t) * p0y + t * p1y;
  const x12 = (1 - t) * p1x + t * p2x;
  const y12 = (1 - t) * p1y + t * p2y;
  const x23 = (1 - t) * p2x + t * p3x;
  const y23 = (1 - t) * p2y + t * p3y;
  const x012 = (1 - t) * x01 + t * x12;
  const y012 = (1 - t) * y01 + t * y12;
  const x123 = (1 - t) * x12 + t * x23;
  const y123 = (1 - t) * y12 + t * y23;
  const x0123 = (1 - t) * x012 + t * x123;
  const y0123 = (1 - t) * y012 + t * y123;
  return [
    [
      { x: p0x, y: p0y },
      { x: x01, y: y01 },
      { x: x012, y: y012 },
      { x: x0123, y: y0123 }
    ],
    [
      { x: x0123, y: y0123 },
      { x: x123, y: y123 },
      { x: x23, y: y23 },
      { x: p3x, y: p3y }
    ]
  ];
}
function calculateDerivativeExtrema(p0, p1, p2, p3) {
  const a = -p0 + 3 * p1 - 3 * p2 + p3;
  const b = 2 * (p0 - 2 * p1 + p2);
  const c = -p0 + p1;
  if (a === 0) {
    if (b !== 0) {
      const t = -c / b;
      if (t > 0 && t < 1) {
        return [t];
      }
    }
    return [];
  }
  const discriminant = b * b - 4 * a * c;
  if (discriminant >= 0) {
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b + sqrtDiscriminant) / (2 * a);
    const t2 = (-b - sqrtDiscriminant) / (2 * a);
    return [t1, t2].filter((t) => t > 0 && t < 1);
  }
  return [];
}
function bezier2DExtrema(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {
  const tx = calculateDerivativeExtrema(cp0x, cp1x, cp2x, cp3x);
  const ty = calculateDerivativeExtrema(cp0y, cp1y, cp2y, cp3y);
  return [...tx, ...ty];
}
function bezierCandidate(points, x, y) {
  const midX = evaluateBezier(points[0].x, points[1].x, points[2].x, points[3].x, 0.5);
  const midY = evaluateBezier(points[0].y, points[1].y, points[2].y, points[3].y, 0.5);
  const distance = Math.hypot(midX - x, midY - y);
  const minDistance = Math.min(
    Math.hypot(points[0].x - x, points[0].y - y),
    Math.hypot(points[1].x - x, points[1].y - y),
    Math.hypot(points[2].x - x, points[2].y - y),
    Math.hypot(points[3].x - x, points[3].y - y)
  );
  return { points, distance, minDistance };
}
function bezier2DDistance(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, x, y, precision = 1) {
  const points0 = [
    { x: cp0x, y: cp0y },
    { x: cp1x, y: cp1y },
    { x: cp2x, y: cp2y },
    { x: cp3x, y: cp3y }
  ];
  let queue = {
    value: bezierCandidate(points0, x, y),
    next: null
  };
  let bestResult;
  while (queue != null) {
    const { points, distance, minDistance } = queue.value;
    queue = queue.next;
    if (bestResult == null || distance < bestResult.distance) {
      bestResult = { distance, minDistance };
    }
    if (bestResult != null && bestResult.distance - minDistance <= precision) {
      continue;
    }
    const [leftPoints, rightPoints] = splitBezier2D(
      points[0].x,
      points[0].y,
      points[1].x,
      points[1].y,
      points[2].x,
      points[2].y,
      points[3].x,
      points[3].y,
      0.5
    );
    const newCandidates = [bezierCandidate(leftPoints, x, y), bezierCandidate(rightPoints, x, y)].sort(
      bezierCandidateCmp
    );
    queue = insertListItemsSorted(queue, newCandidates, bezierCandidateCmp);
  }
  return bestResult?.distance ?? Infinity;
}
var bezierCandidateCmp = (a, b) => b.minDistance - a.minDistance;

// packages/ag-charts-community/src/scene/extendedPath2D.ts
var ExtendedPath2D = class {
  constructor() {
    // The methods of this class will likely be called many times per animation frame,
    // and any allocation can trigger a GC cycle during animation, so we attempt
    // to minimize the number of allocations.
    this.path2d = new Path2D();
    this.previousCommands = [];
    this.previousParams = [];
    this.previousClosedPath = false;
    this.commands = [];
    this.params = [];
    this.cx = NaN;
    this.cy = NaN;
    this.sx = NaN;
    this.sy = NaN;
    this.openedPath = false;
    this.closedPath = false;
  }
  isEmpty() {
    return this.commands.length === 0;
  }
  isDirty() {
    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();
  }
  getPath2D() {
    return this.path2d;
  }
  moveTo(x, y) {
    this.openedPath = true;
    this.sx = x;
    this.sy = y;
    this.cx = x;
    this.cy = y;
    this.path2d.moveTo(x, y);
    this.commands.push(0 /* Move */);
    this.params.push(x, y);
  }
  lineTo(x, y) {
    if (this.openedPath) {
      this.cx = x;
      this.cy = y;
      this.path2d.lineTo(x, y);
      this.commands.push(1 /* Line */);
      this.params.push(x, y);
    } else {
      this.moveTo(x, y);
    }
  }
  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
    if (!this.openedPath) {
      this.moveTo(cx1, cy1);
    }
    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
    this.commands.push(2 /* Curve */);
    this.params.push(cx1, cy1, cx2, cy2, x, y);
  }
  closePath() {
    if (this.openedPath) {
      this.cx = this.sx;
      this.cy = this.sy;
      this.sx = NaN;
      this.sy = NaN;
      this.path2d.closePath();
      this.commands.push(3 /* ClosePath */);
      this.openedPath = false;
      this.closedPath = true;
    }
  }
  rect(x, y, width2, height2) {
    this.moveTo(x, y);
    this.lineTo(x + width2, y);
    this.lineTo(x + width2, y + height2);
    this.lineTo(x, y + height2);
    this.closePath();
  }
  roundRect(x, y, width2, height2, radii) {
    radii = Math.min(radii, width2 / 2, height2 / 2);
    this.moveTo(x, y + radii);
    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);
    this.lineTo(x + radii, y);
    this.lineTo(x + width2 - radii, y);
    this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);
    this.lineTo(x + width2, y + radii);
    this.lineTo(x + width2, y + height2 - radii);
    this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);
    this.lineTo(x + width2 - radii, y + height2);
    this.lineTo(x + radii, y + height2);
    this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);
    this.lineTo(x, y + height2 - radii);
    this.closePath();
  }
  ellipse(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise = false) {
    const r = rx;
    const scaleY = ry / rx;
    const mxx = Math.cos(rotation);
    const myx = Math.sin(rotation);
    const mxy = -scaleY * myx;
    const myy = scaleY * mxx;
    const x0 = r * Math.cos(sAngle);
    const y0 = r * Math.sin(sAngle);
    const sx = cx + mxx * x0 + mxy * y0;
    const sy = cy + myx * x0 + myy * y0;
    const distanceSquared = (sx - this.cx) ** 2 + (sy - this.cy) ** 2;
    if (!this.openedPath) {
      this.moveTo(sx, sy);
    } else if (distanceSquared > 1e-6) {
      this.lineTo(sx, sy);
    }
    let sweep = counterClockwise ? -normalizeAngle360(sAngle - eAngle) : normalizeAngle360(eAngle - sAngle);
    if (Math.abs(Math.abs(eAngle - sAngle) - 2 * Math.PI) < 1e-6 && sweep < 2 * Math.PI) {
      sweep += 2 * Math.PI * (counterClockwise ? -1 : 1);
    }
    const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);
    const step = sweep / arcSections;
    const h = 4 / 3 * Math.tan(step / 4);
    for (let i = 0; i < arcSections; i += 1) {
      const a0 = sAngle + step * (i + 0);
      const a1 = sAngle + step * (i + 1);
      const rSinStart = r * Math.sin(a0);
      const rCosStart = r * Math.cos(a0);
      const rSinEnd = r * Math.sin(a1);
      const rCosEnd = r * Math.cos(a1);
      const cp1x = rCosStart - h * rSinStart;
      const cp1y = rSinStart + h * rCosStart;
      const cp2x = rCosEnd + h * rSinEnd;
      const cp2y = rSinEnd - h * rCosEnd;
      const cp3x = rCosEnd;
      const cp3y = rSinEnd;
      this.cubicCurveTo(
        cx + mxx * cp1x + mxy * cp1y,
        cy + myx * cp1x + myy * cp1y,
        cx + mxx * cp2x + mxy * cp2y,
        cy + myx * cp2x + myy * cp2y,
        cx + mxx * cp3x + mxy * cp3y,
        cy + myx * cp3x + myy * cp3y
      );
    }
  }
  arc(x, y, r, sAngle, eAngle, counterClockwise) {
    this.ellipse(x, y, r, r, 0, sAngle, eAngle, counterClockwise);
  }
  appendSvg(svg) {
    const parts = parseSvg(svg);
    if (parts == null)
      return false;
    let sx = 0;
    let sy = 0;
    let cx;
    let cy;
    let cpx = 0;
    let cpy = 0;
    for (const { command, params } of parts) {
      cx ?? (cx = params[0]);
      cy ?? (cy = params[1]);
      const relative = command === command.toLowerCase();
      const dx = relative ? cx : 0;
      const dy = relative ? cy : 0;
      switch (command.toLowerCase()) {
        case "m":
          this.moveTo(dx + params[0], dy + params[1]);
          cx = dx + params[0];
          cy = dy + params[1];
          sx = cx;
          sy = cy;
          break;
        case "c":
          this.cubicCurveTo(
            dx + params[0],
            dy + params[1],
            dx + params[2],
            dy + params[3],
            dx + params[4],
            dy + params[5]
          );
          cpx = dx + params[2];
          cpy = dy + params[3];
          cx = dx + params[4];
          cy = dy + params[5];
          break;
        case "s":
          this.cubicCurveTo(
            cx + cx - cpx,
            cy + cy - cpy,
            dx + params[0],
            dy + params[1],
            dx + params[2],
            dy + params[3]
          );
          cpx = dx + params[0];
          cpy = dy + params[1];
          cx = dx + params[2];
          cy = dy + params[3];
          break;
        case "q":
          this.cubicCurveTo(
            (dx + 2 * params[0]) / 3,
            (dy + 2 * params[1]) / 3,
            (2 * params[0] + params[2]) / 3,
            (2 * params[1] + params[3]) / 3,
            params[2],
            params[3]
          );
          cpx = params[0];
          cpy = params[1];
          cx = params[2];
          cy = params[3];
          break;
        case "t":
          this.cubicCurveTo(
            (cx + 2 * (cx + cx - cpx)) / 3,
            (cy + 2 * (cy + cy - cpy)) / 3,
            (2 * (cx + cx - cpx) + params[0]) / 3,
            (2 * (cy + cy - cpy) + params[1]) / 3,
            params[0],
            params[1]
          );
          cpx = cx + cx - cpx;
          cpy = cy + cy - cpy;
          cx = params[0];
          cy = params[1];
          break;
        case "a":
          this.svgEllipse(
            cx,
            cy,
            params[0],
            params[1],
            params[2] * Math.PI / 180,
            params[3],
            params[4],
            dx + params[5],
            dy + params[6]
          );
          cx = dx + params[5];
          cy = dy + params[6];
          break;
        case "h":
          this.lineTo(dx + params[0], cy);
          cx = dx + params[0];
          break;
        case "l":
          this.lineTo(dx + params[0], dy + params[1]);
          cx = dx + params[0];
          cy = dy + params[1];
          break;
        case "v":
          this.lineTo(cx, dy + params[0]);
          cy = dy + params[0];
          break;
        case "z":
          this.closePath();
          cx = sx;
          cy = sy;
          break;
        default:
          throw new Error(`Could not translate command '${command}' with '${params.join(" ")}'`);
      }
    }
    return true;
  }
  svgEllipse(x1, y1, rx, ry, rotation, fA, fS, x2, y2) {
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const dx = (x1 - x2) / 2;
    const dy = (y1 - y2) / 2;
    const sin = Math.sin(rotation);
    const cos = Math.cos(rotation);
    const rotX = cos * dx + sin * dy;
    const rotY = -sin * dx + cos * dy;
    const normX = rotX / rx;
    const normY = rotY / ry;
    let scale2 = normX * normX + normY * normY;
    let cx = (x1 + x2) / 2;
    let cy = (y1 + y2) / 2;
    let cpx = 0;
    let cpy = 0;
    if (scale2 >= 1) {
      scale2 = Math.sqrt(scale2);
      rx *= scale2;
      ry *= scale2;
    } else {
      scale2 = Math.sqrt(1 / scale2 - 1);
      if (fA === fS)
        scale2 = -scale2;
      cpx = scale2 * rx * normY;
      cpy = -scale2 * ry * normX;
      cx += cos * cpx - sin * cpy;
      cy += sin * cpx + cos * cpy;
    }
    const sAngle = Math.atan2((rotY - cpy) / ry, (rotX - cpx) / rx);
    const deltaTheta = Math.atan2((-rotY - cpy) / ry, (-rotX - cpx) / rx) - sAngle;
    const eAngle = sAngle + deltaTheta;
    const counterClockwise = !!(1 - fS);
    this.ellipse(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise);
  }
  clear(trackChanges) {
    if (trackChanges) {
      this.previousCommands = this.commands;
      this.previousParams = this.params;
      this.previousClosedPath = this.closedPath;
    }
    this.path2d = new Path2D();
    this.openedPath = false;
    this.closedPath = false;
    this.commands = [];
    this.params = [];
  }
  isPointInPath(x, y) {
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    const ox = -1e4;
    const oy = -1e4;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    let intersectionCount = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          px = params[pi++];
          sx = px;
          py = params[pi++];
          sy = py;
          break;
        case 1 /* Line */:
          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 2 /* Curve */:
          intersectionCount += cubicSegmentIntersections(
            px,
            py,
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            ox,
            oy,
            x,
            y
          );
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 3 /* ClosePath */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          break;
      }
    }
    return intersectionCount % 2 === 1;
  }
  distanceSquared(x, y) {
    let best = Infinity;
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    let sx = NaN;
    let sy = NaN;
    let cx = 0;
    let cy = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          cx = sx = params[pi++];
          cy = sy = params[pi++];
          break;
        case 1 /* Line */: {
          const x0 = cx;
          const y0 = cy;
          cx = params[pi++];
          cy = params[pi++];
          best = lineDistanceSquared(x, y, x0, y0, cx, cy, best);
          break;
        }
        case 2 /* Curve */:
          const cp0x = cx;
          const cp0y = cy;
          const cp1x = params[pi++];
          const cp1y = params[pi++];
          const cp2x = params[pi++];
          const cp2y = params[pi++];
          cx = params[pi++];
          cy = params[pi++];
          best = bezier2DDistance(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cx, cy, x, y) ** 2;
          break;
        case 3 /* ClosePath */:
          best = lineDistanceSquared(x, y, cx, cy, sx, sy, best);
          break;
      }
    }
    return best;
  }
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
  toSVG(transform = (x, y) => ({ x, y })) {
    const buffer = [];
    const { commands, params } = this;
    const addCommand = (command, count) => {
      buffer.push(command);
      for (let i = 0; i < count; i += 2) {
        const { x, y } = transform(params[pi++], params[pi++]);
        buffer.push(x, y);
      }
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          addCommand("M", 2);
          break;
        case 1 /* Line */:
          addCommand("L", 2);
          break;
        case 2 /* Curve */:
          addCommand("C", 6);
          break;
        case 3 /* ClosePath */:
          addCommand("Z", 0);
          break;
      }
    }
    return buffer.join(" ");
  }
  computeBBox() {
    const { commands, params } = this;
    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];
    let [cx, cy] = [NaN, NaN];
    let [sx, sy] = [NaN, NaN];
    const joinPoint = (x, y) => {
      top = Math.min(y, top);
      left = Math.min(x, left);
      right = Math.max(x, right);
      bot = Math.max(y, bot);
      cx = x;
      cy = y;
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          joinPoint(params[pi++], params[pi++]);
          sx = cx;
          sy = cy;
          break;
        case 1 /* Line */:
          joinPoint(params[pi++], params[pi++]);
          break;
        case 2 /* Curve */: {
          const cp0x = cx;
          const cp0y = cy;
          const cp1x = params[pi++];
          const cp1y = params[pi++];
          const cp2x = params[pi++];
          const cp2y = params[pi++];
          const cp3x = params[pi++];
          const cp3y = params[pi++];
          const ts = bezier2DExtrema(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
          ts.forEach((t) => {
            const px = evaluateBezier(cp0x, cp1x, cp2x, cp3x, t);
            const py = evaluateBezier(cp0y, cp1y, cp2y, cp3y, t);
            joinPoint(px, py);
          });
          joinPoint(cp3x, cp3y);
          break;
        }
        case 3 /* ClosePath */:
          joinPoint(sx, sy);
          sx = NaN;
          sy = NaN;
          break;
      }
    }
    return new BBox(left, top, right - left, bot - top);
  }
};

// packages/ag-charts-community/src/scene/util/pixel.ts
function align(pixelRatio, start2, length) {
  const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;
  if (length == null) {
    return alignedStart;
  } else if (length === 0) {
    return 0;
  } else if (length < 1) {
    return Math.ceil(length * pixelRatio) / pixelRatio;
  }
  return Math.round((length + start2) * pixelRatio) / pixelRatio - alignedStart;
}
function alignBefore(pixelRatio, start2) {
  return Math.floor(start2 * pixelRatio) / pixelRatio;
}

// packages/ag-charts-community/src/scene/pattern/patterns.ts
function drawPatternUnitPolygon(path, params, moves) {
  const { width: width2, height: height2, padding: padding2, strokeWidth } = params;
  const x0 = width2 / 2;
  const y0 = height2 / 2;
  const w = Math.max(1, width2 - padding2 - strokeWidth / 2);
  const h = Math.max(1, height2 - padding2 - strokeWidth / 2);
  let didMove = false;
  for (const [dx, dy] of moves) {
    const x = x0 + (dx - 0.5) * w;
    const y = y0 + (dy - 0.5) * h;
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
    }
    didMove = true;
  }
  path.closePath();
}
var PATTERNS = {
  circles(path, { width: width2, strokeWidth, padding: padding2 }) {
    const c = width2 / 2;
    const r = Math.max(1, c - padding2 - strokeWidth / 2);
    path.arc(c, c, r, 0, Math.PI * 2);
  },
  squares(path, { width: width2, height: height2, pixelRatio, padding: padding2, strokeWidth }) {
    const offset = padding2 + strokeWidth / 2;
    path.moveTo(align(pixelRatio, offset), align(pixelRatio, offset));
    path.lineTo(align(pixelRatio, width2 - offset), align(pixelRatio, offset));
    path.lineTo(align(pixelRatio, width2 - offset), align(pixelRatio, height2 - offset));
    path.lineTo(align(pixelRatio, offset), align(pixelRatio, height2 - offset));
    path.closePath();
  },
  triangles(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.5, 0],
      [1, 1],
      [0, 1]
    ]);
  },
  diamonds(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.5, 0],
      [1, 0.5],
      [0.5, 1],
      [0, 0.5]
    ]);
  },
  stars(path, { width: width2, height: height2, padding: padding2 }) {
    const spikes = 5;
    const outerRadius = Math.max(1, (width2 - padding2) / 2);
    const innerRadius = outerRadius / 2;
    const rotation = Math.PI / 2;
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = i * Math.PI / spikes - rotation;
      const xCoordinate = width2 / 2 + Math.cos(angle) * radius;
      const yCoordinate = height2 / 2 + Math.sin(angle) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  },
  hearts(path, { width: width2, height: height2, padding: padding2 }) {
    const r = Math.max(1, width2 / 4 - padding2 / 2);
    const x = width2 / 2;
    const y = height2 / 2 + r / 2;
    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
    path.lineTo(x, y + r);
    path.closePath();
  },
  crosses(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.25, 0],
      [0.5, 0.25],
      [0.75, 0],
      [1, 0.25],
      [0.75, 0.5],
      [1, 0.75],
      [0.75, 1],
      [0.5, 0.75],
      [0.25, 1],
      [0, 0.75],
      [0.25, 0.5],
      [0, 0.25]
    ]);
  },
  "vertical-lines"(path, { width: width2, height: height2, pixelRatio, strokeWidth }) {
    const x = align(pixelRatio, width2 / 2) - strokeWidth % 2 / 2;
    path.moveTo(x, 0);
    path.lineTo(x, height2);
  },
  "horizontal-lines"(path, { width: width2, height: height2, pixelRatio, strokeWidth }) {
    const y = align(pixelRatio, height2 / 2) - strokeWidth % 2 / 2;
    path.moveTo(0, y);
    path.lineTo(width2, y);
  },
  "forward-slanted-lines"(path, { width: width2, height: height2, strokeWidth }) {
    const angle = Math.atan2(height2, width2);
    const insetX = strokeWidth * Math.cos(angle);
    const insetY = strokeWidth * Math.sin(angle);
    path.moveTo(-insetX, insetY);
    path.lineTo(insetX, -insetY);
    path.moveTo(-insetX, height2 + insetY);
    path.lineTo(width2 + insetX, -insetY);
    path.moveTo(width2 - insetX, height2 + insetY);
    path.lineTo(width2 + insetX, height2 - insetY);
  },
  "backward-slanted-lines"(path, { width: width2, height: height2, strokeWidth }) {
    const angle = Math.atan2(height2, width2);
    const insetX = strokeWidth * Math.cos(angle);
    const insetY = strokeWidth * Math.sin(angle);
    path.moveTo(width2 - insetX, -insetY);
    path.lineTo(width2 + insetX, insetY);
    path.moveTo(-insetX, -insetY);
    path.lineTo(width2 + insetX, height2 + insetY);
    path.moveTo(-insetX, height2 - insetY);
    path.lineTo(insetX, height2 + insetY);
  }
};

// packages/ag-charts-community/src/scene/pattern/pattern.ts
var Pattern = class {
  constructor(patternOptions) {
    this._cache = void 0;
    this.width = Math.max(patternOptions?.width ?? 10, 1);
    this.height = Math.max(patternOptions?.height ?? 10, 1);
    this.fill = patternOptions.fill ?? "none";
    this.fillOpacity = patternOptions.fillOpacity ?? 1;
    this.backgroundFill = patternOptions.backgroundFill ?? "none";
    this.backgroundFillOpacity = patternOptions.backgroundFillOpacity ?? 1;
    this.stroke = patternOptions.stroke ?? "black";
    this.strokeOpacity = patternOptions.strokeOpacity ?? 1;
    this.strokeWidth = patternOptions.strokeWidth ?? 1;
    this.padding = patternOptions.padding ?? 1;
    this.pattern = patternOptions.pattern ?? "forward-slanted-lines";
    this.rotation = patternOptions.rotation ?? 0;
    this.scale = patternOptions.scale ?? 1;
    this.path = patternOptions.path;
  }
  getPath(pixelRatio) {
    const { pattern, width: width2, height: height2, padding: padding2, strokeWidth, path: svgPath } = this;
    const path = new ExtendedPath2D();
    let renderPattern = PATTERNS[pattern] != null;
    if (svgPath) {
      renderPattern && (renderPattern = !path.appendSvg(svgPath));
    }
    if (renderPattern) {
      PATTERNS[pattern](path, { width: width2, height: height2, pixelRatio, strokeWidth, padding: padding2 });
    }
    return path;
  }
  renderStroke(path2d, ctx) {
    const { stroke: stroke2, strokeWidth, strokeOpacity } = this;
    if (!strokeWidth)
      return;
    ctx.strokeStyle = stroke2;
    ctx.lineWidth = strokeWidth;
    ctx.globalAlpha = strokeOpacity;
    ctx.stroke(path2d);
  }
  renderFill(path2d, ctx) {
    const { fill, fillOpacity } = this;
    if (fill === "none") {
      return;
    }
    ctx.fillStyle = fill;
    ctx.globalAlpha = fillOpacity;
    ctx.fill(path2d);
  }
  createCanvasPattern(ctx, pixelRatio) {
    const { width: width2, height: height2, scale: scale2, backgroundFill, backgroundFillOpacity } = this;
    if (width2 * scale2 < 1 || height2 * scale2 < 1) {
      Logger11.warnOnce("Pattern fill is too small to render, ignoring.");
      return null;
    }
    const offscreenPattern = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio: pixelRatio * scale2 });
    const offscreenPatternCtx = offscreenPattern.context;
    if (backgroundFill !== "none") {
      offscreenPatternCtx.fillStyle = backgroundFill;
      offscreenPatternCtx.globalAlpha = backgroundFillOpacity;
      offscreenPatternCtx.fillRect(0, 0, width2, height2);
    }
    const path2d = this.getPath(pixelRatio).getPath2D();
    this.renderFill(path2d, offscreenPatternCtx);
    this.renderStroke(path2d, offscreenPatternCtx);
    const pattern = ctx.createPattern(offscreenPattern.canvas, "repeat");
    this.setPatternTransform(pattern, pixelRatio);
    offscreenPattern.destroy();
    return pattern;
  }
  setPatternTransform(pattern, pixelRatio, tx = 0, ty = 0) {
    if (pattern == null)
      return;
    const angle = normalizeAngle360FromDegrees(this.rotation);
    const scale2 = 1 / pixelRatio;
    const cos = Math.cos(angle) * scale2;
    const sin = Math.sin(angle) * scale2;
    pattern.setTransform(new DOMMatrix([cos, sin, -sin, cos, tx, ty]));
  }
  createPattern(ctx, pixelRatio) {
    if (this._cache != null && this._cache.ctx === ctx && this._cache.pixelRatio === pixelRatio) {
      return this._cache.pattern;
    }
    const pattern = this.createCanvasPattern(ctx, pixelRatio);
    if (pattern == null)
      return;
    this._cache = { ctx, pattern, pixelRatio };
    return pattern;
  }
  toSvg() {
    const {
      width: width2,
      height: height2,
      fill,
      fillOpacity,
      backgroundFill,
      backgroundFillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      rotation,
      scale: scale2
    } = this;
    const pattern = createSvgElement7("pattern");
    pattern.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    pattern.setAttribute("width", String(width2));
    pattern.setAttribute("height", String(height2));
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    const rect = createSvgElement7("rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width2));
    rect.setAttribute("height", String(height2));
    rect.setAttribute("fill", backgroundFill);
    rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
    pattern.appendChild(rect);
    const path = createSvgElement7("path");
    path.setAttribute("fill", fill);
    path.setAttribute("fill-opacity", String(fillOpacity));
    path.setAttribute("stroke-opacity", String(strokeOpacity));
    path.setAttribute("stroke", stroke2);
    path.setAttribute("stroke-width", String(strokeWidth));
    path.setAttribute("transform", `rotate(${rotation}) scale(${scale2})`);
    path.setAttribute("d", this.getPath(1).toSVG());
    pattern.appendChild(path);
    return pattern;
  }
};

// packages/ag-charts-community/src/scene/util/fill.ts
import { isArray as isArray3, isObject as isObject2 } from "ag-charts-core";
function isGradientFill(fill) {
  return isObject2(fill) && fill.type == "gradient";
}
function isStringFillArray(fills) {
  return isArray3(fills) && fills.every((fill) => typeof fill === "string");
}
function isPatternFill(fill) {
  return fill !== null && isObject2(fill) && fill.type == "pattern";
}
function isImageFill(fill) {
  return fill !== null && isObject2(fill) && fill.type == "image";
}

// packages/ag-charts-community/src/scene/shape/svgUtils.ts
function setSvgFontAttributes(element2, options) {
  const { fontStyle, fontWeight, fontSize, fontFamily } = options;
  if (fontStyle)
    element2.setAttribute("font-style", fontStyle);
  if (fontWeight)
    element2.setAttribute("font-weight", String(fontWeight));
  if (fontSize != null)
    element2.setAttribute("font-size", String(fontSize));
  if (fontFamily)
    element2.setAttribute("font-family", fontFamily);
}
function setSvgStrokeAttributes(element2, options) {
  const { stroke: stroke2, strokeWidth, strokeOpacity } = options;
  if (stroke2)
    element2.setAttribute("stroke", stroke2);
  if (strokeWidth != null)
    element2.setAttribute("stroke-width", String(strokeWidth));
  if (strokeOpacity != null)
    element2.setAttribute("stroke-opacity", String(strokeOpacity));
}
function setSvgLineDashAttributes(element2, options) {
  const { lineDash, lineDashOffset } = options;
  if (lineDash?.some((d) => d !== 0)) {
    const lineDashArray = lineDash.length % 2 === 1 ? [...lineDash, ...lineDash] : lineDash;
    element2.setAttribute("stroke-dasharray", lineDashArray.join(" "));
    if (lineDashOffset != null)
      element2.setAttribute("stroke-dashoffset", String(lineDashOffset));
  }
}

// packages/ag-charts-community/src/scene/shape/shape.ts
var Shape = class extends Node2 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.fill = "black";
    this.strokeWidth = 0;
    this.lineDashOffset = 0;
    this.opacity = 1;
  }
  getGradient(fill) {
    if (isGradientFill(fill))
      return this.createGradient(fill);
  }
  createGradient(fill) {
    const { colorSpace = "rgb", gradient = "linear", colorStops, rotation = 0, reverse = false } = fill;
    if (colorStops == null)
      return;
    let stops = getColorStops(colorStops, ["black"], [0, 1]);
    if (reverse) {
      stops = stops.map((s) => ({ color: s.color, stop: 1 - s.stop })).reverse();
    }
    switch (gradient) {
      case "linear":
        return new LinearGradient(colorSpace, stops, rotation);
      case "radial":
        return new RadialGradient(colorSpace, stops);
      case "conic":
        return new ConicGradient(colorSpace, stops, rotation);
    }
  }
  getPattern(fill) {
    if (isPatternFill(fill))
      return this.createPattern(fill);
  }
  createPattern(fill) {
    return new Pattern(fill);
  }
  getImage(fill) {
    if (isImageFill(fill))
      return this.createImage(fill);
  }
  createImage(fill) {
    return new Image2(this.imageLoader, fill);
  }
  onFillChange() {
    if (typeof this.fill === "object") {
      if (objectsEqual(this._cachedFill ?? {}, this.fill)) {
        return;
      }
    }
    this.fillGradient = this.getGradient(this.fill);
    this.fillPattern = this.getPattern(this.fill);
    this.fillImage = this.getImage(this.fill);
    this._cachedFill = this.fill;
  }
  onStrokeChange() {
    this.strokeGradient = this.getGradient(this.stroke);
  }
  /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */
  align(start2, length) {
    return align(this.layerManager?.canvas?.pixelRatio ?? 1, start2, length);
  }
  markDirty(property) {
    super.markDirty(property);
    this.cachedDefaultGradientFillBBox = void 0;
  }
  fillStroke(ctx, path) {
    this.renderFill(ctx, path);
    this.renderStroke(ctx, path);
  }
  renderFill(ctx, path) {
    const { fill, fillOpacity, fillImage } = this;
    if (fill != null && fill !== "none" && fillOpacity > 0) {
      const { globalAlpha } = ctx;
      if (fillImage) {
        ctx.globalAlpha = fillImage.backgroundFillOpacity;
        ctx.fillStyle = fillImage.backgroundFill;
        this.executeFill(ctx, path);
        ctx.globalAlpha = globalAlpha;
      }
      this.applyFillAndAlpha(ctx);
      this.applyShadow(ctx);
      this.executeFill(ctx, path);
      ctx.globalAlpha = globalAlpha;
      ctx.shadowColor = "rgba(0, 0, 0, 0)";
    }
  }
  executeFill(ctx, path) {
    if (path) {
      ctx.fill(path);
    } else {
      ctx.fill();
    }
  }
  applyFillAndAlpha(ctx) {
    const { fill, fillGradient, fillPattern, fillImage, fillOpacity = 1, opacity = 1 } = this;
    ctx.globalAlpha *= opacity * fillOpacity;
    if (fillGradient) {
      const { fillBBox = this.getDefaultGradientFillBBox() ?? this.getBBox(), fillParams } = this;
      ctx.fillStyle = fillGradient.createGradient(ctx, fillBBox, fillParams) ?? "black";
    } else if (fillPattern) {
      const { x, y } = this.getBBox();
      const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
      const pattern = fillPattern.createPattern(ctx, pixelRatio);
      fillPattern.setPatternTransform(pattern, pixelRatio, x, y);
      if (pattern) {
        ctx.fillStyle = pattern;
      } else {
        ctx.fillStyle = fillPattern.fill;
        ctx.globalAlpha *= fillPattern.fillOpacity;
      }
    } else if (fillImage) {
      const bbox = this.getBBox();
      const image = fillImage.createPattern(ctx, bbox.width, bbox.height, this);
      fillImage.setImageTransform(image, bbox);
      ctx.fillStyle = image ?? "transparent";
    } else {
      ctx.fillStyle = typeof fill === "string" ? fill : "black";
    }
  }
  applyStrokeAndAlpha(ctx) {
    const { stroke: stroke2, strokeOpacity = 1, strokeGradient, opacity = 1 } = this;
    ctx.strokeStyle = strokeGradient?.createGradient(ctx, this.getBBox()) ?? (typeof stroke2 === "string" ? stroke2 : void 0) ?? "black";
    ctx.globalAlpha *= opacity * strokeOpacity;
  }
  applyShadow(ctx) {
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const fillShadow = this.fillShadow;
    if (fillShadow?.enabled) {
      ctx.shadowColor = fillShadow.color;
      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
      ctx.shadowBlur = fillShadow.blur * pixelRatio;
    }
  }
  renderStroke(ctx, path) {
    const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin, miterLimit } = this;
    if (stroke2 != null && stroke2 !== "none" && strokeWidth > 0 && strokeOpacity > 0) {
      const { globalAlpha } = ctx;
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      if (miterLimit != null) {
        ctx.miterLimit = miterLimit;
      }
      this.executeStroke(ctx, path);
      ctx.globalAlpha = globalAlpha;
    }
  }
  executeStroke(ctx, path) {
    if (path) {
      ctx.stroke(path);
    } else {
      ctx.stroke();
    }
  }
  getDefaultGradientFillBBox() {
    this.cachedDefaultGradientFillBBox ?? (this.cachedDefaultGradientFillBBox = Object.freeze(this.computeDefaultGradientFillBBox()));
    return this.cachedDefaultGradientFillBBox;
  }
  computeDefaultGradientFillBBox() {
    return;
  }
  containsPoint(x, y) {
    return this.isPointInPath(x, y);
  }
  applySvgFillAttributes(element2, defs) {
    const { fill, fillOpacity } = this;
    if (typeof fill === "string") {
      element2.setAttribute("fill", fill);
    } else if (isGradientFill(fill) && this.fillGradient) {
      defs ?? (defs = []);
      const gradient = this.fillGradient.toSvg(this.fillBBox ?? this.getBBox());
      const id = generateUUID();
      gradient.setAttribute("id", id);
      defs.push(gradient);
      element2.setAttribute("fill", `url(#${id})`);
    } else if (isPatternFill(fill) && this.fillPattern) {
      defs ?? (defs = []);
      const pattern = this.fillPattern.toSvg();
      const id = generateUUID();
      pattern.setAttribute("id", id);
      defs.push(pattern);
      element2.setAttribute("fill", `url(#${id})`);
    } else if (isImageFill(fill) && this.fillImage) {
      defs ?? (defs = []);
      const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
      const pattern = this.fillImage.toSvg(this.getBBox(), pixelRatio);
      const id = generateUUID();
      pattern.setAttribute("id", id);
      defs.push(pattern);
      element2.setAttribute("fill", `url(#${id})`);
    } else {
      element2.setAttribute("fill", "none");
    }
    element2.setAttribute("fill-opacity", String(fillOpacity));
    return defs;
  }
  applySvgStrokeAttributes(element2) {
    const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this;
    setSvgStrokeAttributes(element2, { stroke: isString(stroke2) ? stroke2 : void 0, strokeOpacity, strokeWidth });
    setSvgLineDashAttributes(element2, { lineDash, lineDashOffset });
  }
};
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "fillOpacity", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "strokeOpacity", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onFillChange() })
], Shape.prototype, "fill", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onStrokeChange() })
], Shape.prototype, "stroke", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "strokeWidth", 2);
__decorateClass([
  SceneArrayChangeDetection()
], Shape.prototype, "lineDash", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "lineDashOffset", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "lineCap", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "lineJoin", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "miterLimit", 2);
__decorateClass([
  SceneChangeDetection({ convertor: (v) => clamp8(0, v ?? 1, 1) })
], Shape.prototype, "opacity", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: TRIPLE_EQ, checkDirtyOnAssignment: true })
], Shape.prototype, "fillShadow", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: boxesEqual2, changeCb: (s) => s.onFillChange() })
], Shape.prototype, "fillBBox", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onFillChange() })
], Shape.prototype, "fillParams", 2);

// packages/ag-charts-community/src/scene/transformable.ts
import { createSvgElement as createSvgElement8 } from "ag-charts-core";

// packages/ag-charts-community/src/scene/matrix.ts
import { isNumberEqual } from "ag-charts-core";
var IDENTITY_MATRIX_ELEMENTS = [1, 0, 0, 1, 0, 0];
var Matrix = class _Matrix {
  get e() {
    return [...this.elements];
  }
  constructor(elements = IDENTITY_MATRIX_ELEMENTS) {
    this.elements = [...elements];
  }
  setElements(elements) {
    const e = this.elements;
    e[0] = elements[0];
    e[1] = elements[1];
    e[2] = elements[2];
    e[3] = elements[3];
    e[4] = elements[4];
    e[5] = elements[5];
    return this;
  }
  get identity() {
    const e = this.elements;
    return isNumberEqual(e[0], 1) && isNumberEqual(e[1], 0) && isNumberEqual(e[2], 0) && isNumberEqual(e[3], 1) && isNumberEqual(e[4], 0) && isNumberEqual(e[5], 0);
  }
  /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */
  AxB(A, B, C2) {
    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
    C2 = C2 ?? A;
    C2[0] = a;
    C2[1] = b;
    C2[2] = c;
    C2[3] = d;
    C2[4] = e;
    C2[5] = f;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */
  multiplySelf(other) {
    this.AxB(this.elements, other.elements);
    return this;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */
  multiply(other) {
    const elements = new Array(6);
    if (other instanceof _Matrix) {
      this.AxB(this.elements, other.elements, elements);
    } else {
      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements);
    }
    return new _Matrix(elements);
  }
  preMultiplySelf(other) {
    this.AxB(other.elements, this.elements, this.elements);
    return this;
  }
  /**
   * Returns the inverse of this matrix as a new matrix.
   */
  inverse() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
  }
  invertSelf() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    el[0] = d;
    el[1] = -b;
    el[2] = -c;
    el[3] = a;
    el[4] = c * f - d * e;
    el[5] = b * e - a * f;
    return this;
  }
  transformPoint(x, y) {
    const e = this.elements;
    return {
      x: x * e[0] + y * e[2] + e[4],
      y: x * e[1] + y * e[3] + e[5]
    };
  }
  transformBBox(bbox, target) {
    const el = this.elements;
    const xx = el[0];
    const xy = el[1];
    const yx = el[2];
    const yy = el[3];
    const h_w = bbox.width * 0.5;
    const h_h = bbox.height * 0.5;
    const cx = bbox.x + h_w;
    const cy = bbox.y + h_h;
    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
    target ?? (target = new BBox(0, 0, 0, 0));
    target.x = cx * xx + cy * yx + el[4] - w;
    target.y = cx * xy + cy * yy + el[5] - h;
    target.width = w + w;
    target.height = h + h;
    return target;
  }
  toContext(ctx) {
    if (this.identity) {
      return;
    }
    const e = this.elements;
    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
    const sx = scalingX;
    const sy = scalingY;
    let scx;
    let scy;
    if (sx === 1 && sy === 1) {
      scx = 0;
      scy = 0;
    } else {
      scx = opts?.scalingCenterX ?? 0;
      scy = opts?.scalingCenterY ?? 0;
    }
    const r = rotation;
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    let rcx;
    let rcy;
    if (r === 0) {
      rcx = 0;
      rcy = 0;
    } else {
      rcx = opts?.rotationCenterX ?? 0;
      rcy = opts?.rotationCenterY ?? 0;
    }
    const tx = translationX;
    const ty = translationY;
    const tx4 = scx * (1 - sx) - rcx;
    const ty4 = scy * (1 - sy) - rcy;
    matrix.setElements([
      cos * sx,
      sin * sx,
      -sin * sy,
      cos * sy,
      cos * tx4 - sin * ty4 + rcx + tx,
      sin * tx4 + cos * ty4 + rcy + ty
    ]);
    return matrix;
  }
};

// packages/ag-charts-community/src/scene/transformable.ts
function isMatrixTransform(node) {
  return isMatrixTransformType(node.constructor);
}
var MATRIX_TRANSFORM_TYPE = Symbol("isMatrixTransform");
function isMatrixTransformType(cstr) {
  return cstr[MATRIX_TRANSFORM_TYPE] === true;
}
function MatrixTransform(Parent) {
  var _a, _b;
  const ParentNode = Parent;
  if (isMatrixTransformType(Parent)) {
    return Parent;
  }
  const TRANSFORM_MATRIX = Symbol("matrix_combined_transform");
  class MatrixTransformInternal extends ParentNode {
    constructor() {
      super(...arguments);
      this[_b] = new Matrix();
      this._dirtyTransform = true;
    }
    onChangeDetection(property) {
      super.onChangeDetection(property);
      this._dirtyTransform = true;
      if (this.batchLevel > 0) {
        return;
      }
      this.markDirty("transform");
    }
    updateMatrix(_matrix) {
    }
    computeTransformMatrix() {
      if (!this._dirtyTransform)
        return;
      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);
      this.updateMatrix(this[TRANSFORM_MATRIX]);
      this._dirtyTransform = false;
    }
    toParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].transformBBox(bbox);
    }
    toParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].transformPoint(x, y);
    }
    fromParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);
    }
    fromParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);
    }
    computeBBox() {
      const bbox = super.computeBBox();
      if (!bbox)
        return bbox;
      return this.toParent(bbox);
    }
    computeBBoxWithoutTransforms() {
      return super.computeBBox();
    }
    pickNode(x, y) {
      ({ x, y } = this.fromParentPoint(x, y));
      return super.pickNode(x, y);
    }
    pickNodes(x, y, into) {
      ({ x, y } = this.fromParentPoint(x, y));
      return super.pickNodes(x, y, into);
    }
    render(renderCtx) {
      this.computeTransformMatrix();
      const { ctx } = renderCtx;
      const matrix = this[TRANSFORM_MATRIX];
      let performRestore = false;
      try {
        if (!matrix.identity) {
          ctx.save();
          performRestore = true;
          matrix.toContext(ctx);
        }
        super.render(renderCtx);
      } finally {
        if (performRestore) {
          ctx.restore();
        }
      }
    }
    toSVG() {
      this.computeTransformMatrix();
      const svg = super.toSVG();
      const matrix = this[TRANSFORM_MATRIX];
      if (matrix.identity || svg == null)
        return svg;
      const g = createSvgElement8("g");
      g.append(...svg.elements);
      const [a, b, c, d, e, f] = matrix.e;
      g.setAttribute("transform", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
      return {
        elements: [g],
        defs: svg.defs
      };
    }
  }
  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;
  MatrixTransformInternal[_a] = true;
  return MatrixTransformInternal;
}
function Rotatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const ROTATABLE_MATRIX = Symbol("matrix_rotation");
  class RotatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.rotationCenterX = 0;
      this.rotationCenterY = 0;
      this.rotation = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { rotation, rotationCenterX, rotationCenterY } = this;
      if (rotation === 0)
        return;
      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {
        rotationCenterX,
        rotationCenterY
      });
      matrix.multiplySelf(this[ROTATABLE_MATRIX]);
    }
  }
  _a = ROTATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotationCenterX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotationCenterY", 2);
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotation", 2);
  return RotatableInternal;
}
function Scalable(Parent) {
  var _a;
  const ParentNode = Parent;
  const SCALABLE_MATRIX = Symbol("matrix_scale");
  class ScalableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.scalingX = 1;
      this.scalingY = 1;
      this.scalingCenterX = 0;
      this.scalingCenterY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;
      if (scalingX === 1 && scalingY === 1)
        return;
      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {
        scalingCenterX,
        scalingCenterY
      });
      matrix.multiplySelf(this[SCALABLE_MATRIX]);
    }
  }
  _a = SCALABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingY", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingCenterX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingCenterY", 2);
  return ScalableInternal;
}
function Translatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const TRANSLATABLE_MATRIX = Symbol("matrix_translation");
  class TranslatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.translationX = 0;
      this.translationY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { translationX, translationY } = this;
      if (translationX === 0 && translationY === 0)
        return;
      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);
      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);
    }
  }
  _a = TRANSLATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], TranslatableInternal.prototype, "translationX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], TranslatableInternal.prototype, "translationY", 2);
  return TranslatableInternal;
}
var Transformable = class {
  /**
   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvas(node, bbox) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      bbox = parent.fromParent(bbox);
    }
    if (isMatrixTransform(node)) {
      bbox = node.fromParent(bbox);
    }
    return bbox;
  }
  /**
   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space
   * into the Canvas coordinate space.
   */
  static toCanvas(node, bbox) {
    if (bbox == null) {
      bbox = node.getBBox();
    } else if (isMatrixTransform(node)) {
      bbox = node.toParent(bbox);
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        bbox = parent.toParent(bbox);
      }
    }
    return bbox;
  }
  /**
   * Converts a point from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvasPoint(node, x, y) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      ({ x, y } = parent.fromParentPoint(x, y));
    }
    if (isMatrixTransform(node)) {
      ({ x, y } = node.fromParentPoint(x, y));
    }
    return { x, y };
  }
  /**
   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.
   */
  static toCanvasPoint(node, x, y) {
    if (isMatrixTransform(node)) {
      ({ x, y } = node.toParentPoint(x, y));
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        ({ x, y } = parent.toParentPoint(x, y));
      }
    }
    return { x, y };
  }
};

// packages/ag-charts-community/src/scene/group.ts
var sharedOffscreenCanvas;
var _Group = class _Group extends Node2 {
  // optimizeForInfrequentRedraws: true
  constructor(opts) {
    super(opts);
    this.childNodes = /* @__PURE__ */ new Set();
    this.dirty = false;
    this.dirtyZIndex = false;
    this.clipRect = void 0;
    this.opacity = 1;
    this.renderToOffscreenCanvas = false;
    this.optimizeForInfrequentRedraws = false;
    // Used when renderToOffscreenCanvas: true
    this.layer = void 0;
    // optimizeForInfrequentRedraws: false
    this.image = void 0;
    this._lastWidth = NaN;
    this._lastHeight = NaN;
    this._lastDevicePixelRatio = NaN;
    this.isContainerNode = true;
    this.renderToOffscreenCanvas = opts?.renderToOffscreenCanvas === true;
  }
  static is(value) {
    return value instanceof _Group;
  }
  static computeChildrenBBox(nodes, skipInvisible = true) {
    return BBox.merge(Node2.extractBBoxes(nodes, skipInvisible));
  }
  static compareChildren(a, b) {
    return compareZIndex(a.zIndex, b.zIndex) || a.serialNumber - b.serialNumber;
  }
  // We consider a group to be boundless, thus any point belongs to it.
  containsPoint(_x, _y) {
    return true;
  }
  computeBBox() {
    return _Group.computeChildrenBBox(this.children());
  }
  computeSafeClippingBBox(pixelRatio) {
    const bbox = this.computeBBox();
    if (bbox?.isFinite() !== true)
      return;
    let strokeWidth = 0;
    const strokeMiterAmount = 4;
    for (const child of this.descendants()) {
      if (child instanceof Shape) {
        strokeWidth = Math.max(strokeWidth, child.strokeWidth);
      }
    }
    const padding2 = Math.max(
      // Account for anti-aliasing artefacts
      1,
      // Account for strokes (incl. miters) - this may not be the best place to include this
      strokeWidth / 2 * strokeMiterAmount
    );
    const { x: originX, y: originY } = Transformable.toCanvasPoint(this, 0, 0);
    const x = alignBefore(pixelRatio, originX + bbox.x - padding2) - originX;
    const y = alignBefore(pixelRatio, originY + bbox.y - padding2) - originY;
    const width2 = Math.ceil(bbox.x + bbox.width - x + padding2);
    const height2 = Math.ceil(bbox.y + bbox.height - y + padding2);
    return new BBox(x, y, width2, height2);
  }
  prepareSharedCanvas(width2, height2, pixelRatio) {
    if (sharedOffscreenCanvas == null || sharedOffscreenCanvas.pixelRatio !== pixelRatio) {
      sharedOffscreenCanvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });
    } else {
      sharedOffscreenCanvas.resize(width2, height2, pixelRatio);
    }
    return sharedOffscreenCanvas;
  }
  setScene(scene) {
    super.setScene(scene);
    if (this.layer) {
      this.scene?.layersManager.removeLayer(this.layer);
      this.layer = void 0;
    }
    for (const child of this.children()) {
      child.setScene(scene);
    }
  }
  markDirty(property) {
    this.dirty = true;
    super.markDirty(property);
  }
  markDirtyChildrenOrder() {
    super.markDirtyChildrenOrder();
    this.dirtyZIndex = true;
    this.markDirty();
  }
  /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */
  append(nodes) {
    for (const node of toIterable(nodes)) {
      node.parentNode?.removeChild(node);
      this.childNodes.add(node);
      node.parentNode = this;
      node.setScene(this.scene);
    }
    this.markDirtyChildrenOrder();
    this.markDirty();
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  removeChild(node) {
    if (!this.childNodes?.delete(node)) {
      throw new Error(
        `AG Charts - internal error, unknown child node ${node.name ?? node.id} in $${this.name ?? this.id}`
      );
    }
    node.parentNode = void 0;
    node.setScene();
    this.markDirtyChildrenOrder();
    this.markDirty();
  }
  clear() {
    for (const child of this.children()) {
      delete child.parentNode;
      child.setScene();
    }
    this.childNodes?.clear();
    this.markDirty();
  }
  /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */
  pickNode(x, y) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return;
    }
    if (this.childNodes != null && this.childNodes.size !== 0) {
      const children = [...this.children()];
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const hit = child.pickNode(x, y);
        if (hit != null) {
          return hit;
        }
      }
    } else if (!this.isContainerNode) {
      return this;
    }
  }
  pickNodes(x, y, into = []) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return into;
    }
    if (!this.isContainerNode) {
      into.push(this);
    }
    for (const child of this.children()) {
      child.pickNodes(x, y, into);
    }
    return into;
  }
  isDirty(renderCtx) {
    const { width: width2, height: height2, devicePixelRatio } = renderCtx;
    const { dirty, layer } = this;
    const layerResized = layer != null && (this._lastWidth !== width2 || this._lastHeight !== height2);
    const pixelRatioChanged = this._lastDevicePixelRatio !== devicePixelRatio;
    this._lastWidth = width2;
    this._lastHeight = height2;
    this._lastDevicePixelRatio = devicePixelRatio;
    return dirty || layerResized || pixelRatioChanged;
  }
  preRender(renderCtx) {
    let counts;
    if (this.dirty) {
      counts = super.preRender(renderCtx, 0);
      for (const child of this.children()) {
        const childCounts = child.preRender(renderCtx);
        counts.groups += childCounts.groups;
        counts.nonGroups += childCounts.nonGroups;
        counts.complexity += childCounts.complexity;
      }
      counts.groups += 1;
      counts.nonGroups -= 1;
    } else {
      counts = this.childNodeCounts;
    }
    if (this.renderToOffscreenCanvas && !this.optimizeForInfrequentRedraws && counts.nonGroups > 0 && this.getVisibility()) {
      this.layer ?? (this.layer = this.layerManager?.addLayer({ name: this.name }));
    } else if (this.layer != null) {
      this.layerManager?.removeLayer(this.layer);
      this.layer = void 0;
    }
    return counts;
  }
  render(renderCtx) {
    const { layer, renderToOffscreenCanvas } = this;
    const childRenderCtx = { ...renderCtx };
    const dirty = this.isDirty(renderCtx);
    this.dirty = false;
    if (!renderToOffscreenCanvas) {
      this.renderInContext(childRenderCtx);
      super.render(childRenderCtx);
      return;
    }
    const { ctx, stats, devicePixelRatio: pixelRatio } = renderCtx;
    let { image } = this;
    if (dirty) {
      image?.bitmap.close();
      image = void 0;
      const bbox = layer ? void 0 : this.computeSafeClippingBBox(pixelRatio);
      const renderOffscreen = (offscreenCanvas, ...transform) => {
        const offscreenCtx = offscreenCanvas.context;
        childRenderCtx.ctx = offscreenCtx;
        offscreenCanvas.clear();
        offscreenCtx.save();
        try {
          offscreenCtx.setTransform(...transform);
          offscreenCtx.globalAlpha = 1;
          this.renderInContext(childRenderCtx);
        } finally {
          offscreenCtx.restore();
          offscreenCtx.verifyDepthZero?.();
        }
      };
      if (layer) {
        renderOffscreen(layer, ctx.getTransform());
      } else if (bbox) {
        const { x, y, width: width2, height: height2 } = bbox;
        const canvas = this.prepareSharedCanvas(width2, height2, pixelRatio);
        renderOffscreen(canvas, pixelRatio, 0, 0, pixelRatio, -x * pixelRatio, -y * pixelRatio);
        image = { bitmap: canvas.transferToImageBitmap(), x, y, width: width2, height: height2 };
      }
      this.image = image;
      if (stats)
        stats.layersRendered++;
    } else if (stats) {
      stats.layersSkipped++;
    }
    const { globalAlpha } = ctx;
    ctx.globalAlpha = globalAlpha * this.opacity;
    if (layer) {
      ctx.save();
      try {
        ctx.resetTransform();
        layer.drawImage(ctx);
      } finally {
        ctx.restore();
      }
    } else if (image) {
      const { bitmap, x, y, width: width2, height: height2 } = image;
      ctx.drawImage(bitmap, 0, 0, width2 * pixelRatio, height2 * pixelRatio, x, y, width2, height2);
    }
    ctx.globalAlpha = globalAlpha;
    super.render(childRenderCtx);
  }
  applyClip(ctx, clipRect) {
    const { x, y, width: width2, height: height2 } = clipRect;
    ctx.beginPath();
    ctx.rect(x, y, width2, height2);
    ctx.clip();
  }
  renderInContext(childRenderCtx) {
    const { ctx, stats } = childRenderCtx;
    if (this.dirtyZIndex) {
      this.sortChildren(_Group.compareChildren);
      this.dirtyZIndex = false;
    }
    ctx.save();
    try {
      ctx.globalAlpha *= this.opacity;
      if (this.clipRect != null) {
        this.applyClip(ctx, this.clipRect);
        childRenderCtx.clipBBox = Transformable.toCanvas(this, this.clipRect);
      }
      for (const child of this.children()) {
        if (!child.visible) {
          if (stats) {
            stats.nodesSkipped += child.childNodeCounts.nonGroups + child.childNodeCounts.groups;
            stats.opsSkipped += child.childNodeCounts.complexity;
          }
          continue;
        }
        child.isolatedRender(childRenderCtx);
      }
    } finally {
      ctx.restore();
    }
  }
  sortChildren(compareFn) {
    if (!this.childNodes)
      return;
    const sortedChildren = [...this.childNodes].sort(compareFn);
    this.childNodes.clear();
    for (const child of sortedChildren) {
      this.childNodes.add(child);
    }
  }
  *children() {
    yield* this.childNodes;
  }
  *excludeChildren(exclude) {
    for (const child of this.children()) {
      if (exclude.instance && !(child instanceof exclude.instance) || exclude.name && child.name !== exclude.name) {
        yield child;
      }
    }
  }
  *descendants() {
    for (const child of this.children()) {
      yield child;
      if (child instanceof _Group) {
        yield* child.descendants();
      }
    }
  }
  /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRect(bbox) {
    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;
  }
  /**
   * Set the clip rect within the canvas coordinate space.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRectCanvasSpace(bbox) {
    this.clipRect = bbox;
  }
  getVisibility() {
    for (const node of this.traverseUp(true)) {
      if (!node.visible) {
        return false;
      }
    }
    return true;
  }
  toSVG() {
    if (!this.visible)
      return;
    const defs = [];
    const elements = [];
    for (const child of this.children()) {
      const svg = child.toSVG();
      if (svg != null) {
        elements.push(...svg.elements);
        if (svg.defs != null) {
          defs.push(...svg.defs);
        }
      }
    }
    return { elements, defs };
  }
};
_Group.className = "Group";
__decorateClass([
  SceneChangeDetection({ convertor: (v) => clamp9(0, v, 1) })
], _Group.prototype, "opacity", 2);
var Group = _Group;
var ScalableGroup = class extends Scalable(Group) {
};
var RotatableGroup = class extends Rotatable(Group) {
};
var TranslatableGroup = class extends Translatable(Group) {
};
var TransformableGroup = class extends Rotatable(Translatable(Group)) {
};

// packages/ag-charts-community/src/scene/selection.ts
var Selection = class _Selection {
  constructor(parentNode, classOrFactory, autoCleanup = true) {
    this.parentNode = parentNode;
    this.autoCleanup = autoCleanup;
    this.garbageBin = /* @__PURE__ */ new Set();
    this._nodesMap = /* @__PURE__ */ new Map();
    this._nodes = [];
    this.data = [];
    this.debug = Debug.create(true, "scene", "scene:selections");
    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node2, classOrFactory) ? () => new classOrFactory() : classOrFactory;
  }
  static select(parent, classOrFactory, garbageCollection = true) {
    return new _Selection(parent, classOrFactory, garbageCollection);
  }
  static selectAll(parent, predicate) {
    const results = [];
    const traverse = (node) => {
      if (predicate(node)) {
        results.push(node);
      }
      if (node instanceof Group) {
        for (const child of node.children()) {
          traverse(child);
        }
      }
    };
    traverse(parent);
    return results;
  }
  static selectByClass(node, ...Classes) {
    return _Selection.selectAll(node, (n) => Classes.some((C2) => n instanceof C2));
  }
  static selectByTag(node, tag) {
    return _Selection.selectAll(node, (n) => n.tag === tag);
  }
  createNode(datum, initializer, idx) {
    const node = this.nodeFactory(datum);
    node.datum = datum;
    initializer?.(node);
    if (idx == null) {
      this._nodes.push(node);
    } else {
      this._nodes.splice(idx, 0, node);
    }
    this.parentNode.appendChild(node);
    return node;
  }
  /**
   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
   * of the array.
   */
  update(data, initializer, getDatumId) {
    if (this.garbageBin.size > 0) {
      this.debug(`Selection - update() called with pending garbage`, data);
    }
    if (getDatumId) {
      const dataMap = /* @__PURE__ */ new Map();
      const duplicateMap = /* @__PURE__ */ new Map();
      for (let idx = 0; idx < data.length; idx++) {
        const datum = data[idx];
        let id = getDatumId(datum);
        if (dataMap.has(id)) {
          const index = (duplicateMap.get(id) ?? 0) + 1;
          duplicateMap.set(id, index);
          id = `${id}:${index}`;
        }
        dataMap.set(id, idx);
      }
      for (const [node, datumId] of this._nodesMap.entries()) {
        const idx = dataMap.get(datumId);
        if (idx == null) {
          this.garbageBin.add(node);
        } else {
          node.datum = data[idx];
          this.garbageBin.delete(node);
          dataMap.delete(datumId);
        }
      }
      for (const [datumId, idx] of dataMap.entries()) {
        const datum = data[idx];
        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
      }
    } else {
      const maxLength = Math.max(data.length, this.data.length);
      for (let i = 0; i < maxLength; i++) {
        if (i >= data.length) {
          this.garbageBin.add(this._nodes[i]);
        } else if (i >= this._nodes.length) {
          this.createNode(data[i], initializer);
        } else {
          this._nodes[i].datum = data[i];
          this.garbageBin.delete(this._nodes[i]);
        }
      }
    }
    this.data = data.slice();
    if (this.autoCleanup) {
      this.cleanup();
    }
    return this;
  }
  cleanup() {
    if (this.garbageBin.size === 0) {
      return this;
    }
    this._nodes = this._nodes.filter((node) => {
      if (this.garbageBin.has(node)) {
        this._nodesMap.delete(node);
        this.garbageBin.delete(node);
        node.destroy();
        return false;
      }
      return true;
    });
    return this;
  }
  clear() {
    this.update([]);
    return this;
  }
  isGarbage(node) {
    return this.garbageBin.has(node);
  }
  each(iterate3) {
    for (const entry of this._nodes.entries()) {
      iterate3(entry[1], entry[1].datum, entry[0]);
    }
    return this;
  }
  *[Symbol.iterator]() {
    for (let index = 0; index < this._nodes.length; index++) {
      const node = this._nodes[index];
      yield { node, datum: node.datum, index };
    }
  }
  select(predicate) {
    return _Selection.selectAll(this.parentNode, predicate);
  }
  selectByClass(Class) {
    return _Selection.selectByClass(this.parentNode, Class);
  }
  selectByTag(tag) {
    return _Selection.selectByTag(this.parentNode, tag);
  }
  nodes() {
    return this._nodes;
  }
  at(index) {
    return this._nodes.at(index);
  }
  get length() {
    return this._nodes.length;
  }
};

// packages/ag-charts-community/src/scene/shape/line.ts
import { createSvgElement as createSvgElement9 } from "ag-charts-core";
var Line = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.fill = void 0;
    this.strokeWidth = 1;
  }
  set x(value) {
    this.x1 = value;
    this.x2 = value;
  }
  set y(value) {
    this.y1 = value;
    this.y2 = value;
  }
  get midPoint() {
    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };
  }
  computeBBox() {
    return new BBox(
      Math.min(this.x1, this.x2),
      Math.min(this.y1, this.y2),
      Math.abs(this.x2 - this.x1),
      Math.abs(this.y2 - this.y1)
    );
  }
  isPointInPath(x, y) {
    if (this.x1 === this.x2 || this.y1 === this.y2) {
      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);
    }
    return false;
  }
  distanceSquared(px, py) {
    const { x1, y1, x2, y2 } = this;
    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);
  }
  render(renderCtx) {
    const { ctx, devicePixelRatio } = renderCtx;
    let { x1, y1, x2, y2 } = this;
    if (x1 === x2) {
      const { strokeWidth } = this;
      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      x1 = x;
      x2 = x;
    } else if (y1 === y2) {
      const { strokeWidth } = this;
      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      y1 = y;
      y2 = y;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    this.fillStroke(ctx);
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = createSvgElement9("line");
    element2.setAttribute("x1", String(this.x1));
    element2.setAttribute("y1", String(this.y1));
    element2.setAttribute("x2", String(this.x2));
    element2.setAttribute("y2", String(this.y2));
    this.applySvgStrokeAttributes(element2);
    return {
      elements: [element2]
    };
  }
};
Line.className = "Line";
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "y2", 2);

// packages/ag-charts-community/src/scene/shape/rect.ts
import { boxesEqual as boxesEqual3 } from "ag-charts-core";

// packages/ag-charts-community/src/scene/util/corner.ts
var drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {
  if (move) {
    path.moveTo(x0, y0);
  }
  if (x0 !== x1 || y0 !== y1) {
    const r0 = Math.atan2(y0 - cy, x0 - cx);
    const r1 = Math.atan2(y1 - cy, x1 - cx);
    path.arc(cx, cy, cornerRadius, r0, r1);
  } else {
    path.lineTo(x0, y0);
  }
};

// packages/ag-charts-community/src/scene/shape/path.ts
import { createSvgElement as createSvgElement10 } from "ag-charts-core";
var Path = class extends Shape {
  constructor() {
    super(...arguments);
    /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */
    this.path = new ExtendedPath2D();
    this._clipX = NaN;
    this._clipY = NaN;
    this.clip = false;
    /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */
    this._dirtyPath = true;
    this.lastPixelRatio = NaN;
  }
  set clipX(value) {
    this._clipX = value;
    this.dirtyPath = true;
  }
  set clipY(value) {
    this._clipY = value;
    this.dirtyPath = true;
  }
  set dirtyPath(value) {
    if (this._dirtyPath !== value) {
      this._dirtyPath = value;
      if (value) {
        this.markDirty("path");
      }
    }
  }
  get dirtyPath() {
    return this._dirtyPath;
  }
  checkPathDirty() {
    if (this._dirtyPath) {
      return;
    }
    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);
  }
  resetPathDirty() {
    this.path.clear(true);
    this._dirtyPath = false;
  }
  isPathDirty() {
    return this.path.isDirty();
  }
  onChangeDetection(property) {
    if (!this._dirtyPath) {
      this._dirtyPath = true;
      super.onChangeDetection(property);
    }
  }
  computeBBox() {
    this.updatePathIfDirty();
    return this.path.computeBBox();
  }
  isPointInPath(x, y) {
    this.updatePathIfDirty();
    return this.path.closedPath && this.path.isPointInPath(x, y);
  }
  distanceSquared(x, y) {
    return this.distanceSquaredTransformedPoint(x, y);
  }
  svgPathData(transform) {
    this.updatePathIfDirty();
    return this.path.toSVG(transform);
  }
  distanceSquaredTransformedPoint(x, y) {
    this.updatePathIfDirty();
    if (this.path.closedPath && this.path.isPointInPath(x, y)) {
      return 0;
    }
    return this.path.distanceSquared(x, y);
  }
  isDirtyPath() {
    return false;
  }
  updatePath() {
  }
  updatePathIfDirty() {
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
  }
  preRender(renderCtx) {
    if (renderCtx.devicePixelRatio !== this.lastPixelRatio) {
      this.dirtyPath = true;
    }
    this.lastPixelRatio = renderCtx.devicePixelRatio;
    this.updatePathIfDirty();
    return super.preRender(renderCtx, this.path.commands.length);
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {
      ctx.save();
      try {
        const margin = this.strokeWidth / 2;
        this._clipPath ?? (this._clipPath = new ExtendedPath2D());
        this._clipPath.clear();
        this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
        ctx.clip(this._clipPath?.getPath2D());
        if (this._clipX > 0 && this._clipY > 0) {
          this.drawPath(ctx);
        }
      } finally {
        ctx.restore();
      }
    } else {
      this._clipPath = void 0;
      this.drawPath(ctx);
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  drawPath(ctx) {
    this.fillStroke(ctx, this.path.getPath2D());
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = createSvgElement10("path");
    element2.setAttribute("d", this.svgPathData());
    const defs = this.applySvgFillAttributes(element2, []);
    this.applySvgStrokeAttributes(element2);
    return {
      elements: [element2],
      defs
    };
  }
};
Path.className = "Path";
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clip", 2);
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clipX", 1);
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clipY", 1);

// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon = 1e-6;
var cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {
  let leadingClipped = false;
  let trailingClipped = false;
  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));
  let leading1 = 0;
  let trailing0 = 0;
  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));
  if (leading0 > leadingEdge) {
    leadingClipped = true;
    leading0 = leadingEdge;
    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));
  } else if (leading0 < epsilon) {
    leading0 = 0;
  }
  if (trailing1 > trailingEdge) {
    trailingClipped = true;
    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));
    trailing1 = trailingEdge;
  } else if (trailing1 < epsilon) {
    trailing1 = 0;
  }
  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };
};
var clippedRoundRect = (path, x, y, width2, height2, cornerRadii, clipBBox) => {
  let {
    topLeft: topLeftCornerRadius,
    topRight: topRightCornerRadius,
    bottomRight: bottomRightCornerRadius,
    bottomLeft: bottomLeftCornerRadius
  } = cornerRadii;
  const maxVerticalCornerRadius = Math.max(
    topLeftCornerRadius + bottomLeftCornerRadius,
    topRightCornerRadius + bottomRightCornerRadius
  );
  const maxHorizontalCornerRadius = Math.max(
    topLeftCornerRadius + topRightCornerRadius,
    bottomLeftCornerRadius + bottomRightCornerRadius
  );
  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
    if (clipBBox == null) {
      path.rect(x, y, width2, height2);
    } else {
      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);
    }
    return;
  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
    path.roundRect(x, y, width2, height2, topLeftCornerRadius);
    return;
  }
  if (width2 < 0) {
    x += width2;
    width2 = Math.abs(width2);
  }
  if (height2 < 0) {
    y += height2;
    height2 = Math.abs(height2);
  }
  if (width2 <= 0 || height2 <= 0)
    return;
  if (clipBBox == null) {
    clipBBox = new BBox(x, y, width2, height2);
  } else {
    const x0 = Math.max(x, clipBBox.x);
    const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);
    const y0 = Math.max(y, clipBBox.y);
    const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);
    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);
  }
  const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);
  if (borderScale > 1) {
    topLeftCornerRadius /= borderScale;
    topRightCornerRadius /= borderScale;
    bottomRightCornerRadius /= borderScale;
    bottomLeftCornerRadius /= borderScale;
  }
  let drawTopLeftCorner = true;
  let drawTopRightCorner = true;
  let drawBottomRightCorner = true;
  let drawBottomLeftCorner = true;
  let topLeftCorner;
  let topRightCorner;
  let bottomRightCorner;
  let bottomLeftCorner;
  if (drawTopLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),
      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),
      topLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomLeftCorner = false;
    if (nodes.trailingClipped)
      drawTopRightCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);
    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);
    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);
    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);
    const cx = x + topLeftCornerRadius;
    const cy = y + topLeftCornerRadius;
    topLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawTopRightCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(y + topRightCornerRadius - clipBBox.y, 0),
      Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0),
      topRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopLeftCorner = false;
    if (nodes.trailingClipped)
      drawBottomRightCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);
    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);
    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);
    const cx = x + width2 - topRightCornerRadius;
    const cy = y + topRightCornerRadius;
    topRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomRightCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0),
      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0),
      bottomRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopRightCorner = false;
    if (nodes.trailingClipped)
      drawBottomLeftCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);
    const cx = x + width2 - bottomRightCornerRadius;
    const cy = y + height2 - bottomRightCornerRadius;
    bottomRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0),
      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),
      bottomLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomRightCorner = false;
    if (nodes.trailingClipped)
      drawTopLeftCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);
    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);
    const cx = x + bottomLeftCornerRadius;
    const cy = y + height2 - bottomLeftCornerRadius;
    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  let didMove = false;
  if (drawTopLeftCorner && topLeftCorner != null) {
    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawTopRightCorner && topRightCorner != null) {
    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomRightCorner && bottomRightCorner != null) {
    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomLeftCorner && bottomLeftCorner != null) {
    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
  }
  path.closePath();
};
var Rect = class extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new ExtendedPath2D();
    this.x = 0;
    this.y = 0;
    this.width = 10;
    this.height = 10;
    this.topLeftCornerRadius = 0;
    this.topRightCornerRadius = 0;
    this.bottomRightCornerRadius = 0;
    this.bottomLeftCornerRadius = 0;
    this.clipBBox = void 0;
    this.crisp = false;
    this.lastUpdatePathStrokeWidth = this.strokeWidth;
    this.effectiveStrokeWidth = this.strokeWidth;
    this.hittester = super.isPointInPath.bind(this);
    this.distanceCalculator = super.distanceSquaredTransformedPoint.bind(this);
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    this.microPixelEffectOpacity = 1;
  }
  set cornerRadius(cornerRadius) {
    this.topLeftCornerRadius = cornerRadius;
    this.topRightCornerRadius = cornerRadius;
    this.bottomRightCornerRadius = cornerRadius;
    this.bottomLeftCornerRadius = cornerRadius;
  }
  isDirtyPath() {
    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());
  }
  updatePath() {
    const {
      path,
      borderPath,
      crisp,
      topLeftCornerRadius: topLeft,
      topRightCornerRadius: topRight,
      bottomRightCornerRadius: bottomRight,
      bottomLeftCornerRadius: bottomLeft
    } = this;
    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const pixelSize = 1 / pixelRatio;
    let microPixelEffectOpacity = 1;
    path.clear(true);
    borderPath.clear(true);
    if (w === 0 || h === 0) {
      this.effectiveStrokeWidth = 0;
      this.lastUpdatePathStrokeWidth = 0;
      this.microPixelEffectOpacity = 0;
      return;
    }
    if (crisp) {
      if (w <= pixelSize) {
        microPixelEffectOpacity *= w / pixelSize;
      }
      if (h <= pixelSize) {
        microPixelEffectOpacity *= h / pixelSize;
      }
      w = this.align(x, w);
      h = this.align(y, h);
      x = this.align(x);
      y = this.align(y);
      clipBBox = clipBBox != null ? new BBox(
        this.align(clipBBox.x),
        this.align(clipBBox.y),
        this.align(clipBBox.x, clipBBox.width),
        this.align(clipBBox.y, clipBBox.height)
      ) : void 0;
    }
    if (strokeWidth) {
      if (w < pixelSize) {
        const lx = x + pixelSize / 2;
        borderPath.moveTo(lx, y);
        borderPath.lineTo(lx, y + h);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (h < pixelSize) {
        const ly = y + pixelSize / 2;
        borderPath.moveTo(x, ly);
        borderPath.lineTo(x + w, ly);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (strokeWidth < w && strokeWidth < h) {
        const halfStrokeWidth = strokeWidth / 2;
        x += halfStrokeWidth;
        y += halfStrokeWidth;
        w -= strokeWidth;
        h -= strokeWidth;
        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);
        const cornerRadii = {
          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,
          topRight: topRight > 0 ? topRight - strokeWidth : 0,
          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,
          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0
        };
        this.borderClipPath = void 0;
        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {
          clippedRoundRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);
          clippedRoundRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);
        }
      } else {
        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();
        this.borderClipPath.clear(true);
        this.borderClipPath.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      }
    } else {
      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };
      this.borderClipPath = void 0;
      clippedRoundRect(path, x, y, w, h, cornerRadii, clipBBox);
    }
    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {
      const bbox = this.getBBox();
      this.hittester = bbox.containsPoint.bind(bbox);
      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);
    } else {
      this.hittester = super.isPointInPath;
      this.distanceCalculator = super.distanceSquaredTransformedPoint;
    }
    this.effectiveStrokeWidth = strokeWidth;
    this.lastUpdatePathStrokeWidth = strokeWidth;
    this.microPixelEffectOpacity = microPixelEffectOpacity;
  }
  computeBBox() {
    const { x, y, width: width2, height: height2, clipBBox } = this;
    return clipBBox?.clone() ?? new BBox(x, y, width2, height2);
  }
  isPointInPath(x, y) {
    return this.hittester(x, y);
  }
  get midPoint() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  distanceSquared(x, y) {
    return this.distanceCalculator(x, y);
  }
  applyFillAndAlpha(ctx) {
    super.applyFillAndAlpha(ctx);
    ctx.globalAlpha *= this.microPixelEffectOpacity;
  }
  applyStrokeAndAlpha(ctx) {
    super.applyStrokeAndAlpha(ctx);
    ctx.globalAlpha *= this.microPixelEffectOpacity;
  }
  renderStroke(ctx) {
    const { stroke: stroke2, effectiveStrokeWidth } = this;
    if (stroke2 && effectiveStrokeWidth) {
      const { globalAlpha } = ctx;
      const { lineDash, lineDashOffset, lineCap, lineJoin, borderPath, borderClipPath } = this;
      if (borderClipPath) {
        ctx.clip(borderClipPath.getPath2D());
      }
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = effectiveStrokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.stroke(borderPath.getPath2D());
      ctx.globalAlpha = globalAlpha;
    }
  }
};
Rect.className = "Rect";
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "height", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "topLeftCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "topRightCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "bottomRightCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "bottomLeftCornerRadius", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: boxesEqual3 })
], Rect.prototype, "clipBBox", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "crisp", 2);

// packages/ag-charts-community/src/scene/shape/text.ts
import { createSvgElement as createSvgElement11, isArray as isArray4, isString as isString3, toPlainText } from "ag-charts-core";

// packages/ag-charts-community/src/util/canvas.util.ts
function createCanvasContext(width2 = 0, height2 = 0) {
  return new OffscreenCanvas(width2, height2).getContext("2d");
}

// packages/ag-charts-community/src/util/lruCache.ts
var LRUCache = class {
  constructor(maxCacheSize = 5) {
    this.maxCacheSize = maxCacheSize;
    this.store = /* @__PURE__ */ new Map();
  }
  get(key) {
    if (!this.store.has(key))
      return void 0;
    const hit = this.store.get(key);
    this.store.delete(key);
    this.store.set(key, hit);
    return hit;
  }
  has(key) {
    return this.store.has(key);
  }
  set(key, value) {
    this.store.set(key, value);
    if (this.store.size > this.maxCacheSize) {
      const iterator = this.store.keys();
      let evictCount = this.store.size - this.maxCacheSize;
      while (evictCount > 0) {
        const evictKeyIterator = iterator.next();
        if (!evictKeyIterator.done) {
          this.store.delete(evictKeyIterator.value);
        }
        evictCount--;
      }
    }
    return value;
  }
  clear() {
    this.store.clear();
  }
};

// packages/ag-charts-community/src/util/textMeasurer.ts
var CachedTextMeasurerPool = class {
  // Measures the dimensions of the provided text, handling multiline if needed.
  static measureText(text, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureText(text);
  }
  static measureLines(text, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureLines(text);
  }
  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.
  static getMeasurer(options) {
    const font2 = TextUtils.toFontString(options.font);
    const key = `${font2}-${options.textAlign ?? "start"}-${options.textBaseline ?? "top"}`;
    return this.instanceMap.get(key) ?? this.createFontMeasurer(font2, options, key);
  }
  static clear() {
    this.instanceMap.clear();
  }
  // Creates or retrieves a TextMeasurer instance for a specific font.
  static createFontMeasurer(font2, options, key) {
    const ctx = createCanvasContext();
    ctx.font = font2;
    ctx.textAlign = options.textAlign ?? "start";
    ctx.textBaseline = options.textBaseline ?? "top";
    const measurer2 = new CachedTextMeasurer(ctx, options);
    this.instanceMap.set(key, measurer2);
    return measurer2;
  }
};
CachedTextMeasurerPool.instanceMap = new LRUCache(10);
var CachedTextMeasurer = class {
  constructor(ctx, options) {
    this.ctx = ctx;
    // cached text measurements
    this.measureMap = new LRUCache(100);
    if (options.textAlign) {
      ctx.textAlign = options.textAlign;
    }
    if (options.textBaseline) {
      ctx.textBaseline = options.textBaseline;
    }
    ctx.font = TextUtils.toFontString(options.font);
    this.textMeasurer = new SimpleTextMeasurer(
      (t) => this.cachedCtxMeasureText(t),
      options.textBaseline ?? "alphabetic"
    );
  }
  textWidth(text, estimate) {
    return this.textMeasurer.textWidth(text, estimate);
  }
  measureText(text) {
    return this.textMeasurer.measureText(text);
  }
  measureLines(text) {
    return this.textMeasurer.measureLines(text);
  }
  cachedCtxMeasureText(text) {
    if (!this.measureMap.has(text)) {
      const rawResult = this.ctx.measureText(text);
      this.measureMap.set(text, {
        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,
        emHeightAscent: rawResult.emHeightAscent,
        emHeightDescent: rawResult.emHeightDescent,
        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,
        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,
        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,
        alphabeticBaseline: rawResult.alphabeticBaseline,
        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,
        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,
        hangingBaseline: rawResult.hangingBaseline,
        ideographicBaseline: rawResult.ideographicBaseline,
        width: rawResult.width
      });
    }
    return this.measureMap.get(text);
  }
};
var TextUtils = class {
  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily }) {
    let fontString = "";
    if (fontStyle && fontStyle !== "normal") {
      fontString += `${fontStyle} `;
    }
    if (fontWeight && fontWeight !== "normal" && fontWeight !== 400) {
      fontString += `${fontWeight} `;
    }
    fontString += `${fontSize}px`;
    fontString += ` ${fontFamily}`;
    return fontString.trim();
  }
  static getLineHeight(fontSize) {
    return Math.ceil(fontSize * this.defaultLineHeight);
  }
  static getHorizontalModifier(textAlign) {
    switch (textAlign) {
      case "left":
      case "start":
        return 0;
      case "center":
        return 0.5;
      case "right":
      case "end":
        return 1;
      default:
        return 0;
    }
  }
  // Determines vertical offset modifier based on text baseline.
  static getVerticalModifier(textBaseline) {
    switch (textBaseline) {
      case "hanging":
      case "top":
        return 0;
      case "middle":
        return 0.5;
      case "alphabetic":
      case "bottom":
      case "ideographic":
      default:
        return 1;
    }
  }
};
TextUtils.EllipsisChar = "\u2026";
// Representation for text clipping.
TextUtils.defaultLineHeight = 1.15;
// Normally between 1.1 and 1.2
TextUtils.lineSplitter = /\r?\n/g;
var SimpleTextMeasurer = class {
  constructor(measureTextFn, textBaseline = "alphabetic") {
    this.measureTextFn = measureTextFn;
    this.textBaseline = textBaseline;
    // local chars width cache per TextMeasurer
    this.charMap = /* @__PURE__ */ new Map();
  }
  // Measures metrics for a single line of text.
  getMetrics(text) {
    const m = this.measureTextFn(text);
    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
    return {
      width: m.width,
      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent
    };
  }
  // Calculates aggregated metrics for multiline text.
  getMultilineMetrics(lines) {
    let width2 = 0;
    let height2 = 0;
    let offsetTop = 0;
    let offsetLeft = 0;
    let baselineDistance = 0;
    let alphabeticBaseline = 0;
    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);
    const lineMetrics = [];
    let index = 0;
    const length = lines.length;
    for (const line of lines) {
      const m = this.measureTextFn(line);
      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
      if (width2 < m.width) {
        width2 = m.width;
      }
      if (offsetLeft < m.actualBoundingBoxLeft) {
        offsetLeft = m.actualBoundingBoxLeft;
      }
      if (index === 0) {
        height2 += m.actualBoundingBoxAscent;
        offsetTop += m.actualBoundingBoxAscent;
        alphabeticBaseline = m.alphabeticBaseline;
      } else {
        baselineDistance += m.fontBoundingBoxAscent;
      }
      if (index === length - 1) {
        height2 += m.actualBoundingBoxDescent;
      } else {
        baselineDistance += m.fontBoundingBoxDescent;
      }
      lineMetrics.push({
        text: line,
        width: m.width,
        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
        offsetTop: m.actualBoundingBoxAscent,
        offsetLeft: m.actualBoundingBoxLeft
      });
      index++;
    }
    height2 += baselineDistance;
    offsetTop += baselineDistance * verticalModifier;
    return { width: width2, height: height2, offsetTop, offsetLeft, alphabeticBaseline, lineMetrics };
  }
  textWidth(text, estimate) {
    if (estimate) {
      let estimatedWidth = 0;
      for (let i = 0; i < text.length; i++) {
        estimatedWidth += this.textWidth(text.charAt(i));
      }
      return estimatedWidth;
    }
    if (text.length > 1) {
      return this.measureTextFn(text).width;
    }
    return this.charMap.get(text) ?? this.charWidth(text);
  }
  measureText(text) {
    return this.getMetrics(text);
  }
  // Measures the dimensions of the provided text, handling multiline if needed.
  measureLines(text) {
    const lines = typeof text === "string" ? text.split(TextUtils.lineSplitter) : text;
    return this.getMultilineMetrics(lines);
  }
  charWidth(char) {
    const { width: width2 } = this.measureTextFn(char);
    this.charMap.set(char, width2);
    return width2;
  }
};

// packages/ag-charts-community/src/scene/sceneDebug.ts
import { Logger as Logger12, getWindow as getWindow2, isString as isString2, toArray as toArray2 } from "ag-charts-core";
function formatBytes(value) {
  for (const unit of ["B", "KB", "MB", "GB"]) {
    if (value < 1536) {
      return `${value.toFixed(1)}${unit}`;
    }
    value /= 1024;
  }
  return `${value.toFixed(1)}TB}`;
}
function memoryUsage() {
  if (!("memory" in performance))
    return;
  const { totalJSHeapSize, usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
  const result = [];
  for (const amount of [usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit]) {
    if (typeof amount !== "number")
      continue;
    result.push(formatBytes(amount));
  }
  return `Heap ${result.join(" / ")}`;
}
function debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {
  if (!Debug.check("scene:stats" /* SCENE_STATS */, "scene:stats:verbose" /* SCENE_STATS_VERBOSE */))
    return;
  const {
    layersRendered = 0,
    layersSkipped = 0,
    nodesRendered = 0,
    nodesSkipped = 0,
    opsPerformed = 0,
    opsSkipped = 0
  } = renderCtxStats ?? {};
  const end2 = performance.now();
  const { start: start2, ...durations } = debugSplitTimes;
  const splits = Object.entries(durations).map(([n, t]) => {
    return time(n, t);
  }).filter((v) => v != null).join(" + ");
  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join(" ; ");
  const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */);
  const memUsage = memoryUsage();
  const stats = [
    `${time("\u23F1\uFE0F", start2, end2)} (${splits})`,
    `${extras}`,
    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,
    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null,
    detailedStats ? `Ops: ${pct(opsPerformed, opsSkipped)}` : null,
    detailedStats && memUsage ? memUsage : null
  ].filter(isString2);
  const measurer2 = new SimpleTextMeasurer((t) => ctx.measureText(t));
  const statsSize = new Map(stats.map((t) => [t, measurer2.measureLines(t)]));
  const width2 = Math.max(...Array.from(statsSize.values(), (s) => s.width));
  const height2 = accumulate(statsSize.values(), (s) => s.height);
  const x = 2 + seriesRect.x;
  ctx.save();
  try {
    ctx.fillStyle = "white";
    ctx.fillRect(x, 0, width2, height2);
    ctx.fillStyle = "black";
    let y = 0;
    for (const [stat, size] of statsSize.entries()) {
      y += size.height;
      ctx.fillText(stat, x, y);
    }
  } catch (e) {
    Logger12.warnOnce("Error during debug stats rendering", e);
  } finally {
    ctx.restore();
  }
}
function prepareSceneNodeHighlight(ctx) {
  const config = toArray2(getWindow2("agChartsSceneDebug"));
  const result = [];
  for (const name of config) {
    if (name === "layout") {
      result.push("seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/);
    } else {
      result.push(name);
    }
  }
  ctx.debugNodeSearch = result;
}
function debugSceneNodeHighlight(ctx, debugNodes) {
  ctx.save();
  try {
    for (const [name, node] of Object.entries(debugNodes)) {
      const bbox = Transformable.toCanvas(node);
      if (!bbox) {
        Logger12.log(`Scene.render() - no bbox for debugged node [${name}].`);
        continue;
      }
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
      ctx.fillStyle = "red";
      ctx.strokeStyle = "white";
      ctx.font = "16px sans-serif";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.lineWidth = 2;
      ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
      ctx.fillText(name, bbox.x, bbox.y, bbox.width);
    }
  } catch (e) {
    Logger12.warnOnce("Error during debug rendering", e);
  } finally {
    ctx.restore();
  }
}
var skippedProperties = /* @__PURE__ */ new Set();
var allowedProperties = /* @__PURE__ */ new Set([
  "gradient",
  // '_datum',
  "zIndex",
  "clipRect",
  "cachedBBox",
  "childNodeCounts",
  "path",
  "__zIndex",
  "name",
  "__scalingCenterX",
  "__scalingCenterY",
  "__rotationCenterX",
  "__rotationCenterY",
  "_previousDatum",
  "__fill",
  "__lineDash",
  "borderPath",
  "borderClipPath",
  "_clipPath"
]);
function nodeProps(node) {
  const { ...allProps } = node;
  for (const prop of Object.keys(allProps)) {
    if (allowedProperties.has(prop))
      continue;
    if (typeof allProps[prop] === "number")
      continue;
    if (typeof allProps[prop] === "string")
      continue;
    if (typeof allProps[prop] === "boolean")
      continue;
    skippedProperties.add(prop);
    delete allProps[prop];
  }
  return allProps;
}
function buildTree(node, mode) {
  if (!Debug.check(true, "scene" /* SCENE */)) {
    return {};
  }
  let order = 0;
  return {
    node: mode === "json" ? nodeProps(node) : node,
    name: node.name ?? node.id,
    dirty: node instanceof Group ? node.dirty : void 0,
    ...Array.from(node instanceof Group ? node.children() : [], (c) => buildTree(c, mode)).reduce((result, childTree) => {
      let { name: treeNodeName } = childTree;
      const {
        node: { visible, opacity, zIndex, translationX, translationY, rotation, scalingX, scalingY },
        node: childNode
      } = childTree;
      if (!visible || opacity <= 0) {
        treeNodeName = `(${treeNodeName})`;
      }
      if (Group.is(childNode) && childNode.renderToOffscreenCanvas) {
        treeNodeName = `*${treeNodeName}*`;
      }
      const zIndexString = Array.isArray(zIndex) ? `(${zIndex.join(", ")})` : zIndex;
      const key = [
        `${(order++).toString().padStart(3, "0")}|`,
        `${treeNodeName ?? "<unknown>"}`,
        `z: ${zIndexString}`,
        translationX && `x: ${translationX}`,
        translationY && `y: ${translationY}`,
        rotation && `r: ${rotation}`,
        scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,
        scalingY != null && scalingY !== 1 && `sy: ${scalingY}`
      ].filter((v) => !!v).join(" ");
      let selectedKey = key;
      let index = 1;
      while (result[selectedKey] != null && index < 100) {
        selectedKey = `${key} (${index++})`;
      }
      result[selectedKey] = childTree;
      return result;
    }, {})
  };
}
function buildDirtyTree(node) {
  const nodeDirty = node instanceof Group ? node.dirty : void 0;
  if (!nodeDirty) {
    return { dirtyTree: {}, paths: [] };
  }
  const childrenDirtyTree = Array.from(node instanceof Group ? node.children() : [], (c) => buildDirtyTree(c)).filter(
    (c) => c.paths.length > 0
  );
  const name = Group.is(node) ? node.name ?? node.id : node.id;
  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];
  return {
    dirtyTree: {
      name,
      node,
      dirty: nodeDirty,
      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {
        result[childTree.name ?? "<unknown>"] = childTree;
        return result;
      }, {})
    },
    paths
  };
}
function pct(rendered, skipped) {
  const total = rendered + skipped;
  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
}
function time(name, start2, end2) {
  const duration = end2 != null ? end2 - start2 : start2;
  return `${name}: ${Math.round(duration * 100) / 100}ms`;
}
function accumulate(iterator, mapper) {
  let sum = 0;
  for (const item of iterator) {
    sum += mapper(item);
  }
  return sum;
}

// packages/ag-charts-community/src/scene/shape/text.ts
var externUseGlyphIndependentMeasurements = false;
var _Text = class _Text extends Shape {
  constructor(options) {
    super(options);
    this.x = 0;
    this.y = 0;
    this.lines = [];
    this.text = void 0;
    this.fontSize = _Text.defaultFontSize;
    this.fontFamily = "sans-serif";
    this.textAlign = "start";
    this.textBaseline = "alphabetic";
    this.boxPadding = 0;
    this.trimText = options?.trimText ?? true;
  }
  onTextChange() {
    this.richText?.clear();
    this.textMap?.clear();
    if (isArray4(this.text)) {
      this.lines = [];
      this.richText ?? (this.richText = new Group());
      this.richText.setScene(this.scene);
      this.richText.append(this.text.map(() => new _Text({ trimText: false })));
    } else {
      const lines = this.text?.split("\n") ?? [];
      this.lines = this.trimText ? lines.map((line) => line.trim()) : lines;
    }
  }
  static computeBBox(lines, x, y, opts, useGlyphIndependentMeasurements = true) {
    const {
      font: font2,
      font: { fontSize },
      textAlign,
      textBaseline,
      lineHeight = useGlyphIndependentMeasurements ? TextUtils.getLineHeight(fontSize) : void 0
    } = opts;
    const {
      width: width2,
      alphabeticBaseline,
      offsetLeft: exactOffsetLeft,
      offsetTop: exactOffsetTop,
      height: exactHeight
    } = CachedTextMeasurerPool.measureLines(
      lines,
      useGlyphIndependentMeasurements ? { font: font2, lineHeight, textAlign: "start", textBaseline: "top" } : opts
    );
    const height2 = lineHeight == null ? exactHeight : lineHeight * lines.length;
    let offsetTop;
    if (lineHeight == null) {
      offsetTop = exactOffsetTop;
    } else if (textBaseline === "alphabetic") {
      const padding2 = (lineHeight - fontSize) / 2;
      offsetTop = padding2 - alphabeticBaseline;
    } else {
      offsetTop = TextUtils.getVerticalModifier(textBaseline) * height2;
    }
    const offsetLeft = useGlyphIndependentMeasurements ? width2 * TextUtils.getHorizontalModifier(textAlign) : exactOffsetLeft;
    return new BBox(x - offsetLeft, y - offsetTop, width2, height2);
  }
  computeBBox(useGlyphIndependentMeasurements = externUseGlyphIndependentMeasurements) {
    this.generateTextMap();
    if (this.textMap?.size) {
      const bbox = BBox.merge(this.textMap.values());
      bbox.x = this.x;
      bbox.y = this.y;
      return bbox;
    }
    const { x, y, lines, textBaseline, textAlign, lineHeight } = this;
    const measuredTextBounds = _Text.computeBBox(
      lines,
      x,
      y,
      { font: this, textBaseline, textAlign, lineHeight },
      useGlyphIndependentMeasurements
    );
    if (this.boxing != null)
      measuredTextBounds.grow(this.boxPadding);
    return measuredTextBounds;
  }
  getBBox(useGlyphIndependentMeasurements = true) {
    if (useGlyphIndependentMeasurements) {
      externUseGlyphIndependentMeasurements = true;
      const bbox = this.computeBBox(true);
      externUseGlyphIndependentMeasurements = false;
      return bbox;
    }
    return super.getBBox();
  }
  getPlainText() {
    return toPlainText(this.text);
  }
  getTextMeasureBBox() {
    return this.computeBBox();
  }
  isPointInPath(x, y) {
    return this.getBBox()?.containsPoint(x, y) ?? false;
  }
  setScene(scene) {
    this.richText?.setScene(scene);
    super.setScene(scene);
  }
  generateTextMap() {
    if (!isArray4(this.text) || this.textMap?.size)
      return;
    this.textMap ?? (this.textMap = /* @__PURE__ */ new Map());
    let index = 0;
    let totalWidth = 0;
    let offsetY = 0;
    const mainStyle = {
      fill: this.fill,
      fontSize: this.fontSize,
      fontFamily: this.fontFamily,
      fontStyle: this.fontStyle,
      fontWeight: this.fontWeight
    };
    for (const textNode of this.richText.children()) {
      const { color: color7, ...textSegment } = this.text[index++];
      textNode.x = 0;
      textNode.y = 0;
      textNode.setProperties(mergeDefaults({ fill: color7 }, textSegment, mainStyle));
      const textBBox = textNode.getBBox();
      this.textMap.set(textNode, textBBox);
      offsetY = Math.max(
        offsetY,
        textBBox.y + textBBox.height / 2 + (textNode.lineHeight ?? TextUtils.getLineHeight(textNode.fontSize))
      );
      totalWidth += textBBox.x + textBBox.width;
    }
    let offsetX = this.x - totalWidth / 2;
    for (const [textNode, bbox] of this.textMap) {
      textNode.x += offsetX;
      textNode.y += offsetY;
      offsetX += bbox.width;
    }
  }
  render(renderCtx) {
    const { ctx, stats } = renderCtx;
    if (!this.text || !this.layerManager) {
      if (stats)
        stats.nodesSkipped += 1;
      return super.render(renderCtx);
    }
    if (isArray4(this.text)) {
      this.generateTextMap();
      const { width: width2 } = this.richText.getBBox();
      let translateX = 0;
      switch (this.textAlign) {
        case "left":
        case "start":
          translateX = width2 / 2;
          break;
        case "right":
        case "end":
          translateX = width2 / -2;
      }
      ctx.save();
      ctx.translate(translateX, this.y);
      this.richText.render(renderCtx);
      ctx.restore();
    } else {
      this.renderText(renderCtx);
    }
    if (_Text.debug.check() && !this.textMap?.size) {
      const bbox = this.getBBox(true);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
    }
    super.render(renderCtx);
  }
  markDirty(property) {
    this.textMap?.clear();
    return super.markDirty(property);
  }
  renderText(renderCtx) {
    const { fill, stroke: stroke2, strokeWidth } = this;
    if (!fill && !(stroke2 && strokeWidth) || !this.layerManager) {
      return super.render(renderCtx);
    }
    const { ctx } = renderCtx;
    const font2 = TextUtils.toFontString(this);
    if (ctx.font !== font2) {
      ctx.font = font2;
    }
    const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textAlign, textBaseline } = this;
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    if (this.boxing) {
      const opts = { font: this, textBaseline, textAlign, lineHeight };
      const textBBox = _Text.computeBBox(this.lines, this.x, this.y, opts);
      if (textBBox.width !== 0 && textBBox.height !== 0) {
        const { x, y, width: width2, height: height2 } = textBBox.grow(this.boxPadding);
        this.boxing.opacity = this.opacity;
        this.boxing.x = x;
        this.boxing.y = y;
        this.boxing.width = width2;
        this.boxing.height = height2;
        this.boxing.preRender(renderCtx);
        this.boxing.render(renderCtx);
      }
    }
    this.fillStroke(ctx);
  }
  executeFill(ctx) {
    const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textBaseline, lines } = this;
    const lineOriginY = textBaseline === "alphabetic" ? 0 : TextUtils.getVerticalModifier(textBaseline) * lineHeight * (1 - lines.length);
    this.renderLines(lineOriginY, lineHeight, (line, x, y) => ctx.fillText(line, x, y));
  }
  executeStroke(ctx) {
    const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textBaseline, lines } = this;
    const lineOriginY = textBaseline === "alphabetic" ? 0 : TextUtils.getVerticalModifier(textBaseline) * lineHeight * (1 - lines.length);
    this.renderLines(lineOriginY, lineHeight, (line, x, y) => ctx.strokeText(line, x, y));
  }
  renderLines(offsetY, lineHeight, renderCallback) {
    const { lines, x, y } = this;
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(offsetY) || !Number.isFinite(lineHeight)) {
      return;
    }
    for (const line of lines) {
      renderCallback(line, x, y + offsetY);
      offsetY += lineHeight;
    }
  }
  setFont(props) {
    this.fontFamily = props.fontFamily;
    this.fontSize = props.fontSize;
    this.fontStyle = props.fontStyle;
    this.fontWeight = props.fontWeight;
  }
  setAlign(props) {
    this.textAlign = props.textAlign;
    this.textBaseline = props.textBaseline;
  }
  setBoxing(props) {
    const stroke2 = props.border?.enabled ? props.border?.stroke : void 0;
    if (props.fill != null || stroke2 != null) {
      this.boxing ?? (this.boxing = new Rect({ scene: this.scene }));
      this.boxing.fill = props.fill;
      this.boxing.fillOpacity = props.fillOpacity ?? 1;
      this.boxing.cornerRadius = props.cornerRadius ?? 0;
      this.boxing.stroke = stroke2;
      this.boxing.strokeWidth = props.border?.strokeWidth ?? 0;
      this.boxing.strokeOpacity = props.border?.strokeOpacity ?? 1;
      this.boxPadding = props.padding ?? 0;
    } else if (this.boxing) {
      this.boxing.destroy();
      this.boxing = void 0;
    }
  }
  getBoxingProperties() {
    const { fill, fillOpacity, cornerRadius, stroke: stroke2, strokeWidth, strokeOpacity } = this.boxing ?? {};
    return {
      border: { enabled: stroke2 != null, stroke: stroke2, strokeWidth, strokeOpacity },
      cornerRadius,
      fill,
      fillOpacity,
      padding: this.boxPadding
    };
  }
  toSVG() {
    if (!this.visible || !this.text)
      return;
    const element2 = createSvgElement11("text");
    if (isString3(this.text)) {
      this.applySvgFillAttributes(element2);
      setSvgFontAttributes(element2, this);
      element2.setAttribute(
        "text-anchor",
        {
          center: "middle",
          left: "start",
          right: "end",
          start: "start",
          end: "end"
        }[this.textAlign ?? "start"]
      );
      element2.setAttribute("alignment-baseline", this.textBaseline);
      element2.setAttribute("x", String(this.x));
      element2.setAttribute("y", String(this.y));
      element2.textContent = this.text;
    } else {
      for (const segment of this.text) {
        const segmentElement = createSvgElement11("tspan");
        setSvgFontAttributes(segmentElement, {
          fontSize: segment.fontSize ?? this.fontSize,
          fontFamily: segment.fontFamily ?? this.fontFamily,
          fontWeight: segment.fontWeight ?? this.fontWeight,
          fontStyle: segment.fontStyle ?? this.fontStyle
        });
        this.applySvgFillAttributes(segmentElement);
        segmentElement.textContent = segment.text;
        element2.append(segmentElement);
      }
    }
    return { elements: [element2] };
  }
};
_Text.className = "Text";
_Text.debug = Debug.create(true, "scene:text" /* SCENE_TEXT */);
_Text.defaultFontSize = 10;
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "y", 2);
__decorateClass([
  SceneRefChangeDetection({
    changeCb: (o) => o.onTextChange()
  })
], _Text.prototype, "text", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontStyle", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontWeight", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontSize", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontFamily", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "textAlign", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "textBaseline", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "lineHeight", 2);
var Text = _Text;
var RotatableText = class extends Rotatable(Text) {
};
var TransformableText = class extends Rotatable(Translatable(Text)) {
};

// packages/ag-charts-community/src/util/stateMachine.ts
var debugColor = "color: green";
var debugQuietColor = "color: grey";
function applyProperties(parentState, childState) {
  const childProperties = listDecoratedProperties(childState);
  if (childProperties.length === 0)
    return;
  const properties = extractDecoratedProperties(parentState);
  for (const property of childProperties) {
    if (property in properties) {
      childState[property] = properties[property];
    }
  }
}
var AbstractStateMachine = class {
  transitionRoot(event, data) {
    if (this.parent) {
      this.parent.transitionRoot(event, data);
    } else {
      this.transition(event, data);
    }
  }
};
var _StateMachine = class _StateMachine extends AbstractStateMachine {
  constructor(defaultState, states, enterEach) {
    super();
    this.defaultState = defaultState;
    this.states = states;
    this.enterEach = enterEach;
    this.debug = Debug.create(true, "animation");
    this.state = defaultState;
    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);
  }
  // TODO: handle events which do not require data without requiring `undefined` to be passed as as parameter, while
  // also still requiring data to be passed to those events which do require it.
  transition(event, data) {
    const shouldTransitionSelf = this.transitionChild(event, data);
    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {
      return;
    }
    const currentState = this.state;
    const currentStateConfig = this.states[this.state];
    let destination = currentStateConfig[event];
    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;
    if (Array.isArray(destination)) {
      destination = destination.find((transition) => {
        if (!transition.guard)
          return true;
        const valid = transition.guard(data);
        if (!valid) {
          this.debug(`${debugPrefix} (guarded)`, transition.target, debugQuietColor);
        }
        return valid;
      });
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {
      this.debug(`${debugPrefix} (guarded)`, destination.target, debugQuietColor);
      return;
    }
    if (!destination) {
      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);
      return;
    }
    const destinationState = this.getDestinationState(destination);
    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;
    this.debug(`${debugPrefix} ${destinationState}`, debugColor);
    this.state = destinationState;
    if (typeof destination === "function") {
      destination(data);
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine)) {
      destination.action?.(data);
    }
    exitFn?.();
    this.enterEach?.(currentState, destinationState);
    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {
      this.states[destinationState].onEnter?.(currentState, data);
    }
  }
  transitionAsync(event, data) {
    setTimeout(() => {
      this.transition(event, data);
    }, 0);
  }
  is(value) {
    if (this.state === _StateMachine.child && this.childState) {
      return this.childState.is(value);
    }
    return this.state === value;
  }
  resetHierarchy() {
    this.debug(
      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,
      "color: green"
    );
    this.state = this.defaultState;
  }
  transitionChild(event, data) {
    if (this.state !== _StateMachine.child || !this.childState)
      return true;
    applyProperties(this, this.childState);
    this.childState.transition(event, data);
    if (!this.childState.is(_StateMachine.parent))
      return true;
    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);
    this.state = this.defaultState;
    this.states[this.state].onEnter?.();
    this.childState.resetHierarchy();
    return false;
  }
  getDestinationState(destination) {
    let state = this.state;
    if (typeof destination === "string") {
      state = destination;
    } else if (destination instanceof _StateMachine) {
      this.childState = destination;
      this.childState.parent = this;
      state = _StateMachine.child;
    } else if (typeof destination === "object") {
      if (destination.target instanceof _StateMachine) {
        this.childState = destination.target;
        this.childState.parent = this;
        state = _StateMachine.child;
      } else if (destination.target != null) {
        state = destination.target;
      }
    }
    return state;
  }
};
_StateMachine.child = "__child";
_StateMachine.parent = "__parent";
var StateMachine = _StateMachine;

// packages/ag-charts-community/src/chart/caption.ts
import { createId as createId2, isArray as isArray6, toPlainText as toPlainText2 } from "ag-charts-core";

// packages/ag-charts-community/src/util/proxy.ts
import { isArray as isArray5 } from "ag-charts-core";
function ProxyProperty(proxyPath, configMetadata) {
  const pathArray = isArray5(proxyPath) ? proxyPath : proxyPath.split(".");
  if (pathArray.length === 1) {
    const [property] = pathArray;
    return addTransformToInstanceProperty(
      (target, _, value) => target[property] = value,
      (target) => target[property],
      configMetadata
    );
  }
  return addTransformToInstanceProperty(
    (target, _, value) => setPath(target, pathArray, value),
    (target) => getPath(target, pathArray),
    configMetadata
  );
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);
}
function ActionOnSet(opts) {
  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== void 0) {
        oldValueFn?.call(target, oldValue);
      }
      if (newValue !== void 0) {
        newValueFn?.call(target, newValue);
      }
      changeValueFn?.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
function ObserveChanges(observerFn) {
  return addObserverToInstanceProperty(observerFn);
}

// packages/ag-charts-community/src/util/textWrapper.ts
var TextWrapper = class {
  static wrapText(text, options) {
    return this.wrapLines(text, options).join("\n");
  }
  static wrapLines(text, options) {
    const clippedResult = this.textWrap(text, options);
    if (options.overflow === "hide" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {
      return [];
    }
    return clippedResult;
  }
  static appendEllipsis(text) {
    return text.replace(/[.,]{1,5}$/, "") + TextUtils.EllipsisChar;
  }
  static truncateLine(text, measurer2, maxWidth, ellipsisForce) {
    const ellipsisWidth = measurer2.textWidth(TextUtils.EllipsisChar);
    let estimatedWidth = 0;
    let i = 0;
    for (; i < text.length; i++) {
      const charWidth = measurer2.textWidth(text.charAt(i));
      if (estimatedWidth + charWidth > maxWidth)
        break;
      estimatedWidth += charWidth;
    }
    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {
      return ellipsisForce ? text + TextUtils.EllipsisChar : text;
    }
    text = text.slice(0, i).trimEnd();
    while (text.length && measurer2.textWidth(text) + ellipsisWidth > maxWidth) {
      text = text.slice(0, -1).trimEnd();
    }
    return text + TextUtils.EllipsisChar;
  }
  static textWrap(text, options) {
    const lines = text.split(TextUtils.lineSplitter);
    const measurer2 = CachedTextMeasurerPool.getMeasurer(options);
    if (options.textWrap === "never") {
      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer2, options.maxWidth));
    }
    const result = [];
    const wrapHyphenate = options.textWrap === "hyphenate";
    const wrapOnSpace = options.textWrap == null || options.textWrap === "on-space";
    for (const untrimmedLine of lines) {
      let line = untrimmedLine.trimEnd();
      if (line === "") {
        result.push(line);
        continue;
      }
      let i = 0;
      let estimatedWidth = 0;
      let lastSpaceIndex = 0;
      while (i < line.length) {
        const char = line.charAt(i);
        estimatedWidth += measurer2.textWidth(char);
        if (char === " ") {
          lastSpaceIndex = i;
        }
        if (estimatedWidth > options.maxWidth) {
          if (i === 0)
            break;
          const actualWidth = measurer2.textWidth(line.slice(0, i + 1));
          if (actualWidth <= options.maxWidth) {
            estimatedWidth = actualWidth;
            i++;
            continue;
          }
          if (lastSpaceIndex) {
            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);
            const textWidth = measurer2.textWidth(nextWord);
            if (textWidth <= options.maxWidth) {
              result.push(line.slice(0, lastSpaceIndex).trimEnd());
              line = line.slice(lastSpaceIndex).trimStart();
              i = 0;
              estimatedWidth = 0;
              lastSpaceIndex = 0;
              continue;
            } else if (wrapOnSpace && textWidth > options.maxWidth) {
              result.push(
                line.slice(0, lastSpaceIndex).trimEnd(),
                this.truncateLine(
                  line.slice(lastSpaceIndex).trimStart(),
                  measurer2,
                  options.maxWidth,
                  true
                )
              );
            }
          } else if (wrapOnSpace) {
            result.push(this.truncateLine(line, measurer2, options.maxWidth, true));
          }
          if (wrapOnSpace) {
            line = "";
            break;
          }
          const postfix = wrapHyphenate ? "-" : "";
          let newLine = line.slice(0, i).trim();
          while (newLine.length && measurer2.textWidth(newLine + postfix) > options.maxWidth) {
            newLine = newLine.slice(0, -1).trimEnd();
          }
          result.push(newLine + postfix);
          if (!newLine.length) {
            line = "";
            break;
          }
          line = line.slice(newLine.length).trimStart();
          i = -1;
          estimatedWidth = 0;
          lastSpaceIndex = 0;
        }
        i++;
      }
      if (line) {
        result.push(line);
      }
    }
    this.avoidOrphans(result, measurer2, options);
    return this.clipLines(result, measurer2, options);
  }
  static getWordAt(text, position) {
    const nextSpaceIndex = text.indexOf(" ", position);
    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);
  }
  static clipLines(lines, measurer2, options) {
    if (!options.maxHeight) {
      return lines;
    }
    const { height: height2, lineMetrics } = measurer2.measureLines(lines);
    if (height2 <= options.maxHeight) {
      return lines;
    }
    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {
      const { lineHeight } = lineMetrics[i];
      cumulativeHeight += lineHeight;
      if (cumulativeHeight > options.maxHeight) {
        if (options.overflow === "hide") {
          return [];
        }
        const clippedResults = lines.slice(0, i || 1);
        const lastLine = clippedResults.pop();
        return clippedResults.concat(this.truncateLine(lastLine, measurer2, options.maxWidth, true));
      }
    }
    return lines;
  }
  static avoidOrphans(lines, measurer2, options) {
    if (options.avoidOrphans === false || lines.length < 2)
      return;
    const { length } = lines;
    const lastLine = lines[length - 1];
    const beforeLast = lines[length - 2];
    if (beforeLast.length < lastLine.length)
      return;
    const lastSpaceIndex = beforeLast.lastIndexOf(" ");
    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(" ") || lastLine.includes(" "))
      return;
    const lastWord = beforeLast.slice(lastSpaceIndex + 1);
    if (measurer2.textWidth(lastLine + lastWord) <= options.maxWidth) {
      lines[length - 2] = beforeLast.slice(0, lastSpaceIndex);
      lines[length - 1] = lastWord + " " + lastLine;
    }
  }
};

// packages/ag-charts-community/src/chart/caption.ts
var Caption = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.id = createId2(this);
    this.node = new RotatableText({ zIndex: 1 }).setProperties({
      textAlign: "center",
      pointerEvents: 1 /* None */
    });
    this.enabled = false;
    this.textAlign = "center";
    this.fontSize = 10 /* SMALLER */;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
    this.padding = 0;
    this.layoutStyle = "block";
    this.truncated = false;
  }
  registerInteraction(moduleCtx, where) {
    return moduleCtx.eventsHub.on("layout:complete", () => this.updateA11yText(moduleCtx, where));
  }
  computeTextWrap(containerWidth, containerHeight) {
    const { text, padding: padding2, wrapping } = this;
    if (isArray6(text))
      return;
    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding2 * 2;
    const maxHeight = this.maxHeight ?? containerHeight - padding2 * 2;
    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
      this.node.text = text;
      return;
    }
    const wrappedText = TextWrapper.wrapText(text ?? "", { maxWidth, maxHeight, font: this, textWrap: wrapping });
    this.node.text = wrappedText;
    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);
  }
  updateA11yText(moduleCtx, where) {
    const { proxyInteractionService } = moduleCtx;
    if (this.enabled && this.text) {
      const bbox = Transformable.toCanvas(this.node);
      if (bbox) {
        const { id: domManagerId } = this;
        this.proxyText ?? (this.proxyText = proxyInteractionService.createProxyElement({ type: "text", domManagerId, where }));
        this.proxyText.textContent = toPlainText2(this.text);
        this.proxyText.setBounds(bbox);
        this.proxyText.addListener("mousemove", (ev) => this.handleMouseMove(moduleCtx, ev));
        this.proxyText.addListener("mouseleave", (ev) => this.handleMouseLeave(moduleCtx, ev));
      }
    } else {
      this.proxyText?.destroy();
      this.proxyText = void 0;
    }
  }
  handleMouseMove(moduleCtx, event) {
    if (event != null && this.enabled && this.truncated) {
      const { x, y } = Transformable.toCanvas(this.node);
      const canvasX = event.sourceEvent.offsetX + x;
      const canvasY = event.sourceEvent.offsetY + y;
      moduleCtx.tooltipManager.updateTooltip(this.id, { canvasX, canvasY, showArrow: false }, [
        { type: "structured", title: toPlainText2(this.text) }
      ]);
    }
  }
  handleMouseLeave(moduleCtx, _event) {
    moduleCtx.tooltipManager.removeTooltip(this.id);
  }
};
Caption.SMALL_PADDING = 10;
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "visible")
], Caption.prototype, "enabled", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "text", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "textAlign", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontStyle", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontWeight", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontSize", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontFamily", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "fill")
], Caption.prototype, "color", 2);
__decorateClass([
  Property
], Caption.prototype, "spacing", 2);
__decorateClass([
  Property
], Caption.prototype, "maxWidth", 2);
__decorateClass([
  Property
], Caption.prototype, "maxHeight", 2);
__decorateClass([
  Property
], Caption.prototype, "wrapping", 2);
__decorateClass([
  Property
], Caption.prototype, "padding", 2);
__decorateClass([
  Property
], Caption.prototype, "layoutStyle", 2);

// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {
  ChartAxisDirection2["X"] = "x";
  ChartAxisDirection2["Y"] = "y";
  ChartAxisDirection2["Angle"] = "angle";
  ChartAxisDirection2["Radius"] = "radius";
  return ChartAxisDirection2;
})(ChartAxisDirection || {});

// packages/ag-charts-community/src/chart/label.ts
import { isPlainObject as isPlainObject5 } from "ag-charts-core";

// packages/ag-charts-community/src/util/timeFormat.ts
var CONSTANTS = {
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
function dayOfYear(date5, startOfYear = new Date(date5.getFullYear(), 0, 1)) {
  const startOffset = date5.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date5.getTime() - startOfYear.getTime() + startOffset * 6e4;
  const timeOneDay = 36e5 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date5, startDay) {
  const startOfYear = new Date(date5.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date5.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date5) {
    return Math.floor(dayOfYear(date5, startOffset) / 7) + 1;
  }
  return 0;
}
var SUNDAY = 0;
var MONDAY = 1;
var THURSDAY = 4;
function isoWeekOfYear(date5, year = date5.getFullYear()) {
  const firstOfYear = new Date(year, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date5) {
    return Math.floor(dayOfYear(date5, startOffset) / 7) + 1;
  }
  return isoWeekOfYear(date5, year - 1);
}
function timezone(date5) {
  const offset = date5.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset);
  const sign = offset > 0 ? "-" : "+";
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, "0")}${pad(Math.floor(unsignedOffset % 60), 2, "0")}`;
}
var FORMATTERS = {
  a: (d) => CONSTANTS.shortDays[d.getDay()],
  A: (d) => CONSTANTS.days[d.getDay()],
  b: (d) => CONSTANTS.shortMonths[d.getMonth()],
  B: (d) => CONSTANTS.months[d.getMonth()],
  c: "%x, %X",
  d: (d, p) => pad(d.getDate(), 2, p ?? "0"),
  e: "%_d",
  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? "0"),
  H: (d, p) => pad(d.getHours(), 2, p ?? "0"),
  I: (d, p) => {
    const hours = d.getHours() % 12;
    return hours === 0 ? "12" : pad(hours, 2, p ?? "0");
  },
  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? "0"),
  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? "0"),
  M: (d, p) => pad(d.getMinutes(), 2, p ?? "0"),
  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? "0"),
  p: (d) => d.getHours() < 12 ? "AM" : "PM",
  Q: (d) => String(d.getTime()),
  s: (d) => String(Math.floor(d.getTime() / 1e3)),
  S: (d, p) => pad(d.getSeconds(), 2, p ?? "0"),
  u: (d) => {
    let day = d.getDay();
    if (day < 1)
      day += 7;
    return String(day % 7);
  },
  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? "0"),
  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? "0"),
  w: (d, p) => pad(d.getDay(), 2, p ?? "0"),
  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? "0"),
  x: "%-m/%-d/%Y",
  X: "%-I:%M:%S %p",
  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? "0"),
  Y: (d, p) => pad(d.getFullYear(), 4, p ?? "0"),
  Z: (d) => timezone(d),
  "%": () => "%"
};
var PADS = {
  _: " ",
  "0": "0",
  "-": ""
};
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildDateFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf("%");
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0)
      break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === "function") {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === "string") {
      const formatter2 = buildDateFormatter(maybeFormatter);
      formatParts.push([formatter2, maybePad]);
    } else {
      formatParts.push(`${maybePad ?? ""}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return (dateTime) => {
    const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
    return formatParts.map((c) => typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
  };
}

// packages/ag-charts-community/src/chart/formatter/formatManager.ts
import { Logger as Logger14, createNumberFormatter as createNumberFormatter2, isPlainObject as isPlainObject4, parseNumberFormat as parseNumberFormat2 } from "ag-charts-core";

// packages/ag-charts-community/src/util/format.util.ts
var percentFormatter = new Intl.NumberFormat("en-US", { style: "percent" });
function formatValue(value, maximumFractionDigits = 2) {
  if (typeof value === "number") {
    return formatNumber(value, maximumFractionDigits);
  }
  return typeof value === "string" ? value : String(value ?? "");
}
function formatPercent(value) {
  return percentFormatter.format(value);
}
var numberFormatters = (/* @__PURE__ */ new Map()).set(
  2,
  new Intl.NumberFormat("en-US", { maximumFractionDigits: 2, useGrouping: false })
);
function formatNumber(value, maximumFractionDigits) {
  let formatter2 = numberFormatters.get(maximumFractionDigits);
  if (!formatter2) {
    formatter2 = new Intl.NumberFormat("en-US", { maximumFractionDigits, useGrouping: false });
    numberFormatters.set(maximumFractionDigits, formatter2);
  }
  return formatter2.format(value);
}

// packages/ag-charts-community/src/util/listeners.ts
import { Logger as Logger13 } from "ag-charts-core";
var Listeners = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Map();
  }
  addListener(eventType, handler) {
    const record = { symbol: Symbol(eventType), handler };
    if (this.registeredListeners.has(eventType)) {
      this.registeredListeners.get(eventType).push(record);
    } else {
      this.registeredListeners.set(eventType, [record]);
    }
    return () => this.removeListener(record.symbol);
  }
  removeListener(eventSymbol) {
    for (const [type, listeners] of this.registeredListeners.entries()) {
      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);
      if (matchIndex >= 0) {
        listeners.splice(matchIndex, 1);
        if (listeners.length === 0) {
          this.registeredListeners.delete(type);
        }
        break;
      }
    }
  }
  dispatch(eventType, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        listener.handler(...params);
      } catch (e) {
        Logger13.errorOnce(e);
      }
    }
  }
  getListenersByType(eventType) {
    return this.registeredListeners.get(eventType) ?? [];
  }
  destroy() {
    this.registeredListeners.clear();
  }
};

// packages/ag-charts-community/src/chart/axis/timeFormatUtil.ts
var defaultTimeFormats = {
  millisecond: "%H:%M:%S.%L",
  second: "%H:%M:%S",
  minute: "%H:%M",
  hour: "%H:%M",
  day: "%e",
  month: "%b",
  year: "%Y"
};
var hardCodedTimeFormats = {
  millisecond: "%Y %b %e %H:%M:%S.%L",
  second: "%Y %b %e %H:%M:%S",
  minute: "%Y %b %e %H:%M",
  hour: "%Y %b %e %H:%M",
  day: "%Y %b %e",
  month: "%Y %b",
  year: "%Y"
};
var FORMAT_ORDERS = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5,
  millisecond: 6
};
var MILLISECOND_FORMAT = /%[-_0]?L/;
var SECOND_FORMAT = /%[-_0]?S/;
var MINUTE_FORMAT = /%[-_0]?M/;
var HOUR_FORMAT = /%[-_0]?[HI]/;
var DAY_FORMAT = /^%[-_0]?[de]$/;
var MONTH_FORMAT = /^%[-_0]?[Bbm]$/;
var YEAR_FORMAT = /^%[-_0]?[Yy]$/;
function deriveTimeSpecifier(format, unit, truncateDate) {
  if (typeof format === "string")
    return format;
  format ?? (format = defaultTimeFormats);
  const {
    millisecond = defaultTimeFormats.millisecond,
    second = defaultTimeFormats.second,
    minute = defaultTimeFormats.minute,
    hour = defaultTimeFormats.hour,
    day = defaultTimeFormats.day,
    month = defaultTimeFormats.month,
    year = defaultTimeFormats.year
  } = format;
  const formatOrder = FORMAT_ORDERS[unit];
  const hardcodedTimeFormat = hardCodedTimeFormats[unit];
  const truncationOrder = truncateDate ? FORMAT_ORDERS[truncateDate] : -1;
  if (truncationOrder < FORMAT_ORDERS.year && formatOrder >= FORMAT_ORDERS.year && !YEAR_FORMAT.test(year) || truncationOrder < FORMAT_ORDERS.month && formatOrder >= FORMAT_ORDERS.month && !MONTH_FORMAT.test(month) || truncationOrder < FORMAT_ORDERS.day && formatOrder >= FORMAT_ORDERS.day && !DAY_FORMAT.test(day)) {
    return hardcodedTimeFormat;
  }
  let timeFormat;
  switch (unit) {
    case "year":
      return year;
    case "month":
      return truncationOrder < FORMAT_ORDERS.year ? `${month} ${year}` : month;
    case "day":
      return truncationOrder < FORMAT_ORDERS.year ? `${month} ${day} ${year}` : `${month} ${day}`;
    case "hour":
      timeFormat = hour;
      break;
    case "minute":
      timeFormat = minute;
      break;
    case "second":
      timeFormat = second;
      break;
    case "millisecond":
      timeFormat = millisecond;
      break;
    default:
      return hardcodedTimeFormat;
  }
  if (formatOrder >= FORMAT_ORDERS.hour && !HOUR_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.minute && !MINUTE_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.second && !SECOND_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.millisecond && !MILLISECOND_FORMAT.test(timeFormat)) {
    return hardcodedTimeFormat;
  }
  let dateFormat;
  if (truncationOrder < FORMAT_ORDERS.year) {
    dateFormat = `${month} ${day} ${year}`;
  } else if (truncationOrder < FORMAT_ORDERS.month) {
    dateFormat = `${month} ${day}`;
  }
  return dateFormat ? `${timeFormat} ${dateFormat}` : timeFormat;
}

// packages/ag-charts-community/src/chart/formatter/formatManager.ts
var FormatManager = class _FormatManager extends Listeners {
  constructor() {
    super(...arguments);
    this.formats = /* @__PURE__ */ new Map();
    this.dateFormatter = simpleMemorize2(
      (propertyFormatter, specifier, unit, style, truncateDate) => {
        const mergedFormatter = _FormatManager.mergeSpecifiers(propertyFormatter, specifier) ?? defaultTimeFormats;
        return _FormatManager.getFormatter("date", mergedFormatter, unit, style, { truncateDate });
      }
    );
    this.formatter = void 0;
  }
  static mergeSpecifiers(...specifiers) {
    let out;
    for (const specifier of specifiers) {
      if (typeof specifier === "string") {
        out = specifier;
      } else if (isPlainObject4(specifier)) {
        out = isPlainObject4(out) ? { ...out, ...specifier } : specifier;
      }
    }
    return out;
  }
  static getFormatter(type, specifier, unit, style = "long", { truncateDate } = {}) {
    if (isPlainObject4(specifier)) {
      if (type !== "date") {
        Logger14.warn("Date formatter configuration is not supported for non-date types.");
        return;
      }
      unit ?? (unit = "millisecond");
      const fullFormat = style === "component" ? specifier?.[unit] ?? defaultTimeFormats[unit] : deriveTimeSpecifier(specifier, unit, truncateDate);
      return buildDateFormatter(fullFormat);
    }
    switch (type) {
      case "number": {
        const options = parseNumberFormat2(specifier);
        if (options == null)
          return;
        return createNumberFormatter2(options);
      }
      case "date":
        return buildDateFormatter(specifier);
      case "category":
        return (value) => specifier.replace("%s", String(value));
    }
  }
  setFormatter(formatter2) {
    if (this.formatter !== formatter2) {
      this.formatter = formatter2;
      this.formats.clear();
      this.dateFormatter.reset();
      this.dispatch("format-changed");
    }
  }
  format(formatInContext, params, { specifier, truncateDate } = {}) {
    if (params.value == null)
      return;
    const { formatter: formatter2 } = this;
    if (formatter2 == null)
      return;
    if (typeof formatter2 === "function") {
      const value = formatInContext(formatter2, params);
      return value != null ? String(value) : void 0;
    }
    const propertyFormatter = formatter2[params.property];
    if (propertyFormatter == null)
      return;
    if (typeof propertyFormatter === "function") {
      const value = formatInContext(propertyFormatter, params);
      return value != null ? String(value) : void 0;
    } else if (params.type === "date") {
      const { unit, style } = params;
      const dateFormatter = this.dateFormatter(propertyFormatter, specifier, unit, style, truncateDate);
      return dateFormatter?.(params.value);
    }
    const valueSpecifier = specifier ?? propertyFormatter;
    if (typeof valueSpecifier !== "string")
      return;
    let valueFormatter = this.formats.get(valueSpecifier);
    if (valueFormatter == null) {
      valueFormatter = _FormatManager.getFormatter(params.type, valueSpecifier);
      this.formats.set(valueSpecifier, valueFormatter);
    }
    return valueFormatter?.(params.value, params.type === "number" ? params.fractionDigits : void 0);
  }
  defaultFormat(params, { specifier, truncateDate } = {}) {
    const { formatter: formatter2 } = this;
    const propertyFormatter = typeof formatter2 === "function" ? void 0 : formatter2?.[params.property];
    switch (params.type) {
      case "date": {
        const { unit, style } = params;
        const propertySpecifier = propertyFormatter != null && typeof propertyFormatter !== "function" ? propertyFormatter : void 0;
        const dateFormatter = this.dateFormatter(propertySpecifier, specifier, unit, style, truncateDate);
        return dateFormatter?.(params.value) ?? String(params.value);
      }
      case "number":
        return formatValue(params.value, params.fractionDigits);
      case "category":
        if (Array.isArray(params.value)) {
          return params.value.join(" - ");
        } else if (typeof params.value === "string") {
          return params.value;
        } else if (typeof params.value === "number") {
          return formatValue(params.value);
        } else {
          return String(params.value);
        }
    }
  }
};

// packages/ag-charts-community/src/chart/label.ts
var LabelBorder = class {
  constructor() {
    this.enabled = true;
  }
};
__decorateClass([
  Property
], LabelBorder.prototype, "enabled", 2);
__decorateClass([
  Property
], LabelBorder.prototype, "stroke", 2);
__decorateClass([
  Property
], LabelBorder.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LabelBorder.prototype, "strokeOpacity", 2);
var Label = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.border = new LabelBorder();
    this._cachedFormatter = void 0;
  }
  formatValue(formatWithContext, type, value, params) {
    const { formatter: formatter2, format } = this;
    let result;
    if (formatter2 != null) {
      result ?? (result = formatWithContext(formatter2, params));
    }
    if (format != null) {
      let cachedFormatter = this._cachedFormatter;
      if (cachedFormatter == null || cachedFormatter.type !== type || cachedFormatter.format !== format) {
        cachedFormatter = {
          type,
          format,
          formatter: FormatManager.getFormatter(type, format)
        };
        this._cachedFormatter = cachedFormatter;
      }
      result ?? (result = cachedFormatter.formatter?.(value));
    }
    return result != null ? String(result) : void 0;
  }
};
__decorateClass([
  Property
], Label.prototype, "enabled", 2);
__decorateClass([
  Property
], Label.prototype, "border", 2);
__decorateClass([
  Property
], Label.prototype, "color", 2);
__decorateClass([
  Property
], Label.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], Label.prototype, "fill", 2);
__decorateClass([
  Property
], Label.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], Label.prototype, "fontStyle", 2);
__decorateClass([
  Property
], Label.prototype, "fontWeight", 2);
__decorateClass([
  Property
], Label.prototype, "fontSize", 2);
__decorateClass([
  Property
], Label.prototype, "fontFamily", 2);
__decorateClass([
  Property
], Label.prototype, "formatter", 2);
__decorateClass([
  Property
], Label.prototype, "format", 2);
__decorateClass([
  Property
], Label.prototype, "padding", 2);
__decorateClass([
  Property
], Label.prototype, "itemStyler", 2);
function expandLabelPadding(label) {
  const { enabled: borderEnabled = false, stroke: borderStroke } = label?.border ?? {};
  const hasBoxing = label?.fill != null || borderEnabled && borderStroke != null;
  const padding2 = hasBoxing ? label?.padding : null;
  if (padding2 == null) {
    return { bottom: 0, left: 0, right: 0, top: 0 };
  } else if (typeof padding2 === "number") {
    return { bottom: padding2, left: padding2, right: padding2, top: padding2 };
  } else {
    const { bottom = 0, left = 0, right = 0, top = 0 } = padding2;
    return { bottom, left, right, top };
  }
}
function calculateLabelRotation(rotation, parallel, regularFlipRotation = 0, parallelFlipRotation = 0) {
  const configuredRotation = normalizeAngle360FromDegrees(rotation);
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };
}
function getLabelSpacing(minSpacing, rotated) {
  if (minSpacing != null) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
  if (parallel && !labelRotation) {
    return sideFlag * parallelFlipFlag === -1 ? "top" : "bottom";
  }
  return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return "end";
      }
    } else {
      return "center";
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return "end";
  }
  return "start";
}
function labelSpecifier(format, timeInterval3) {
  if (format == null)
    return;
  if (typeof format === "string") {
    return format;
  } else if (isPlainObject5(format) && timeInterval3 != null) {
    return format[intervalUnit(timeInterval3)];
  }
}
function timeIntervalMaxLabelSize(label, primaryLabel, domain, timeInterval3, textMeasurer) {
  const specifier = labelSpecifier(label.format, timeInterval3) ?? (typeof label.format === "string" ? label.format : void 0);
  if (specifier == null)
    return { width: 0, height: 0 };
  const labelFormatter = buildDateFormatter(specifier);
  const hierarchy = timeInterval3 ? intervalHierarchy(timeInterval3) : void 0;
  const primarySpecifier = labelSpecifier(primaryLabel?.format, hierarchy);
  const primaryLabelFormatter = primarySpecifier ? buildDateFormatter(primarySpecifier) : labelFormatter;
  const d0 = new Date(domain[0]);
  const d1 = new Date(domain[domain.length - 1]);
  const hierarchyRange = hierarchy ? intervalRange(hierarchy, new Date(domain[0]), new Date(domain[domain.length - 1]), {
    extend: true
  }) : void 0;
  let maxWidth = 0;
  let maxHeight = 0;
  if (labelFormatter != null) {
    const padding2 = expandLabelPadding(label);
    const xPadding = padding2.left + padding2.right;
    const yPadding = padding2.top + padding2.bottom;
    let l0;
    let l1;
    if (hierarchyRange != null && hierarchyRange.length > 1) {
      l0 = hierarchyRange[0];
      l1 = hierarchyRange[1];
    } else {
      l0 = d0;
      l1 = d1;
    }
    const labelRange = intervalRange(timeInterval3, l0, l1, { limit: 50 });
    for (const date5 of labelRange) {
      const text = labelFormatter(date5);
      const { width: width2, height: height2 } = textMeasurer.measureLines(text);
      maxWidth = Math.max(maxWidth, width2 + xPadding);
      maxHeight = Math.max(maxHeight, height2 + yPadding);
    }
  }
  if (primaryLabelFormatter != null && hierarchyRange != null) {
    const padding2 = expandLabelPadding(primaryLabel);
    const xPadding = padding2.left + padding2.right;
    const yPadding = padding2.top + padding2.bottom;
    for (const date5 of hierarchyRange) {
      const text = primaryLabelFormatter(date5);
      const { width: width2, height: height2 } = textMeasurer.measureLines(text);
      maxWidth = Math.max(maxWidth, width2 + xPadding);
      maxHeight = Math.max(maxHeight, height2 + yPadding);
    }
  }
  return {
    width: Math.ceil(maxWidth),
    height: Math.ceil(maxHeight)
  };
}
function createLabelData(tickData, labelX, labelMatrix, textMeasurer, label) {
  const padding2 = expandLabelPadding(label);
  const xPadding = padding2.left + padding2.right;
  const yPadding = padding2.top + padding2.bottom;
  const labelData = [];
  for (const { tickLabel: text, translation } of tickData) {
    if (!text)
      continue;
    const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translation, 0, 0));
    const metrics = textMeasurer.measureLines(text);
    const width2 = metrics.width + xPadding;
    const height2 = metrics.height + yPadding;
    labelData.push({
      point: { x, y },
      label: { text, width: width2, height: height2 }
    });
  }
  return labelData;
}
function createFixedLabelData({ width: width2, height: height2, spacing }, labelX, labelMatrix) {
  const labelData = [];
  for (const translationY of [0, spacing]) {
    const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translationY, 0, 0));
    labelData.push({
      point: { x, y },
      label: { text: void 0, width: width2, height: height2 }
    });
  }
  return labelData;
}

// packages/ag-charts-community/src/chart/axis/axis.ts
import { CleanupRegistry, WeakCache, createId as createId4 } from "ag-charts-core";

// packages/ag-charts-community/src/module/moduleMap.ts
import { isString as isString4 } from "ag-charts-core";
var ModuleMap = class {
  constructor() {
    this.moduleMap = /* @__PURE__ */ new Map();
  }
  *modules() {
    for (const m of this.moduleMap.values()) {
      yield m.moduleInstance;
    }
  }
  addModule(module, moduleFactory) {
    if (this.moduleMap.has(module.optionsKey)) {
      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);
    }
    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });
  }
  removeModule(module) {
    const moduleKey = isString4(module) ? module : module.optionsKey;
    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    this.moduleMap.delete(moduleKey);
  }
  getModule(module) {
    return this.moduleMap.get(isString4(module) ? module : module.optionsKey)?.moduleInstance;
  }
  isEnabled(module) {
    return this.moduleMap.has(isString4(module) ? module : module.optionsKey);
  }
  mapModules(callback5) {
    return Array.from(this.moduleMap.values(), (m, i) => callback5(m.moduleInstance, i));
  }
  destroy() {
    for (const moduleKey of this.moduleMap.keys()) {
      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    }
    this.moduleMap.clear();
  }
};

// packages/ag-charts-community/src/util/callbackCache.ts
import { Logger as Logger15 } from "ag-charts-core";
function needsContext(caller, _params) {
  return "context" in caller;
}
function maybeSetContext(caller, params) {
  if (caller != null && needsContext(caller, params)) {
    if (params[0] != null && typeof params[0] === "object" && params[0].context === void 0) {
      params[0].context = caller.context;
      return true;
    }
  }
  return false;
}
function callWithContext(callers, fn, ...params) {
  if (Array.isArray(callers)) {
    for (const caller of callers) {
      if (maybeSetContext(caller, params)) {
        break;
      }
    }
  } else {
    maybeSetContext(callers, params);
  }
  return fn(...params);
}
var CallbackCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
  call(callers, fn, ...params) {
    let serialisedParams;
    let paramCache = this.cache.get(fn);
    try {
      serialisedParams = JSON.stringify(params);
    } catch {
      return this.invoke(callers, fn, paramCache, void 0, ...params);
    }
    if (paramCache == null) {
      paramCache = /* @__PURE__ */ new Map();
      this.cache.set(fn, paramCache);
    }
    if (!paramCache.has(serialisedParams)) {
      return this.invoke(callers, fn, paramCache, serialisedParams, ...params);
    }
    return paramCache.get(serialisedParams);
  }
  invoke(callers, fn, paramCache, serialisedParams, ...params) {
    try {
      const result = callWithContext(callers, fn, ...params);
      if (paramCache && serialisedParams != null) {
        paramCache.set(serialisedParams, result);
      }
      return result;
    } catch (e) {
      Logger15.warnOnce(`User callback errored, ignoring`, e);
      return;
    }
  }
  invalidateCache() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
import { createId as createId3 } from "ag-charts-core";

// packages/ag-charts-community/src/scene/shape/range.ts
var Range = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.startLine = false;
    this.endLine = false;
    this.horizontal = false;
    this.strokeWidth = 1;
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    let { x1, y1, x2, y2 } = this;
    x1 = this.align(x1);
    y1 = this.align(y1);
    x2 = this.align(x2);
    y2 = this.align(y2);
    const { fill, horizontal } = this;
    const { globalAlpha } = ctx;
    if (fill != null) {
      this.applyFillAndAlpha(ctx);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x1, y2);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = globalAlpha;
    }
    const { stroke: stroke2, strokeWidth, startLine, endLine } = this;
    const strokeActive = !!((startLine || endLine) && stroke2 && strokeWidth);
    if (strokeActive) {
      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash([...lineDash]);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.beginPath();
      if (startLine) {
        ctx.moveTo(x1, y1);
        if (horizontal) {
          ctx.lineTo(x1, y2);
        } else {
          ctx.lineTo(x2, y1);
        }
      }
      if (endLine) {
        ctx.moveTo(x2, y2);
        if (horizontal) {
          ctx.lineTo(x2, y1);
        } else {
          ctx.lineTo(x1, y2);
        }
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
};
Range.className = "Range";
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "y2", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "startLine", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "endLine", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "horizontal", 2);

// packages/ag-charts-community/src/chart/rangeAlignment.ts
function rangeAlignment(start2, end2) {
  const startValue = start2?.valueOf();
  const endValue = end2?.valueOf();
  if (typeof startValue !== "number" || typeof endValue !== "number")
    return [void 0, void 0];
  return startValue < endValue ? [0 /* Leading */, 1 /* Trailing */] : [1 /* Trailing */, 0 /* Leading */];
}

// packages/ag-charts-community/src/util/value.ts
import { isFiniteNumber, isString as isString5, isValidDate } from "ag-charts-core";
function isStringObject(value) {
  return value != null && Object.hasOwn(value, "toString") && isString5(value.toString());
}
function isNumberObject(value) {
  return value != null && Object.hasOwn(value, "valueOf") && isFiniteNumber(value.valueOf());
}
function isContinuous(value) {
  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);
}
function checkDatum(value, isContinuousScale) {
  return value != null && (!isContinuousScale || isContinuous(value));
}
function transformIntegratedCategoryValue(value) {
  if (isStringObject(value) && Object.hasOwn(value, "id")) {
    return value.id;
  }
  return value;
}

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
function getCrossLineValue(crossLine) {
  switch (crossLine.type) {
    case "line":
      return crossLine.value;
    case "range":
      return crossLine.range;
  }
}
function validateCrossLineValue(crossLine, scale2) {
  const value = getCrossLineValue(crossLine);
  if (value == null) {
    return false;
  }
  const isContinuous2 = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
  const validValue = (val) => checkDatum(val, isContinuous2) && !isNaN(scale2.convert(val, { clamp: true }));
  if (crossLine.type === "range") {
    const [start2, end2] = value;
    return validValue(start2) && validValue(end2);
  } else {
    return validValue(value);
  }
}

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var horizontalLineAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var verticalLineAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: -1, labelV: -1 },
  "inside-top-right": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var horizontalRangeAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var verticalRangeAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: -1, labelV: -1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var CartesianCrossLineLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fontSize = 14 /* LARGE */;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
  }
};
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "text", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "padding", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "color", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "position", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "rotation", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "parallel", 2);
var CartesianCrossLine = class extends BaseProperties {
  constructor() {
    super();
    this.id = createId3(this);
    this.defaultColorRange = [];
    this.fill = "#c16068";
    this.label = new CartesianCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.position = "top";
    this.rangeGroup = new Group({ name: this.id });
    this.lineGroup = new Group({ name: this.id });
    this.labelGroup = new Group({ name: this.id });
    this.crossLineRange = new Range();
    this.crossLineLabel = new TransformableText();
    this.data = void 0;
    this.startLine = false;
    this.endLine = false;
    this._isRange = void 0;
    this.lineGroup.append(this.crossLineRange);
    this.labelGroup.append(this.crossLineLabel);
    this.crossLineRange.pointerEvents = 1 /* None */;
  }
  get defaultLabelPosition() {
    return "top";
  }
  update(visible) {
    const { enabled, type, data, scale: scale2 } = this;
    if (!scale2 || !enabled || !visible || !validateCrossLineValue(this, scale2) || data == null) {
      this.rangeGroup.visible = false;
      this.lineGroup.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.rangeGroup.visible = visible;
    this.lineGroup.visible = visible;
    this.labelGroup.visible = visible;
    this.updateNodes();
    const isRange = type === "range";
    if (isRange !== this._isRange) {
      if (isRange) {
        this.rangeGroup.appendChild(this.crossLineRange);
      } else {
        this.lineGroup.appendChild(this.crossLineRange);
      }
    }
    this._isRange = isRange;
  }
  calculateLayout(visible) {
    this.data = void 0;
    if (!visible)
      return;
    const { type, range: range3, value, scale: scale2, clippedRange, strokeWidth = 0 } = this;
    if (!scale2)
      return;
    const bandwidth = scale2.bandwidth ?? 0;
    const step = scale2.step ?? 0;
    const rangePadding = scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0;
    let [clippedRange0, clippedRange1] = findMinMax(clippedRange);
    clippedRange0 -= bandwidth;
    clippedRange1 += bandwidth;
    let yStart;
    let yEnd;
    let clampedYStart;
    let clampedYEnd;
    if (type === "line") {
      const offset = bandwidth / 2;
      yStart = scale2.convert(value) + offset;
      yEnd = NaN;
      clampedYStart = scale2.convert(value, { clamp: true }) + offset;
      clampedYEnd = NaN;
      if (clampedYStart >= clippedRange1 || clampedYStart <= clippedRange0) {
        return;
      }
    } else if (range3) {
      const [r0, r1] = range3;
      const [startAlignment, endAlignment] = rangeAlignment(r0, r1);
      yStart = scale2.convert(r0, { alignment: startAlignment });
      yEnd = scale2.convert(r1, { alignment: endAlignment });
      clampedYStart = scale2.convert(r0, { clamp: true, alignment: startAlignment });
      clampedYEnd = scale2.convert(r1, { clamp: true, alignment: endAlignment });
      if (clampedYStart > clampedYEnd) {
        [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];
        [yStart, yEnd] = [yEnd, yStart];
      }
      if (clampedYStart >= clippedRange1 || clampedYEnd <= clippedRange0) {
        return;
      }
      if (Number.isFinite(yStart)) {
        clampedYStart -= rangePadding;
      }
      if (Number.isFinite(yEnd)) {
        yEnd += bandwidth;
        clampedYEnd += bandwidth + rangePadding;
      }
    } else {
      return;
    }
    clampedYStart = clampArray(clampedYStart, clippedRange);
    clampedYEnd = clampArray(clampedYEnd, clippedRange);
    if (yStart - rangePadding >= clampedYStart)
      yStart -= rangePadding;
    if (yEnd + rangePadding <= clampedYEnd)
      yEnd += rangePadding;
    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + rangePadding;
    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - rangePadding && yEnd <= clampedYEnd;
    this.data = [clampedYStart, clampedYEnd];
    if (this.label.enabled === false || !this.label.text)
      return;
  }
  updateNodes() {
    const { position, data: [r0, r1] = [0, 0], gridLength } = this;
    const dr = Number.isFinite(r1) ? r1 - r0 : 0;
    let bounds;
    switch (position) {
      case "top":
      case "bottom":
        bounds = new BBox(r0, position === "top" ? 0 : -gridLength, dr, gridLength);
        break;
      case "left":
      case "right":
        bounds = new BBox(position === "left" ? 0 : -gridLength, r0, gridLength, dr);
    }
    this.updateRangeNode(bounds);
    const { label } = this;
    if (label.enabled !== false && label.text) {
      this.updateLabel();
      this.positionLabel(bounds);
    }
  }
  updateRangeNode(bounds) {
    const {
      type,
      position,
      crossLineRange,
      startLine,
      endLine,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash
    } = this;
    crossLineRange.x1 = bounds.x;
    crossLineRange.x2 = bounds.x + bounds.width;
    crossLineRange.y1 = bounds.y;
    crossLineRange.y2 = bounds.y + bounds.height;
    crossLineRange.horizontal = position === "top" || position === "bottom";
    crossLineRange.startLine = startLine;
    crossLineRange.endLine = endLine;
    crossLineRange.fill = type === "range" ? fill : void 0;
    crossLineRange.fillOpacity = fillOpacity ?? 1;
    crossLineRange.stroke = stroke2;
    crossLineRange.strokeWidth = strokeWidth ?? 1;
    crossLineRange.strokeOpacity = strokeOpacity ?? 1;
    crossLineRange.lineDash = lineDash;
  }
  updateLabel() {
    const { crossLineLabel, label } = this;
    if (!label.text)
      return;
    crossLineLabel.fontStyle = label.fontStyle;
    crossLineLabel.fontWeight = label.fontWeight;
    crossLineLabel.fontSize = label.fontSize;
    crossLineLabel.fontFamily = label.fontFamily;
    crossLineLabel.fill = label.color;
    crossLineLabel.text = label.text;
  }
  get anchor() {
    const horizontal = this.position === "left" || this.position === "right";
    const range3 = this.type === "range";
    const { position = this.defaultLabelPosition } = this.label;
    if (range3) {
      const anchors = horizontal ? horizontalRangeAnchors : verticalRangeAnchors;
      return anchors[position];
    } else {
      const anchors = horizontal ? horizontalLineAnchors : verticalLineAnchors;
      return anchors[position];
    }
  }
  positionLabel(bounds) {
    const { crossLineLabel, label, anchor } = this;
    crossLineLabel.rotation = toRadians(label.rotation ?? 0);
    crossLineLabel.textBaseline = "middle";
    crossLineLabel.textAlign = "center";
    const bbox = crossLineLabel.getBBox();
    if (!bbox)
      return;
    const { width: width2, height: height2 } = bbox;
    const xOffset = label.padding + width2 / 2;
    const yOffset = label.padding + height2 / 2;
    const x = bounds.x + bounds.width * (anchor.rangeH + 1) / 2 - xOffset * anchor.labelH;
    const y = bounds.y + bounds.height * (anchor.rangeV + 1) / 2 - yOffset * anchor.labelV;
    crossLineLabel.x = x;
    crossLineLabel.y = y;
    crossLineLabel.rotationCenterX = x;
    crossLineLabel.rotationCenterY = y;
  }
  computeLabelSize() {
    const { label } = this;
    if (label.enabled === false || !label.text)
      return;
    const tempText = new TransformableText();
    tempText.fontFamily = label.fontFamily;
    tempText.fontSize = label.fontSize;
    tempText.fontStyle = label.fontStyle;
    tempText.fontWeight = label.fontWeight;
    tempText.text = label.text;
    tempText.rotation = toRadians(label.rotation ?? 0);
    tempText.textBaseline = "middle";
    tempText.textAlign = "center";
    const bbox = tempText.getBBox();
    if (!bbox)
      return;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  calculatePadding(into) {
    const { label, anchor } = this;
    const size = this.computeLabelSize();
    if (!size)
      return;
    const { width: width2, height: height2 } = size;
    const xOffset = label.padding + width2;
    const yOffset = label.padding + height2;
    const horizontal = this.position === "left" || this.position === "right";
    if (horizontal) {
      if (anchor.rangeH === -1 && anchor.labelH === 1) {
        into.left = Math.max(into.left ?? 0, xOffset);
      } else if (anchor.rangeH === 1 && anchor.labelH === -1) {
        into.right = Math.max(into.right ?? 0, xOffset);
      }
    }
    if (!horizontal) {
      if (anchor.rangeV === -1 && anchor.labelV === 1) {
        into.top = Math.max(into.top ?? 0, yOffset);
      } else if (anchor.rangeV === 1 && anchor.labelV === -1) {
        into.bottom = Math.max(into.bottom ?? 0, yOffset);
      }
    }
  }
};
CartesianCrossLine.className = "CrossLine";
__decorateClass([
  Property
], CartesianCrossLine.prototype, "enabled", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "type", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "range", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "value", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "fill", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "stroke", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "lineDash", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "label", 2);

// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var AxisGridLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.style = [
      {
        fill: void 0,
        fillOpacity: 1,
        stroke: void 0,
        strokeWidth: void 0,
        lineDash: []
      }
    ];
  }
};
__decorateClass([
  Property
], AxisGridLine.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisGridLine.prototype, "width", 2);
__decorateClass([
  Property
], AxisGridLine.prototype, "style", 2);

// packages/ag-charts-community/src/chart/axis/axisInterval.ts
var AxisInterval = class extends BaseProperties {
};
__decorateClass([
  Property
], AxisInterval.prototype, "placement", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "step", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "values", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "minSpacing", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "maxSpacing", 2);

// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.border = new LabelBorder();
    this.wrapping = "never";
    this.truncate = false;
    this.spacing = 5;
    this.color = "#575757";
    this.avoidCollisions = true;
    this.mirrored = false;
    this.parallel = false;
    this._formatters = {
      "component:year": void 0,
      "component:month": void 0,
      "component:day": void 0,
      "component:none": void 0,
      "long:year": void 0,
      "long:month": void 0,
      "long:day": void 0,
      "long:none": void 0
    };
  }
  /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */
  getSideFlag() {
    return this.mirrored ? 1 : -1;
  }
  formatValue(callWithContext2, params, index, options = {
    dateStyle: "long",
    truncateDate: void 0
  }) {
    const { formatter: formatter2, format } = this;
    const { type, value, domain, boundSeries } = params;
    const fractionDigits = params.type === "number" ? params.fractionDigits : void 0;
    const unit = params.type === "date" ? params.unit : void 0;
    let result;
    if (formatter2 != null) {
      const step = params.type === "date" ? params.step : void 0;
      result = callWithContext2(formatter2, { value, index, domain, fractionDigits, unit, step, boundSeries });
    }
    if (format != null && result == null) {
      const { specifier, dateStyle, truncateDate } = options;
      const cacheKey = `${dateStyle}:${truncateDate ?? "none"}`;
      let valueFormatter = this._formatters[cacheKey];
      const mergedFormat = FormatManager.mergeSpecifiers(specifier, format);
      if (valueFormatter == null || valueFormatter.type !== type || valueFormatter.unit !== unit || !objectsEqual(valueFormatter.mergedFormat, mergedFormat)) {
        valueFormatter = {
          type,
          mergedFormat,
          unit,
          formatter: FormatManager.getFormatter(type, mergedFormat, unit, dateStyle, options)
        };
        this._formatters[cacheKey] = valueFormatter;
      }
      result = valueFormatter.formatter?.(value, fractionDigits);
    }
    return result != null ? String(result) : void 0;
  }
};
__decorateClass([
  Property
], AxisLabel.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "border", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fill", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "wrapping", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "truncate", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "spacing", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "color", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "rotation", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "avoidCollisions", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "mirrored", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "padding", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "parallel", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "itemStyler", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "formatter", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "format", 2);

// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.stroke = void 0;
  }
};
__decorateClass([
  Property
], AxisLine.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisLine.prototype, "width", 2);
__decorateClass([
  Property
], AxisLine.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTick.ts
var AxisTick = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.width = 1;
    this.size = 6;
  }
};
__decorateClass([
  Property
], AxisTick.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisTick.prototype, "width", 2);
__decorateClass([
  Property
], AxisTick.prototype, "size", 2);
__decorateClass([
  Property
], AxisTick.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.caption = new Caption();
    this.enabled = false;
    this.spacing = Caption.SMALL_PADDING;
    this.fontSize = 10 /* SMALLER */;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
  }
};
__decorateClass([
  Property
], AxisTitle.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "text", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "spacing", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontStyle", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontWeight", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontSize", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontFamily", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "color", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "wrapping", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "formatter", 2);

// packages/ag-charts-community/src/chart/axis/axisUtil.ts
function prepareAxisAnimationContext(axis) {
  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
  const min = Math.floor(requestedRangeMin);
  const max = Math.ceil(requestedRangeMax);
  return { min, max, visible: min !== max };
}
var fullCircle = Math.PI * 2;
var halfCircle = fullCircle / 2;
function normaliseEndRotation(start2, end2) {
  const directDistance = Math.abs(end2 - start2);
  if (directDistance < halfCircle) {
    return end2;
  } else if (start2 > end2) {
    return end2 + fullCircle;
  }
  return end2 - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
  const { min, max } = ctx;
  const outOfBounds = (y) => {
    return y < min || y > max;
  };
  const tick = {
    fromFn(node, datum, status) {
      let { x1, x2, y1, y2 } = node;
      let opacity = node.opacity;
      if (status === "added" || outOfBounds(datum.offset)) {
        ({ x1, x2, y1, y2 } = datum);
        opacity = 0;
      }
      return {
        x1,
        x2,
        y1,
        y2,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(_node, datum, status) {
      const { x1, x2, y1, y2 } = datum;
      let opacity = 1;
      if (status === "removed") {
        opacity = 0;
      }
      return { x1, x2, y1, y2, opacity };
    },
    applyFn(node, props) {
      node.setProperties(props);
      node.visible = !outOfBounds(node.y);
    }
  };
  const label = {
    fromFn(node, newDatum, status) {
      const datum = node.previousDatum ?? newDatum;
      let { x, y, rotationCenterX, rotationCenterY, rotation } = datum;
      let opacity = node.opacity;
      if (status === "removed" || outOfBounds(datum.y)) {
        rotation = newDatum.rotation;
      } else if (status === "added" || outOfBounds(node.datum.y)) {
        ({ x, y, rotationCenterX, rotationCenterY, rotation } = newDatum);
        opacity = 0;
      }
      return {
        x,
        y,
        rotationCenterX,
        rotationCenterY,
        rotation,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(node, datum, status) {
      const { x, y, rotationCenterX, rotationCenterY } = datum;
      let rotation = 0;
      let opacity = 1;
      if (status === "added") {
        rotation = datum.rotation;
      } else if (status === "removed") {
        opacity = 0;
        rotation = datum.rotation;
      } else {
        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);
      }
      return {
        x,
        y,
        rotationCenterX,
        rotationCenterY,
        rotation,
        opacity,
        finish: { rotation: datum.rotation }
      };
    }
  };
  const line = {
    fromFn(node, datum) {
      const { x1, x2, y1, y2 } = node.previousDatum ?? datum;
      return {
        x1,
        x2,
        y1,
        y2,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { x1, x2, y1, y2 } = datum;
      return { x1, x2, y1, y2 };
    }
  };
  const group = {
    fromFn(node, _datum) {
      const { translationX, translationY } = node;
      return {
        translationX,
        translationY,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { translationX, translationY } = datum;
      return { translationX, translationY };
    }
  };
  return { tick, line, label, group };
}
function resetAxisGroupFn() {
  return (_node, datum) => {
    return {
      translationX: datum.translationX,
      translationY: datum.translationY
    };
  };
}
function resetAxisLabelSelectionFn() {
  return (_node, datum) => {
    return {
      x: datum.x,
      y: datum.y,
      rotationCenterX: datum.rotationCenterX,
      rotationCenterY: datum.rotationCenterY,
      rotation: datum.rotation
    };
  };
}
function resetAxisLineSelectionFn() {
  return (_node, datum) => {
    const { x1, x2, y1, y2 } = datum;
    return { x1, x2, y1, y2 };
  };
}
function resetAxisFillSelectionFn() {
  return (_node, datum) => {
    const { x1, x2, y1, y2 } = datum;
    return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
  };
}

// packages/ag-charts-community/src/chart/axis/axis.ts
function tickLayoutCacheValid(a, b) {
  return a.domain === b.domain && a.rangeExtent === b.rangeExtent && a.nice === b.nice && a.gridLength === b.gridLength && a.visibleRange[0] === b.visibleRange[0] && a.visibleRange[1] === b.visibleRange[1] && a.initialPrimaryTickCount?.unzoomed === b.initialPrimaryTickCount?.unzoomed && a.initialPrimaryTickCount?.zoomed === b.initialPrimaryTickCount?.zoomed;
}
var _Axis = class _Axis {
  constructor(moduleCtx, scale2) {
    this.moduleCtx = moduleCtx;
    this.scale = scale2;
    this.id = createId4(this);
    this._crossLines = [];
    this.nice = true;
    this.reverse = false;
    this.keys = [];
    this.interval = new AxisInterval();
    this.dataDomain = { domain: [], clipped: false };
    this.title = new AxisTitle();
    this.gridLength = 0;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    this.gridPadding = 0;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    this.seriesAreaPadding = 0;
    this.layoutConstraints = {
      stacked: true,
      align: "start",
      width: 100,
      unit: "percent"
    };
    this.boundSeries = [];
    this.includeInvisibleDomains = false;
    this.interactionEnabled = true;
    this.axisGroup = new Group({ name: `${this.id}-axis` });
    // Order is important to apply the correct z-index.
    this.tickLineGroup = this.axisGroup.appendChild(
      new TransformableGroup({ name: `${this.id}-Axis-tick-lines`, zIndex: 0 /* TickLines */ })
    );
    this.tickLabelGroup = this.axisGroup.appendChild(
      new TransformableGroup({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* TickLabels */ })
    );
    this.labelGroup = new Group({
      name: `${this.id}-Labels`,
      zIndex: 11 /* SERIES_ANNOTATION */
    });
    this.gridGroup = new TranslatableGroup({ name: `${this.id}-Axis-grid`, zIndex: 2 /* AXIS_GRID */ });
    this.gridFillGroup = this.gridGroup.appendChild(new Group({ name: `${this.id}-gridFills` }));
    this.gridLineGroup = this.gridGroup.appendChild(new Group({ name: `${this.id}-gridLines` }));
    this.crossLineRangeGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Range`,
      zIndex: 6 /* SERIES_CROSSLINE_RANGE */
    });
    this.crossLineLineGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Line`,
      zIndex: 10 /* SERIES_CROSSLINE_LINE */
    });
    this.crossLineLabelGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Label`,
      zIndex: 15 /* SERIES_LABEL */
    });
    this.tickLabelGroupSelection = Selection.select(
      this.tickLabelGroup,
      TransformableText,
      false
    );
    this.line = new AxisLine();
    this.tick = new AxisTick();
    this.gridLine = new AxisGridLine();
    this.label = this.createLabel();
    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
    this.translation = { x: 0, y: 0 };
    this.layout = {
      label: {
        fractionDigits: 0,
        spacing: this.label.spacing,
        format: this.label.format
      }
    };
    this.axisContext = void 0;
    this.cleanup = new CleanupRegistry();
    // AG-15360 Avoid calling removeTooltip() if no tooltip is shown. This avoid a laggy tooltips caused by interference
    // with SeriesAreaManager's tooltip updates.
    this.isHovering = false;
    this.range = [0, 1];
    this.visibleRange = [0, 1];
    this.animatable = true;
    this.tickLayout = void 0;
    this.formatterBoundSeries = new WeakCache(() => {
      const { direction, boundSeries } = this;
      return deepFreeze(boundSeries.flatMap((series) => series.getFormatterContext(direction)));
    });
    this.moduleMap = new ModuleMap();
    this.range = this.scale.range.slice();
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
    this.cleanup.register(
      this.moduleCtx.widgets.containerWidget.addListener("mousemove", (e) => this.onMouseMove(e))
    );
  }
  set crossLines(value) {
    const { CrossLineConstructor } = this.constructor;
    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));
    this._crossLines = value.map((crossLine) => {
      const instance = new CrossLineConstructor();
      instance.set(crossLine);
      return instance;
    });
    this._crossLines.forEach((crossLine) => {
      this.attachCrossLine(crossLine);
      this.initCrossLine(crossLine);
    });
  }
  get crossLines() {
    return this._crossLines;
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get primaryLabel() {
    return void 0;
  }
  get primaryTick() {
    return void 0;
  }
  isCategoryLike() {
    return false;
  }
  resetAnimation(_phase) {
  }
  onMouseMove(event) {
    const node = this.tickLabelGroup.pickNode(event.currentX, event.currentY);
    const datum = node?.datum;
    const { textUntruncated: title = void 0 } = datum ?? {};
    if (title != null) {
      this.moduleCtx.tooltipManager.updateTooltip(
        this.id,
        { canvasX: event.currentX, canvasY: event.currentY, showArrow: false },
        [{ type: "structured", title }]
      );
      this.isHovering = true;
    } else if (this.isHovering) {
      this.moduleCtx.tooltipManager.removeTooltip(this.id);
      this.isHovering = false;
    }
  }
  attachCrossLine(crossLine) {
    this.crossLineRangeGroup.appendChild(crossLine.rangeGroup);
    this.crossLineLineGroup.appendChild(crossLine.lineGroup);
    this.crossLineLabelGroup.appendChild(crossLine.labelGroup);
  }
  detachCrossLine(crossLine) {
    this.crossLineRangeGroup.removeChild(crossLine.rangeGroup);
    this.crossLineLineGroup.removeChild(crossLine.lineGroup);
    this.crossLineLabelGroup.removeChild(crossLine.labelGroup);
  }
  destroy() {
    this.moduleMap.destroy();
    this.cleanup.flush();
  }
  setScaleRange(visibleRange) {
    const { range: rr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (visibleRange[1] - visibleRange[0]);
    const shift = span * visibleRange[0];
    const start2 = rr[0] - shift;
    scale2.range = [start2, start2 + span];
  }
  updateScale() {
    const {
      range: [r0, r1]
    } = this;
    this.setScaleRange(this.visibleRange);
    this.crossLines.forEach((crossLine) => {
      crossLine.clippedRange = [r0, r1];
    });
  }
  setCrossLinesVisible(visible) {
    this.crossLineRangeGroup.visible = visible;
    this.crossLineLineGroup.visible = visible;
    this.crossLineLabelGroup.visible = visible;
  }
  attachAxis(groups) {
    groups.gridNode.appendChild(this.gridGroup);
    groups.axisNode.appendChild(this.axisGroup);
    groups.labelNode.appendChild(this.labelGroup);
    groups.crossLineRangeNode.appendChild(this.crossLineRangeGroup);
    groups.crossLineLineNode.appendChild(this.crossLineLineGroup);
    groups.crossLineLabelNode.appendChild(this.crossLineLabelGroup);
  }
  detachAxis(groups) {
    groups.gridNode.removeChild(this.gridGroup);
    groups.axisNode.removeChild(this.axisGroup);
    groups.labelNode.removeChild(this.labelGroup);
    groups.crossLineRangeNode.removeChild(this.crossLineRangeGroup);
    groups.crossLineLineNode.removeChild(this.crossLineLineGroup);
    groups.crossLineLabelNode.removeChild(this.crossLineLabelGroup);
  }
  attachLabel(axisLabelNode) {
    this.labelGroup.append(axisLabelNode);
  }
  /**
   * Checks if a point or an object is in range.
   * @param value A point (or object's starting point).
   * @param tolerance Expands the range on both ends by this amount.
   */
  inRange(value, tolerance = 0) {
    const [min, max] = findMinMax(this.range);
    return value >= min - tolerance && value <= max + tolerance;
  }
  /**
   * Get a point's overflow on the range, expanded to include the non-visible range.
   * @param value Point
   * @returns Overflow
   */
  getRangeOverflow(value) {
    const { range: rr, visibleRange: vr } = this;
    const size = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const [min, max] = findMinMax([rr[0] - size * vr[0], rr[0] - size * vr[0] + size]);
    if (value < min)
      return value - min;
    if (value > max)
      return value - max;
    return 0;
  }
  createDatumFormatter(_domain, _ticks) {
    return;
  }
  onGridLengthChange(value, prevValue) {
    if (prevValue ^ value) {
      this.onGridVisibilityChange();
    }
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
  }
  onGridVisibilityChange() {
  }
  createLabel() {
    return new AxisLabel();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */
  update() {
    this.formatterBoundSeries.clear();
    this.updatePosition();
    this.updateSelections();
    this.tickLineGroup.visible = this.tick.enabled;
    this.gridLineGroup.visible = this.gridLine.enabled;
    this.tickLabelGroup.visible = this.label.enabled;
    this.updateLabels();
    this.updateCrossLines();
  }
  getLabelStyles(params, additionalStyles, label = this.label) {
    const defaultStyle = {
      border: label.border,
      color: label.color,
      cornerRadius: label.cornerRadius,
      fill: label.fill,
      fillOpacity: label.fillOpacity,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight,
      padding: label.padding,
      spacing: label.spacing
    };
    let stylerOutput;
    if (label.itemStyler) {
      stylerOutput = this.cachedCallWithContext(label.itemStyler, {
        ...params,
        ...defaultStyle
      });
    }
    const merged = mergeDefaults(stylerOutput, additionalStyles, defaultStyle);
    return {
      border: merged.border,
      color: merged.color,
      cornerRadius: merged.cornerRadius,
      fill: merged.fill,
      fillOpacity: merged.fillOpacity,
      fontFamily: merged.fontFamily,
      fontSize: merged.fontSize,
      fontStyle: merged.fontStyle,
      fontWeight: merged.fontWeight,
      padding: merged.padding,
      spacing: merged.spacing
    };
  }
  getTickSize(tick = this.tick) {
    return tick.enabled ? tick.size : 0;
  }
  processData() {
    this.invalidateLayoutCache();
    const { includeInvisibleDomains, boundSeries, direction } = this;
    const visibleSeries = includeInvisibleDomains ? boundSeries : boundSeries.filter((s) => s.isEnabled());
    const domains = visibleSeries.map((series) => series.getDomain(direction));
    this.setDomains(...domains);
  }
  setDomains(...domains) {
    let domain;
    let animatable;
    if (domains.length > 0) {
      ({ domain, animatable } = this.scale.normalizeDomains(...domains));
    } else {
      domain = [];
      animatable = true;
    }
    this.dataDomain = this.normaliseDataDomain(domain);
    if (this.reverse) {
      this.dataDomain.domain.reverse();
    }
    this.animatable = animatable;
  }
  calculateDomain(initialPrimaryTickCount) {
    const {
      dataDomain: { domain },
      range: range3,
      nice,
      scale: scale2,
      gridLength
    } = this;
    const rangeExtent = findRangeExtent(range3);
    const visibleRange = [0, 1];
    this.updateScale();
    const { unzoomedTickLayoutCache } = this;
    let unzoomedTickLayout;
    if (unzoomedTickLayoutCache == null || !tickLayoutCacheValid(unzoomedTickLayoutCache, {
      domain,
      rangeExtent,
      nice,
      gridLength,
      visibleRange,
      initialPrimaryTickCount
    })) {
      const scaleRange = scale2.range;
      this.setScaleRange([0, 1]);
      const niceMode = nice ? 0 /* TickAndDomain */ : 2 /* Off */;
      unzoomedTickLayout = this.calculateTickLayout(domain, niceMode, [0, 1], initialPrimaryTickCount);
      scale2.range = scaleRange;
      this.unzoomedTickLayoutCache = {
        domain,
        rangeExtent,
        nice,
        gridLength,
        visibleRange,
        initialPrimaryTickCount,
        tickLayout: unzoomedTickLayout
      };
    } else {
      unzoomedTickLayout = unzoomedTickLayoutCache.tickLayout;
    }
    this.updateScale();
    scale2.domain = unzoomedTickLayout.niceDomain;
    return { unzoomedTickLayout, domain: scale2.domain };
  }
  calculateLayout(initialPrimaryTickCount, chartLayout) {
    this.chartLayout = chartLayout;
    const { visibleRange, nice } = this;
    const unzoomed = visibleRange[0] === 0 && visibleRange[1] === 1;
    const { unzoomedTickLayout, domain } = this.calculateDomain(initialPrimaryTickCount);
    let tickLayout;
    if (unzoomed) {
      tickLayout = unzoomedTickLayout;
    } else {
      const { range: range3, gridLength } = this;
      const rangeExtent = findRangeExtent(range3);
      const niceMode = nice ? 1 /* TicksOnly */ : 2 /* Off */;
      const { tickLayoutCache } = this;
      if (tickLayoutCache == null || !tickLayoutCacheValid(tickLayoutCache, {
        domain,
        rangeExtent,
        nice,
        gridLength,
        visibleRange,
        initialPrimaryTickCount
      })) {
        tickLayout = this.calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount);
        this.tickLayoutCache = {
          domain,
          rangeExtent,
          nice,
          gridLength,
          visibleRange,
          initialPrimaryTickCount,
          tickLayout
        };
      } else {
        tickLayout = tickLayoutCache.tickLayout;
      }
    }
    const { rawTickCount: zoomedTickCount = 0, fractionDigits, bbox } = tickLayout;
    const unzoomedTickCount = unzoomedTickLayout.rawTickCount ?? 0;
    const primaryTickCount = zoomedTickCount !== 0 && unzoomedTickCount !== 0 ? { zoomed: zoomedTickCount, unzoomed: unzoomedTickCount } : void 0;
    this.tickLayout = tickLayout.layout;
    this.layout.label = {
      fractionDigits,
      spacing: this.label.spacing,
      format: this.label.format
    };
    this.layoutCrossLines();
    return { primaryTickCount, bbox };
  }
  invalidateLayoutCache() {
    this.unzoomedTickLayoutCache = void 0;
    this.tickLayoutCache = void 0;
    this.tickLayout = void 0;
  }
  updateCrossLines() {
    const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
    this.crossLines.forEach((crossLine) => {
      crossLine.update(crosslinesVisible);
    });
  }
  updatePosition() {
    const { crossLineRangeGroup, crossLineLineGroup, crossLineLabelGroup, gridGroup, translation } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    gridGroup.setProperties({ translationX, translationY });
    crossLineRangeGroup.setProperties({ translationX, translationY });
    crossLineLineGroup.setProperties({ translationX, translationY });
    crossLineLabelGroup.setProperties({ translationX, translationY });
  }
  // For formatting (nice rounded) tick values.
  tickFormatter(domain, ticks, primary, inputFractionDigits, inputTimeInterval, dateStyle = "long") {
    const { moduleCtx, label } = this;
    const { formatManager } = moduleCtx;
    const primaryLabel = primary ? this.primaryLabel : void 0;
    const tickFormatParams = this.tickFormatParams(domain, ticks, inputFractionDigits, inputTimeInterval);
    const boundSeries = this.formatterBoundSeries.get();
    let fractionDigits;
    let timeInterval3;
    let truncateDate;
    if (tickFormatParams.type === "number") {
      fractionDigits = tickFormatParams.fractionDigits;
    } else if (tickFormatParams.type === "date") {
      const { unit, step, epoch } = tickFormatParams;
      timeInterval3 = { unit, step, epoch };
      truncateDate = tickFormatParams.truncateDate;
    }
    const f = this.uncachedCallWithContext.bind(this);
    const params = {
      datum: void 0,
      seriesId: void 0,
      legendItemName: void 0,
      key: void 0,
      source: "axis-label",
      property: this.direction,
      domain,
      boundSeries
    };
    const currentLabel = primaryLabel ?? label;
    const specifier = primary ? label.format : void 0;
    const options = {
      specifier: FormatManager.mergeSpecifiers(primaryLabel?.format, label.format),
      truncateDate
    };
    return (value, index) => {
      const formatParams = this.datumFormatParams(value, params, fractionDigits, timeInterval3, dateStyle);
      formatParams.value = value;
      return currentLabel.formatValue(f, formatParams, index, { specifier, dateStyle, truncateDate }) ?? formatManager.format(f, formatParams, options) ?? formatManager.defaultFormat(formatParams, options);
    };
  }
  formatDatum(contextProvider, input, source, seriesId, legendItemName, datum, key, domain, label, params) {
    if (input == null)
      return "";
    const { moduleCtx, direction, dataDomain } = this;
    domain ?? (domain = dataDomain.domain);
    const { formatManager } = moduleCtx;
    const boundSeries = this.formatterBoundSeries.get();
    let inputFractionDigits;
    switch (source) {
      case "crosshair":
      case "annotation-label":
        inputFractionDigits = this.layout.label.fractionDigits + 1;
        break;
      case "series-label":
        inputFractionDigits = 2;
        break;
      case "tooltip":
        inputFractionDigits = 3;
        break;
      case "legend-label":
        inputFractionDigits = void 0;
        break;
    }
    const formatParams = this.datumFormatParams(
      input,
      {
        source,
        datum,
        seriesId,
        legendItemName,
        key,
        property: direction,
        domain,
        boundSeries
      },
      inputFractionDigits,
      void 0,
      "long"
    );
    const { type, value } = formatParams;
    const f = this.createCallWithContext(contextProvider);
    const result = label?.formatValue(f, type, value, params ?? formatParams) ?? formatManager.format(f, formatParams) ?? this.label.formatValue(f, formatParams, NaN) ?? formatManager.defaultFormat(formatParams);
    return String(result);
  }
  getBBox() {
    return this.axisGroup.getBBox();
  }
  initCrossLine(crossLine) {
    crossLine.scale = this.scale;
    crossLine.gridLength = this.gridLength;
  }
  hasVisibleSeries() {
    return this.boundSeries.some((s) => s.isEnabled());
  }
  clipTickLines(x, y, width2, height2) {
    this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));
  }
  clipGrid(x, y, width2, height2) {
    this.gridGroup.setClipRect(new BBox(x, y, width2, height2));
  }
  getTitleFormatterParams(domain) {
    const { direction } = this;
    const boundSeries = this.formatterBoundSeries.get();
    return { domain, direction, boundSeries, defaultValue: this.title?.text };
  }
  normaliseDataDomain(d) {
    return { domain: [...d], clipped: false };
  }
  getLayoutState() {
    return {
      id: this.id,
      rect: this.getBBox(),
      gridPadding: this.gridPadding,
      seriesAreaPadding: this.seriesAreaPadding,
      tickSize: this.getTickSize(),
      direction: this.direction,
      domain: this.dataDomain.domain,
      scale: this.scale,
      ...this.layout
    };
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    this.axisContext ?? (this.axisContext = this.createAxisContext());
    return { ...this.moduleCtx, parent: this.axisContext };
  }
  createAxisContext() {
    const { scale: scale2 } = this;
    return {
      axisId: this.id,
      scale: this.scale,
      direction: this.direction,
      continuous: ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2),
      getCanvasBounds: () => {
        return Transformable.toCanvas(this.axisGroup);
      },
      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {
        const seriesKeys = series.getKeyProperties(this.direction);
        seriesKeys.forEach((key) => keys.add(key));
        return keys;
      }, /* @__PURE__ */ new Set()),
      seriesIds: () => this.boundSeries.map((series) => series.id),
      scaleInvert: (val) => scale2.invert(val, true),
      scaleInvertNearest: (val) => scale2.invert(val, true),
      formatScaleValue: (value, source, label) => this.formatDatum(
        void 0,
        value,
        source,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        label
      ),
      attachLabel: (node) => this.attachLabel(node),
      inRange: (value, tolerance) => this.inRange(value, tolerance),
      getRangeOverflow: (value) => this.getRangeOverflow(value),
      pickBand: (point) => this.pickBand(point)
    };
  }
  pickBand(point) {
    if (!BandScale.is(this.scale)) {
      return;
    }
    const { scale: scale2, range: range3 } = this;
    const value = scale2.invert(this.isVertical() ? point.y : point.x, true);
    const bandwidth = scale2.bandwidth ?? 0;
    const step = scale2.step ?? 0;
    const offset = (step - bandwidth) / 2;
    const position = scale2.convert(value);
    const start2 = position - offset;
    const end2 = position + bandwidth + offset;
    return {
      id: this.id,
      value,
      band: [clampArray(start2, range3), clampArray(end2, range3)],
      position
    };
  }
  isVertical() {
    return this.direction === "y" /* Y */;
  }
  isReversed() {
    return this.reverse;
  }
  cachedCallWithContext(fn, ...params) {
    const { callbackCache, chartService } = this.moduleCtx;
    return callbackCache.call([this, chartService], fn, ...params);
  }
  uncachedCallWithContext(fn, ...params) {
    const { chartService } = this.moduleCtx;
    return callWithContext([this, chartService], fn, ...params);
  }
  createCallWithContext(contextProvider) {
    const { chartService } = this.moduleCtx;
    return (fn, ...params) => callWithContext([contextProvider, this, chartService], fn, ...params);
  }
};
_Axis.defaultTickMinSpacing = 50;
_Axis.CrossLineConstructor = CartesianCrossLine;
__decorateClass([
  Property
], _Axis.prototype, "nice", 2);
__decorateClass([
  Property
], _Axis.prototype, "reverse", 2);
__decorateClass([
  Property
], _Axis.prototype, "keys", 2);
__decorateClass([
  Property
], _Axis.prototype, "interval", 2);
__decorateClass([
  Property
], _Axis.prototype, "title", 2);
__decorateClass([
  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))
], _Axis.prototype, "gridLength", 2);
var Axis = _Axis;

// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts
import { boxCollides as boxCollides2, countFractionDigits as countFractionDigits3, dropFirstWhile, dropLastWhile } from "ag-charts-core";

// packages/ag-charts-community/src/scale/categoryScale.ts
import { clamp as clamp11 } from "ag-charts-core";

// packages/ag-charts-community/src/util/timeFormatDefaults.ts
function dateToNumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
function lowestGranularityForInterval(interval) {
  if (interval < durationSecond) {
    return "millisecond";
  } else if (interval < durationMinute) {
    return "second";
  } else if (interval < durationHour) {
    return "minute";
  } else if (interval < durationHour * 23) {
    return "hour";
  } else if (interval < 28 * durationDay) {
    return "day";
  } else if (interval < durationYear) {
    return "month";
  } else {
    return "year";
  }
}
function lowestGranularityUnitForTicks(ticks) {
  if (ticks.length === 0) {
    return "millisecond";
  } else if (ticks.length === 1) {
    return lowestGranularityUnitForValue(ticks[0]);
  }
  let minInterval = Infinity;
  for (let i = 1; i < ticks.length; i++) {
    minInterval = Math.min(minInterval, Math.abs(ticks[i].valueOf() - ticks[i - 1].valueOf()));
  }
  return lowestGranularityForInterval(minInterval);
}
function lowestGranularityUnitForValue(value) {
  if (intervalFloor("second", value) < value) {
    return "millisecond";
  } else if (intervalFloor("minute", value) < value) {
    return "second";
  } else if (intervalFloor("hour", value) < value) {
    return "minute";
  } else if (intervalFloor("day", value) < value) {
    return "hour";
  } else if (intervalFloor("month", value) < value) {
    return "day";
  } else if (intervalFloor("year", value) < value) {
    return "month";
  }
  return "year";
}
function dateTruncationForDomain(domain) {
  const [d0, d1] = domain.length === 0 ? [0, 0] : findMinMax([domain[0].valueOf(), domain[domain.length - 1].valueOf()]);
  const startYear = new Date(d0).getFullYear();
  const stopYear = new Date(d1).getFullYear();
  if (startYear !== stopYear)
    return;
  const startMonth = new Date(d0).getMonth();
  const stopMonth = new Date(d1).getMonth();
  if (startMonth !== stopMonth)
    return "year";
  const startDate = new Date(d0).getDate();
  const stopDate = new Date(d1).getDate();
  if (startDate !== stopDate)
    return "month";
  return "day";
}

// packages/ag-charts-community/src/scale/scaleUtil.ts
import { clamp as clamp10 } from "ag-charts-core";
function filterVisibleTicks(ticks, reversed, visibleRange) {
  if (visibleRange == null || visibleRange[0] === 0 && visibleRange[1] === 1) {
    return { ticks, count: ticks.length, firstTickIndex: 0 };
  }
  const vt0 = clamp10(0, Math.floor(visibleRange[0] * ticks.length), ticks.length);
  const vt1 = clamp10(0, Math.ceil(visibleRange[1] * ticks.length), ticks.length);
  const t0 = reversed ? ticks.length - vt1 : vt0;
  const t1 = reversed ? ticks.length - vt0 : vt1;
  return {
    ticks: ticks.slice(t0, t1),
    count: ticks.length,
    firstTickIndex: t0
  };
}

// packages/ag-charts-community/src/scale/categoryScale.ts
var CategoryScale = class _CategoryScale extends BandScale {
  constructor() {
    super(...arguments);
    this.type = "category";
    this.defaultTickCount = 0;
    /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate data (not allowed).
     */
    this.index = /* @__PURE__ */ new Map();
    this.indexInitialized = false;
    /**
     * Contains unique data only.
     */
    this._domain = [];
  }
  static is(value) {
    return value instanceof _CategoryScale;
  }
  set domain(values) {
    if (this._domain === values)
      return;
    this.invalid = true;
    this._domain = values;
    this.index.clear();
    this.indexInitialized = false;
  }
  get domain() {
    return this._domain;
  }
  get bands() {
    return this._domain;
  }
  normalizeDomains(...domains) {
    let normalizedDomain = void 0;
    const seenDomains = /* @__PURE__ */ new Set();
    let animatable = true;
    for (const domain of domains) {
      if (seenDomains.has(domain))
        continue;
      seenDomains.add(domain);
      if (normalizedDomain == null) {
        normalizedDomain = deduplicateCategories(domain);
      } else {
        animatable && (animatable = domainOrderedToNormalizedDomain(domain, normalizedDomain));
        normalizedDomain = deduplicateCategories([...normalizedDomain, ...domain]);
      }
    }
    normalizedDomain ?? (normalizedDomain = []);
    return { domain: normalizedDomain, animatable };
  }
  toDomain(_value) {
    return void 0;
  }
  invert(position, nearest = false) {
    this.refresh();
    const offset = nearest ? this.bandwidth / 2 : 0;
    const index = this.invertNearestIndex(Math.max(0, position - offset));
    const matches = nearest || position === this.ordinalRange(index);
    return matches ? this.domain[index] : void 0;
  }
  ticks(params, domain = this.domain, visibleRange) {
    const { bands } = this;
    let { tickCount } = params;
    if (tickCount === 0) {
      const firstTickIndex2 = bands.length > 1 ? 1 : 0;
      return { ticks: [bands[firstTickIndex2]], count: void 0, firstTickIndex: firstTickIndex2 };
    }
    let step = tickCount != null && tickCount !== 0 ? bands.length / tickCount | 0 : 1;
    step = previousPowerOf2(step);
    if (step <= 1) {
      return filterVisibleTicks(domain, false, visibleRange);
    }
    tickCount = bands.length / step | 0;
    const span = step * tickCount;
    const inset = previousPowerOf2((bands.length - span) / 2 | 0);
    const vt0 = clamp11(0, Math.floor((visibleRange?.[0] ?? 0) * bands.length), bands.length);
    const vt1 = clamp11(0, Math.ceil((visibleRange?.[1] ?? 1) * bands.length), bands.length);
    const i0 = Math.floor((vt0 - inset) / step) * step + inset;
    const i1 = Math.ceil((vt1 - inset) / step) * step + inset;
    const ticks = [];
    for (let i = i0; i < i1; i += step) {
      if (i >= 0 && i < bands.length) {
        ticks.push(bands[i]);
      }
    }
    let firstTickIndex = ticks.length > 0 ? this.findIndex(ticks[0]) : void 0;
    if (firstTickIndex != null) {
      firstTickIndex = Math.floor((firstTickIndex - inset) / step);
    }
    return { ticks, count: void 0, firstTickIndex };
  }
  findIndex(value) {
    const { index, indexInitialized } = this;
    if (!indexInitialized) {
      const { domain } = this;
      for (let i = 0; i < domain.length; i++) {
        index.set(dateToNumber(domain[i]), i);
      }
      this.indexInitialized = true;
    }
    return index.get(dateToNumber(value));
  }
};
function deduplicateCategories(d) {
  let domain;
  const uniqueValues = /* @__PURE__ */ new Set();
  for (const value of d) {
    const key = dateToNumber(value);
    const lastSize = uniqueValues.size;
    uniqueValues.add(key);
    const isUniqueValue = uniqueValues.size !== lastSize;
    if (isUniqueValue) {
      domain?.push(value);
    } else {
      domain ?? (domain = d.slice(0, uniqueValues.size));
    }
  }
  return domain ?? d;
}
function domainOrderedToNormalizedDomain(domain, normalizedDomain) {
  let normalizedIndex = -1;
  for (const value of domain) {
    const normalizedNextIndex = normalizedDomain.indexOf(value);
    if (normalizedNextIndex === -1) {
      normalizedIndex = Infinity;
    } else if (normalizedNextIndex <= normalizedIndex) {
      return false;
    } else {
      normalizedIndex = normalizedNextIndex;
    }
  }
  return true;
}

// packages/ag-charts-community/src/util/date.ts
function compareDates(a, b) {
  return a.valueOf() - b.valueOf();
}
function deduplicateSortedArray(values) {
  let v0 = NaN;
  const out = [];
  for (const v of values) {
    const v1 = v.valueOf();
    if (v0 !== v1)
      out.push(v);
    v0 = v1;
  }
  return out;
}
function sortAndUniqueDates(values) {
  const sortedValues = values.slice().sort(compareDates);
  return datesSortOrder(sortedValues) == null ? deduplicateSortedArray(sortedValues) : sortedValues;
}
function datesSortOrder(d) {
  if (d.length === 0)
    return 1;
  const sign = Number(d[d.length - 1]) > Number(d[0]) ? 1 : -1;
  let v0 = -Infinity * sign;
  for (const v of d) {
    const v1 = v.valueOf();
    if (Math.sign(v1 - v0) !== sign)
      return;
    v0 = v1;
  }
  return sign;
}

// packages/ag-charts-community/src/scale/timeScale.ts
import { isPlainObject as isPlainObject6 } from "ag-charts-core";
var sunday = new Date(1970, 0, 4);
var TimeScale = class _TimeScale extends ContinuousScale {
  constructor() {
    super([], [0, 1]);
    this.type = "time";
  }
  static is(value) {
    return value instanceof _TimeScale;
  }
  toDomain(d) {
    return new Date(d);
  }
  convert(value, options) {
    return super.convert(value?.valueOf() ?? NaN, options);
  }
  invert(value) {
    return new Date(super.invert(value));
  }
  niceDomain(ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    let [d0, d1] = domain;
    const maxAttempts = 4;
    const availableRange = this.getPixelRange();
    for (let i = 0; i < maxAttempts; i++) {
      const [n0, n1] = updateNiceDomainIteration(d0, d1, ticks, availableRange);
      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {
        break;
      }
      d0 = n0;
      d1 = n1;
    }
    return [d0, d1];
  }
  /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */
  ticks(params, domain = this.domain, visibleRange = [0, 1], { extend = false } = {}) {
    const { nice, interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = params;
    if (domain.length < 2)
      return;
    const timestamps = domain.map(dateToNumber);
    const start2 = timestamps[0];
    const stop = timestamps[timestamps.length - 1];
    if (interval != null) {
      const availableRange = this.getPixelRange();
      return {
        ticks: getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange, extend }) ?? getDefaultDateTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange, extend }),
        count: void 0
      };
    } else if (nice && tickCount === 2) {
      return { ticks: domain, count: void 0 };
    } else if (nice && tickCount === 1) {
      return { ticks: domain.slice(0, 1), count: void 0 };
    }
    const timeInterval3 = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, {
      weekStart: sunday
    });
    if (timeInterval3 == null)
      return;
    const ticks = intervalRange(timeInterval3, new Date(start2), new Date(stop), { visibleRange, extend });
    const firstTickIndex = intervalRangeStartIndex(timeInterval3, new Date(start2), new Date(stop), {
      visibleRange,
      extend
    });
    return {
      ticks,
      count: void 0,
      firstTickIndex,
      timeInterval: timeInterval3
    };
  }
};
function getDefaultDateTicks({
  start: start2,
  stop,
  tickCount,
  minTickCount,
  maxTickCount,
  visibleRange,
  extend
}) {
  const t = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, { weekStart: sunday });
  return t ? intervalRange(t, new Date(start2), new Date(stop), { visibleRange, extend }) : [];
}
function getDateTicksForInterval({
  start: start2,
  stop,
  interval,
  availableRange,
  visibleRange,
  extend
}) {
  if (!interval) {
    return [];
  }
  if (isPlainObject6(interval) || typeof interval === "string") {
    const ticks2 = intervalRange(interval, new Date(start2), new Date(stop), { visibleRange, extend });
    if (isDenseInterval(ticks2.length, availableRange)) {
      return;
    }
    return ticks2;
  }
  const absInterval = Math.abs(interval);
  if (isDenseInterval(Math.abs(stop - start2) / absInterval, availableRange))
    return;
  const tickInterval = TickIntervals.findLast((t) => absInterval % t.duration === 0);
  if (tickInterval) {
    const { timeInterval: timeInterval3, step, duration } = tickInterval;
    const alignedInterval = {
      ...timeInterval3,
      step: step * intervalStep(timeInterval3) * Math.round(absInterval / duration),
      epoch: defaultEpoch(timeInterval3, { weekStart: sunday })
    };
    return intervalRange(alignedInterval, new Date(start2), new Date(stop), { visibleRange, extend });
  }
  let date5 = new Date(Math.min(start2, stop));
  const stopDate = new Date(Math.max(start2, stop));
  const ticks = [];
  while (date5 <= stopDate) {
    ticks.push(date5);
    date5 = new Date(date5);
    date5.setMilliseconds(date5.getMilliseconds() + absInterval);
  }
  return ticks;
}
function updateNiceDomainIteration(d0, d1, ticks, availableRange) {
  const { interval } = ticks;
  const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));
  const stop = Math.max(dateToNumber(d0), dateToNumber(d1));
  let i;
  if (isPlainObject6(interval) || typeof interval === "string") {
    i = interval;
  } else {
    let tickCount;
    if (typeof interval === "number") {
      tickCount = (stop - start2) / Math.max(interval, 1);
      if (isDenseInterval(tickCount, availableRange)) {
        tickCount = void 0;
      }
    }
    tickCount ?? (tickCount = ticks.tickCount ?? ContinuousScale.defaultTickCount);
    i = getTickTimeInterval(start2, stop, tickCount, ticks.minTickCount, ticks.maxTickCount, { weekStart: sunday });
  }
  if (i == null)
    return [d0, d1];
  const domain = intervalRange(i, new Date(start2), new Date(stop), { extend: true });
  if (domain == null || domain.length < 2)
    return [d0, d1];
  const r0 = domain[0];
  const r1 = domain[domain.length - 1];
  return d0 <= d1 ? [r0, r1] : [r1, r0];
}

// packages/ag-charts-community/src/scale/ordinalTimeScale.ts
var OrdinalTimeScale = class _OrdinalTimeScale extends DiscreteTimeScale {
  constructor() {
    super(...arguments);
    this.type = "ordinal-time";
    this.defaultTickCount = ContinuousScale.defaultTickCount;
    this._domain = [];
    this.isReversed = false;
  }
  static is(value) {
    return value instanceof _OrdinalTimeScale;
  }
  set domain(domain) {
    if (domain === this._domain)
      return;
    this.invalid = true;
    this._domain = domain;
    this._bands = void 0;
    this.isReversed = domainReversed(domain);
  }
  get domain() {
    return this._domain;
  }
  get bands() {
    this._bands ?? (this._bands = this.isReversed ? this.domain.slice().reverse() : this.domain);
    return this._bands;
  }
  normalizeDomains(...domains) {
    const sortedDomains = domains.filter((domain) => domain.length > 0);
    if (sortedDomains.length === 0) {
      return { domain: [], animatable: false };
    } else if (sortedDomains.length === 1) {
      let domain = sortedDomains[0];
      const sortOrder = datesSortOrder(domain);
      if (sortOrder === -1) {
        domain = domain.slice().reverse();
      } else if (sortOrder == null) {
        domain = sortAndUniqueDates(domain.slice());
      }
      return { domain, animatable: true };
    }
    return {
      domain: sortAndUniqueDates(sortedDomains.flat()),
      animatable: true
    };
  }
  ticks(params, domain, visibleRange = [0, 1], { extend = false, dropInitial = false } = {}) {
    const { interval, maxTickCount, tickCount = maxTickCount } = params;
    const { bands } = this;
    if (!bands.length)
      return;
    this.refresh();
    if (interval == null) {
      const { ticks: ticks2, tickOffset, tickEvery } = this.getDefaultTicks(domain, tickCount, visibleRange, extend);
      let firstTickIndex = ticks2.length > 0 ? this.findIndex(ticks2[0]) : void 0;
      firstTickIndex = firstTickIndex != null ? Math.floor((firstTickIndex - tickOffset) / tickEvery) : void 0;
      return { ticks: ticks2, count: void 0, firstTickIndex };
    }
    let start2;
    let stop;
    if (domain && domain.length >= 2) {
      start2 = domain[0].valueOf();
      stop = domain[domain.length - 1].valueOf();
    } else {
      start2 = bands[0].valueOf();
      stop = bands[bands.length - 1].valueOf();
    }
    const [r0, r1] = this.range;
    const availableRange = Math.abs(r1 - r0);
    const dateTicks = getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange, extend }) ?? this.getDefaultTicks(domain, tickCount, visibleRange, extend).ticks;
    const ticks = [];
    let lastIndex = -1;
    for (const dateTick of dateTicks) {
      const index = this.findIndex(dateTick, 1 /* Trailing */) ?? -1;
      const duplicated = index === lastIndex;
      lastIndex = index;
      if (!(dropInitial && index === 0) && index !== -1 && !duplicated) {
        ticks.push(bands[index]);
      }
    }
    return { ticks, count: void 0, firstTickIndex: void 0 };
  }
  stepTicks(bandStep, domain, visibleRange = [0, 1], dropLast = true) {
    const bandIndices = domain ? this.bandDomainIndices(domain) : void 0;
    const ticks = this.ticksEvery(bandIndices, visibleRange, bandStep, 0, false);
    const lastTick = ticks.at(-1);
    const lastBandIndex = dropLast && bandStep > 1 ? bandIndices?.[1] : void 0;
    const lastTickIndex = lastBandIndex != null && lastTick != null ? this.findIndex(lastTick) : void 0;
    if (lastTickIndex != null && lastBandIndex != null && lastBandIndex - lastTickIndex < bandStep) {
      ticks.pop();
    }
    return ticks;
  }
  bandCount(visibleRange = [0, 1]) {
    const { domain } = this;
    const startIndex = Math.floor(visibleRange[0] * domain.length);
    const endIndex = Math.ceil(visibleRange[1] * domain.length);
    return endIndex - startIndex;
  }
  getDefaultTicks(domain, maxTickCount, visibleRange, extend) {
    const { bands } = this;
    const tickEvery = Math.ceil(bands.length / maxTickCount);
    const tickOffset = Math.floor(tickEvery / 2);
    const bandIndices = domain ? this.bandDomainIndices(domain) : void 0;
    return {
      ticks: this.ticksEvery(bandIndices, visibleRange, tickEvery, tickOffset, extend),
      tickOffset,
      tickEvery
    };
  }
  bandDomainIndices(domain) {
    const isReversed = domainReversed(domain);
    const i0 = this.findIndex(domain[isReversed ? domain.length - 1 : 0], 1 /* Trailing */) ?? 0;
    const i1 = this.findIndex(domain[isReversed ? 0 : domain.length - 1], 1 /* Trailing */) ?? this.bands.length - 1;
    return [i0, i1];
  }
  ticksEvery([i0, i1] = [0, this.bands.length], visibleRange, tickEvery, tickOffset, extend) {
    const { bands } = this;
    const offset = i0;
    const span = i1 - i0 + 1;
    let startIndex = offset + Math.floor(visibleRange[0] * span);
    let endIndex = offset + Math.ceil(visibleRange[1] * span);
    if (extend) {
      startIndex -= tickEvery;
      endIndex += tickEvery;
    }
    startIndex = Math.max(startIndex, 0);
    endIndex = Math.min(endIndex, bands.length);
    let ticks;
    if (tickEvery <= 1) {
      ticks = bands.slice(startIndex, endIndex);
    } else {
      ticks = [];
      for (let index = startIndex; index < endIndex; index += 1) {
        if ((index - offset + tickOffset) % tickEvery === 0) {
          ticks.push(bands[index]);
        }
      }
    }
    return ticks;
  }
};
function domainReversed(domain) {
  return domain.length > 0 && domain[0] > domain[domain.length - 1];
}

// packages/ag-charts-community/src/scale/unitTimeScale.ts
import { Logger as Logger16, findMaxIndex as findMaxIndex2, findMinIndex as findMinIndex2, isPlainObject as isPlainObject7 } from "ag-charts-core";
var MAX_BANDS = 5e7;
var UnitTimeScale = class _UnitTimeScale extends DiscreteTimeScale {
  constructor() {
    super(...arguments);
    this.type = "unit-time";
    this.defaultTickCount = 12;
    this._domain = [];
    /* eslint-enable */
    this._bands = void 0;
  }
  static is(value) {
    return value instanceof _UnitTimeScale;
  }
  static supportsInterval(domain, interval) {
    return supportsInterval(domain, interval);
  }
  set domain(domain) {
    if (domain === this._domain)
      return;
    this._domain = domain;
    this._bands = void 0;
  }
  get domain() {
    return this._domain;
  }
  get interval() {
    return this._interval;
  }
  set interval(interval) {
    if (this._interval === interval)
      return;
    this._interval = interval;
    this._bands = void 0;
  }
  get bands() {
    this._bands ?? (this._bands = this.calculateBands(this._domain, [0, 1]).bands);
    return this._bands;
  }
  normalizeDomains(...domains) {
    return normalizeContinuousDomains(...domains);
  }
  convert(value, options) {
    if (!(value instanceof Date))
      value = new Date(value);
    const { domain, interval } = this;
    if (domain.length < 2)
      return NaN;
    if (options?.clamp !== true && interval != null) {
      const t = value.valueOf();
      const [start2, stop] = calculateBandRange(domain, interval);
      const d0 = Math.min(start2.valueOf(), stop.valueOf());
      const d1 = Math.max(start2.valueOf(), stop.valueOf());
      if (t < d0 || t >= d1 + intervalMilliseconds(interval))
        return NaN;
    }
    return super.convert(value, options);
  }
  calculateBands(domain, visibleRange, extend = false) {
    if (domain === this.domain && visibleRange[0] === 0 && visibleRange[1] === 1 && !extend && this._bands != null) {
      return { bands: this._bands, firstBandIndex: 0 };
    }
    if (domain.length < 2)
      return { bands: [], firstBandIndex: void 0 };
    const { interval } = this;
    if (interval == null)
      return { bands: [], firstBandIndex: void 0 };
    const rangeParams = { visibleRange, extend };
    if (!supportsInterval(domain, interval, rangeParams))
      return { bands: [], firstBandIndex: void 0 };
    const [start2, stop] = calculateBandRange(domain, interval);
    if (intervalRangeCount(interval, start2, stop, rangeParams) > MAX_BANDS) {
      Logger16.warnOnce(`the configured unit results in too many bands, ignoring. Supply a larger unit.`);
      return { bands: [], firstBandIndex: void 0 };
    }
    const bands = intervalRange(interval, start2, stop, rangeParams);
    const firstBandIndex = intervalRangeStartIndex(interval, start2, stop, rangeParams);
    return { bands, firstBandIndex };
  }
  ticks({ interval }, domain = this.domain, visibleRange = [0, 1], { extend = false } = {}) {
    if (domain.length < 2)
      return;
    const { bands, firstBandIndex } = this.calculateBands(domain, visibleRange, extend);
    const milliseconds = this.interval ? intervalMilliseconds(this.interval) : Infinity;
    if (interval == null)
      return { ticks: bands, count: void 0, firstTickIndex: firstBandIndex };
    const d0 = Math.min(domain[0].valueOf(), domain[1].valueOf());
    const d1 = Math.max(domain[0].valueOf(), domain[1].valueOf());
    let intervalTicks;
    let intervalStartIndex;
    let intervalEndIndex;
    if (isPlainObject7(interval) || typeof interval === "string") {
      intervalTicks = intervalRange(interval, domain[0], domain[1], { extend: true, visibleRange });
      intervalStartIndex = 0;
      intervalEndIndex = intervalTicks.length - 1;
    } else {
      intervalTicks = bands;
      intervalStartIndex = findMaxIndex2(0, bands.length - 1, (index) => bands[index].valueOf() <= d0) ?? 0;
      intervalEndIndex = findMaxIndex2(0, bands.length - 1, (index) => bands[index].valueOf() <= d1) ?? bands.length - 1;
    }
    const ticks = [];
    let lastIndex;
    for (let i = intervalStartIndex; i <= intervalEndIndex; i++) {
      const intervalTickValue = intervalTicks[i].valueOf();
      const bandIndex = findMaxIndex2(0, bands.length - 1, (index) => bands[index].valueOf() <= intervalTickValue);
      const tick = bandIndex != null && bandIndex != lastIndex ? bands[bandIndex] : void 0;
      lastIndex = bandIndex;
      if (tick != null && intervalTickValue - tick.getTime() <= milliseconds)
        ticks.push(tick);
    }
    let bandStart;
    let bandEnd;
    if (this.interval) {
      const bandRange = calculateBandRange([new Date(d0), new Date(d1)], this.interval);
      bandStart = bandRange[0].valueOf();
      bandEnd = bandRange[1].valueOf();
    } else {
      bandStart = d0;
      bandEnd = d1;
    }
    let firstTickIndex = findMinIndex2(0, ticks.length - 1, (i) => ticks[i].valueOf() >= bandStart) ?? 0;
    let lastTickIndex = findMaxIndex2(0, ticks.length - 1, (i) => ticks[i].valueOf() <= bandEnd) ?? ticks.length - 1;
    if (extend) {
      firstTickIndex = Math.max(firstTickIndex - 1, 0);
      lastTickIndex = Math.min(lastTickIndex + 1, ticks.length - 1);
    }
    return {
      ticks: ticks.slice(firstTickIndex, lastTickIndex + 1),
      count: ticks.length,
      firstTickIndex: firstBandIndex
    };
  }
};
function supportsInterval(domain, interval, rangeParams) {
  const [start2, stop] = calculateBandRange(domain, interval);
  return intervalRangeCount(interval, start2, stop, rangeParams) <= MAX_BANDS;
}
function calculateBandRange(domain, interval) {
  const start2 = intervalFloor(interval, domain[0]);
  const stop = intervalFloor(interval, domain[1]);
  return [start2, stop];
}

// packages/ag-charts-community/src/scene/util/labelPlacement.ts
import { boxCollides, boxContains as boxContains2 } from "ag-charts-core";
function circleRectOverlap({ point: c, anchor: unitCenter }, x, y, w, h) {
  if (c.size === 0) {
    return false;
  }
  let cx = c.x;
  let cy = c.y;
  if (unitCenter != null) {
    cx -= (unitCenter.x - 0.5) * c.size;
    cy -= (unitCenter.y - 0.5) * c.size;
  }
  let edgeX = cx;
  if (cx < x) {
    edgeX = x;
  } else if (cx > x + w) {
    edgeX = x + w;
  }
  let edgeY = cy;
  if (cy < y) {
    edgeY = y;
  } else if (cy > y + h) {
    edgeY = y + h;
  }
  const dx = cx - edgeX;
  const dy = cy - edgeY;
  const d = Math.sqrt(dx * dx + dy * dy);
  return d <= c.size * 0.5;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === "object" && typeof x.label === "object";
}
var labelPlacements = {
  top: { x: 0, y: -1 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  "top-left": { x: -1, y: -1 },
  "top-right": { x: 1, y: -1 },
  "bottom-left": { x: -1, y: 1 },
  "bottom-right": { x: 1, y: 1 }
};
function placeLabels(data, bounds, padding2 = 5) {
  const result = /* @__PURE__ */ new Map();
  const previousResults = [];
  const sortedDataClone = new Map(
    [...data.entries()].map(([k, d]) => [k, d.toSorted((a, b) => b.point.size - a.point.size)])
  );
  const dataValues = [...sortedDataClone.values()].flat();
  for (const [seriesId, datums] of sortedDataClone.entries()) {
    const labels = [];
    if (!datums[0]?.label)
      continue;
    for (let index = 0, ln = datums.length; index < ln; index++) {
      const d = datums[index];
      const { point, label, anchor } = d;
      const { text, width: width2, height: height2 } = label;
      const r = point.size * 0.5;
      let dx = 0;
      let dy = 0;
      if (r > 0 && d.placement != null) {
        const placement = labelPlacements[d.placement];
        dx = (width2 * 0.5 + r + padding2) * placement.x;
        dy = (height2 * 0.5 + r + padding2) * placement.y;
      }
      const x = point.x - width2 * 0.5 + dx - ((anchor?.x ?? 0.5) - 0.5) * point.size;
      const y = point.y - height2 * 0.5 + dy - ((anchor?.y ?? 0.5) - 0.5) * point.size;
      const withinBounds = boxContains2(bounds, x, y, width2, height2);
      if (!withinBounds)
        continue;
      const overlapPoints = dataValues.some((dataDatum) => circleRectOverlap(dataDatum, x, y, width2, height2));
      if (overlapPoints)
        continue;
      const overlapLabels = previousResults.some((pr) => boxCollides(pr, x, y, width2, height2));
      if (overlapLabels)
        continue;
      const resultDatum = { index, text, x, y, width: width2, height: height2, datum: d };
      labels.push(resultDatum);
      previousResults.push(resultDatum);
    }
    result.set(seriesId, labels);
  }
  return result;
}

// packages/ag-charts-community/src/util/secondaryAxisTicks.ts
import { countFractionDigits as countFractionDigits2 } from "ag-charts-core";
function calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange) {
  let [d0, d1] = findMinMax(domain.map(Number));
  const unzoomedTickCount = Math.floor(primaryTickCount.unzoomed);
  if (unzoomedTickCount <= 1) {
    const [start3, stop2] = domainWithOddTickCount(d0, d1);
    const tickCount = 5 * Math.pow(2, -Math.ceil(Math.log2(visibleRange[1] - visibleRange[0])));
    const { ticks: ticks2 } = createTicks(start3, stop2, tickCount, void 0, void 0, visibleRange);
    const d2 = [scale2.toDomain(start3), scale2.toDomain(stop2)];
    if (reverse)
      d2.reverse();
    return { domain: d2, ticks: ticks2 };
  }
  if (d0 === d1) {
    const order = Math.floor(Math.log10(d0));
    const magnitude = Math.pow(10, order);
    const rangeOffsetStep = Math.min(magnitude, 1);
    const rangeOffset = unzoomedTickCount - 1;
    d0 -= rangeOffsetStep * Math.floor(rangeOffset / 2);
    d1 = d0 + rangeOffsetStep * rangeOffset;
  }
  let start2 = d0;
  let stop = d1;
  start2 = calculateNiceStart(start2, stop, unzoomedTickCount);
  const baseStep = getTickStep(start2, stop, unzoomedTickCount);
  const segments = unzoomedTickCount - 1;
  stop = start2 + segments * baseStep;
  const stepAlignedStart = Math.floor(start2 / baseStep) * baseStep;
  const stepAlignedStop = Math.floor(stop / baseStep) * baseStep;
  if (stepAlignedStart <= d0 && stepAlignedStop >= d1) {
    start2 = stepAlignedStart;
    stop = stepAlignedStop;
  }
  const d = [scale2.toDomain(start2), scale2.toDomain(stop)];
  if (reverse)
    d.reverse();
  const step = baseStep * ((primaryTickCount.unzoomed - 1) / (primaryTickCount.zoomed - 1));
  const ticks = getTicks(start2, step, Math.floor(primaryTickCount.zoomed));
  return { domain: d, ticks };
}
function domainWithOddTickCount(d0, d1) {
  let start2 = d0;
  let stop = d1;
  let iterations = 0;
  do {
    [start2, stop] = niceTicksDomain(start2, stop);
    const { ticks } = createTicks(start2, stop, 5);
    if (ticks.length % 2 === 1)
      return [start2, stop];
    start2 -= 1;
    stop += 1;
  } while (iterations++ < 10);
  return [d0, d1];
}
function calculateNiceStart(a, b, count) {
  a = Math.floor(a);
  const rawStep = Math.abs(b - a) / (count - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start2, step, count) {
  const fractionDigits = countFractionDigits2(step);
  const f = Math.pow(10, fractionDigits);
  const ticks = [];
  for (let i = 0; i < count; i++) {
    const tick = start2 + step * i;
    ticks.push(Math.round(tick * f) / f);
  }
  return ticks;
}
function getTickStep(start2, stop, count) {
  const segments = count - 1;
  const rawStep = (stop - start2) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  const step = rawStep / magnitude;
  if (step > 0 && step <= 1)
    return magnitude;
  if (step > 1 && step <= 2)
    return 2 * magnitude;
  if (step > 2 && step <= 5)
    return 5 * magnitude;
  if (step > 5 && step <= 10)
    return 10 * magnitude;
  return rawStep;
}

// packages/ag-charts-community/src/util/tempUtils.ts
function createIdsGenerator() {
  const idsCounter = /* @__PURE__ */ new Map();
  return (name) => {
    const counter = idsCounter.get(name);
    if (counter) {
      idsCounter.set(name, counter + 1);
      return `${name}_${counter}`;
    }
    idsCounter.set(name, 1);
    return name;
  };
}

// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts
var DENSE_TICK_COUNT = 18;
var TICK_STEP_VALUES = [1, 2, 3, 4, 6, 8, 9, 10, 12];
var sunday2 = new Date(1970, 0, 4);
var AxisTickGenerator = class {
  constructor(axis) {
    this.axis = axis;
  }
  estimateTickCount(domain, range3, visibleRange, defaultTickMinSpacing, minSpacing, maxSpacing) {
    const { scale: scale2, label } = this.axis;
    const { defaultTickCount } = scale2;
    const rangeExtent = findRangeExtent(range3);
    const zoomExtent = findRangeExtent(visibleRange);
    if (CategoryScale.is(scale2)) {
      const maxTickCount = domain.length;
      let estimatedTickCount = Math.ceil(rangeExtent / (zoomExtent * label.fontSize));
      estimatedTickCount = Math.min(estimatedTickCount, maxTickCount);
      return {
        minTickCount: 0,
        maxTickCount,
        tickCount: estimatedTickCount
      };
    }
    return estimateTickCount(
      rangeExtent,
      zoomExtent,
      minSpacing,
      maxSpacing,
      defaultTickCount,
      defaultTickMinSpacing
    );
  }
  generateTicks({
    range: range3,
    domain,
    reverse,
    primaryTickCount,
    defaultTickMinSpacing,
    visibleRange,
    niceMode,
    parallelFlipRotation,
    regularFlipRotation,
    labelX,
    sideFlag,
    removeOverflowLabels,
    removeOverflowThreshold = 0,
    sizeLimit
  }) {
    const {
      label,
      primaryLabel,
      interval: { minSpacing, maxSpacing }
    } = this.axis;
    const { parallel, fontFamily, fontSize, fontStyle, fontWeight } = label;
    const secondaryAxis = primaryTickCount !== void 0;
    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation(
      label.rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    );
    const { maxTickCount } = this.estimateTickCount(
      domain,
      range3,
      visibleRange,
      defaultTickMinSpacing,
      minSpacing,
      maxSpacing
    );
    const maxIterations = Number.isFinite(maxTickCount) ? maxTickCount : 10;
    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
    const font2 = { fontFamily, fontSize, fontStyle, fontWeight };
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });
    const checkLabelOverlap = label.enabled && label.avoidCollisions;
    const initialRotation = configuredRotation + defaultRotation;
    const labelMatrix = new Matrix();
    const updateLabelMatrix = (iterationRotation) => {
      const labelRotation = initialRotation + iterationRotation;
      Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);
    };
    const getLabelData = ({ ticks }, iterationRotation) => {
      updateLabelMatrix(iterationRotation);
      return createLabelData(ticks, labelX, labelMatrix, textMeasurer, label);
    };
    const getTimeLabelData = (tickData2, iterationRotation) => {
      const { niceDomain, ticks, timeInterval: timeInterval3 } = tickData2;
      if (timeInterval3 == null)
        return [];
      updateLabelMatrix(iterationRotation);
      const spacing = ticksSpacing(ticks);
      const { width: width2, height: height2 } = timeIntervalMaxLabelSize(
        label,
        primaryLabel,
        niceDomain ?? domain,
        timeInterval3,
        textMeasurer
      );
      return createFixedLabelData({ width: width2, height: height2, spacing }, labelX, labelMatrix);
    };
    const getLabelOverlap = (tickData2, iterationRotation) => {
      if (!checkLabelOverlap)
        return false;
      const rotated = configuredRotation !== 0 || iterationRotation !== 0;
      const labelSpacing = getLabelSpacing(label.minSpacing, rotated);
      return axisLabelsOverlap(getTimeLabelData(tickData2, iterationRotation), labelSpacing) || axisLabelsOverlap(getLabelData(tickData2, iterationRotation), labelSpacing);
    };
    let tickData = {
      tickDomain: [],
      niceDomain: domain,
      ticks: [],
      rawTicks: [],
      rawTickCount: void 0,
      timeInterval: void 0,
      fractionDigits: 0
    };
    let index = 0;
    let autoRotation = 0;
    let labelOverlap = true;
    let terminate = false;
    while (!terminate && labelOverlap && index <= maxIterations) {
      autoRotation = 0;
      for (const strategy of this.getTickStrategies({
        domain,
        range: range3,
        reverse,
        niceMode,
        secondaryAxis,
        sizeLimit
      })) {
        ({ tickData, index, autoRotation, terminate } = strategy({
          index,
          tickData,
          terminate,
          primaryTickCount,
          defaultTickMinSpacing,
          visibleRange,
          labelsOverlap() {
            return getLabelOverlap(tickData, autoRotation);
          }
        }));
      }
      labelOverlap = getLabelOverlap(tickData, autoRotation);
    }
    const textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
    const rotation = configuredRotation + autoRotation;
    if (removeOverflowLabels && tickData.ticks.length > 2) {
      const labelData = getLabelData(tickData, autoRotation);
      const lastTick = tickData.ticks.at(-1);
      const lastLabel = labelData.at(-1);
      if (lastTick != null && lastLabel != null && lastTick.translation + lastLabel.label.width / 2 > range3[1] + removeOverflowThreshold) {
        lastTick.tickLabel = void 0;
        if (visibleRange[0] === 0 && visibleRange[1] === 1) {
          tickData.ticks[0].tickLabel = void 0;
        }
      }
    }
    return { tickData, rotation, textBaseline, textAlign };
  }
  getTickStrategies({
    domain,
    range: range3,
    reverse,
    niceMode,
    secondaryAxis,
    sizeLimit
  }) {
    const { label, interval } = this.axis;
    const avoidLabelCollisions = label.enabled && label.avoidCollisions;
    const autoRotate = label.autoRotate === true && label.rotation === void 0;
    const strategies = [];
    let tickGenerationType;
    if (interval.values) {
      tickGenerationType = 2 /* VALUES */;
    } else if (secondaryAxis) {
      tickGenerationType = 1 /* CREATE_SECONDARY */;
    } else {
      tickGenerationType = 0 /* CREATE */;
    }
    const tickGenerationStrategy = ({
      index,
      tickData,
      primaryTickCount,
      defaultTickMinSpacing,
      visibleRange,
      terminate
    }) => this.createTickData(
      domain,
      range3,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount,
      defaultTickMinSpacing,
      tickGenerationType,
      index,
      tickData,
      terminate,
      sizeLimit
    );
    strategies.push(tickGenerationStrategy);
    if (avoidLabelCollisions && autoRotate) {
      const autoRotateStrategy = ({ index, tickData, labelsOverlap, terminate }) => ({
        index,
        tickData,
        autoRotation: labelsOverlap() ? normalizeAngle360FromDegrees(label.autoRotateAngle) : 0,
        terminate
      });
      strategies.push(autoRotateStrategy);
    }
    return strategies;
  }
  createTickData(domain, range3, reverse, niceMode, visibleRange, primaryTickCount, defaultTickMinSpacing, tickGenerationType, index, previousTickData, terminate, sizeLimit) {
    const { interval } = this.axis;
    const { step, values, minSpacing, maxSpacing } = interval;
    const { maxTickCount, minTickCount, tickCount } = this.estimateTickCount(
      domain,
      range3,
      visibleRange,
      defaultTickMinSpacing,
      minSpacing,
      maxSpacing
    );
    const maxIterations = tickCount - minTickCount;
    const countTicks2 = (i) => Math.max(tickCount - i, minTickCount);
    const previousTicks = previousTickData.rawTicks;
    const regenerateTicks = step == null && values == null && countTicks2(index) > minTickCount;
    const getTickParams = {
      domain,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount,
      tickGenerationType,
      minTickCount,
      maxTickCount,
      tickCount: 0
    };
    getTickParams.tickCount = countTicks2(index);
    let nextTicks = this.getTicks(getTickParams);
    if (regenerateTicks && ticksEqual(nextTicks.rawTicks, previousTicks)) {
      let lowerBound = index;
      let upperBound = maxIterations;
      while (lowerBound <= upperBound) {
        index = (lowerBound + upperBound) / 2 | 0;
        getTickParams.tickCount = countTicks2(index);
        const nextTicksCandidate = this.getTicks(getTickParams);
        if (ticksEqual(nextTicksCandidate.rawTicks, previousTicks)) {
          lowerBound = index + 1;
        } else {
          nextTicks = nextTicksCandidate;
          upperBound = index - 1;
        }
      }
    }
    const {
      tickDomain,
      niceDomain,
      rawTicks,
      rawTickCount,
      rawFirstTickIndex,
      generatePrimaryTicks,
      primaryTicksIndices,
      alignment,
      fractionDigits,
      timeInterval: timeInterval3
    } = nextTicks;
    const ticks = this.formatTicks({
      range: range3,
      niceDomain,
      rawTicks,
      rawFirstTickIndex,
      generatePrimaryTicks,
      primaryTicksIndices,
      alignment,
      fractionDigits,
      timeInterval: timeInterval3,
      sizeLimit
    });
    const tickData = {
      tickDomain,
      niceDomain,
      rawTicks,
      rawTickCount,
      timeInterval: timeInterval3,
      fractionDigits,
      ticks
    };
    index += 1;
    terminate || (terminate = step != null || values != null);
    return { tickData, index, autoRotation: 0, terminate };
  }
  getTimeIntervalTicks(visibleRange, tickCount, maxTickCount, tickParams, timeInterval3, reverse) {
    const parentInterval = intervalHierarchy(timeInterval3);
    if (parentInterval == null)
      return;
    const { scale: scale2 } = this.axis;
    if (!TimeScale.is(scale2) && !DiscreteTimeScale.is(scale2))
      return;
    if (reverse) {
      visibleRange = [1 - visibleRange[1], 1 - visibleRange[0]];
    }
    const dv0 = Math.min(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
    const dv1 = Math.max(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
    let [dp0, dp1] = intervalExtent(new Date(dv0), new Date(dv1), visibleRange);
    dp0 = intervalFloor(parentInterval, dp0);
    if (dp0.valueOf() >= dv0)
      dp0 = intervalPrevious(parentInterval, dp0);
    dp1 = intervalCeil(parentInterval, dp1);
    if (dp1.valueOf() <= dv1)
      dp1 = intervalNext(parentInterval, dp1);
    const primaryTicks = intervalRange(parentInterval, dp0, dp1);
    const milliseconds = intervalMilliseconds(timeInterval3);
    let primaryTicksIndices = /* @__PURE__ */ new Set();
    const skipFirstPrimaryTick = OrdinalTimeScale.is(scale2);
    const ticks = [];
    const intervalTickParams = {
      ...tickParams,
      interval: timeInterval3
    };
    let parentLevelMode;
    let alignment;
    let ordinalTickStep = 0;
    if (OrdinalTimeScale.is(scale2)) {
      const minimumTimeGranularity = this.axis.minimumTimeGranularity;
      const timeIntervalGranularity = intervalUnit(timeInterval3);
      parentLevelMode = minimumTimeGranularity != null && intervalMilliseconds(minimumTimeGranularity) >= intervalMilliseconds(timeIntervalGranularity) ? 2 /* OrdinalTimeStepTicks */ : 3 /* OrdinalTimeScaleTicks */;
      alignment = 1 /* Trailing */;
      const tickDensity = tickCount / maxTickCount;
      const baseTickStep = scale2.bandCount(visibleRange) / (tickDensity * DENSE_TICK_COUNT);
      ordinalTickStep = TICK_STEP_VALUES.findLast((t) => baseTickStep >= t) ?? 1;
    } else if (UnitTimeScale.is(scale2) && (scale2.interval == null || intervalMilliseconds(scale2.interval) >= milliseconds)) {
      parentLevelMode = 1 /* UnitTimeScaleTicks */;
    } else {
      parentLevelMode = 0 /* ContinuousTimeScaleTicks */;
      alignment = 2 /* Interpolate */;
    }
    for (let i = 0; i < primaryTicks.length - 1; i += 1) {
      const p0 = primaryTicks[i];
      const p1 = primaryTicks[i + 1];
      const first2 = i === 0;
      const last = i === primaryTicks.length - 2;
      const dp = p1.valueOf() - p0.valueOf();
      const pVisibleRange = [
        Math.max((dv0 - p0.valueOf()) / dp, 0),
        Math.min((dv1 - p0.valueOf()) / dp, 1)
      ];
      let intervalTicks;
      switch (parentLevelMode) {
        case 0 /* ContinuousTimeScaleTicks */:
          intervalTicks = createTimeScaleTicks(
            intervalTickParams.interval,
            [p0, p1],
            pVisibleRange,
            true
          ).ticks;
          break;
        case 1 /* UnitTimeScaleTicks */:
        case 3 /* OrdinalTimeScaleTicks */:
          const scaleTicks = scale2.ticks(intervalTickParams, [p0, p1], pVisibleRange, {
            extend: true,
            dropInitial: true
          });
          intervalTicks = scaleTicks?.ticks ?? [];
          break;
        case 2 /* OrdinalTimeStepTicks */:
          intervalTicks = scale2.stepTicks(
            ordinalTickStep,
            [p0, p1],
            void 0,
            !last
          );
          break;
      }
      dropFirstWhile(intervalTicks, (firstTick2) => firstTick2.valueOf() < p0.valueOf());
      if (!last) {
        dropLastWhile(intervalTicks, (lastTick) => {
          switch (parentLevelMode) {
            case 0 /* ContinuousTimeScaleTicks */:
            case 3 /* OrdinalTimeScaleTicks */:
              return lastTick.valueOf() + milliseconds > p1.valueOf();
            case 1 /* UnitTimeScaleTicks */:
            case 2 /* OrdinalTimeStepTicks */:
              return lastTick.valueOf() >= p1.valueOf();
          }
        });
      }
      if (intervalTicks.length === 0)
        continue;
      const firstTick = intervalTicks[0];
      const firstTickDiff = compareDates(firstTick, p0);
      const firstPrimary = parentLevelMode === 0 /* ContinuousTimeScaleTicks */ ? firstTickDiff === 0 : firstTickDiff <= milliseconds;
      if (firstPrimary && (!skipFirstPrimaryTick || !first2)) {
        primaryTicksIndices.add(ticks.length);
      }
      ticks.push(...intervalTicks);
    }
    if (primaryTicksIndices.size === 0 || // If there's only one primary tick and it's the first tick, don't show primary ticks
    primaryTicksIndices.size === 1 && primaryTicksIndices.has(0)) {
      primaryTicksIndices = void 0;
    }
    let firstTickIndex;
    return { ticks, tickCount: void 0, firstTickIndex, primaryTicksIndices, alignment };
  }
  getTicks({
    domain,
    reverse,
    niceMode,
    visibleRange,
    tickGenerationType,
    tickCount,
    minTickCount,
    maxTickCount,
    primaryTickCount
  }) {
    const { axis } = this;
    const { primaryLabel, scale: scale2, interval } = axis;
    const domainParams = {
      nice: niceMode === 0 /* TickAndDomain */,
      interval: interval.step,
      tickCount,
      minTickCount,
      maxTickCount
    };
    const tickParams = {
      ...domainParams,
      nice: niceMode === 0 /* TickAndDomain */ || niceMode === 1 /* TicksOnly */
    };
    let secondaryAxisTicks;
    if (tickGenerationType === 1 /* CREATE_SECONDARY */ && primaryTickCount != null && ContinuousScale.is(scale2)) {
      secondaryAxisTicks = calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange);
    }
    const niceDomain = niceMode === 0 /* TickAndDomain */ ? secondaryAxisTicks?.domain ?? scale2.niceDomain(domainParams, domain) : domain;
    let tickDomain = niceDomain;
    let rawTicks;
    let rawTickCount;
    let rawFirstTickIndex;
    let timeInterval3;
    let primaryTicksIndices;
    let alignment;
    const generatePrimaryTicks = primaryLabel?.enabled === true && tickParams.interval == null;
    const scaleDomain = scale2.domain;
    scale2.domain = niceDomain;
    switch (tickGenerationType) {
      case 2 /* VALUES */:
        tickDomain = interval.values;
        rawTicks = interval.values;
        rawTickCount = rawTicks.length;
        if (OrdinalTimeScale.is(scale2)) {
          alignment = 1 /* Trailing */;
        } else if (UnitTimeScale.is(scale2)) {
          alignment = 2 /* Interpolate */;
        }
        if (ContinuousScale.is(scale2)) {
          const [d0, d1] = findMinMax(niceDomain.map(Number));
          rawTicks = rawTicks.filter((value) => Number(value) >= d0 && Number(value) <= d1).sort((a, b) => Number(a) - Number(b));
        }
        break;
      case 1 /* CREATE_SECONDARY */:
        if (secondaryAxisTicks) {
          rawTicks = secondaryAxisTicks.ticks;
          rawTickCount = secondaryAxisTicks.ticks.length;
        } else {
          const tickGeneration = scale2.ticks(tickParams, niceDomain, visibleRange);
          rawTicks = tickGeneration?.ticks ?? [];
          rawTickCount = tickGeneration?.count;
        }
        break;
      default: {
        if (niceDomain.length > 0 && tickParams.interval == null && (UnitTimeScale.is(scale2) || generatePrimaryTicks && (TimeScale.is(scale2) || OrdinalTimeScale.is(scale2)))) {
          const dates = niceDomain;
          const start2 = Math.min(dates[0].valueOf(), dates[dates.length - 1].valueOf());
          const end2 = Math.max(dates[0].valueOf(), dates[dates.length - 1].valueOf());
          timeInterval3 = getTickTimeInterval(start2, end2, tickCount, minTickCount, maxTickCount, {
            weekStart: primaryLabel == null ? sunday2 : void 0,
            primaryOnly: true
          });
        }
        let minTimeInterval;
        if (OrdinalTimeScale.is(scale2)) {
          minTimeInterval = axis.minimumTimeGranularity;
        } else if (UnitTimeScale.is(scale2)) {
          minTimeInterval = scale2.interval;
        }
        if (minTimeInterval != null && timeInterval3 != null && // Prefer UnitTimeAxis.unit over this interval, because the user may have defined an epoch
        intervalMilliseconds(minTimeInterval) >= intervalMilliseconds(timeInterval3)) {
          timeInterval3 = minTimeInterval;
        }
        const intervalTicks = timeInterval3 ? this.getTimeIntervalTicks(
          visibleRange,
          tickCount,
          maxTickCount,
          tickParams,
          timeInterval3,
          reverse
        ) : void 0;
        if (intervalTicks) {
          ({
            ticks: rawTicks,
            tickCount: rawTickCount,
            firstTickIndex: rawFirstTickIndex,
            primaryTicksIndices,
            alignment
          } = intervalTicks);
        } else {
          const intervalTickParams = UnitTimeScale.is(scale2) && tickParams.interval == null && timeInterval3 != null ? { ...tickParams, interval: timeInterval3 } : tickParams;
          const tickGeneration = scale2.ticks(intervalTickParams, niceDomain, visibleRange);
          rawTicks = tickGeneration?.ticks ?? [];
          rawTickCount = tickGeneration?.count;
          rawFirstTickIndex = tickGeneration?.firstTickIndex;
          if (TimeScale.is(scale2) || DiscreteTimeScale.is(scale2)) {
            const timeTickParams = tickParams;
            const paramsInterval = typeof timeTickParams.interval === "number" ? lowestGranularityForInterval(timeTickParams.interval) : timeTickParams.interval;
            timeInterval3 ?? (timeInterval3 = paramsInterval ?? tickGeneration?.timeInterval);
          }
        }
      }
    }
    const fractionDigits = rawTicks.reduce(
      (max, tick) => Math.max(max, typeof tick === "number" ? countFractionDigits3(tick) : 0),
      0
    );
    if (!generatePrimaryTicks) {
      primaryTicksIndices = void 0;
    }
    scale2.domain = scaleDomain;
    return {
      tickDomain,
      niceDomain,
      rawTicks,
      rawTickCount,
      rawFirstTickIndex,
      generatePrimaryTicks,
      primaryTicksIndices,
      alignment,
      fractionDigits,
      timeInterval: timeInterval3
    };
  }
  formatTicks({
    niceDomain,
    range: range3,
    rawTicks,
    rawFirstTickIndex = 0,
    generatePrimaryTicks,
    primaryTicksIndices,
    alignment,
    fractionDigits,
    timeInterval: timeInterval3,
    sizeLimit = Infinity
  }) {
    const { axis } = this;
    const { label, scale: scale2 } = axis;
    const scaleDomain = scale2.domain;
    scale2.domain = niceDomain;
    const dateStyle = generatePrimaryTicks ? "component" : "long";
    const axisTickFormatter = label.enabled ? axis.tickFormatter(niceDomain, rawTicks, false, fractionDigits, timeInterval3, dateStyle) : void 0;
    const parentInterval = timeInterval3 != null ? intervalHierarchy(timeInterval3) : void 0;
    const axisPrimaryTickFormatter = generatePrimaryTicks ? axis.tickFormatter(niceDomain, rawTicks, true, fractionDigits, parentInterval, dateStyle) : void 0;
    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;
    const ticks = [];
    const continuous = TimeScale.is(scale2) || DiscreteTimeScale.is(scale2);
    const idGenerator = createIdsGenerator();
    const isVertical = axis.direction === "y" /* Y */;
    const maxBand = (BandScale.is(scale2) ? scale2.bandwidth : null) ?? Infinity;
    const wrapOptions = {
      font: label,
      maxWidth: isVertical ? sizeLimit : maxBand,
      maxHeight: isVertical ? maxBand : sizeLimit,
      overflow: label.truncate ? "ellipsis" : "hide",
      textWrap: label.wrapping
    };
    for (let i = 0; i < rawTicks.length; i++) {
      const tick = rawTicks[i];
      const translation = scale2.convert(tick, { alignment }) + halfBandwidth;
      if (range3.length > 0 && !axis.inRange(translation, 1e-3))
        continue;
      const primary = primaryTicksIndices?.has(i) ?? false;
      let tickLabel = primary ? axisPrimaryTickFormatter?.(tick, i) : axisTickFormatter?.(tick, i);
      const inputText = tickLabel ?? String(tick);
      if (label.avoidCollisions) {
        tickLabel = TextWrapper.wrapText(inputText, wrapOptions) || tickLabel;
      }
      let tickId;
      const continuousValue = continuous ? tick?.valueOf() : void 0;
      if (Number.isFinite(continuousValue)) {
        tickId = idGenerator(`v:${continuousValue}`);
      } else {
        tickId = idGenerator(`l:${tickLabel}`);
      }
      ticks.push({
        index: i + rawFirstTickIndex,
        tick,
        tickId,
        tickLabel,
        textUntruncated: tickLabel != null && inputText !== tickLabel ? inputText : void 0,
        translation: Math.floor(translation),
        primary
      });
    }
    scale2.domain = scaleDomain;
    return ticks;
  }
};
function axisLabelsOverlap(data, padding2 = 0) {
  const result = [];
  for (const datum of data) {
    const { x, y } = datum.point;
    let { width: width2, height: height2 } = datum.label;
    width2 += padding2;
    height2 += padding2;
    if (result.some((l) => boxCollides2(l, x, y, width2, height2))) {
      return true;
    }
    result.push({ x, y, width: width2, height: height2 });
  }
  return false;
}
function createTimeScaleTicks(interval, domain, visibleRange, extend) {
  if (interval == null) {
    return { ticks: domain, firstTickIndex: void 0 };
  }
  const d0 = domain[0].valueOf();
  const d1 = domain[1].valueOf();
  if (typeof interval !== "number") {
    const epoch = domain[0];
    const alignedInterval = typeof interval === "string" ? { unit: interval, epoch } : { ...interval, epoch };
    const ticks2 = intervalRange(alignedInterval, domain[0], domain[1], { visibleRange, extend });
    const firstTickIndex = intervalRangeStartIndex(alignedInterval, domain[0], domain[1], { visibleRange, extend });
    return { ticks: ticks2, firstTickIndex };
  }
  const ticks = [];
  for (let intervalTickTime = d0; intervalTickTime <= d1; intervalTickTime += interval) {
    ticks.push(new Date(intervalTickTime));
  }
  return { ticks, firstTickIndex: void 0 };
}
function ticksEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i += 1) {
    if (a[i]?.valueOf() !== b[i]?.valueOf()) {
      return false;
    }
  }
  return true;
}
function ticksSpacing(ticks) {
  if (ticks.length < 2)
    return Infinity;
  let spacing = 0;
  let y0 = ticks[0].translation;
  for (let i = 1; i < ticks.length; i++) {
    const y1 = ticks[i].translation;
    const delta3 = Math.abs(y1 - y0);
    spacing = Math.max(spacing, delta3);
    y0 = y1;
  }
  return spacing;
}

// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass([
  Property
], CartesianAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
  Property
], CartesianAxisLabel.prototype, "autoRotateAngle", 2);

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis = class _CartesianAxis extends Axis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.maxThicknessRatio = 0.3;
    this.headingLabelGroup = this.axisGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-Axis-heading` })
    );
    this.lineNodeGroup = this.axisGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-Axis-line` })
    );
    this.lineNode = this.lineNodeGroup.appendChild(new Line({ zIndex: 1 /* AxisLine */ }));
    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);
    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);
    this.gridFillGroupSelection = Selection.select(this.gridFillGroup, Rect, false);
    this.tempText = new TransformableText({ debugDirty: false });
    this.tempCaption = new Caption();
    this.tickGenerator = new AxisTickGenerator(this);
    this.animationManager = moduleCtx.animationManager;
    this.animationState = new StateMachine("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.resetSelectionNodes()
        },
        reset: "empty"
      },
      ready: {
        update: (data) => this.animateReadyUpdate(data),
        resize: () => this.resetSelectionNodes(),
        reset: "empty"
      }
    });
    this.headingLabelGroup.appendChild(this.title.caption.node);
    let previousSize = void 0;
    this.cleanup.register(
      moduleCtx.eventsHub.on("layout:complete", (e) => {
        const size = [e.chart.width, e.chart.height];
        if (previousSize != null && !arraysEqual2(size, previousSize)) {
          this.animationState.transition("resize");
        }
        previousSize = size;
      }),
      this.title.caption.registerInteraction(this.moduleCtx, "afterend")
    );
  }
  static is(value) {
    return value instanceof _CartesianAxis;
  }
  get horizontal() {
    return this.position === "top" || this.position === "bottom";
  }
  onGridVisibilityChange() {
    this.gridLineGroupSelection.clear();
    this.gridFillGroupSelection.clear();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    }
  }
  get direction() {
    return this.position === "top" || this.position === "bottom" ? "x" /* X */ : "y" /* Y */;
  }
  createAxisContext() {
    return { ...super.createAxisContext(), position: this.position };
  }
  createLabel() {
    return new CartesianAxisLabel();
  }
  updateDirection() {
    switch (this.position) {
      case "top":
        this.label.mirrored = true;
        this.label.parallel = true;
        break;
      case "right":
        this.label.mirrored = true;
        this.label.parallel = false;
        break;
      case "bottom":
        this.label.mirrored = false;
        this.label.parallel = true;
        break;
      case "left":
        this.label.mirrored = false;
        this.label.parallel = false;
        break;
    }
    if (this.axisContext) {
      this.axisContext.position = this.position;
      this.axisContext.direction = this.direction;
    }
  }
  calculateLayout(primaryTickCount, chartLayout) {
    this.updateDirection();
    return super.calculateLayout(primaryTickCount, chartLayout);
  }
  layoutCrossLines() {
    const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
    this.crossLines.forEach((crossLine) => {
      crossLine.calculateLayout?.(crosslinesVisible);
    });
  }
  calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount) {
    const sideFlag = this.label.getSideFlag();
    const rotation = this.horizontal ? -0.5 * Math.PI : 0;
    const parallelFlipRotation = normalizeAngle360(rotation);
    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
    const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);
    if (niceMode === 2 /* Off */ && this.label.enabled === false && this.tick.enabled === false && this.gridLine.enabled === false) {
      const { bbox: bbox2, spacing: spacing2 } = this.tickBBox(domain, [], []);
      const layout2 = {
        ticks: [],
        tickLines: [],
        gridLines: [],
        gridFills: [],
        labels: [],
        spacing: spacing2
      };
      return {
        ticks: [],
        rawTickCount: 0,
        tickDomain: domain,
        niceDomain: domain,
        fractionDigits: 0,
        timeInterval: void 0,
        bbox: bbox2,
        layout: layout2
      };
    }
    const { range: range3, reverse, defaultTickMinSpacing } = this;
    const removeOverflowLabels = this.label.avoidCollisions && this.horizontal && (ContinuousScale.is(this.scale) || DiscreteTimeScale.is(this.scale));
    const tickGenerationResult = this.tickGenerator.generateTicks({
      domain,
      range: range3,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount: initialPrimaryTickCount,
      defaultTickMinSpacing,
      parallelFlipRotation,
      regularFlipRotation,
      labelX,
      sideFlag,
      sizeLimit: this.chartLayout?.sizeLimit,
      removeOverflowLabels,
      removeOverflowThreshold: this.chartLayout?.padding.right
    });
    const { tickData } = tickGenerationResult;
    const { ticks, tickDomain, rawTicks, rawTickCount, fractionDigits, timeInterval: timeInterval3, niceDomain } = tickData;
    const labels = ticks.map((d) => this.getTickLabelProps(d, tickGenerationResult));
    const { position, gridPadding, gridLength } = this;
    const direction = position === "bottom" || position === "right" ? -1 : 1;
    const p1 = direction * gridPadding;
    const p2 = direction * (gridLength + gridPadding);
    const gridLines = this.calculateGridLines(ticks, p1, p2);
    const gridFills = this.calculateGridFills(ticks, p1, p2);
    const tickLines = this.calculateTickLines(ticks, direction);
    const { bbox, spacing } = this.tickBBox(tickDomain, ticks, labels);
    const layout = { ticks, gridLines, gridFills, tickLines, labels, spacing };
    return { ticks: rawTicks, rawTickCount, tickDomain, niceDomain, fractionDigits, timeInterval: timeInterval3, bbox, layout };
  }
  calculateGridLines(ticks, p1, p2) {
    return ticks.map((tick, index) => this.calculateGridLine(tick, index, p1, p2, ticks));
  }
  calculateGridLine({ index: tickIndex, tickId, translation: offset }, _index, p1, p2, _ticks) {
    const { gridLine, horizontal } = this;
    const [x1, y1, x2, y2] = horizontal ? [offset, p1, offset, p2] : [p1, offset, p2, offset];
    const { style } = gridLine;
    const { stroke: stroke2, strokeWidth = 0, lineDash } = style[tickIndex % style.length] ?? {};
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
  }
  calculateGridFills(ticks, p1, p2) {
    const { horizontal, range: range3, type } = this;
    const gridFills = [];
    if (ticks.length == 0)
      return gridFills;
    let gridFillIndexOffset = 0;
    const isVerticalUnitTime = !horizontal && type === "unit-time";
    const firstFillOffCanvas = isVerticalUnitTime && ticks[0].translation < range3[0] || !isVerticalUnitTime && ticks[0].translation > range3[0];
    if (firstFillOffCanvas) {
      const injectedTick = { tickId: `before:${ticks[0].tickId}`, translation: range3[0] };
      gridFills.push(this.calculateGridFill(injectedTick, -1, ticks[0].index, p1, p2, ticks));
      gridFillIndexOffset = 1;
    }
    gridFills.push(
      ...ticks.map(
        (tick, index) => this.calculateGridFill(tick, index, tick.index + gridFillIndexOffset, p1, p2, ticks)
      )
    );
    return gridFills;
  }
  calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks) {
    const { gridLine, horizontal, range: range3 } = this;
    const nextTick = ticks[index + 1];
    const startOffset = translation;
    const endOffset = nextTick ? nextTick.translation : range3[1];
    const [x1, y1, x2, y2] = horizontal ? [startOffset, Math.max(p1, p2), endOffset, Math.min(p1, p2)] : [Math.min(p1, p2), Math.min(startOffset, endOffset), Math.max(p1, p2), Math.max(startOffset, endOffset)];
    const { fill, fillOpacity } = gridLine.style[gridFillIndex % gridLine.style.length] ?? {};
    return { tickId, x1, y1, x2, y2, fill, fillOpacity };
  }
  calculateTickLines(ticks, direction) {
    return ticks.map((tick) => this.calculateTickLine(tick, tick.index, direction, ticks));
  }
  calculateTickLine({ primary, tickId, translation: offset }, _index, direction, _ticks) {
    const { horizontal, tick, primaryTick } = this;
    const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
    const h = -direction * this.getTickSize(datumTick);
    const [x1, y1, x2, y2] = horizontal ? [offset, 0, offset, h] : [0, offset, h, offset];
    const { stroke: stroke2, width: strokeWidth } = datumTick;
    const lineDash = void 0;
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
  }
  update() {
    this.updateDirection();
    const previousTicksIds = Array.from(this.tickLabelGroupSelection.nodes(), (node) => node.datum.tickId);
    super.update();
    this.tickLineGroup.visible = this.tick.enabled || (this.primaryTick?.enabled ?? false);
    this.tickLabelGroup.visible = this.label.enabled || (this.primaryTick?.enabled ?? false);
    const { tickLayout } = this;
    this.updateTitle(this.scale.domain, tickLayout?.spacing ?? 0);
    if (!this.animatable) {
      this.moduleCtx.animationManager.skipCurrentBatch();
    }
    if (tickLayout) {
      const { ticks } = tickLayout;
      if (this.animationManager.isSkipped()) {
        this.resetSelectionNodes();
      } else {
        const tickIds = ticks.map((datum) => datum.tickId);
        const diff2 = diffArrays(previousTicksIds, tickIds);
        this.animationState.transition("update", diff2);
      }
    }
    const { enabled, stroke: stroke2, width: width2 } = this.line;
    this.lineNode.setProperties({ stroke: stroke2, strokeWidth: enabled ? width2 : 0 });
    this.updateTickLines();
    this.updateGridLines();
    this.updateGridFills();
  }
  getAxisTransform() {
    return {
      translationX: Math.floor(this.translation.x),
      translationY: Math.floor(this.translation.y)
    };
  }
  updatePosition() {
    super.updatePosition();
    const axisTransform = this.getAxisTransform();
    this.tickLineGroup.datum = axisTransform;
    this.tickLabelGroup.datum = axisTransform;
    this.lineNodeGroup.datum = axisTransform;
    this.headingLabelGroup.datum = axisTransform;
  }
  getAxisLineCoordinates() {
    const { horizontal } = this;
    const [c1, c2] = findMinMax(this.range);
    return horizontal ? { x1: c1, x2: c2, y1: 0, y2: 0 } : { x1: 0, x2: 0, y1: c1, y2: c2 };
  }
  getTickLineBBox(datum) {
    const { translation } = datum;
    const { position, primaryTick } = this;
    let tickSize = this.getTickSize();
    if (primaryTick?.enabled) {
      tickSize = Math.max(tickSize, this.getTickSize(primaryTick));
    }
    switch (position) {
      case "top":
        return new BBox(translation, -tickSize, translation, tickSize);
      case "bottom":
        return new BBox(translation, 0, translation, tickSize);
      case "left":
        return new BBox(-tickSize, translation, tickSize, translation);
      case "right":
        return new BBox(0, translation, tickSize, translation);
    }
  }
  lineNodeBBox() {
    const { position, seriesAreaPadding } = this;
    const { y1, y2 } = this.getAxisLineCoordinates();
    const dy = y2 - y1;
    switch (position) {
      case "top":
        return new BBox(y1, -seriesAreaPadding, dy, seriesAreaPadding);
      case "bottom":
        return new BBox(y1, 0, dy, seriesAreaPadding);
      case "left":
        return new BBox(-seriesAreaPadding, y1, seriesAreaPadding, dy);
      case "right":
        return new BBox(0, y1, seriesAreaPadding, dy);
    }
  }
  titleBBox(domain, spacing) {
    const { tempCaption } = this;
    tempCaption.node.setProperties(this.titleProps(tempCaption, domain, spacing));
    return tempCaption.node.getBBox();
  }
  tickBBox(domain, ticks, labels) {
    const { tick, primaryTick, label, primaryLabel, title, position, horizontal, seriesAreaPadding } = this;
    const boxes = [];
    boxes.push(this.lineNodeBBox());
    if (tick.enabled || primaryTick?.enabled) {
      for (const datum of ticks) {
        boxes.push(this.getTickLineBBox(datum));
      }
    }
    const { tempText } = this;
    if (label.enabled) {
      for (const datum of labels) {
        if (!datum.visible)
          continue;
        tempText.setProperties(datum);
        const box = tempText.getBBox(false);
        if (box) {
          boxes.push(box);
        }
      }
    }
    if (primaryLabel?.enabled && position === "bottom") {
      const inexactMeasurementPadding = 2;
      boxes.push(
        new BBox(
          0,
          TextUtils.getLineHeight(label.fontSize) + inexactMeasurementPadding,
          1,
          this.getTickSize(tick) + label.spacing + seriesAreaPadding
        )
      );
      if (primaryLabel.format != null) {
        const { format } = primaryLabel;
        const formats = isPlainObject8(format) ? Object.values(format) : [format];
        const maxLines = formats.reduce((m, f) => Math.max(m, countLines(f)), 0);
        boxes.push(
          new BBox(
            0,
            this.getTickSize(primaryTick ?? tick) + primaryLabel.spacing + seriesAreaPadding,
            1,
            maxLines * TextUtils.getLineHeight(primaryLabel.fontSize) + inexactMeasurementPadding
          )
        );
      }
    }
    let spacing = 0;
    if (title.enabled) {
      const combined = BBox.merge(boxes);
      spacing = horizontal ? combined.height : combined.width;
      boxes.push(this.titleBBox(domain, spacing));
    }
    const bbox = BBox.merge(boxes);
    return { bbox, spacing };
  }
  titleProps(caption, domain, spacing) {
    const { title } = this;
    if (!title.enabled) {
      caption.enabled = false;
      return {
        visible: false,
        text: "",
        textBaseline: "bottom",
        x: 0,
        y: 0,
        rotationCenterX: 0,
        rotationCenterY: 0,
        rotation: 0
      };
    }
    caption.enabled = true;
    caption.color = title.color;
    caption.fontFamily = title.fontFamily;
    caption.fontSize = title.fontSize;
    caption.fontStyle = title.fontStyle;
    caption.fontWeight = title.fontWeight;
    caption.wrapping = title.wrapping;
    const padding2 = (title.spacing ?? 0) + spacing;
    const { range: range3 } = this;
    const midOffset = (range3[0] + range3[1]) / 2;
    let x;
    let y;
    let rotation;
    let textBaseline;
    switch (this.position) {
      case "top":
        x = midOffset;
        y = -padding2;
        rotation = 0;
        textBaseline = "bottom";
        break;
      case "bottom":
        x = midOffset;
        y = padding2;
        rotation = 0;
        textBaseline = "top";
        break;
      case "left":
        x = -padding2;
        y = midOffset;
        rotation = -0.5 * Math.PI;
        textBaseline = "bottom";
        break;
      case "right":
        x = padding2;
        y = midOffset;
        rotation = 0.5 * Math.PI;
        textBaseline = "bottom";
        break;
    }
    const { formatter: formatter2 = (p) => p.defaultValue } = title;
    const text = this.cachedCallWithContext(formatter2, this.getTitleFormatterParams(domain));
    caption.text = text;
    return {
      visible: true,
      text,
      textBaseline,
      x,
      y,
      rotationCenterX: x,
      rotationCenterY: y,
      rotation
    };
  }
  getLabelBorderOffset(label) {
    const padding2 = expandLabelPadding(label);
    function unreachable(a) {
      return a;
    }
    switch (this.position) {
      case "top":
        return padding2.bottom;
      case "right":
        return padding2.left;
      case "bottom":
        return padding2.top;
      case "left":
        return padding2.right;
      default:
        unreachable(this.position);
    }
  }
  getTickLabelProps(datum, tickGenerationResult) {
    const { horizontal, primaryLabel, primaryTick, seriesAreaPadding, scale: scale2 } = this;
    const { tickId, tickLabel: text = "", translation, primary, textUntruncated } = datum;
    const label = primary && primaryLabel?.enabled ? primaryLabel : this.label;
    const tick = primary && primaryTick?.enabled ? primaryTick : this.tick;
    const { rotation, textBaseline, textAlign } = tickGenerationResult;
    const { range: range3 } = scale2;
    const sideFlag = this.label.getSideFlag();
    const borderOffset = -this.getLabelBorderOffset(label);
    const labelOffset = sideFlag * (this.getTickSize(tick) + label.spacing + seriesAreaPadding) + borderOffset;
    const visible = text !== "";
    const x = horizontal ? translation : labelOffset;
    const y = horizontal ? -labelOffset : translation;
    return {
      ...this.getLabelStyles({ value: text }, void 0, label),
      tickId,
      rotation,
      text,
      textAlign,
      textBaseline,
      textUntruncated,
      visible,
      x,
      y,
      rotationCenterX: x,
      rotationCenterY: y,
      range: range3
    };
  }
  updateSelections() {
    if (!this.tickLayout)
      return;
    const lineData = this.getAxisLineCoordinates();
    const { tickLines, gridLines, gridFills, labels } = this.tickLayout;
    const getDatumId = (datum) => datum.tickId;
    this.lineNode.datum = lineData;
    this.gridLineGroupSelection.update(this.gridLine.enabled ? gridLines : [], void 0, getDatumId);
    this.gridFillGroupSelection.update(this.gridLine.enabled ? gridFills : [], void 0, getDatumId);
    this.tickLineGroupSelection.update(tickLines, void 0, getDatumId);
    this.tickLabelGroupSelection.update(labels, void 0, getDatumId);
  }
  updateGridLines() {
    this.gridLineGroupSelection.each((line, datum) => {
      line.stroke = datum.stroke;
      line.strokeWidth = datum.strokeWidth;
      line.lineDash = datum.lineDash;
    });
  }
  updateGridFills() {
    this.gridFillGroupSelection.each((rect, datum) => {
      rect.fill = datum.fill;
      rect.fillOpacity = datum.fillOpacity ?? 1;
    });
  }
  updateTickLines() {
    this.tickLineGroupSelection.each((line, datum) => {
      line.stroke = datum.stroke;
      line.strokeWidth = datum.strokeWidth;
      line.lineDash = datum.lineDash;
    });
  }
  updateTitle(domain, spacing) {
    const { caption } = this.title;
    const titleProps = this.titleProps(caption, domain, spacing);
    caption.node.visible = titleProps.visible;
    caption.node.text = titleProps.text;
    caption.node.textBaseline = titleProps.textBaseline;
    caption.node.datum = titleProps;
  }
  updateLabels() {
    if (!this.label.enabled)
      return;
    this.tickLabelGroupSelection.each((node, datum) => {
      node.fill = datum.color;
      node.text = datum.text;
      node.textBaseline = datum.textBaseline;
      node.textAlign = datum.textAlign ?? "center";
      node.pointerEvents = datum.textUntruncated == null ? 1 /* None */ : 0 /* All */;
      node.setFont(datum);
      node.setBoxing(datum);
    });
  }
  animateReadyUpdate(diff2) {
    const { animationManager } = this.moduleCtx;
    const selectionCtx = prepareAxisAnimationContext(this);
    const fns = prepareAxisAnimationFunctions(selectionCtx);
    fromToMotion(
      this.id,
      "axis-group",
      animationManager,
      [this.lineNodeGroup, this.tickLabelGroup, this.tickLineGroup, this.headingLabelGroup],
      fns.group
    );
    fromToMotion(this.id, "line", animationManager, [this.lineNode], fns.line);
    fromToMotion(
      this.id,
      "line-paths",
      animationManager,
      [this.gridLineGroupSelection, this.tickLineGroupSelection],
      fns.tick,
      (_, d) => d.tickId,
      diff2
    );
    fromToMotion(
      this.id,
      "tick-labels",
      animationManager,
      [this.tickLabelGroupSelection],
      fns.label,
      (_, d) => d.tickId,
      diff2
    );
    fromToMotion(
      this.id,
      "title",
      animationManager,
      [this.title.caption.node],
      fns.label,
      (_, d) => d.tickId,
      diff2
    );
  }
  resetSelectionNodes() {
    resetMotion(
      [this.lineNodeGroup, this.tickLabelGroup, this.tickLineGroup, this.headingLabelGroup],
      resetAxisGroupFn()
    );
    resetMotion([this.gridLineGroupSelection, this.tickLineGroupSelection], resetAxisLineSelectionFn());
    resetMotion([this.gridFillGroupSelection], resetAxisFillSelectionFn());
    resetMotion([this.tickLabelGroupSelection], resetAxisLabelSelectionFn());
    resetMotion([this.title.caption.node], resetAxisLabelSelectionFn());
    resetMotion([this.lineNode], resetAxisLineSelectionFn());
  }
};
__decorateClass([
  Property
], _CartesianAxis.prototype, "thickness", 2);
__decorateClass([
  Property
], _CartesianAxis.prototype, "maxThicknessRatio", 2);
__decorateClass([
  Property
], _CartesianAxis.prototype, "position", 2);
var CartesianAxis = _CartesianAxis;

// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxis = class extends CartesianAxis {
  constructor(moduleCtx, scale2 = new LinearScale()) {
    super(moduleCtx, scale2);
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    return { domain: extent2, clipped };
  }
  createDatumFormatter(_domain, ticks) {
    const { format } = this.label;
    return typeof format === "number" ? tickFormat(ticks, format) : void 0;
  }
  tickFormatParams(_domain, _ticks, fractionDigits) {
    return { type: "number", fractionDigits };
  }
  datumFormatParams(value, params, fractionDigits) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    return {
      type: "number",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      fractionDigits
    };
  }
};
NumberAxis.className = "NumberAxis";
NumberAxis.type = "number";
__decorateClass([
  Property
], NumberAxis.prototype, "min", 2);
__decorateClass([
  Property
], NumberAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/chart.ts
import {
  AsyncAwaitQueue,
  CleanupRegistry as CleanupRegistry19,
  Logger as Logger32,
  createId as createId9,
  entries as entries5,
  getWindow as getWindow19,
  groupBy,
  isFiniteNumber as isFiniteNumber3,
  pause
} from "ag-charts-core";

// packages/ag-charts-community/src/module/module.ts
import { CleanupRegistry as CleanupRegistry2 } from "ag-charts-core";
var ModuleRegistry = class {
  constructor() {
    this.modules = [];
    this.dependencies = /* @__PURE__ */ new Map();
    this.modulesByOptionKey = /* @__PURE__ */ new Map();
  }
  register(...modules) {
    for (const module of modules) {
      this.registerDependencies(module);
      const otherModule = this.modules.find(
        (other) => module.type === other.type && ("optionsKey" in module && "optionsKey" in other ? module.optionsKey === other.optionsKey : true) && module.identifier === other.identifier
      );
      if (otherModule) {
        if (module.packageType === "enterprise" && otherModule.packageType === "community") {
          const index = this.modules.indexOf(otherModule);
          this.modules.splice(index, 1, module);
          if ("optionsKey" in module) {
            this.modulesByOptionKey.set(module.optionsKey, module);
          }
        }
      } else {
        this.modules.push(module);
        if ("optionsKey" in module) {
          this.modulesByOptionKey.set(module.optionsKey, module);
        }
      }
    }
  }
  hasEnterpriseModules() {
    return this.modules.some((m) => m.packageType === "enterprise");
  }
  *byType(...types) {
    const yielded = /* @__PURE__ */ new Set();
    const modulesByType = this.modules.filter((module) => types.includes(module.type));
    const calculateDependencies = (module) => {
      const deps = this.dependencies.get(module);
      return deps?.flatMap(calculateDependencies).concat(deps) ?? [];
    };
    const unresolvable = [];
    for (const module of modulesByType) {
      const uniqueKey = "optionsKey" in module ? module.optionsKey : module.contextKey;
      if (yielded.has(uniqueKey))
        continue;
      for (const dependency of calculateDependencies(uniqueKey)) {
        if (yielded.has(dependency))
          continue;
        const dependencyModule = this.modulesByOptionKey.get(dependency);
        if (!dependencyModule) {
          unresolvable.push(dependency);
          continue;
        }
        if (!types.includes(dependencyModule.type))
          continue;
        yield dependencyModule;
        yielded.add(dependency);
      }
      yield module;
      yielded.add(uniqueKey);
    }
    if (unresolvable.length > 0) {
      throw new Error(`Could not resolve module dependencies: ${unresolvable}`);
    }
  }
  registerDependencies(module) {
    if (module.dependencies == null || module.dependencies.length === 0)
      return;
    const uniqueKey = "optionsKey" in module ? module.optionsKey : module.contextKey;
    this.dependencies.set(uniqueKey, module.dependencies);
  }
};
var moduleRegistry = new ModuleRegistry();

// packages/ag-charts-community/src/util/dom.ts
import { getDocument, getWindow as getWindow3 } from "ag-charts-core";
function setElementBBox(element2, bbox) {
  if (!element2)
    return;
  const { x, y, width: width2, height: height2 } = normalizeBounds(bbox);
  setPixelValue(element2.style, "width", width2);
  setPixelValue(element2.style, "height", height2);
  setPixelValue(element2.style, "left", x);
  setPixelValue(element2.style, "top", y);
}
function getElementBBox(element2) {
  const width2 = parseFloat(element2.style.width) || element2.offsetWidth;
  const height2 = parseFloat(element2.style.height) || element2.offsetHeight;
  const x = parseFloat(element2.style.left) || element2.offsetLeft;
  const y = parseFloat(element2.style.top) || element2.offsetTop;
  return { x, y, width: width2, height: height2 };
}
function isInputPending() {
  const navigator = getWindow3("navigator");
  if ("scheduling" in navigator) {
    const scheduling = navigator.scheduling;
    if ("isInputPending" in scheduling) {
      return scheduling.isInputPending({ includeContinuous: true });
    }
  }
  return false;
}
function normalizeBounds(bbox) {
  let { x, y, width: width2, height: height2 } = bbox;
  if ((width2 == null || width2 > 0) && (height2 == null || height2 > 0)) {
    return bbox;
  }
  if (x != null && width2 != null && width2 < 0) {
    width2 = -width2;
    x = x - width2;
  }
  if (y != null && height2 != null && height2 < 0) {
    height2 = -height2;
    y = y - height2;
  }
  return { x, y, width: width2, height: height2 };
}
function setPixelValue(style, key, value) {
  if (value == null) {
    style.removeProperty(key);
  } else {
    style.setProperty(key, `${value}px`);
  }
}

// packages/ag-charts-community/src/util/json.ts
import { Logger as Logger17, isArray as isArray7, isDate, isFunction, isHtmlElement, isObject as isObject3, isPlainObject as isPlainObject9, isRegExp } from "ag-charts-core";
var CLASS_INSTANCE_TYPE = "class-instance";
function jsonDiff(source, target, shallow) {
  if (isArray7(target)) {
    if (!isArray7(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v, shallow) != null)) {
      return target;
    }
  } else if (isPlainObject9(target)) {
    if (!isPlainObject9(source)) {
      return target;
    }
    const result = {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(source),
      ...Object.keys(target)
    ]);
    for (const key of allKeys) {
      if (source[key] === target[key]) {
        continue;
      } else if (shallow?.has(key)) {
        result[key] = target[key];
      } else if (typeof source[key] === typeof target[key]) {
        const diff2 = jsonDiff(source[key], target[key], shallow);
        if (diff2 !== null) {
          result[key] = diff2;
        }
      } else {
        result[key] = target[key];
      }
    }
    return Object.keys(result).length ? result : null;
  } else if (source !== target) {
    return target;
  }
  return null;
}
function deepClone(source, opts) {
  if (isArray7(source)) {
    return cloneArray(source, opts);
  }
  if (isPlainObject9(source)) {
    return clonePlainObject(source, opts);
  }
  if (source instanceof Map) {
    return new Map(deepClone(Array.from(source)));
  }
  return shallowClone(source);
}
function cloneArray(source, opts) {
  const result = [];
  const seen = opts?.seen;
  for (const item of source) {
    if (typeof item === "object" && seen?.includes(item)) {
      Logger17.warn("cycle detected in array", item);
      continue;
    }
    seen?.push(item);
    result.push(deepClone(item, opts));
    seen?.pop();
  }
  return result;
}
function clonePlainObject(source, opts) {
  const target = {};
  for (const key of Object.keys(source)) {
    if (opts?.assign?.has(key)) {
      target[key] = source[key];
    } else if (opts?.shallow?.has(key)) {
      target[key] = shallowClone(source[key]);
    } else {
      target[key] = deepClone(source[key], opts);
    }
  }
  return target;
}
function shallowClone(source) {
  if (isArray7(source)) {
    return source.slice(0);
  }
  if (isPlainObject9(source)) {
    return { ...source };
  }
  if (isDate(source)) {
    return new Date(source);
  }
  if (isRegExp(source)) {
    return new RegExp(source.source, source.flags);
  }
  return source;
}
function jsonApply(target, source, params = {}) {
  const { path, matcherPath = path?.replace(/(\[[0-9+]+])/i, "[]"), skip = [] } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path ?? "<root>"}`);
  }
  if (source == null) {
    return target;
  }
  if (isProperties(target)) {
    return target.set(source);
  }
  const targetAny = target;
  const targetType = classify(target);
  for (const property of Object.keys(source)) {
    if (SKIP_JS_BUILTINS.has(property))
      continue;
    const propertyMatcherPath = `${matcherPath ? matcherPath + "." : ""}${property}`;
    if (skip.includes(propertyMatcherPath))
      continue;
    const newValue = source[property];
    const propertyPath = `${path ? path + "." : ""}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === CLASS_INSTANCE_TYPE && !(property in target || property === "context")) {
        if (newValue === void 0)
          continue;
        Logger17.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
        continue;
      }
      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== "object")) {
        Logger17.warn(
          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`
        );
        continue;
      }
      if (isProperties(currentValue)) {
        if (newValue === void 0) {
          currentValue.clear();
        } else {
          currentValue.set(newValue);
        }
      } else if (newValueType === "object" && property !== "context") {
        if (!(property in targetAny)) {
          Logger17.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
          continue;
        }
        if (currentValue == null) {
          targetAny[property] = newValue;
        } else {
          jsonApply(currentValue, newValue, {
            ...params,
            path: propertyPath,
            matcherPath: propertyMatcherPath
          });
        }
      } else {
        targetAny[property] = newValue;
      }
    } catch (error) {
      Logger17.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);
    }
  }
  return target;
}
function classify(value) {
  if (value == null) {
    return null;
  }
  if (isHtmlElement(value) || isDate(value)) {
    return "primitive";
  }
  if (isArray7(value)) {
    return "array";
  }
  if (isObject3(value)) {
    return isPlainObject9(value) ? "object" : CLASS_INSTANCE_TYPE;
  }
  if (isFunction(value)) {
    return "function";
  }
  return "primitive";
}

// packages/ag-charts-community/src/util/mutex.ts
import { Logger as Logger18 } from "ag-charts-core";
var Mutex = class {
  constructor() {
    this.available = true;
    this.acquireQueue = [];
  }
  acquire(cb) {
    return new Promise((resolve) => {
      this.acquireQueue.push([cb, resolve]);
      if (this.available) {
        this.dispatchNext().catch((e) => Logger18.errorOnce(e));
      }
    });
  }
  async acquireImmediately(cb) {
    if (!this.available) {
      return false;
    }
    await this.acquire(cb);
    return true;
  }
  async waitForClearAcquireQueue() {
    return this.acquire(() => Promise.resolve(void 0));
  }
  async dispatchNext() {
    this.available = false;
    let [next, done] = this.acquireQueue.shift() ?? [];
    while (next) {
      try {
        await next();
        done?.();
      } catch (error) {
        Logger18.error("mutex callback error", error);
        done?.();
      }
      [next, done] = this.acquireQueue.shift() ?? [];
    }
    this.available = true;
  }
};

// packages/ag-charts-community/src/util/observable.ts
var Observable = class {
  constructor() {
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(eventType, listener) {
    if (typeof listener !== "function") {
      throw new Error("AG Charts - listener must be a Function");
    }
    const eventTypeListeners = this.eventListeners.get(eventType);
    if (eventTypeListeners) {
      eventTypeListeners.add(listener);
    } else {
      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));
    }
  }
  removeEventListener(type, listener) {
    const listeners = this.eventListeners.get(type);
    if (listeners == null)
      return;
    listeners.delete(listener);
    if (listeners.size === 0) {
      this.eventListeners.delete(type);
    }
  }
  hasEventListener(type) {
    return this.eventListeners.has(type);
  }
  clearEventListeners() {
    this.eventListeners.clear();
  }
  fireEvent(event) {
    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));
  }
};

// packages/ag-charts-community/src/util/padding.ts
var Padding = class extends BaseProperties {
  constructor(top = 0, right = top, bottom = top, left = right) {
    super();
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
};
__decorateClass([
  Property
], Padding.prototype, "top", 2);
__decorateClass([
  Property
], Padding.prototype, "right", 2);
__decorateClass([
  Property
], Padding.prototype, "bottom", 2);
__decorateClass([
  Property
], Padding.prototype, "left", 2);

// packages/ag-charts-community/src/util/render.ts
import { getWindow as getWindow4 } from "ag-charts-core";
function debouncedAnimationFrame(cb) {
  return buildScheduler((innerCb, _delayMs) => getWindow4().requestAnimationFrame(innerCb), cb);
}
function debouncedCallback(cb) {
  return buildScheduler((innerCb, delayMs = 0) => {
    if (delayMs === 0) {
      queueMicrotask(innerCb);
    } else {
      setTimeout(innerCb, delayMs);
    }
  }, cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone?.();
    awaitingDone = void 0;
    awaitingPromise = void 0;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({ count });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done, done);
  };
  return {
    schedule(delayMs) {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb, delayMs);
      }
      scheduleCount++;
    },
    async await() {
      if (!busy()) {
        return;
      }
      awaitingPromise ?? (awaitingPromise = new Promise((resolve) => {
        awaitingDone = resolve;
      }));
      while (busy()) {
        await awaitingPromise;
      }
    }
  };
}

// packages/ag-charts-community/src/widget/widget.ts
import {
  attachListener as attachListener4,
  getAttribute,
  getWindow as getWindow7,
  setAttribute,
  setElementStyle,
  setElementStyles
} from "ag-charts-core";

// packages/ag-charts-community/src/widget/widgetEvents.ts
var WIDGET_HTML_EVENTS = [
  "blur",
  "change",
  "contextmenu",
  "focus",
  "keydown",
  "keyup",
  "click",
  "dblclick",
  "mouseenter",
  "mousemove",
  "mouseleave",
  "wheel",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel"
];
function allocMouseEvent(type, sourceEvent, current) {
  const { offsetX, offsetY, clientX, clientY } = sourceEvent;
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current, sourceEvent);
  return { type, device: "mouse", offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };
}
function allocTouchEvent(type, sourceEvent, _current) {
  return { type, sourceEvent };
}
var WidgetAllocators = {
  blur: (sourceEvent) => {
    return { type: "blur", sourceEvent };
  },
  change: (sourceEvent) => {
    return { type: "change", sourceEvent };
  },
  contextmenu: (sourceEvent, current) => {
    return allocMouseEvent("contextmenu", sourceEvent, current);
  },
  focus: (sourceEvent) => {
    return { type: "focus", sourceEvent };
  },
  keydown: (sourceEvent) => {
    return { type: "keydown", sourceEvent };
  },
  keyup: (sourceEvent) => {
    return { type: "keyup", sourceEvent };
  },
  click: (sourceEvent, current) => {
    return allocMouseEvent("click", sourceEvent, current);
  },
  dblclick: (sourceEvent, current) => {
    return allocMouseEvent("dblclick", sourceEvent, current);
  },
  mouseenter: (sourceEvent, current) => {
    return allocMouseEvent("mouseenter", sourceEvent, current);
  },
  mousemove: (sourceEvent, current) => {
    return allocMouseEvent("mousemove", sourceEvent, current);
  },
  mouseleave: (sourceEvent, current) => {
    return allocMouseEvent("mouseleave", sourceEvent, current);
  },
  wheel: (sourceEvent) => {
    const { offsetX, offsetY, clientX, clientY } = sourceEvent;
    const factor = sourceEvent.deltaMode === 0 ? 0.01 : 1;
    const deltaX = sourceEvent.deltaX * factor;
    const deltaY = sourceEvent.deltaY * factor;
    return { type: "wheel", offsetX, offsetY, clientX, clientY, deltaX, deltaY, sourceEvent };
  },
  touchstart: (sourceEvent, current) => {
    return allocTouchEvent("touchstart", sourceEvent, current);
  },
  touchmove: (sourceEvent, current) => {
    return allocTouchEvent("touchmove", sourceEvent, current);
  },
  touchend: (sourceEvent, current) => {
    return allocTouchEvent("touchend", sourceEvent, current);
  },
  touchcancel: (sourceEvent, current) => {
    return allocTouchEvent("touchcancel", sourceEvent, current);
  }
};
var WidgetEventUtil = class {
  static alloc(type, sourceEvent, current) {
    return WidgetAllocators[type](sourceEvent, current);
  }
  static isHTMLEvent(type) {
    const htmlTypes = WIDGET_HTML_EVENTS;
    return htmlTypes.includes(type);
  }
  static calcCurrentXY(current, event) {
    const currentRect = current.getBoundingClientRect();
    return { currentX: event.clientX - currentRect.x, currentY: event.clientY - currentRect.y };
  }
};

// packages/ag-charts-community/src/widget/widgetListenerHTML.ts
import { entries as entries2 } from "ag-charts-core";
var WidgetListenerHTML = class {
  constructor() {
    this.widgetListeners = {};
    this.sourceListeners = {};
  }
  initSourceHandler(type, handler) {
    this.sourceListeners ?? (this.sourceListeners = {});
    this.sourceListeners[type] = handler;
  }
  lazyGetWidgetListeners(type, target) {
    var _a;
    if (!(type in (this.sourceListeners ?? {}))) {
      const sourceHandler = (sourceEvent) => {
        const widgetEvent = WidgetEventUtil.alloc(type, sourceEvent, target.getElement());
        this.dispatch(type, target, widgetEvent);
      };
      const opts = {};
      if (type.startsWith("touch"))
        opts.passive = false;
      this.initSourceHandler(type, sourceHandler);
      target.getElement().addEventListener(type, sourceHandler, opts);
    }
    this.widgetListeners ?? (this.widgetListeners = {});
    (_a = this.widgetListeners)[type] ?? (_a[type] = []);
    return this.widgetListeners[type];
  }
  add(type, target, handler) {
    const listeners = this.lazyGetWidgetListeners(type, target);
    listeners.push(handler);
  }
  remove(type, target, handler) {
    const listeners = this.lazyGetWidgetListeners(type, target);
    const index = listeners.indexOf(handler);
    if (index > -1)
      listeners.splice(index, 1);
  }
  destroy(target) {
    this.widgetListeners = void 0;
    if (this.sourceListeners) {
      for (const [key, sourceHandler] of entries2(this.sourceListeners)) {
        target.getElement().removeEventListener(key, sourceHandler);
      }
      this.sourceListeners = void 0;
    }
  }
  dispatch(type, target, event) {
    for (const widgetListener of this.widgetListeners?.[type] ?? []) {
      widgetListener(event, target);
    }
  }
};

// packages/ag-charts-community/src/widget/widgetListenerInternal.ts
import { CleanupRegistry as CleanupRegistry5, attachListener as attachListener3, boxContains as boxContains3 } from "ag-charts-core";

// packages/ag-charts-community/src/widget/mouseDragger.ts
import { CleanupRegistry as CleanupRegistry3, attachListener, getWindow as getWindow5 } from "ag-charts-core";
var MouseDragger = class {
  constructor(glob, self, myCallbacks, downEvent) {
    this.glob = glob;
    this.self = self;
    this.window = getWindow5();
    this.cleanup = new CleanupRegistry3();
    this.mousegeneral = (generalEvent) => {
      generalEvent.stopPropagation();
      generalEvent.stopImmediatePropagation();
    };
    this.mousemove = (moveEvent) => {
      moveEvent.stopPropagation();
      moveEvent.stopImmediatePropagation();
      this.glob.globalMouseDragCallbacks?.mousemove(moveEvent);
    };
    this.mouseup = (upEvent) => {
      if (upEvent.button === 0) {
        upEvent.stopPropagation();
        upEvent.stopImmediatePropagation();
        this.glob.globalMouseDragCallbacks?.mouseup(upEvent);
        this.destroy();
      }
    };
    const { window: window2, mousegeneral, mousemove, mouseup } = this;
    this.cleanup.register(
      attachListener(window2, "mousedown", mousegeneral, { capture: true }),
      attachListener(window2, "mouseenter", mousegeneral, { capture: true }),
      attachListener(window2, "mouseleave", mousegeneral, { capture: true }),
      attachListener(window2, "mouseout", mousegeneral, { capture: true }),
      attachListener(window2, "mouseover", mousegeneral, { capture: true }),
      attachListener(window2, "mousemove", mousemove, { capture: true }),
      attachListener(window2, "mouseup", mouseup, { capture: true })
    );
    self.mouseDragger = this;
    glob.globalMouseDragCallbacks = myCallbacks;
    glob.globalMouseDragCallbacks.mousedown(downEvent);
    downEvent.stopPropagation();
    downEvent.stopImmediatePropagation();
  }
  destroy() {
    this.cleanup.flush();
    this.glob.globalMouseDragCallbacks = void 0;
    this.self.mouseDragger = void 0;
  }
};
function startMouseDrag(glob, self, myCallbacks, downEvent) {
  if (glob.globalMouseDragCallbacks != null)
    return void 0;
  return new MouseDragger(glob, self, myCallbacks, downEvent);
}

// packages/ag-charts-community/src/widget/touchDragger.ts
import { CleanupRegistry as CleanupRegistry4, attachListener as attachListener2, getWindow as getWindow6 } from "ag-charts-core";
var LONG_TAP_DURATION_MS = 500;
var LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX = 100;
function deltaClientSquared(a, b) {
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return dx * dx + dy * dy;
}
var gIsInLongTap = false;
var TouchDragger = class {
  constructor(glob, self, myCallbacks, initialTouch, target) {
    this.glob = glob;
    this.self = self;
    this.initialTouch = initialTouch;
    this.target = target;
    this.cleanup = new CleanupRegistry4();
    this.longTapInterrupted = false;
    this.longtap = () => {
      const { target, initialTouch } = this;
      if (!this.longTapInterrupted) {
        const cleanup = new CleanupRegistry4();
        target.dispatchEvent(new TouchEvent("touchcancel", { touches: [initialTouch], bubbles: true }));
        gIsInLongTap = true;
        const longTapMove = (e) => e.preventDefault();
        const longTapEnd = (e) => {
          gIsInLongTap = false;
          e.preventDefault();
          cleanup.flush();
        };
        cleanup.register(
          attachListener2(target, "touchmove", longTapMove, { passive: false }),
          attachListener2(target, "touchend", longTapEnd, { passive: false }),
          attachListener2(target, "touchcancel", longTapEnd, { passive: false })
        );
        const { clientX, clientY } = initialTouch;
        const contextMenuEvent = new PointerEvent("contextmenu", {
          bubbles: true,
          cancelable: true,
          view: getWindow6(),
          clientX,
          clientY,
          pointerType: "touch"
        });
        target.dispatchEvent(contextMenuEvent);
      }
    };
    this.touchmove = (moveEvent) => {
      const { glob, self, initialTouch } = this;
      const touch = this.findInitialFinger(moveEvent.targetTouches);
      if (touch != null) {
        this.longTapInterrupted = this.longTapInterrupted || deltaClientSquared(initialTouch, touch) > LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX;
        if (self.dragTouchEnabled) {
          glob.globalTouchDragCallbacks?.touchmove(moveEvent, touch);
        }
      }
    };
    this.touchend = (endEvent) => {
      this.longTapInterrupted = true;
      const touch = this.findInitialFinger(endEvent.changedTouches, endEvent.touches);
      if (touch != null) {
        this.glob.globalTouchDragCallbacks?.touchend(endEvent, touch);
      }
      this.destroy();
    };
    this.longtapTimer = setTimeout(this.longtap, LONG_TAP_DURATION_MS);
    const { touchmove, touchend } = this;
    this.cleanup.register(
      attachListener2(target, "touchmove", touchmove, { passive: false }),
      attachListener2(target, "touchstart", touchend, { passive: false }),
      attachListener2(target, "touchend", touchend, { passive: false }),
      attachListener2(target, "touchcancel", touchend, { passive: false })
    );
    self.touchDragger = this;
    glob.globalTouchDragCallbacks = myCallbacks;
  }
  destroy() {
    clearTimeout(this.longtapTimer);
    this.cleanup.flush();
    this.glob.globalTouchDragCallbacks = void 0;
    this.self.touchDragger = void 0;
  }
  findInitialFinger(...touchLists) {
    const touches = touchLists.map((touchList) => Array.from(touchList)).flat();
    return Array.from(touches).find((v) => v.identifier === this.initialTouch.identifier);
  }
};
function startOneFingerTouch(glob, self, myCallbacks, initialTouch, target) {
  if (glob.globalTouchDragCallbacks != null || gIsInLongTap)
    return void 0;
  return new TouchDragger(glob, self, myCallbacks, initialTouch, target);
}

// packages/ag-charts-community/src/widget/widgetListenerInternal.ts
function makeMouseDrag(current, type, origin2, sourceEvent) {
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), sourceEvent);
  const originDeltaX = sourceEvent.pageX - origin2.pageX;
  const originDeltaY = sourceEvent.pageY - origin2.pageY;
  return {
    type,
    device: "mouse",
    offsetX: origin2.offsetX + originDeltaX,
    offsetY: origin2.offsetY + originDeltaY,
    clientX: sourceEvent.clientX,
    clientY: sourceEvent.clientY,
    currentX,
    currentY,
    originDeltaX,
    originDeltaY,
    sourceEvent
  };
}
function getTouchOffsets(current, { pageX, pageY }) {
  const { x, y } = current.getElement().getBoundingClientRect();
  return { offsetX: pageX - x, offsetY: pageY - y };
}
function makeTouchDrag(current, type, origin2, sourceEvent, touch) {
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), touch);
  const originDeltaX = touch.pageX - origin2.pageX;
  const originDeltaY = touch.pageY - origin2.pageY;
  return {
    type,
    device: "touch",
    offsetX: origin2.offsetX + originDeltaX,
    offsetY: origin2.offsetY + originDeltaY,
    clientX: touch.clientX,
    clientY: touch.clientY,
    currentX,
    currentY,
    originDeltaX,
    originDeltaY,
    sourceEvent
  };
}
var GlobalCallbacks = {};
var WidgetListenerInternal = class {
  constructor(dispatchCallback) {
    this.dispatchCallback = dispatchCallback;
    this.dragTouchEnabled = true;
  }
  destroy() {
    this.dragTriggerRemover?.();
    this.dragTriggerRemover = void 0;
    this.listeners?.clear();
    this.mouseDragger?.destroy();
    this.touchDragger?.destroy();
  }
  getListenerSet(type) {
    this.listeners ?? (this.listeners = /* @__PURE__ */ new Map());
    let result = this.listeners.get(type);
    if (result === void 0) {
      result = /* @__PURE__ */ new Set();
      this.listeners.set(type, result);
    }
    return result;
  }
  add(type, target, handler) {
    this.getListenerSet(type).add(handler);
    switch (type) {
      case "drag-start":
      case "drag-move":
      case "drag-end": {
        this.registerDragTrigger(target);
        break;
      }
    }
  }
  remove(type, _target, handler) {
    this.getListenerSet(type).delete(handler);
  }
  registerDragTrigger(target) {
    if (this.dragTriggerRemover == null) {
      const element2 = target.getElement();
      const cleanup = new CleanupRegistry5();
      cleanup.register(
        attachListener3(element2, "mousedown", (event) => this.triggerMouseDrag(target, event)),
        attachListener3(element2, "touchstart", (event) => this.triggerTouchDrag(target, event), {
          passive: false
        })
      );
      this.dragTriggerRemover = () => cleanup.flush();
    }
  }
  triggerMouseDrag(current, downEvent) {
    if (downEvent.button === 0) {
      this.startMouseDrag(current, downEvent);
    }
  }
  startMouseDrag(current, initialDownEvent) {
    const origin2 = { pageX: NaN, pageY: NaN, offsetX: NaN, offsetY: NaN };
    partialAssign(["pageX", "pageY", "offsetX", "offsetY"], origin2, initialDownEvent);
    const dragCallbacks = {
      mousedown: (downEvent) => {
        const dragStartEvent = makeMouseDrag(current, "drag-start", origin2, downEvent);
        this.dispatch("drag-start", current, dragStartEvent);
      },
      mousemove: (moveEvent) => {
        const dragMoveEvent = makeMouseDrag(current, "drag-move", origin2, moveEvent);
        this.dispatch("drag-move", current, dragMoveEvent);
      },
      mouseup: (upEvent) => {
        const dragEndEvent = makeMouseDrag(current, "drag-end", origin2, upEvent);
        this.dispatch("drag-end", current, dragEndEvent);
        this.endDrag(current, dragEndEvent);
      }
    };
    this.mouseDragger = startMouseDrag(GlobalCallbacks, this, dragCallbacks, initialDownEvent);
  }
  endDrag(target, { sourceEvent, clientX, clientY }) {
    const elem = target.getElement();
    const rect = elem.getBoundingClientRect();
    if (!boxContains3(rect, clientX, clientY)) {
      elem.dispatchEvent(new MouseEvent("mouseleave", sourceEvent));
      sourceEvent.target?.dispatchEvent(new MouseEvent("mouseenter", sourceEvent));
    }
  }
  triggerTouchDrag(current, startEvent) {
    const touch = startEvent.targetTouches[0];
    if (startEvent.targetTouches.length === 1 && touch != null) {
      this.startOneFingerTouch(current, startEvent, touch);
    }
  }
  startOneFingerTouch(current, initialEvent, initialTouch) {
    const origin2 = { pageX: NaN, pageY: NaN, ...getTouchOffsets(current, initialTouch) };
    partialAssign(["pageX", "pageY"], origin2, initialTouch);
    const dragCallbacks = {
      touchmove: (moveEvent, touch) => {
        const dragMoveEvent = makeTouchDrag(current, "drag-move", origin2, moveEvent, touch);
        this.dispatch("drag-move", current, dragMoveEvent);
      },
      touchend: (cancelEvent, touch) => {
        const dragMoveEvent = makeTouchDrag(current, "drag-end", origin2, cancelEvent, touch);
        this.dispatch("drag-end", current, dragMoveEvent);
      }
    };
    const target = current.getElement();
    this.touchDragger = startOneFingerTouch(GlobalCallbacks, this, dragCallbacks, initialTouch, target);
    const dragStartEvent = makeTouchDrag(current, "drag-start", origin2, initialEvent, initialTouch);
    this.dispatch("drag-start", current, dragStartEvent);
  }
  dispatch(type, current, event) {
    for (const handler of this.getListenerSet(type)) {
      handler(event, current);
    }
    this.dispatchCallback(type, event);
  }
};

// packages/ag-charts-community/src/widget/widget.ts
var WidgetBounds = class {
  constructor(elem) {
    this.elem = elem;
  }
  setBounds(bounds) {
    setElementBBox(this.elemContainer ?? this.elem, bounds);
  }
  getBounds() {
    return getElementBBox(this.elemContainer ?? this.elem);
  }
  static setElementContainer(widget, elemContainer) {
    const currentBounds = widget.getBounds();
    setElementBBox(elemContainer, currentBounds);
    setElementStyles(widget.elem, { width: "100%", height: "100%" });
    widget.elem.remove();
    widget.elemContainer = elemContainer;
    widget.elemContainer.replaceChildren(widget.elem);
  }
};
var Widget = class extends WidgetBounds {
  constructor() {
    super(...arguments);
    this.index = NaN;
    this.children = [];
  }
  set id(elementId) {
    setAttribute(this.elem, "id", elementId);
  }
  get id() {
    return getAttribute(this.elem, "id");
  }
  getElement() {
    return this.elem;
  }
  getBoundingClientRect() {
    return this.elem.getBoundingClientRect();
  }
  get clientWidth() {
    return this.elem.clientWidth;
  }
  get clientHeight() {
    return this.elem.clientHeight;
  }
  destroy() {
    this.destroyListener?.();
    this.destroyListener = void 0;
    this.parent?.removeChild(this);
    this.children.forEach((child) => {
      child.parent = void 0;
      child.destroy();
    });
    this.children.length = 0;
    this.destructor();
    this.remove();
    this.internalListener?.destroy();
    this.htmlListener?.destroy(this);
  }
  remove() {
    this.elem.remove();
    this.elemContainer?.remove();
  }
  setHidden(hidden) {
    setElementStyle(this.elem, "display", hidden ? "none" : void 0);
  }
  isHidden() {
    return getWindow7()?.getComputedStyle?.(this.elem).display === "none";
  }
  setCursor(cursor) {
    setElementStyle(this.elem, "cursor", cursor);
  }
  setTextContent(textContent) {
    this.elem.textContent = textContent ?? null;
  }
  setAriaDescribedBy(ariaDescribedBy) {
    setAttribute(this.elem, "aria-describedby", ariaDescribedBy);
  }
  setAriaHidden(ariaHidden) {
    setAttribute(this.elem, "aria-hidden", ariaHidden);
  }
  setAriaLabel(ariaLabel) {
    setAttribute(this.elem, "aria-label", ariaLabel);
  }
  setAriaExpanded(ariaExpanded) {
    setAttribute(this.elem, "aria-expanded", ariaExpanded);
  }
  setAriaControls(ariaControls) {
    setAttribute(this.elem, "aria-controls", ariaControls);
  }
  setAriaHasPopup(ariaHasPopup) {
    setAttribute(this.elem, "aria-haspopup", ariaHasPopup);
  }
  setInnerHTML(html) {
    this.elem.innerHTML = html;
  }
  setPointerEvents(pointerEvents) {
    setElementStyle(this.elem, "pointer-events", pointerEvents);
  }
  isDisabled() {
    return getAttribute(this.elem, "aria-disabled", false);
  }
  hasPopup() {
    const ariaHasPopup = getAttribute(this.elem, "aria-haspopup");
    return ariaHasPopup !== void 0 && ariaHasPopup !== "false";
  }
  parseFloat(s) {
    return s === "" ? 0 : parseFloat(s);
  }
  cssLeft() {
    return this.parseFloat(this.elem.style.left);
  }
  cssTop() {
    return this.parseFloat(this.elem.style.top);
  }
  cssWidth() {
    return this.parseFloat(this.elem.style.width);
  }
  cssHeight() {
    return this.parseFloat(this.elem.style.height);
  }
  focus(opts) {
    this.elem.focus(opts);
  }
  setFocusOverride(focus) {
    setAttribute(this.elem, "data-focus-override", focus);
  }
  setPreventsDefault(preventDefault) {
    setAttribute(this.elem, "data-preventdefault", preventDefault);
  }
  setTabIndex(tabIndex) {
    setAttribute(this.elem, "tabindex", tabIndex);
  }
  addChild(child) {
    this.addChildToDOM(child, this.getBefore(child));
    this.children.push(child);
    child.index = this.children.length - 1;
    child.parent = this;
    this.onChildAdded(child);
  }
  removeChild(child) {
    const i = this.children.findIndex((value) => value === child);
    this.children.splice(i, 1);
    this.removeChildFromDOM(child);
    this.onChildRemoved(child);
  }
  moveChild(child, domIndex) {
    if (child.domIndex === domIndex)
      return;
    child.domIndex = domIndex;
    this.removeChildFromDOM(child);
    this.addChildToDOM(child, this.getBefore(child));
  }
  addClass(...tokens) {
    this.elem.classList.add(...tokens);
  }
  removeClass(...tokens) {
    this.elem.classList.remove(...tokens);
  }
  toggleClass(token, force) {
    this.elem.classList.toggle(token, force);
  }
  appendOrInsert(child, before) {
    if (before) {
      before.getElement().insertAdjacentElement("beforebegin", child);
    } else {
      this.elem.appendChild(child);
    }
  }
  addChildToDOM(child, before) {
    this.appendOrInsert(child.getElement(), before);
  }
  removeChildFromDOM(child) {
    this.elem.removeChild(child.getElement());
  }
  onChildAdded(_child) {
  }
  onChildRemoved(_child) {
  }
  getBefore({ domIndex }) {
    if (domIndex === void 0)
      return void 0;
    return this.children.filter((child) => child.domIndex !== void 0 && child.domIndex > domIndex).reduce((prev, curr) => !prev || curr.domIndex < prev.domIndex ? curr : prev, void 0);
  }
  addListener(type, listener) {
    if (WidgetEventUtil.isHTMLEvent(type)) {
      this.htmlListener ?? (this.htmlListener = new WidgetListenerHTML());
      this.htmlListener.add(type, this, listener);
    } else {
      this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));
      this.internalListener.add(type, this, listener);
    }
    return () => this.removeListener(type, listener);
  }
  removeListener(type, listener) {
    if (WidgetEventUtil.isHTMLEvent(type)) {
      this.htmlListener?.remove(type, this, listener);
    } else if (this.htmlListener != null) {
      this.internalListener?.remove(type, this, listener);
    }
  }
  setDragTouchEnabled(dragTouchEnabled) {
    this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));
    this.internalListener.dragTouchEnabled = dragTouchEnabled;
  }
  onDispatch(type, event) {
    if (!event.sourceEvent?.bubbles)
      return;
    let { parent } = this;
    while (parent != null) {
      const { internalListener } = parent;
      if (internalListener != null) {
        const parentEvent = { ...event, ...WidgetEventUtil.calcCurrentXY(parent.getElement(), event) };
        internalListener.dispatch(type, parent, parentEvent);
      }
      parent = parent.parent;
    }
  }
  static addWindowEvent(_type, listener) {
    const pagehideHandler = (event) => {
      if (event.persisted) {
        return;
      }
      listener();
    };
    return attachListener4(getWindow7(), "pagehide", pagehideHandler);
  }
};

// packages/ag-charts-community/src/chart/chartCaptions.ts
import { isArray as isArray8 } from "ag-charts-core";
var ChartCaptions = class {
  constructor() {
    this.title = new Caption();
    this.subtitle = new Caption();
    this.footnote = new Caption();
  }
  positionCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const maxHeight = ctx.layoutBox.height / 10;
    if (title.enabled) {
      this.positionCaption("top", title, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", title, ctx.layoutBox);
    }
    if (subtitle.enabled) {
      this.positionCaption("top", subtitle, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", subtitle, ctx.layoutBox);
    }
    if (footnote.enabled) {
      this.positionCaption("bottom", footnote, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("bottom", footnote, ctx.layoutBox);
    }
  }
  positionAbsoluteCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const { rect } = ctx.series;
    for (const caption of [title, subtitle, footnote]) {
      if (caption.layoutStyle !== "overlay")
        continue;
      if (caption.textAlign === "left") {
        caption.node.x = rect.x + caption.padding;
      } else if (caption.textAlign === "right") {
        const bbox = caption.node.getBBox();
        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;
      }
    }
  }
  computeX(align2, layoutBox) {
    if (align2 === "left") {
      return layoutBox.x;
    } else if (align2 === "right") {
      return layoutBox.x + layoutBox.width;
    }
    return layoutBox.x + layoutBox.width / 2;
  }
  positionCaption(vAlign, caption, layoutBox, maxHeight) {
    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);
    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;
    caption.node.y = layoutBox.y + (vAlign === "top" ? 0 : layoutBox.height) + caption.padding;
    caption.node.textBaseline = vAlign;
    caption.computeTextWrap(layoutBox.width, containerHeight);
  }
  shrinkLayoutByCaption(vAlign, caption, layoutBox) {
    if (caption.layoutStyle === "block") {
      const bbox = caption.node.getBBox();
      const { spacing = 0 } = caption;
      if (vAlign === "bottom" && isArray8(caption.text)) {
        caption.node.y -= bbox.height;
        bbox.y -= bbox.height;
      }
      layoutBox.shrink(
        vAlign === "top" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),
        vAlign
      );
    }
  }
};
__decorateClass([
  Property
], ChartCaptions.prototype, "title", 2);
__decorateClass([
  Property
], ChartCaptions.prototype, "subtitle", 2);
__decorateClass([
  Property
], ChartCaptions.prototype, "footnote", 2);

// packages/ag-charts-community/src/chart/chartContext.ts
import { CleanupRegistry as CleanupRegistry14, EventEmitter as EventEmitter6 } from "ag-charts-core";

// packages/ag-charts-community/src/api/preset/chartTypeOriginator.ts
import { Logger as Logger19 } from "ag-charts-core";
var chartTypes2 = [
  "candlestick",
  "hollow-candlestick",
  "ohlc",
  "line",
  "step-line",
  "hlc",
  "high-low"
];
var ChartTypeOriginator = class {
  constructor(chartService) {
    this.chartService = chartService;
    this.mementoOriginatorKey = "chartType";
  }
  createMemento() {
    let chartType = this.chartService.publicApi?.getOptions()?.chartType;
    chartType ?? (chartType = "candlestick");
    return chartType;
  }
  guardMemento(blob) {
    return blob == null || chartTypes2.includes(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    if (memento == null)
      return;
    const options = { chartType: memento };
    this.chartService.publicApi?.updateDelta(options).catch((e) => Logger19.error("error restoring state", e));
  }
};

// packages/ag-charts-community/src/api/state/historyManager.ts
import { CleanupRegistry as CleanupRegistry6 } from "ag-charts-core";

// packages/ag-charts-community/src/version.ts
var VERSION = "12.1.2";

// packages/ag-charts-community/src/api/state/historyManager.ts
var NOT_FOUND = Symbol("previous-memento-not-found");
var HistoryManager = class {
  constructor(eventsHub) {
    this.history = [];
    this.historyIndex = -1;
    this.originators = /* @__PURE__ */ new Map();
    this.clearState = /* @__PURE__ */ new Map();
    this.maxHistoryLength = 100;
    this.debug = Debug.create(true, "history");
    this.cleanup = new CleanupRegistry6();
    this.cleanup.register(
      eventsHub.on("series:undo", this.undo.bind(this)),
      eventsHub.on("series:redo", this.redo.bind(this))
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  addMementoOriginator(originator) {
    this.originators.set(originator.mementoOriginatorKey, originator);
    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());
    this.debugEvent("History add originator:", originator.mementoOriginatorKey);
  }
  clear() {
    this.debug(`History clear:`, Object.keys(this.originators));
    this.history = [];
    this.historyIndex = -1;
    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {
      this.clearState.set(mementoOriginatorKey, originator.createMemento());
    }
  }
  record(label, ...originators) {
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }
    if (this.history.length > this.maxHistoryLength) {
      this.history = this.history.slice(-this.maxHistoryLength);
    }
    const mementos = /* @__PURE__ */ new Map();
    for (const originator of originators) {
      if (!this.originators.has(originator.mementoOriginatorKey)) {
        throw new Error(
          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`
        );
      }
      mementos.set(originator.mementoOriginatorKey, originator.createMemento());
    }
    this.history.push({ label, mementos });
    this.historyIndex = this.history.length - 1;
    this.debugEvent(`History record: [${label}]`);
  }
  undo() {
    const undoAction = this.history[this.historyIndex];
    if (!undoAction)
      return;
    for (const mementoOriginatorKey of undoAction.mementos.keys()) {
      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);
      if (previousMemento === NOT_FOUND) {
        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);
      }
      this.restoreMemento(mementoOriginatorKey, previousMemento);
    }
    this.historyIndex -= 1;
    this.debugEvent(`History undo: [${undoAction.label}]`);
  }
  redo() {
    const redoAction = this.history[this.historyIndex + 1];
    if (!redoAction)
      return;
    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {
      this.restoreMemento(mementoOriginatorKey, memento);
    }
    this.historyIndex += 1;
    this.debugEvent(`History redo: [${redoAction.label}]`);
  }
  findPreviousMemento(mementoOriginatorKey) {
    for (let i = this.historyIndex - 1; i >= 0; i--) {
      if (this.history[i].mementos.has(mementoOriginatorKey)) {
        return this.history[i].mementos.get(mementoOriginatorKey);
      }
    }
    if (this.clearState.has(mementoOriginatorKey)) {
      return this.clearState.get(mementoOriginatorKey);
    }
    return NOT_FOUND;
  }
  restoreMemento(mementoOriginatorKey, memento) {
    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);
  }
  debugEvent(...logContent) {
    this.debug(
      ...logContent,
      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)
    );
  }
};

// packages/ag-charts-community/src/api/state/memento.ts
import { Logger as Logger20, isDate as isDate2, isObject as isObject4 } from "ag-charts-core";
var MementoCaretaker = class _MementoCaretaker {
  constructor(version) {
    this.version = version.split("-")[0];
  }
  save(...originators) {
    const packet = { version: this.version };
    for (const originator of Object.values(originators)) {
      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());
    }
    return packet;
  }
  restore(blob, ...originators) {
    if (typeof blob !== "object") {
      Logger20.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);
      return;
    }
    if (blob == null) {
      Logger20.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);
      return;
    }
    if (!("version" in blob) || typeof blob.version !== "string") {
      Logger20.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);
      return;
    }
    for (const originator of originators) {
      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);
      const messages = [];
      if (!originator.guardMemento(memento, messages)) {
        const messagesString = messages.length > 0 ? `

${messages.join("\n\n")}

` : "";
        Logger20.warnOnce(
          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.${messagesString}`,
          memento
        );
        return;
      }
      originator.restoreMemento(this.version, blob.version, memento);
    }
  }
  /**
   * Encode a memento as a serializable object, encoding any non-serializble types.
   */
  encode(originator, memento) {
    try {
      return JSON.parse(JSON.stringify(memento, _MementoCaretaker.encodeTypes));
    } catch (error) {
      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {
        cause: error
      });
    }
  }
  /**
   * Decode an encoded memento, decoding any non-serializable types.
   */
  decode(originator, encoded) {
    if (encoded == null)
      return encoded;
    try {
      return JSON.parse(JSON.stringify(encoded), _MementoCaretaker.decodeTypes);
    } catch (error) {
      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {
        cause: error
      });
    }
  }
  static encodeTypes(key, value) {
    if (isDate2(this[key])) {
      return { __type: "date", value: this[key].toISOString() };
    }
    return value;
  }
  static decodeTypes(key, value) {
    if (isObject4(this[key]) && "__type" in this[key] && this[key].__type === "date") {
      return new Date(this[key].value);
    }
    return value;
  }
};

// packages/ag-charts-community/src/api/state/stateManager.ts
var StateManager = class {
  constructor() {
    this.caretaker = new MementoCaretaker(VERSION);
    this.state = /* @__PURE__ */ new Map();
  }
  setState(originator, value) {
    if (objectsEqual(this.state.get(originator.mementoOriginatorKey), value)) {
      return;
    }
    this.setStateAndRestore(originator, value);
  }
  setStateAndRestore(originator, value) {
    this.state.set(originator.mementoOriginatorKey, value);
    this.restoreState(originator);
  }
  restoreState(originator) {
    const { caretaker, state } = this;
    if (!state.has(originator.mementoOriginatorKey))
      return;
    const value = state.get(originator.mementoOriginatorKey);
    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);
  }
};

// packages/ag-charts-community/src/dom/domManager.ts
import {
  attachListener as attachListener7,
  createElement,
  createId as createId5,
  entries as entries3,
  getDocument as getDocument4,
  getWindow as getWindow12,
  kebabCase,
  setAttribute as setAttribute4
} from "ag-charts-core";

// packages/ag-charts-community/src/styles.css
var styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box}.ag-charts-wrapper{--align-items: center;--justify-content: center;position:relative;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ag-charts-wrapper--safe-horizontal{--justify-content: flex-start}.ag-charts-wrapper--safe-vertical{--align-items: flex-start}.ag-charts-tab-guard{width:0%;height:0%;position:absolute;pointer-events:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;pointer-events:auto;display:flex;align-items:var(--align-items);justify-content:var(--justify-content)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none;-webkit-user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{pointer-events:none}.ag-charts-canvas canvas{display:block}.ag-charts-series-area{outline:none;pointer-events:auto;position:absolute}.ag-charts-swapchain{top:0;left:0;outline:none;opacity:0;pointer-events:none;position:absolute;width:100%;height:100%}.ag-charts-swapchain:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none;-webkit-user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-accent-color: #2196f3;--ag-charts-background-color: #fff;--ag-charts-border-color: #dddddd;--ag-charts-border-radius: 4px;--ag-charts-chart-background-color: #fff;--ag-charts-chart-padding: 20px;--ag-charts-focus-shadow: 0 0 0 3px #2196f3;--ag-charts-foreground-color: #181d1f;--ag-charts-font-family: Verdana, sans-serif;--ag-charts-font-size: 12px;--ag-charts-font-weight: 400;--ag-charts-popup-shadow: 0 0 16px rgba(0, 0, 0, .15);--ag-charts-subtle-text-color: #8c8c8c;--ag-charts-text-color: #181d1f;--ag-charts-chrome-background-color: #fafafa;--ag-charts-chrome-font-family: Verdana, sans-serif;--ag-charts-chrome-font-size: 12px;--ag-charts-chrome-font-weight: 400;--ag-charts-chrome-subtle-text-color: #8c8c8c;--ag-charts-chrome-text-color: #181d1f;--ag-charts-button-background-color: #fff;--ag-charts-button-border: 1px solid #dddddd;--ag-charts-button-font-weight: normal;--ag-charts-button-text-color: inherit;--ag-charts-input-background-color: #fff;--ag-charts-input-border: 1px solid #dddddd;--ag-charts-input-text-color: #181d1f;--ag-charts-menu-background-color: #fafafa;--ag-charts-menu-border: 1px solid #dddddd;--ag-charts-menu-text-color: #181d1f;--ag-charts-panel-background-color: #fafafa;--ag-charts-panel-text-color: #181d1f;--ag-charts-tooltip-background-color: #fafafa;--ag-charts-tooltip-border: 1px solid #dddddd;--ag-charts-tooltip-text-color: #181d1f;--ag-charts-tooltip-subtle-text-color: #8c8c8c;--ag-charts-crosshair-label-background-color: #fafafa;--ag-charts-crosshair-label-text-color: #181d1f;--ag-charts-spacing: 4px;--ag-charts-icon-size: 16px;--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 12%);--ag-charts-input-border-radius: var(--ag-charts-border-radius);--ag-charts-input-focus-border-color: var(--ag-charts-accent-color);--ag-charts-input-focus-text-color: var(--ag-charts-accent-color);--ag-charts-input-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-input-disabled-border-color: var(--ag-charts-border-color);--ag-charts-input-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-input-text-color) 50% );--ag-charts-input-placeholder-text-color: color-mix( in srgb, var(--ag-charts-input-background-color), var(--ag-charts-input-text-color) 60% );--ag-charts-button-border-radius: var(--ag-charts-border-radius);--ag-charts-button-focus-background-color: color-mix( in srgb, var(--ag-charts-button-background-color), var(--ag-charts-accent-color) 12% );--ag-charts-button-focus-border-color: var(--ag-charts-accent-color);--ag-charts-button-focus-text-color: var(--ag-charts-accent-color);--ag-charts-button-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-button-disabled-border-color: var(--ag-charts-border-color);--ag-charts-button-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-chrome-text-color) 50% );--ag-charts-checkbox-background-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 35% );--ag-charts-checkbox-checked-background-color: var(--ag-charts-accent-color);--ag-charts-tooltip-border-radius: var(--ag-charts-border-radius);--ag-charts-menu-border-radius: var(--ag-charts-border-radius);--ag-charts-chrome-font-size-small: var(--ag-charts-chrome-font-size);--ag-charts-chrome-font-size-medium: calc(var(--ag-charts-chrome-font-size) * (13 / 12));--ag-charts-chrome-font-size-large: calc(var(--ag-charts-chrome-font-size) * (14 / 12));--ag-charts-border: 1px solid var(--ag-charts-border-color);--ag-charts-focus-border: 1px solid var(--ag-charts-accent-color);--ag-charts-focus-border-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%);--ag-charts-layer-menu: 6;--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1}.ag-charts-theme-default-dark{--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 22%)}.ag-chart-canvas-wrapper .ag-charts-theme-default{--ag-charts-border-radius: var(--ag-border-radius, 4px);--ag-charts-border: var(--ag-borders-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-focus-shadow: var(--ag-focus-shadow, 0 0 0 3px var(--ag-charts-accent-color));--ag-charts-focus-border-shadow: var( --ag-focus-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%) )}.ag-charts-icon{display:block;width:20px;height:20px;speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA1aDEydjFIMnoiLz48Y2lyY2xlIGN4PSIxNS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4yNSIgY3k9IjE0LjUiIHI9IjEuNzUiIHN0cm9rZT0iIzAwMCIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0xOCAxNUg2di0xaDEyem0wLTQuNUgydi0xaDE2eiIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-trend-based-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJtNC45OTYgMTIuNjc0IDMuMjkxLTUuNzQzLjg2OC40OTctMy4yOTEgNS43NDN6Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4zNTEiIGN5PSIxNC41IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTggNmgtN1Y1aDd6bTAgNC41aC03di0xaDd6bTAgNC41SDZ2LTFoMTJ6Ii8+PC9zdmc+)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-chevron-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjQ3IDUuNDdhLjc1Ljc1IDAgMCAxIDEuMDYgMGw0IDRhLjc1Ljc1IDAgMCAxIDAgMS4wNmwtNCA0YS43NS43NSAwIDAgMS0xLjA2LTEuMDZMMTAuOTQgMTAgNy40NyA2LjUzYS43NS43NSAwIDAgMSAwLTEuMDYiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;--input-padding: calc(var(--ag-charts-spacing) * 2);--input-padding-large: calc(var(--ag-charts-spacing) * 2.5);color:var(--ag-charts-input-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);transition-duration:.25s;transition-property:none;transition-timing-function:ease-out}.ag-charts-input:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-button-background-color);border:var(--ag-charts-button-border);border-radius:var(--ag-charts-button-border-radius);color:var(--ag-charts-button-text-color);cursor:pointer;padding:var(--input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-focus-color)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{--checkbox-transition-duration: .1s;appearance:none;background:var(--ag-charts-checkbox-background-color);border-radius:calc(var(--ag-charts-border-radius) * 9);cursor:pointer;height:18px;margin:0;transition-duration:var(--checkbox-transition-duration);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:calc(var(--ag-charts-border-radius) * 7);content:" ";height:14px;margin:2px;transition-duration:var(--checkbox-transition-duration);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-checkbox-checked-background-color)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:var(--ag-charts-input-border);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--textarea-line-height: 1.38;background:var(--ag-charts-input-background-color);border:var(--ag-charts-input-border);border-radius:var(--ag-charts-input-border-radius);line-height:var(--textarea-line-height);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);padding:var(--input-padding-large) var(--input-padding)}.ag-charts-textarea::placeholder{color:var(--ag-charts-input-placeholder-text-color)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-legend-toolbar{pointer-events:auto}.ag-charts-proxy-legend-toolbar>div[role=listitem]{pointer-events:none}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:auto;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;-webkit-user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:solid 1px var(--ag-charts-chrome-background-color);box-shadow:var(--ag-charts-focus-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;overflow:visible}.ag-charts-focus-svg-outer-path{stroke:var(--ag-charts-chrome-background-color);stroke-width:4px}.ag-charts-focus-svg-inner-path{stroke:var(--ag-charts-accent-color);stroke-width:2px}.ag-charts-overlay{color:#181d1f;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay{color:#fff}.ag-charts-overlay--loading{color:#8c8c8c}.ag-charts-overlay__loading-background{background:#fff;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay .ag-charts-overlay__loading-background{background:#192232}.ag-charts-tooltip{--tooltip-arrow-size: 8px;--tooltip-row-spacing: 8px;--tooltip-column-spacing: 16px;position:fixed;inset:unset;margin:0;padding:0;overflow:visible;top:var(--top, 0px);left:var(--left, 0px);width:max-content;max-width:100%;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);color:var(--ag-charts-tooltip-text-color);background:var(--ag-charts-tooltip-background-color);border:var(--ag-charts-tooltip-border);border-radius:var(--ag-charts-tooltip-border-radius);box-shadow:var(--ag-charts-popup-shadow)}.ag-charts-tooltip--compact .ag-charts-tooltip-content{--tooltip-row-spacing: 2px;--tooltip-column-spacing: 8px;padding:3px 6px}.ag-charts-tooltip--arrow-top:before,.ag-charts-tooltip--arrow-right:before,.ag-charts-tooltip--arrow-bottom:before,.ag-charts-tooltip--arrow-left:before{content:"";position:absolute;display:block;width:var(--tooltip-arrow-size);height:var(--tooltip-arrow-size);border:inherit;border-bottom-color:transparent;border-right-color:transparent;background:inherit;clip-path:polygon(0 0,100% 0,100% 1px,1px 100%,0 100%)}.ag-charts-tooltip--arrow-top:before{bottom:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * .5)) rotate(45deg)}.ag-charts-tooltip--arrow-bottom:before{top:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * -.5)) rotate(225deg)}.ag-charts-tooltip--arrow-left:before{right:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * .5)) rotate(315deg)}.ag-charts-tooltip--arrow-right:before{left:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * -.5)) rotate(135deg)}.ag-charts-tooltip--no-interaction{pointer-events:none;user-select:none;-webkit-user-select:none}.ag-charts-tooltip--wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-charts-tooltip--wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-charts-tooltip--wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-charts-tooltip--wrap-never{white-space:nowrap}.ag-charts-tooltip-heading,.ag-charts-tooltip-title,.ag-charts-tooltip-label,.ag-charts-tooltip-value{overflow:hidden;text-overflow:ellipsis}.ag-charts-tooltip-content{display:grid;grid:auto-flow minmax(1em,auto) / 1fr;padding:8px 12px;gap:var(--tooltip-row-spacing)}.ag-charts-tooltip-content:has(.ag-charts-tooltip-symbol){grid:auto-flow minmax(1em,auto) / auto 1fr}.ag-charts-tooltip-heading{grid-column:1 / -1}.ag-charts-tooltip-symbol{grid-column:1 / 2;place-self:center}.ag-charts-tooltip-symbol svg{display:block}.ag-charts-tooltip-title{grid-column:-2 / -1}.ag-charts-tooltip-row{grid-column:1 / -1;display:flex;gap:var(--tooltip-column-spacing);align-items:baseline;justify-content:space-between;overflow:hidden}.ag-charts-tooltip-row--inline{grid-column:-2 / -1}.ag-charts-tooltip-label{flex:1;min-width:0}.ag-charts-tooltip-value{min-width:0}.ag-charts-tooltip-footer{grid-column:1 / -1;color:var(--ag-charts-tooltip-subtle-text-color);text-align:center}.ag-charts-popover{position:absolute;border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);background:var(--ag-charts-panel-background-color);color:var(--ag-charts-chrome-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);box-shadow:var(--ag-charts-popup-shadow);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-menu{--item-padding: 6px 12px;--icon-color: var(--ag-charts-menu-text-color);display:grid;grid:auto-flow auto / 1fr;column-gap:12px;font-size:var(--ag-charts-chrome-font-size)}.ag-charts-menu:has(.ag-charts-menu__icon,.ag-charts-menu__row--stroke-width-visible){grid:auto-flow auto / auto 1fr}.ag-charts-menu__row--stroke-width-visible:before{content:"";height:var(--strokeWidth);width:12px;background:var(--icon-color)}.ag-charts-menu__row--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-menu__row{display:grid;grid-column:1 / -1;grid-template-columns:subgrid;align-items:center;padding:var(--item-padding)}.ag-charts-menu__row:not(.ag-charts-menu__row--active){cursor:pointer}.ag-charts-menu__row:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.ag-charts-menu__row:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.ag-charts-menu__row:focus{background:var(--ag-charts-focus-color)}.ag-charts-menu__row:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--ag-charts-layer-menu)}.ag-charts-menu__row--active{--icon-color: var(--ag-charts-accent-color);background:var(--ag-charts-focus-color);color:var(--ag-charts-accent-color)}.ag-charts-menu__label{grid-column:-1 / span 1}.ag-charts-toolbar{--toolbar-gap: calc(var(--ag-charts-spacing) * 2);--toolbar-size: 34px;--toolbar-button-padding: 6px;align-items:center;display:flex;flex-wrap:nowrap;position:absolute}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-button-border);color:var(--ag-charts-button-text-color);cursor:pointer;display:flex;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-medium);font-weight:var(--ag-charts-chrome-font-weight);justify-content:center;min-height:var(--toolbar-size);min-width:var(--toolbar-size);padding:var(--toolbar-button-padding);position:relative;transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out;white-space:nowrap}.ag-charts-toolbar__button:hover{background:var(--ag-charts-focus-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button--active{background:var(--ag-charts-focus-color);border-color:var(--ag-charts-accent-color);color:var(--ag-charts-accent-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-button-disabled-background-color);color:var(--ag-charts-button-disabled-text-color);cursor:default}.ag-charts-toolbar--horizontal{flex-direction:row;.ag-charts-toolbar__button{margin:0 0 0 -1px}.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar--vertical{flex-direction:column;.ag-charts-toolbar__button{margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-border-radius);border-bottom-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-charts-floating-toolbar{border:none;display:flex;.ag-charts-toolbar{align-items:unset;position:unset}}.ag-charts-floating-toolbar__drag-handle{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);cursor:grab;display:flex;justify-content:center;min-width:24px;padding-left:0;padding-right:0}.ag-charts-floating-toolbar__drag-handle--dragging{cursor:grabbing}\n';

// packages/ag-charts-community/src/util/baseManager.ts
import { CleanupRegistry as CleanupRegistry7 } from "ag-charts-core";
var BaseManager = class {
  constructor() {
    this.cleanup = new CleanupRegistry7();
    this.destroyed = false;
  }
  destroy() {
    this.cleanup.flush();
    this.destroyed = true;
  }
};

// packages/ag-charts-community/src/util/guardedElement.ts
import { CleanupRegistry as CleanupRegistry8, attachListener as attachListener5, getDocument as getDocument2, getWindow as getWindow8, setAttribute as setAttribute2 } from "ag-charts-core";
var GuardedElement = class _GuardedElement {
  constructor(element2, topTabGuard, bottomTabGuard) {
    this.element = element2;
    this.topTabGuard = topTabGuard;
    this.bottomTabGuard = bottomTabGuard;
    this.cleanup = new CleanupRegistry8();
    this.guardTabIndex = 0;
    this.hasFocus = false;
    this.initTabGuard(this.topTabGuard, false);
    this.initTabGuard(this.bottomTabGuard, true);
    this.element.addEventListener("focus", () => this.onFocus(), { capture: true });
    this.element.addEventListener("blur", (ev) => this.onBlur(ev), { capture: true });
  }
  set tabIndex(index) {
    this.guardTabIndex = index;
    if (this.guardTabIndex === 0) {
      this.setGuardIndices(void 0);
    } else if (!this.hasFocus) {
      this.setGuardIndices(this.guardTabIndex);
    }
  }
  destroy() {
    this.cleanup.flush();
  }
  initTabGuard(guard, reverse) {
    this.cleanup.register(attachListener5(guard, "focus", () => this.onTab(guard, reverse)));
  }
  setGuardIndices(index) {
    const tabindex = index;
    setAttribute2(this.topTabGuard, "tabindex", tabindex);
    setAttribute2(this.bottomTabGuard, "tabindex", tabindex);
  }
  onFocus() {
    this.hasFocus = true;
    if (this.guardTabIndex !== 0) {
      this.setGuardIndices(0);
    }
  }
  onBlur({ relatedTarget }) {
    const { topTabGuard: top, bottomTabGuard: bot } = this;
    this.hasFocus = false;
    if (this.guardTabIndex !== 0 && relatedTarget !== top && relatedTarget !== bot) {
      this.setGuardIndices(this.guardTabIndex);
    }
  }
  onTab(guard, reverse) {
    if (this.guardTabIndex !== 0) {
      let focusTarget;
      if (guard.tabIndex === 0) {
        focusTarget = this.findExitTarget(!reverse);
        this.setGuardIndices(this.guardTabIndex);
      } else {
        focusTarget = this.findEnterTarget(reverse);
      }
      focusTarget?.focus();
    }
  }
  static queryFocusable(element2, selectors) {
    const myWindow = getWindow8();
    return Array.from(element2.querySelectorAll(selectors)).filter((e) => {
      if (e instanceof HTMLElement) {
        const style = myWindow.getComputedStyle(e);
        return style.display !== "none" && style.visibility !== "none";
      }
      return false;
    });
  }
  findEnterTarget(reverse) {
    const focusables = _GuardedElement.queryFocusable(this.element, '[tabindex="0"]');
    const index = reverse ? focusables.length - 1 : 0;
    return focusables[index];
  }
  findExitTarget(reverse) {
    const focusables = _GuardedElement.queryFocusable(getDocument2(), "[tabindex]").filter((e) => e.tabIndex > 0).sort((a, b) => a.tabIndex - b.tabIndex);
    const { before, after } = _GuardedElement.findBeforeAndAfter(focusables, this.guardTabIndex);
    return reverse ? before : after;
  }
  static findBeforeAndAfter(elements, targetTabIndex) {
    let left = 0;
    let right = elements.length - 1;
    let before = void 0;
    let after = void 0;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const currentTabIndex = elements[mid].tabIndex;
      if (currentTabIndex === targetTabIndex) {
        before = elements[mid - 1] || void 0;
        after = elements[mid + 1] || void 0;
        break;
      } else if (currentTabIndex < targetTabIndex) {
        before = elements[mid];
        left = mid + 1;
      } else {
        after = elements[mid];
        right = mid - 1;
      }
    }
    return { before, after };
  }
};

// packages/ag-charts-community/src/util/keynavUtil.ts
import { CleanupRegistry as CleanupRegistry9, attachListener as attachListener6, getAttribute as getAttribute2, getWindow as getWindow9, setAttribute as setAttribute3 } from "ag-charts-core";
function hasNoModifiers(event) {
  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);
}
function matchesKey(event, ...keys) {
  return hasNoModifiers(event) && keys.some((key) => event.key === key);
}
var PREV_NEXT_KEYS = {
  horizontal: { nextKey: "ArrowRight", prevKey: "ArrowLeft" },
  vertical: { nextKey: "ArrowDown", prevKey: "ArrowUp" }
};
function isButtonClickEvent(event) {
  if ("button" in event) {
    return event.button === 0;
  }
  return hasNoModifiers(event) && (event.code === "Space" || event.key === "Enter");
}
function stopPageScrolling(element2) {
  return attachListener6(element2, "keydown", (event) => {
    if (event.defaultPrevented)
      return;
    const shouldPrevent = getAttribute2(event.target, "data-preventdefault", true);
    if (shouldPrevent && matchesKey(event, "ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp")) {
      event.preventDefault();
    }
  });
}

// packages/ag-charts-community/src/util/sizeMonitor.ts
import { getDocument as getDocument3, getWindow as getWindow11 } from "ag-charts-core";

// packages/ag-charts-community/src/util/pixelRatioObserver.ts
import { getWindow as getWindow10 } from "ag-charts-core";
var PixelRatioObserver = class {
  constructor(callback5) {
    this.callback = callback5;
    this.devicePixelRatio = getWindow10("devicePixelRatio") ?? 1;
    this.devicePixelRatioMediaQuery = void 0;
    this.devicePixelRatioListener = (e) => {
      if (e.matches)
        return;
      this.devicePixelRatio = getWindow10("devicePixelRatio") ?? 1;
      this.unregisterDevicePixelRatioListener();
      this.registerDevicePixelRatioListener();
      this.callback(this.pixelRatio);
    };
  }
  get pixelRatio() {
    return this.devicePixelRatio;
  }
  observe() {
    this.registerDevicePixelRatioListener();
  }
  disconnect() {
    this.unregisterDevicePixelRatioListener();
  }
  unregisterDevicePixelRatioListener() {
    this.devicePixelRatioMediaQuery?.removeEventListener("change", this.devicePixelRatioListener);
    this.devicePixelRatioMediaQuery = void 0;
  }
  registerDevicePixelRatioListener() {
    const devicePixelRatioMediaQuery = getWindow10("matchMedia")?.(`(resolution: ${this.pixelRatio}dppx)`);
    devicePixelRatioMediaQuery?.addEventListener("change", this.devicePixelRatioListener);
    this.devicePixelRatioMediaQuery = devicePixelRatioMediaQuery;
  }
};

// packages/ag-charts-community/src/util/sizeMonitor.ts
var SizeMonitor = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
    this.documentReady = false;
    this.queuedObserveRequests = [];
    this.onLoad = () => {
      this.documentReady = true;
      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));
      this.queuedObserveRequests = [];
      this.observeWindow();
    };
    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver((entries7) => {
        for (const {
          target,
          contentRect: { width: width2, height: height2 }
        } of entries7) {
          const entry = this.elements.get(target);
          this.checkSize(entry, target, width2, height2);
        }
      });
    }
    let animationFrame;
    this.pixelRatioObserver = new PixelRatioObserver(() => {
      clearTimeout(animationFrame);
      animationFrame = setTimeout(() => this.checkPixelRatio(), 0);
    });
    this.documentReady = getDocument3("readyState") === "complete";
    if (this.documentReady) {
      this.observeWindow();
    } else {
      getWindow11()?.addEventListener("load", this.onLoad);
    }
  }
  destroy() {
    getWindow11()?.removeEventListener("load", this.onLoad);
    this.resizeObserver?.disconnect();
    this.resizeObserver = void 0;
    this.pixelRatioObserver?.disconnect();
    this.pixelRatioObserver = void 0;
  }
  observeWindow() {
    this.pixelRatioObserver?.observe();
  }
  checkPixelRatio() {
    const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;
    for (const [element2, entry] of this.elements) {
      if (entry.size != null && entry.size.pixelRatio !== pixelRatio) {
        const { width: width2, height: height2 } = entry.size;
        entry.size = { width: width2, height: height2, pixelRatio };
        entry.cb(entry.size, element2);
      }
    }
  }
  checkSize(entry, element2, width2, height2) {
    if (!entry)
      return;
    if (width2 !== entry.size?.width || height2 !== entry.size?.height) {
      const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;
      entry.size = { width: width2, height: height2, pixelRatio };
      entry.cb(entry.size, element2);
    }
  }
  // Only a single callback is supported.
  observe(element2, cb) {
    if (!this.documentReady) {
      this.queuedObserveRequests.push([element2, cb]);
      return;
    }
    if (this.elements.has(element2)) {
      this.removeFromQueue(element2);
    } else {
      this.resizeObserver?.observe(element2);
    }
    const entry = { cb };
    this.elements.set(element2, entry);
  }
  unobserve(element2) {
    this.resizeObserver?.unobserve(element2);
    this.elements.delete(element2);
    this.removeFromQueue(element2);
    if (!this.elements.size) {
      this.destroy();
    }
  }
  removeFromQueue(element2) {
    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);
  }
};

// packages/ag-charts-community/src/util/stateTracker.ts
var StateTracker = class extends Map {
  constructor(defaultValue, defaultState) {
    super();
    this.defaultValue = defaultValue;
    this.defaultState = defaultState;
  }
  set(key, value) {
    this.delete(key);
    if (typeof value !== "undefined") {
      super.set(key, value);
    }
    delete this.cachedState;
    delete this.cachedValue;
    return this;
  }
  stateId() {
    this.cachedState ?? (this.cachedState = Array.from(this.keys()).pop() ?? this.defaultState);
    return this.cachedState;
  }
  stateValue() {
    this.cachedValue ?? (this.cachedValue = Array.from(this.values()).pop() ?? this.defaultValue);
    return this.cachedValue;
  }
};

// packages/ag-charts-community/src/dom/domLayout.html
var domLayout_default = '<div role="presentation" class="ag-charts-wrapper ag-charts-styles" data-ag-charts><div role="presentation" class="ag-charts-canvas-center"><div role="presentation" class="ag-charts-canvas-container"><div role="presentation" class="ag-charts-canvas" aria-hidden="true"></div><div role="figure" class="ag-charts-canvas-proxy"><div role="presentation" class="ag-charts-series-area"></div></div><div role="presentation" class="ag-charts-canvas-overlay ag-charts-tooltip-container"></div></div></div></div>';

// packages/ag-charts-community/src/dom/domManager.ts
var DOM_ELEMENT_CLASSES = [
  "styles",
  "canvas",
  "canvas-center",
  "canvas-container",
  "canvas-overlay",
  "canvas-proxy",
  "series-area",
  "tooltip-container"
];
var MINIMAL_DOM_ELEMENT_ROLES = /* @__PURE__ */ new Set(["styles", "canvas-container", "canvas", "tooltip-container"]);
var CONTAINER_MODIFIERS = {
  safeHorizontal: "ag-charts-wrapper--safe-horizontal",
  safeVertical: "ag-charts-wrapper--safe-vertical"
};
var domElementConfig = /* @__PURE__ */ new Map([
  ["styles", { childElementType: "style" }],
  ["canvas", { childElementType: "canvas" }],
  ["canvas-proxy", { childElementType: "div" }],
  ["canvas-overlay", { childElementType: "div" }],
  ["canvas-center", { childElementType: "div" }],
  ["series-area", { childElementType: "div" }],
  ["tooltip-container", { childElementType: "div" }]
]);
function setupObserver(element2, cb) {
  if (typeof IntersectionObserver === "undefined")
    return;
  const observer = new IntersectionObserver(
    (observedEntries) => {
      for (const entry of observedEntries) {
        if (entry.target === element2) {
          cb(entry.intersectionRatio);
        }
      }
    },
    { root: element2 }
  );
  observer.observe(element2);
  return observer;
}
var NULL_DOMRECT = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  toJSON() {
    return NULL_DOMRECT;
  }
};
function createTabGuardElement(guardedElem, where) {
  const div = createElement("div");
  div.className = "ag-charts-tab-guard";
  guardedElem.insertAdjacentElement(where, div);
  return div;
}
var _DOMManager = class _DOMManager extends BaseManager {
  constructor(eventsHub, chart, initialContainer, styleContainer, mode = "normal") {
    super();
    this.eventsHub = eventsHub;
    this.chart = chart;
    this.styleContainer = styleContainer;
    this.mode = mode;
    this.anchorName = `--${createId5(this)}`;
    this.styles = /* @__PURE__ */ new Map();
    this.pendingContainer = void 0;
    this.container = void 0;
    this.documentRoot = void 0;
    this.initiallyConnected = void 0;
    this.containerSize = void 0;
    this.sizeMonitor = new SizeMonitor();
    this.cursorState = new StateTracker("default");
    this.minWidth = 0;
    this.minHeight = 0;
    this.element = this.initDOM();
    this.rootElements = this.initRootElements();
    this.rootElements["canvas"].element.style.setProperty("anchor-name", this.anchorName);
    let hidden = false;
    this.observer = setupObserver(this.element, (intersectionRatio) => {
      if (intersectionRatio === 0 && !hidden) {
        this.eventsHub.emit("dom:hidden", null);
      }
      hidden = intersectionRatio === 0;
    });
    this.setSizeOptions();
    this.updateContainerSize();
    this.addStyles("ag-charts-community", styles_default);
    this.setContainer(initialContainer);
    this.cleanup.register(stopPageScrolling(this.element));
    if (this.mode === "normal") {
      const guardedElement = this.rootElements["canvas-center"].element;
      if (guardedElement == null)
        throw new Error("Error initializing tab guards");
      const topGuard = createTabGuardElement(guardedElement, "beforebegin");
      const botGuard = createTabGuardElement(guardedElement, "afterend");
      this.tabGuards = new GuardedElement(guardedElement, topGuard, botGuard);
    }
  }
  initDOM() {
    if (this.mode === "normal") {
      const templateEl = createElement("div");
      templateEl.innerHTML = domLayout_default;
      return templateEl.firstChild;
    }
    const element2 = createElement("div");
    element2.role = "presentation";
    element2.dataset.agCharts = "";
    element2.classList.add("ag-charts-wrapper");
    const seriesArea = createElement("div");
    element2.appendChild(seriesArea);
    seriesArea.role = "presentation";
    seriesArea.classList.add("ag-charts-series-area");
    return element2;
  }
  initRootElements() {
    const { mode, element: element2 } = this;
    const rootElements = {};
    for (const domElement of DOM_ELEMENT_CLASSES) {
      const className = `ag-charts-${domElement}`;
      let el;
      if (mode === "normal") {
        el = element2.classList.contains(className) ? element2 : element2.getElementsByClassName(className)[0];
      } else if (MINIMAL_DOM_ELEMENT_ROLES.has(domElement)) {
        el = element2;
      } else {
        el = element2.getElementsByClassName(className)[0] ?? createElement("div");
      }
      if (el == null) {
        throw new Error(`AG Charts - unable to find DOM element ${className}`);
      }
      rootElements[domElement] = {
        element: el,
        children: /* @__PURE__ */ new Map(),
        listeners: []
      };
    }
    return rootElements;
  }
  destroy() {
    super.destroy();
    this.observer?.unobserve(this.element);
    if (this.container) {
      this.sizeMonitor.unobserve(this.container);
    }
    this.pendingContainer = void 0;
    Object.values(this.rootElements).forEach((el) => {
      el.children.forEach((c) => c.remove());
      el.element.remove();
    });
    this.element.remove();
  }
  postRenderUpdate() {
    if (this.mode === "minimal")
      return;
    if (this.pendingContainer == null || this.pendingContainer === this.container)
      return;
    if (_DOMManager.batchedUpdateContainer.length === 0) {
      getWindow12().setTimeout(this.applyBatchedUpdateContainer.bind(this), 0);
    }
    _DOMManager.batchedUpdateContainer.push(this);
  }
  applyBatchedUpdateContainer() {
    for (const manager of _DOMManager.batchedUpdateContainer) {
      if (!manager.destroyed) {
        manager.updateContainer();
      }
    }
    _DOMManager.batchedUpdateContainer.splice(0);
  }
  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {
    const { style } = this.element;
    style.width = `${optionsWidth ?? minWidth}px`;
    style.height = `${optionsHeight ?? minHeight}px`;
    this.minWidth = optionsWidth ?? minWidth;
    this.minHeight = optionsHeight ?? minHeight;
    this.updateContainerClassName();
  }
  updateContainerSize() {
    const { style: centerStyle } = this.rootElements["canvas-center"].element;
    centerStyle.visibility = this.containerSize == null ? "hidden" : "";
    if (this.containerSize) {
      centerStyle.width = `${this.containerSize.width ?? 0}px`;
      centerStyle.height = `${this.containerSize.height ?? 0}px`;
    } else {
      centerStyle.width = "";
      centerStyle.height = "";
    }
    this.updateContainerClassName();
  }
  setTabGuardIndex(tabIndex) {
    if (!this.tabGuards)
      return;
    this.tabGuards.tabIndex = tabIndex;
  }
  setContainer(newContainer) {
    if (newContainer === this.container)
      return;
    this.pendingContainer = newContainer;
    if (this.mode === "minimal" || this.container == null) {
      this.updateContainer();
    }
  }
  updateContainer() {
    const { pendingContainer } = this;
    if (pendingContainer == null || pendingContainer === this.container)
      return;
    if (this.container) {
      this.container.removeChild(this.element);
      this.sizeMonitor.unobserve(this.container);
    }
    if (this.documentRoot != null) {
      for (const id of this.rootElements["styles"].children.keys()) {
        this.removeChild("styles", id);
      }
    }
    this.container = pendingContainer;
    this.pendingContainer = void 0;
    this.documentRoot = this.getShadowDocumentRoot(pendingContainer);
    this.initiallyConnected = pendingContainer.isConnected;
    for (const [id, styles] of this.styles) {
      this.addStyles(id, styles);
    }
    pendingContainer.appendChild(this.element);
    this.sizeMonitor.observe(pendingContainer, (size) => {
      this.containerSize = size;
      this.updateContainerSize();
      this.eventsHub.emit("dom:resize", null);
    });
    this.eventsHub.emit("dom:container-change", null);
  }
  setThemeClass(themeClassName) {
    const themeClassNamePrefix = "ag-charts-theme-";
    this.element.classList.forEach((className) => {
      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {
        this.element.classList.remove(className);
      }
    });
    this.element.classList.add(themeClassName);
  }
  setThemeParameters(params) {
    for (const [key, value] of entries3(params)) {
      let formattedValue = `${value}`;
      if (key.endsWith("Size") || key.endsWith("Radius")) {
        formattedValue = `${value}px`;
      } else if (key.endsWith("Border") && typeof value === "boolean") {
        formattedValue = value ? "var(--ag-charts-border)" : "none";
      }
      this.element.style.setProperty(`--ag-charts-${kebabCase(key)}`, formattedValue);
    }
  }
  updateCanvasLabel(ariaLabel) {
    setAttribute4(this.rootElements["canvas-proxy"].element, "aria-label", ariaLabel);
  }
  getEventElement(defaultElem, eventType) {
    const events = ["focus", "blur", "keydown", "keyup"];
    return events.includes(eventType) ? this.rootElements["series-area"].element : defaultElem;
  }
  addEventListener(type, listener, options) {
    const element2 = this.getEventElement(this.element, type);
    return attachListener7(element2, type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this.getEventElement(this.element, type).removeEventListener(type, listener, options);
  }
  /** Get the main chart area client bound rect. */
  getBoundingClientRect() {
    return this.rootElements["canvas"].element.getBoundingClientRect();
  }
  /**
   * Get the client bounding rect for overlay elements that might float outside the bounds of the
   * main chart area.
   */
  getOverlayClientRect() {
    const window2 = getWindow12();
    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);
    const containerBBox = this.getRawOverlayClientRect();
    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;
  }
  getRawOverlayClientRect() {
    let element2 = this.element;
    const fullScreenElement = this.element.getRootNode()?.fullscreenElement;
    while (element2 != null) {
      let isContainer;
      if (fullScreenElement != null && element2 === fullScreenElement) {
        isContainer = true;
      } else {
        const styleMap = element2.computedStyleMap?.();
        const overflowY = styleMap?.get("overflow-y")?.toString();
        isContainer = overflowY === "auto" || overflowY === "scroll";
      }
      if (isContainer) {
        return BBox.fromDOMRect(element2.getBoundingClientRect());
      }
      element2 = element2.parentElement;
    }
    if (this.documentRoot != null)
      return BBox.fromDOMRect(this.documentRoot.getBoundingClientRect());
    const { innerWidth, innerHeight } = getWindow12();
    return new BBox(0, 0, innerWidth, innerHeight);
  }
  getShadowDocumentRoot(current = this.container) {
    const docRoot = current?.ownerDocument?.body ?? getDocument4("body");
    while (current != null) {
      if (current === docRoot) {
        return void 0;
      }
      if (current.parentNode instanceof DocumentFragment) {
        return current;
      }
      current = current.parentNode;
    }
  }
  getParent(domElementClass) {
    return this.rootElements[domElementClass].element;
  }
  getChildBoundingClientRect(type) {
    const { children } = this.rootElements[type];
    const childRects = [];
    for (const child of children.values()) {
      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));
    }
    return BBox.merge(childRects);
  }
  isManagedChildDOMElement(el, domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    const search = children?.get(id);
    return search != null && el.contains(search);
  }
  contains(element2, domElementClass) {
    if (domElementClass == null)
      return this.element.contains(element2);
    return this.rootElements[domElementClass].element.contains(element2);
  }
  addStyles(id, styles) {
    const dataAttribute = "data-ag-charts";
    this.styles.set(id, styles);
    if (this.container == null)
      return;
    const checkId = (el) => {
      return el.getAttribute(dataAttribute) === id;
    };
    const addStyleElement = (el) => {
      const metaElements = /* @__PURE__ */ new Set(["TITLE", "META"]);
      let skippingMetaElements = true;
      let insertAfterEl;
      for (const child of el.children) {
        if (skippingMetaElements && metaElements.has(child.tagName)) {
          insertAfterEl = child;
          continue;
        }
        skippingMetaElements = false;
        if (checkId(child))
          return;
        if (child.hasAttribute(dataAttribute)) {
          insertAfterEl = child;
        }
      }
      const styleEl = createElement("style");
      if (this.chart.styleNonce != null) {
        styleEl.nonce = this.chart.styleNonce;
      }
      if (insertAfterEl == null) {
        el.prepend(styleEl);
      } else {
        el.insertBefore(styleEl, insertAfterEl.nextSibling);
      }
      return styleEl;
    };
    let styleElement;
    if (this.styleContainer) {
      styleElement = addStyleElement(this.styleContainer);
    } else if (this.initiallyConnected === false) {
      styleElement = this.addChild("styles", id);
    } else if (this.documentRoot == null && !_DOMManager.headStyles.has(id)) {
      styleElement = addStyleElement(getDocument4("head"));
      _DOMManager.headStyles.add(id);
    } else if (this.documentRoot != null) {
      styleElement = this.addChild("styles", id);
    }
    if (styleElement == null || checkId(styleElement))
      return;
    styleElement.setAttribute(dataAttribute, id);
    styleElement.innerHTML = styles;
  }
  removeStyles(id) {
    this.removeChild("styles", id);
  }
  updateCursor(callerId, style) {
    this.cursorState.set(callerId, style);
    this.element.style.cursor = this.cursorState.stateValue();
  }
  getCursor() {
    return this.element.style.cursor;
  }
  addChild(domElementClass, id, child, insert) {
    const { element: element2, children, listeners } = this.rootElements[domElementClass];
    if (!children) {
      throw new Error("AG Charts - unable to create DOM elements after destroy()");
    }
    if (children.has(id)) {
      return children.get(id);
    }
    const { childElementType = "div" } = domElementConfig.get(domElementClass) ?? {};
    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {
      throw new Error("AG Charts - mismatching DOM element type");
    }
    const newChild = child ?? createElement(childElementType);
    for (const [type, fn, opts] of listeners) {
      newChild.addEventListener(type, fn, opts);
    }
    children.set(id, newChild);
    if (childElementType === "style" && this.chart.styleNonce != null) {
      newChild.nonce = this.chart.styleNonce;
    }
    if (insert) {
      const queryResult = element2.querySelector(insert.query);
      if (queryResult == null) {
        throw new Error(`AG Charts - addChild query failed ${insert.query}`);
      }
      queryResult.insertAdjacentElement(insert.where, newChild);
    } else {
      element2?.appendChild(newChild);
    }
    return newChild;
  }
  removeChild(domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    if (!children)
      return;
    children.get(id)?.remove();
    children.delete(id);
  }
  incrementDataCounter(name) {
    const { dataset } = this.element;
    dataset[name] ?? (dataset[name] = "0");
    dataset[name] = String(Number(dataset[name]) + 1);
  }
  setDataBoolean(name, value) {
    this.element.dataset[name] = String(value);
  }
  updateContainerClassName() {
    const { element: element2, containerSize, minWidth, minHeight } = this;
    element2.classList.toggle(CONTAINER_MODIFIERS.safeHorizontal, minWidth >= (containerSize?.width ?? Infinity));
    element2.classList.toggle(CONTAINER_MODIFIERS.safeVertical, minHeight >= (containerSize?.height ?? Infinity));
  }
};
_DOMManager.batchedUpdateContainer = [];
_DOMManager.headStyles = /* @__PURE__ */ new Set();
var DOMManager = _DOMManager;

// packages/ag-charts-community/src/dom/proxyInteractionService.ts
import { CleanupRegistry as CleanupRegistry10, createElement as createElement8, setElementStyle as setElementStyle3 } from "ag-charts-core";

// packages/ag-charts-community/src/widget/boundedTextWidget.ts
import { createElement as createElement2, createSvgElement as createSvgElement12 } from "ag-charts-core";
var BoundedTextWidget = class extends Widget {
  constructor() {
    super(createElement2("div"));
    this.textElement = createSvgElement12("text");
    this.textElement.role = "presentation";
    this.svgElement = createSvgElement12("svg");
    this.svgElement.appendChild(this.textElement);
    this.svgElement.style.width = "100%";
    this.svgElement.style.opacity = "0";
    this.svgElement.role = "presentation";
    this.elem.appendChild(this.svgElement);
    this.elem.role = "presentation";
  }
  set textContent(text) {
    this.textElement.textContent = text;
    const bboxCalculator = this.textElement;
    const bbox = bboxCalculator.getBBox?.();
    if (bbox) {
      this.svgElement.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
    }
  }
  get textContent() {
    return this.textElement.textContent;
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/buttonWidget.ts
import { createElement as createElement3 } from "ag-charts-core";

// packages/ag-charts-community/src/widget/abstractButtonWidget.ts
import { setAttribute as setAttribute5 } from "ag-charts-core";
var AbstractButtonWidget = class extends Widget {
  constructor(element2, role) {
    super(element2);
    setAttribute5(this.elem, "role", role);
    this.setEnabled(true);
    this.addListener("keydown", ({ sourceEvent }) => {
      if (isButtonClickEvent(sourceEvent)) {
        sourceEvent.preventDefault();
        this.htmlListener?.dispatch("click", this, { type: "click", device: "keyboard", sourceEvent });
      }
    });
  }
  destructor() {
  }
  setEnabled(enabled) {
    setAttribute5(this.elem, "aria-disabled", !enabled);
  }
  addListener(type, listener) {
    return super.addListener(type, (ev, current) => {
      if ((type === "click" || type === "dblclick") && this.isDisabled())
        return;
      listener(ev, current);
    });
  }
};

// packages/ag-charts-community/src/widget/buttonWidget.ts
var ButtonWidget = class extends AbstractButtonWidget {
  constructor() {
    super(createElement3("button"));
  }
};

// packages/ag-charts-community/src/widget/groupWidget.ts
import { createElement as createElement4, setAttribute as setAttribute6 } from "ag-charts-core";
var GroupWidget = class extends Widget {
  constructor() {
    super(createElement4("div"));
    setAttribute6(this.elem, "role", "group");
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/listWidget.ts
import { createElement as createElement6, setAttribute as setAttribute8, setElementStyle as setElementStyle2 } from "ag-charts-core";

// packages/ag-charts-community/src/widget/rovingTabContainerWidget.ts
import { createElement as createElement5, getAttribute as getAttribute3, setAttribute as setAttribute7 } from "ag-charts-core";
var RovingTabContainerWidget = class extends Widget {
  constructor(initialOrientation, role) {
    super(createElement5("div"));
    this.focusedChildIndex = 0;
    this.onChildFocus = (_event, child) => {
      const oldFocus = this.children[this.focusedChildIndex];
      this.focusedChildIndex = child.index;
      oldFocus?.setTabIndex(-1);
      child.setTabIndex(0);
    };
    this.onChildKeyDown = (event, child) => {
      const rovingOrientation = this.orientation;
      const [primaryKeys, secondaryKeys] = rovingOrientation === "both" ? [PREV_NEXT_KEYS["horizontal"], PREV_NEXT_KEYS["vertical"]] : [PREV_NEXT_KEYS[rovingOrientation], void 0];
      let targetIndex = -1;
      if (hasNoModifiers(event.sourceEvent)) {
        const key = event.sourceEvent.key;
        if (key === primaryKeys.nextKey || key === secondaryKeys?.nextKey) {
          targetIndex = child.index + 1;
        } else if (key === primaryKeys.prevKey || key === secondaryKeys?.prevKey) {
          targetIndex = child.index - 1;
        }
      }
      this.children[targetIndex]?.focus();
    };
    setAttribute7(this.elem, "role", role);
    this.orientation = initialOrientation;
  }
  get orientation() {
    return getAttribute3(this.elem, "aria-orientation") ?? "both";
  }
  set orientation(orientation) {
    setAttribute7(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
  }
  focus() {
    this.children[this.focusedChildIndex]?.focus();
  }
  clear() {
    this.focusedChildIndex = 0;
    for (const child of this.children) {
      this.removeChildListeners(child);
      child.parent = void 0;
    }
    this.elem.textContent = "";
    this.children.length = 0;
  }
  addChildListeners(child) {
    child.addListener("focus", this.onChildFocus);
    child.addListener("keydown", this.onChildKeyDown);
  }
  removeChildListeners(child) {
    child.removeListener("focus", this.onChildFocus);
    child.removeListener("keydown", this.onChildKeyDown);
  }
  onChildAdded(child) {
    this.addChildListeners(child);
    child.setTabIndex(this.children.length === 1 ? 0 : -1);
  }
  onChildRemoved(removedChild) {
    this.removeChildListeners(removedChild);
    const { focusedChildIndex, children } = this;
    const removedFocusedChild = focusedChildIndex === removedChild.index;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.index === focusedChildIndex) {
        this.focusedChildIndex = i;
      }
      child.index = i;
    }
    if (removedFocusedChild) {
      const newFocusChild = children[focusedChildIndex] ?? children[focusedChildIndex - 1];
      if (newFocusChild) {
        this.focusedChildIndex = newFocusChild.index;
        newFocusChild.setTabIndex(0);
      } else {
        this.focusedChildIndex = 0;
      }
    }
  }
};

// packages/ag-charts-community/src/widget/listWidget.ts
var ListWidget = class extends RovingTabContainerWidget {
  constructor() {
    super("both", "list");
    this.setHidden(true);
  }
  destructor() {
    this.children.forEach((c) => c.getElement().parentElement.remove());
  }
  addChildToDOM(child, before) {
    const listItem = createElement6("div");
    setAttribute8(listItem, "role", "listitem");
    setElementStyle2(listItem, "position", "absolute");
    Widget.setElementContainer(child, listItem);
    this.appendOrInsert(listItem, before);
    this.setHidden(false);
  }
  removeChildFromDOM(child) {
    child.getElement().parentElement.remove();
    this.setHidden(this.children.length === 0);
  }
  setHidden(hidden) {
    if (this.children.length === 0) {
      hidden = true;
    }
    super.setHidden(hidden);
  }
};

// packages/ag-charts-community/src/widget/nativeWidget.ts
var NativeWidget = class extends Widget {
  constructor(elem) {
    super(elem);
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/sliderWidget.ts
import { clamp as clamp12, createElement as createElement7, getAttribute as getAttribute4, setAttribute as setAttribute9 } from "ag-charts-core";
var _SliderWidget = class _SliderWidget extends Widget {
  constructor() {
    super(createElement7("input"));
    this._step = _SliderWidget.STEP_ONE;
    this.orientation = "both";
  }
  get step() {
    return this._step;
  }
  set step(step) {
    this._step = step;
    this.getElement().step = step.attributeValue;
  }
  get keyboardStep() {
    return this._keyboardStep?.step ?? this._step;
  }
  set keyboardStep(step) {
    if (step === this._keyboardStep?.step)
      return;
    if (this._keyboardStep !== void 0) {
      this.removeListener("keydown", this._keyboardStep.onKeyDown);
      this.removeListener("keyup", this._keyboardStep.onKeyUp);
      this.removeListener("blur", this._keyboardStep.onBlur);
      this._keyboardStep = void 0;
    }
    if (step !== void 0) {
      const onKeyDown = () => this.getElement().step = step.attributeValue;
      const resetStep = () => this.getElement().step = this._step.attributeValue;
      this._keyboardStep = { step, onKeyDown, onKeyUp: resetStep, onBlur: resetStep };
      this.addListener("keydown", this._keyboardStep.onKeyDown);
      this.addListener("keyup", this._keyboardStep.onKeyUp);
      this.addListener("blur", this._keyboardStep.onBlur);
    }
  }
  get orientation() {
    return getAttribute4(this.elem, "aria-orientation") ?? "both";
  }
  set orientation(orientation) {
    setAttribute9(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
    _SliderWidget.registerDefaultPreventers(this, orientation);
  }
  destructor() {
  }
  clampValueRatio(clampMin, clampMax) {
    const ratio8 = this.getValueRatio();
    const clampedRatio = clamp12(clampMin, ratio8, clampMax);
    if (clampedRatio !== ratio8) {
      this.setValueRatio(clampedRatio);
    }
    return clampedRatio;
  }
  setValueRatio(ratio8, opts) {
    const { divider } = this.step;
    const value = Math.round(ratio8 * 1e4) / divider;
    const { ariaValueText = formatPercent(value / divider) } = opts ?? {};
    const elem = this.getElement();
    elem.value = `${value}`;
    elem.ariaValueText = ariaValueText;
  }
  getValueRatio() {
    return this.getElement().valueAsNumber / this.step.divider;
  }
  static registerDefaultPreventers(target, orientation) {
    if (orientation === "both") {
      target.removeListener("keydown", _SliderWidget.onKeyDown);
    } else {
      target.addListener("keydown", _SliderWidget.onKeyDown);
    }
  }
  static onKeyDown(ev, current) {
    let ignoredKeys = [];
    const { orientation } = current;
    if (orientation === "horizontal") {
      ignoredKeys = ["ArrowUp", "ArrowDown"];
    } else if (orientation === "vertical") {
      ignoredKeys = ["ArrowLeft", "ArrowRight"];
    }
    if (ignoredKeys.includes(ev.sourceEvent.code)) {
      ev.sourceEvent.preventDefault();
    }
  }
};
_SliderWidget.STEP_ONE = { attributeValue: "1", divider: 1 };
_SliderWidget.STEP_HUNDRETH = { attributeValue: "0.01", divider: 100 };
var SliderWidget = _SliderWidget;

// packages/ag-charts-community/src/widget/switchWidget.ts
import { setAttribute as setAttribute10 } from "ag-charts-core";
var SwitchWidget = class extends ButtonWidget {
  constructor() {
    super();
    setAttribute10(this.elem, "role", "switch");
    this.setChecked(false);
  }
  setChecked(checked) {
    setAttribute10(this.elem, "aria-checked", checked);
  }
};

// packages/ag-charts-community/src/widget/toolbarWidget.ts
var ToolbarWidget = class extends RovingTabContainerWidget {
  constructor(orientation = "horizontal") {
    super(orientation, "toolbar");
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/dom/proxyInteractionService.ts
function checkType(type, meta) {
  return meta.params?.type === type;
}
function allocateResult(type) {
  if ("button" === type) {
    return new ButtonWidget();
  } else if ("slider" === type) {
    return new SliderWidget();
  } else if ("toolbar" === type) {
    return new ToolbarWidget();
  } else if ("group" === type) {
    return new GroupWidget();
  } else if ("list" === type) {
    return new ListWidget();
  } else if ("region" === type) {
    return new NativeWidget(createElement8("div"));
  } else if ("text" === type) {
    return new BoundedTextWidget();
  } else if ("listswitch" === type) {
    return new SwitchWidget();
  } else {
    throw Error("AG Charts - error allocating meta");
  }
}
function allocateMeta(params) {
  const meta = { params, result: void 0 };
  meta.result = allocateResult(meta.params.type);
  return meta;
}
var ProxyInteractionService = class {
  constructor(eventsHub, localeManager, domManager) {
    this.eventsHub = eventsHub;
    this.localeManager = localeManager;
    this.domManager = domManager;
    this.cleanup = new CleanupRegistry10();
  }
  destroy() {
    this.cleanup.flush();
  }
  addLocalisation(fn) {
    fn();
    this.cleanup.register(this.eventsHub.on("locale:change", fn));
  }
  createProxyContainer(args) {
    const meta = allocateMeta(args);
    const { params, result } = meta;
    const div = result.getElement();
    this.domManager.addChild("canvas-proxy", params.domManagerId, div);
    div.classList.add(...params.classList, "ag-charts-proxy-container");
    div.role = params.type;
    if (checkType("toolbar", meta)) {
      meta.result.orientation = meta.params.orientation;
    }
    this.addLocalisation(() => {
      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
    });
    return result;
  }
  createProxyElement(args) {
    const meta = allocateMeta(args);
    if (checkType("button", meta)) {
      const { params, result } = meta;
      const button = result.getElement();
      this.initInteract(params, result);
      if (typeof params.textContent === "string") {
        button.textContent = params.textContent;
      } else {
        const { textContent } = params;
        this.addLocalisation(() => {
          button.textContent = this.localeManager.t(textContent.id, textContent.params);
        });
      }
      this.setParent(meta.params, meta.result);
    }
    if (checkType("slider", meta)) {
      const { params, result } = meta;
      const slider = result.getElement();
      this.initInteract(params, result);
      slider.type = "range";
      slider.role = "presentation";
      slider.style.margin = "0px";
      this.addLocalisation(() => {
        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
      });
      this.setParent(meta.params, meta.result);
    }
    if (checkType("text", meta)) {
      const { params, result } = meta;
      this.initElement(params, result);
      this.setParent(meta.params, meta.result);
    }
    if (checkType("listswitch", meta)) {
      const { params, result: button } = meta;
      this.initInteract(params, button);
      button.setTextContent(params.textContent);
      button.setChecked(params.ariaChecked);
      button.setAriaDescribedBy(params.ariaDescribedBy);
      this.setParent(meta.params, meta.result);
    }
    if (checkType("region", meta)) {
      const { params, result } = meta;
      const region = result.getElement();
      this.initInteract(params, result);
      region.role = "region";
      this.setParent(meta.params, meta.result);
    }
    return meta.result;
  }
  initElement(params, widget) {
    const element2 = widget.getElement();
    setElementStyle3(element2, "cursor", params.cursor);
    element2.classList.toggle("ag-charts-proxy-elem", true);
    return element2;
  }
  initInteract(params, widget) {
    const { tabIndex, domIndex } = params;
    const element2 = this.initElement(params, widget);
    if (tabIndex !== void 0) {
      element2.tabIndex = tabIndex;
    }
    if (domIndex !== void 0) {
      widget.domIndex = domIndex;
    }
  }
  setParent(params, element2) {
    if ("parent" in params) {
      params.parent?.addChild(element2);
    } else {
      const insert = { where: params.where, query: ".ag-charts-series-area" };
      this.domManager.addChild("canvas-proxy", params.domManagerId, element2.getElement(), insert);
      element2.destroyListener = () => {
        this.domManager.removeChild("canvas-proxy", params.domManagerId);
      };
    }
  }
};

// packages/ag-charts-locale/src/en-US.ts
var AG_CHARTS_LOCALE_EN_US = {
  // Initial screen reader alt-text of the series area
  ariaInitSeriesArea: "interactive chart",
  // Screen reader announcement when focusing an item in the chart
  ariaAnnounceHoverDatum: "${datum}",
  // Screen reader announcement when focusing a chart
  ariaAnnounceChart: "chart, ${seriesCount}[number] series",
  // Screen reader announcement when focusing a standalone chart (gauges, pyramid)
  ariaAnnounceStandaloneChart: "chart, ${caption}",
  // Screen reader announcement when focusing a hierarchy chart
  ariaAnnounceHierarchyChart: "hierarchy chart, ${caption}",
  // Screen reader announcement when focusing a gauge chart
  ariaAnnounceGaugeChart: "gauge chart, ${caption}",
  // Screen reader announcement when focusing an item in a treemap or sunburst chart
  ariaAnnounceHierarchyDatum: "level ${level}[number], ${count}[number] children, ${description}",
  // Screen reader announcement when focusing a link in a Sankey or chord chart
  ariaAnnounceFlowProportionLink: "link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}",
  // Screen reader announcement when focusing a node in a Sankey or chord chart
  ariaAnnounceFlowProportionNode: "node ${index} of ${count}, ${description}",
  // Screen reader description for legend items
  ariaDescriptionLegendItem: "Press Space or Enter to toggle visibility",
  // Screen reader for the '+' horizontal line button on the Y-axis
  ariaLabelAddHorizontalLine: "Add Horizontal Line",
  // Screen reader text for annotations toolbar
  ariaLabelAnnotationsToolbar: "Annotations",
  // Screen reader text for annotation-options toolbar
  ariaLabelAnnotationOptionsToolbar: "Annotation Options",
  // Screen reader text for annotation-settings dialog
  ariaLabelAnnotationSettingsDialog: "Annotation Settings",
  // Screen reader text for the color-code label in the picker dialog
  ariaLabelColor: "Color",
  // Screen reader text for the color picker dialog
  ariaLabelColorPicker: "Color picker",
  // Screen reader text for the alpha-channel slider label
  ariaLabelColorPickerAlpha: "Transparency",
  // Screen reader text for the hue slider label
  ariaLabelColorPickerHue: "Hue",
  // Screen reader text for when the color-code is multi-colored
  ariaLabelColorPickerMultiColor: "Multi Color",
  // Screen reader text for the 2D palette slider label
  ariaLabelColorPickerPalette: "Palette",
  // Screen reader text for the financial charts toolbar
  ariaLabelFinancialCharts: "Financial Charts",
  // Screen reader text for the legend toolbar
  ariaLabelLegend: "Legend",
  // Screen reader text for the legend pagination button
  ariaLabelLegendPagination: "Legend Pagination",
  // Screen reader text for the previous legend page button
  ariaLabelLegendPagePrevious: "Previous Legend Page",
  // Screen reader text for the next legend page button
  ariaLabelLegendPageNext: "Next Legend Page",
  // Screen reader text for the an item in the legend
  ariaLabelLegendItem: "${label}, Legend item ${index}[number] of ${count}[number]",
  // Screen reader text for the an unknown item in the legend
  ariaLabelLegendItemUnknown: "Unknown legend item",
  // Screen reader text for the navigator element
  ariaLabelNavigator: "Navigator",
  // Screen reader text for an accessibility control that changes the position of the navigator's range
  ariaLabelNavigatorRange: "Range",
  // Screen reader text for an accessibility control that changes the start of the navigator's range
  ariaLabelNavigatorMinimum: "Minimum",
  // Screen reader text for an accessibility control that changes the end of the navigator's range
  ariaLabelNavigatorMaximum: "Maximum",
  // Screen reader text for ranges toolbar
  ariaLabelRangesToolbar: "Ranges",
  // Screen reader text for the settings dialog tab-bar
  ariaLabelSettingsTabBar: "Settings",
  // Screen reader text for zoom toolbar
  ariaLabelZoomToolbar: "Zoom",
  // Aria role description for a 2D role="slider"
  ariaRoleDescription2DSlider: "2D slider",
  // Screen reader text for color picker's 2D slider palette
  ariaValueColorPalette: "s ${s}[percent0to2dp], v ${v}[percent0to2dp]",
  // Screen reader text for color picker's 2D slider palette (when arrowing up or down)
  ariaValueColorPaletteFirstV: "v ${v}[percent0to2dp], s ${s}[percent0to2dp]",
  // Screen reader text for the value of the navigator's range
  ariaValuePanRange: "${min}[percent0to2dp] to ${max}[percent0to2dp]",
  // Alt-text for the solid line dash style menu item icon
  iconAltTextLineStyleSolid: "Solid",
  // Alt-text for the long-dashed line dash style menu item icon
  iconAltTextLineStyleDashed: "Long-dashed",
  // Alt-text for the short-dashed line dash style menu item icon
  iconAltTextLineStyleDotted: "Short-dashed",
  // Alt-text for the 'position-top' icon
  iconAltTextPositionTop: "Top",
  // Alt-text for the 'position-center' icon
  iconAltTextPositionCenter: "Center",
  // Alt-text for the 'position-bottom' icon
  iconAltTextPositionBottom: "Bottom",
  // Alt-text for the 'position-left' icon
  iconAltTextAlignLeft: "Left",
  // Alt-text for the 'align-center' icon
  iconAltTextAlignCenter: "Center",
  // Alt-text for the 'position-right' icon
  iconAltTextAlignRight: "Right",
  // Alt-text for the 'close' icon
  iconAltTextClose: "Close",
  // Default text for the 'loading data' overlay
  overlayLoadingData: "Loading data...",
  // Default text for the 'no data' overlay
  overlayNoData: "No data to display",
  // Default text for the 'no visible series' overlay
  overlayNoVisibleSeries: "No visible series",
  // Default text for the 'unsupported browser' overlay
  overlayUnsupportedBrowser: "Incompatible browser version. Please upgrade your browser.",
  // Text for frequency label in Histogram Series tooltip
  seriesHistogramTooltipFrequency: "Frequency",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipSum: "${yName} (sum)",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipCount: "${yName} (count)",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipMean: "${yName} (mean)",
  // Text for the series type toolbar's chart type button
  toolbarSeriesTypeDropdown: "Chart Type",
  // Text for the series type toolbar's OHLC chart type button
  toolbarSeriesTypeOHLC: "OHLC",
  // Text for the series type toolbar's HLC chart type button
  toolbarSeriesTypeHLC: "HLC",
  // Text for the series type toolbar's high low chart type button
  toolbarSeriesTypeHighLow: "High Low",
  // Text for the series type toolbar's candles chart type button
  toolbarSeriesTypeCandles: "Candles",
  // Text for the series type toolbar's hollow candles chart type button
  toolbarSeriesTypeHollowCandles: "Hollow Candles",
  // Text for the series type toolbar's line chart type button
  toolbarSeriesTypeLine: "Line",
  // Text for the series type toolbar's line with markers chart type button
  toolbarSeriesTypeLineWithMarkers: "Line with Markers",
  // Text for the series type toolbar's line with step line chart type button
  toolbarSeriesTypeStepLine: "Step Line",
  // Text for the annotation toolbar's trend line button
  toolbarAnnotationsTrendLine: "Trend Line",
  // Text for the annotation toolbar's Fibonacci Retracement button
  toolbarAnnotationsFibonacciRetracement: "Fib Retracement",
  // Text for the annotation toolbar's Fibonacci Retracement Trend Based button
  toolbarAnnotationsFibonacciRetracementTrendBased: "Fib Trend Based",
  // Text for the annotation toolbar's horizontal line button
  toolbarAnnotationsHorizontalLine: "Horizontal Line",
  // Text for the annotation toolbar's vertical line button
  toolbarAnnotationsVerticalLine: "Vertical Line",
  // Text for the annotation toolbar's parallel channel button
  toolbarAnnotationsParallelChannel: "Parallel Channel",
  // Text for the annotation toolbar's disjoint channel button
  toolbarAnnotationsDisjointChannel: "Disjoint Channel",
  // Text for the annotation toolbar's clear all button
  toolbarAnnotationsClearAll: "Clear All",
  // Text for the annotation toolbar's fill color picker annotation button
  toolbarAnnotationsFillColor: "Fill Color",
  // Text for the annotation toolbar's line color picker annotation button
  toolbarAnnotationsLineColor: "Line Color",
  // Text for the annotation toolbar's line style type button
  toolbarAnnotationsLineStyle: "Line Style",
  // Text for the annotation toolbar's line stroke width button
  toolbarAnnotationsLineStrokeWidth: "Line Stroke Width",
  // Text for the annotation toolbar's settings annotation button
  toolbarAnnotationsSettings: "Settings",
  // Text for the annotation toolbar's text color picker annotation button
  toolbarAnnotationsTextColor: "Text Color",
  // Text for the annotation toolbar's text size picker annotation button
  toolbarAnnotationsTextSize: "Text Size",
  // Text for the annotation toolbar's lock annotation button
  toolbarAnnotationsLock: "Lock",
  // Text for the annotation toolbar's unlock annotation button
  toolbarAnnotationsUnlock: "Unlock",
  // Text for the annotation toolbar's delete annotation button
  toolbarAnnotationsDelete: "Delete",
  // Text for the annotation toolbar's drag handle
  toolbarAnnotationsDragHandle: "Drag Toolbar",
  // Text for the annotation toolbar's line drawings menu button
  toolbarAnnotationsLineAnnotations: "Trend Lines",
  // Text for the annotation toolbar's Fibonacci drawings menu button
  toolbarAnnotationsFibonacciAnnotations: "Fibonacci",
  // Text for the annotation toolbar's text annotations menu button
  toolbarAnnotationsTextAnnotations: "Text Annotations",
  // Text for the annotation toolbar's shapes menu button
  toolbarAnnotationsShapeAnnotations: "Arrows",
  // Text for the annotation toolbar's measurers menu button
  toolbarAnnotationsMeasurerAnnotations: "Measurers",
  // Text for the annotation toolbar's callout button
  toolbarAnnotationsCallout: "Callout",
  // Text for the annotation toolbar's comment button
  toolbarAnnotationsComment: "Comment",
  // Text for the annotation toolbar's note button
  toolbarAnnotationsNote: "Note",
  // Text for the annotation toolbar's text button
  toolbarAnnotationsText: "Text",
  // Text for the annotation toolbar's arrow button
  toolbarAnnotationsArrow: "Arrow",
  // Text for the annotation toolbar's arrow up button
  toolbarAnnotationsArrowUp: "Arrow Up",
  // Text for the annotation toolbar's arrow down button
  toolbarAnnotationsArrowDown: "Arrow Down",
  // Text for the annotation toolbar's date range button
  toolbarAnnotationsDateRange: "Date Range",
  // Text for the annotation toolbar's price range button
  toolbarAnnotationsPriceRange: "Price Range",
  // Text for the annotation toolbar's date and price range button
  toolbarAnnotationsDatePriceRange: "Date and Price",
  // Text for the annotation toolbar's quick date and price range button
  toolbarAnnotationsQuickDatePriceRange: "Measure",
  // Text for the range toolbar's 1 month button
  toolbarRange1Month: "1M",
  // Aria label for the range toolbar's 1 month button
  toolbarRange1MonthAria: "1 month",
  // Text for the range toolbar's 3 month button
  toolbarRange3Months: "3M",
  // Aria label for the range toolbar's 3 month button
  toolbarRange3MonthsAria: "3 months",
  // Text for the range toolbar's 6 month button
  toolbarRange6Months: "6M",
  // Aria label for the range toolbar's 6 month button
  toolbarRange6MonthsAria: "6 months",
  // Text for the range toolbar's year to date button
  toolbarRangeYearToDate: "YTD",
  // Aria label for the range toolbar's year to date month button
  toolbarRangeYearToDateAria: "Year to date",
  // Text for the range toolbar's 1 year button
  toolbarRange1Year: "1Y",
  // Aria label for the range toolbar's 1 year button
  toolbarRange1YearAria: "1 year",
  // Text for the range toolbar's full range button
  toolbarRangeAll: "All",
  // Aria label for the range toolbar's full range button
  toolbarRangeAllAria: "All",
  // Text for the zoom toolbar's zoom out button
  toolbarZoomZoomOut: "Zoom out",
  // Text for the zoom toolbar's zoom in button
  toolbarZoomZoomIn: "Zoom in",
  // Text for the zoom toolbar's pan left button
  toolbarZoomPanLeft: "Pan left",
  // Text for the zoom toolbar's pan right button
  toolbarZoomPanRight: "Pan right",
  // Text for the zoom toolbar's pan to the start button
  toolbarZoomPanStart: "Pan to the start",
  // Text for the zoom toolbar's pan to the end button
  toolbarZoomPanEnd: "Pan to the end",
  // Text for the zoom toolbar's pan reset button
  toolbarZoomReset: "Reset the zoom",
  // Text for the context menu's download button
  contextMenuDownload: "Download",
  // Text for the context menu's toggle series visibility button
  contextMenuToggleSeriesVisibility: "Toggle Visibility",
  // Text for the context menu's toggle other series visibility button
  contextMenuToggleOtherSeries: "Toggle Other Series",
  // Text for the context menu's zoom to point button
  contextMenuZoomToCursor: "Zoom to here",
  // Text for the context menu's pan to point button
  contextMenuPanToCursor: "Pan to here",
  // Text for the context menu's reset zoom button
  contextMenuResetZoom: "Reset zoom",
  // Text for the annotation dialog's header channel tab label
  dialogHeaderChannel: "Channel",
  // Text for the annotation dialog's header line tab label
  dialogHeaderLine: "Line",
  // Text for the annotation dialog's header fibonacci retracement line tab label
  dialogHeaderFibonacciRange: "Fib Retracement",
  // Text for the annotation dialog's header date range tab label
  dialogHeaderDateRange: "Date Range",
  // Text for the annotation dialog's header price range tab label
  dialogHeaderPriceRange: "Price Range",
  // Text for the annotation dialog's header date and price range tab label
  dialogHeaderDatePriceRange: "Date and Price",
  // Text for the annotation dialog's header text tab label
  dialogHeaderText: "Text",
  // Text for the annotation dialog's text alignment radio label
  dialogInputAlign: "Align",
  // Text for the annotation dialog's color picker label
  dialogInputColorPicker: "Color",
  // Text for the annotation dialog's color picker alt text
  dialogInputColorPickerAltText: "Text Color",
  // Text for the annotation dialog's fill color picker label
  dialogInputFillColorPicker: "Fill",
  // Text for the annotation dialog's fill color picker alt text
  dialogInputFillColorPickerAltText: "Fill Color",
  // Text for the annotation dialog's extend channel start checkbox
  dialogInputExtendChannelStart: "Extend channel start",
  // Text for the annotation dialog's extend channel end checkbox
  dialogInputExtendChannelEnd: "Extend channel end",
  // Text for the annotation dialog's extend line start checkbox
  dialogInputExtendLineStart: "Extend line start",
  // Text for the annotation dialog's extend line end checkbox
  dialogInputExtendLineEnd: "Extend line end",
  // Text for the annotation dialog's extend above checkbox
  dialogInputExtendAbove: "Extend above",
  // Text for the annotation dialog's extend below checkbox
  dialogInputExtendBelow: "Extend below",
  // Text for the annotation dialog's extend left checkbox
  dialogInputExtendLeft: "Extend left",
  // Text for the annotation dialog's extend right checkbox
  dialogInputExtendRight: "Extend right",
  // Text for the annotation dialog's reverse checkbox
  dialogInputReverse: "Reverse",
  // Text for the annotation dialog's show fill checkbox
  dialogInputShowFill: "Show Fill",
  // Text for the annotation dialog's font size select box label
  dialogInputFontSize: "Size",
  // Text for the annotation dialog's font size select box alt text
  dialogInputFontSizeAltText: "Font Size",
  // Text for the annotation dialog's line style radio label
  dialogInputLineStyle: "Dash",
  // Text for the annotation dialog's text position radio label
  dialogInputPosition: "Position",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidth: "Weight",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidthAltText: "Line Weight",
  // Text for the annotation dialog's Fibonacci bands label
  dialogInputFibonacciBands: "Bands",
  // Text for the annotation dialog's Fibonacci bands label
  dialogInputFibonacciBandsAltText: "Fibonacci Bands",
  // Text for text area input placeholders
  inputTextareaPlaceholder: "Add Text",
  // Text for the measurer statistics date range bars value
  measurerDateRangeBars: "${value}[number] bars",
  // Text for the measurer statistics price range value
  measurerPriceRangeValue: "${value}[number]",
  // Text for the measurer statistics price range percentage
  measurerPriceRangePercent: "${value}[percent]",
  // Text for the measurer statistics volume value
  measurerVolume: "Vol ${value}",
  // Status when multiple data are under the cursor, and the user can click to cycle through which one appears in the tooltip
  tooltipPaginationStatus: "${index}[number] of ${count}[number]"
};

// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts
import { Logger as Logger21 } from "ag-charts-core";
var messageRegExp = /\$\{(\w+)}(?:\[(\w+)])?/gi;
var formatters = {
  number: new Intl.NumberFormat("en-US"),
  percent: new Intl.NumberFormat("en-US", { style: "percent", minimumFractionDigits: 2, maximumFractionDigits: 2 }),
  percent0to2dp: new Intl.NumberFormat("en-US", {
    style: "percent",
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  }),
  date: new Intl.DateTimeFormat("en-US", { dateStyle: "full" }),
  time: new Intl.DateTimeFormat("en-US", { timeStyle: "full" }),
  datetime: new Intl.DateTimeFormat("en-US", { dateStyle: "full", timeStyle: "full" })
};
var defaultMessageFormatter = ({ defaultValue, variables }) => {
  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {
    const value = variables[match];
    const formatter2 = format != null ? formatters[format] : null;
    if (format != null && formatter2 == null) {
      Logger21.warnOnce(`Format style [${format}] is not supported`);
    }
    if (formatter2 != null) {
      return formatter2.format(value);
    } else if (typeof value === "number") {
      return formatters.number.format(value);
    } else if (value instanceof Date) {
      return formatters.datetime.format(value);
    }
    return String(value);
  });
};

// packages/ag-charts-community/src/locale/localeManager.ts
var LocaleManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.localeText = void 0;
    this.getLocaleText = void 0;
  }
  setLocaleText(localeText) {
    if (this.localeText !== localeText) {
      this.localeText = localeText;
      this.eventsHub.emit("locale:change", null);
    }
  }
  setLocaleTextFormatter(getLocaleText) {
    this.getLocaleText = getLocaleText;
    if (this.getLocaleText !== getLocaleText) {
      this.getLocaleText = getLocaleText;
      this.eventsHub.emit("locale:change", null);
    }
  }
  t(key, variables = {}) {
    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;
    const defaultValue = localeText[key];
    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;
  }
};

// packages/ag-charts-community/src/scene/scene.ts
import { CleanupRegistry as CleanupRegistry11, EventEmitter as EventEmitter2, Logger as Logger22, createId as createId6, downloadUrl } from "ag-charts-core";

// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts
import { createElement as createElement9, getWindow as getWindow13 } from "ag-charts-core";
var HdpiCanvas = class {
  constructor(options) {
    this.enabled = true;
    this.width = 600;
    this.height = 300;
    const { width: width2, height: height2, canvasElement, willReadFrequently = false } = options;
    this.pixelRatio = options.pixelRatio ?? getWindow13("devicePixelRatio") ?? 1;
    this.element = canvasElement ?? createElement9("canvas");
    this.element.style.display = "block";
    this.element.style.width = (width2 ?? this.width) + "px";
    this.element.style.height = (height2 ?? this.height) + "px";
    this.element.width = Math.round((width2 ?? this.width) * this.pixelRatio);
    this.element.height = Math.round((height2 ?? this.height) * this.pixelRatio);
    this.context = this.element.getContext("2d", { willReadFrequently });
    this.onEnabledChange();
    this.resize(width2 ?? 0, height2 ?? 0, this.pixelRatio);
    debugContext(this.context);
  }
  drawImage(context, dx = 0, dy = 0) {
    return context.drawImage(this.context.canvas, dx, dy);
  }
  toDataURL(type) {
    return this.element.toDataURL(type);
  }
  resize(width2, height2, pixelRatio) {
    if (!(width2 > 0 && height2 > 0))
      return;
    const { element: element2, context } = this;
    element2.width = Math.round(width2 * pixelRatio);
    element2.height = Math.round(height2 * pixelRatio);
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    element2.style.width = width2 + "px";
    element2.style.height = height2 + "px";
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
  }
  clear() {
    clearContext(this);
  }
  destroy() {
    this.element.remove();
    this.element.width = 0;
    this.element.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    Object.freeze(this);
  }
  reset() {
    this.context.reset();
    this.context.verifyDepthZero?.();
  }
  onEnabledChange() {
    if (this.element) {
      this.element.style.display = this.enabled ? "" : "none";
    }
  }
};
__decorateClass([
  ObserveChanges((target) => target.onEnabledChange())
], HdpiCanvas.prototype, "enabled", 2);

// packages/ag-charts-community/src/scene/image/imageLoader.ts
import { EventEmitter } from "ag-charts-core";
var ImageLoader = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.cache = /* @__PURE__ */ new Map();
    this.imageLoadingCount = 0;
  }
  loadImage(uri, affectedNode) {
    const entry = this.cache.get(uri);
    if (entry?.image) {
      return entry.image;
    } else if (entry != null && affectedNode) {
      entry.nodes.add(affectedNode);
      return;
    }
    if (!affectedNode) {
      return;
    }
    const nextEntry = { image: void 0, nodes: /* @__PURE__ */ new Set([affectedNode]) };
    const image = new Image();
    this.imageLoadingCount++;
    image.onload = () => {
      nextEntry.image = image;
      for (const node of nextEntry.nodes) {
        node.markDirty();
      }
      nextEntry.nodes.clear();
      this.imageLoadingCount--;
      this.emit("image-loaded", { uri });
    };
    image.onerror = () => {
      this.imageLoadingCount--;
      nextEntry.nodes.clear();
      this.emit("image-error", { uri });
    };
    image.src = uri;
    this.cache.set(uri, nextEntry);
    return nextEntry.image;
  }
  waitingToLoad() {
    return this.imageLoadingCount > 0;
  }
  destroy() {
    this.cache.forEach((entry) => {
      entry.nodes.clear();
    });
    this.cache.clear();
  }
};

// packages/ag-charts-community/src/scene/layersManager.ts
var LayersManager = class {
  constructor(canvas) {
    this.canvas = canvas;
    this.debug = Debug.create(true, "scene");
    this.layersMap = /* @__PURE__ */ new Map();
    this.nextLayerId = 0;
  }
  get size() {
    return this.layersMap.size;
  }
  resize(width2, height2, pixelRatio) {
    this.canvas.resize(width2, height2, pixelRatio);
    this.layersMap.forEach(({ canvas }) => canvas.resize(width2, height2, pixelRatio));
  }
  addLayer(opts) {
    const { width: width2, height: height2, pixelRatio } = this.canvas;
    const { name } = opts;
    const canvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });
    this.layersMap.set(canvas, {
      id: this.nextLayerId++,
      name,
      canvas
    });
    this.debug("Scene.addLayer() - layers", this.layersMap);
    return canvas;
  }
  removeLayer(canvas) {
    if (this.layersMap.has(canvas)) {
      this.layersMap.delete(canvas);
      canvas.destroy();
      this.debug("Scene.removeLayer() -  layers", this.layersMap);
    }
  }
  clear() {
    for (const layer of this.layersMap.values()) {
      layer.canvas.destroy();
    }
    this.layersMap.clear();
  }
};

// packages/ag-charts-community/src/scene/scene.ts
var Scene = class extends EventEmitter2 {
  constructor(canvasOptions) {
    super();
    this.debug = Debug.create(true, "scene" /* SCENE */);
    this.id = createId6(this);
    this.imageLoader = new ImageLoader();
    this.root = null;
    this.pendingSize = null;
    this.isDirty = false;
    this.cleanup = new CleanupRegistry11();
    this.updateDebugFlags();
    this.canvas = new HdpiCanvas(canvasOptions);
    this.layersManager = new LayersManager(this.canvas);
    this.cleanup.register(
      this.imageLoader.on("image-loaded", () => {
        this.emit("scene-changed", {});
      }),
      this.imageLoader.on("image-error", ({ uri }) => {
        Logger22.warnOnce(`Unable to load image ${uri}`);
      })
    );
  }
  waitingForUpdate() {
    return this.imageLoader?.waitingToLoad() ?? false;
  }
  get width() {
    return this.pendingSize?.[0] ?? this.canvas.width;
  }
  get height() {
    return this.pendingSize?.[1] ?? this.canvas.height;
  }
  get pixelRatio() {
    return this.pendingSize?.[2] ?? this.canvas.pixelRatio;
  }
  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */
  setContainer(value) {
    const { element: element2 } = this.canvas;
    element2.parentElement?.removeChild(element2);
    value.appendChild(element2);
    return this;
  }
  setRoot(node) {
    if (this.root === node) {
      return this;
    }
    this.isDirty = true;
    this.root?.setScene();
    this.root = node;
    if (node) {
      node.visible = true;
      node.setScene(this);
    }
    return this;
  }
  updateDebugFlags() {
    Debug.inDevelopmentMode(() => Node2._debugEnabled = true);
  }
  clearCanvas() {
    this.canvas.clear();
  }
  attachNode(node) {
    this.appendChild(node);
    return () => this.removeChild(node);
  }
  appendChild(node) {
    this.root?.appendChild(node);
    return this;
  }
  removeChild(node) {
    this.root?.removeChild(node);
    return this;
  }
  download(fileName, fileFormat) {
    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? "image");
  }
  /** NOTE: Integrated Charts undocumented image download method. */
  getDataURL(fileFormat) {
    return this.canvas.toDataURL(fileFormat);
  }
  resize(width2, height2, pixelRatio) {
    width2 = Math.round(width2);
    height2 = Math.round(height2);
    pixelRatio ?? (pixelRatio = this.pixelRatio);
    if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio)) {
      this.pendingSize = [width2, height2, pixelRatio];
      this.isDirty = true;
      return true;
    }
    return false;
  }
  render(opts) {
    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};
    const {
      canvas,
      canvas: { context: ctx } = {},
      root,
      pendingSize,
      width: width2,
      height: height2,
      pixelRatio: devicePixelRatio
    } = this;
    if (!ctx) {
      return;
    }
    const renderStartTime = performance.now();
    let resized = false;
    if (pendingSize) {
      resized = true;
      this.layersManager.resize(...pendingSize);
      this.pendingSize = null;
    }
    if (root && !root.visible) {
      this.isDirty = false;
      return;
    }
    let rootDirty;
    if (root instanceof Group) {
      rootDirty = root.dirty;
    }
    if (root != null && rootDirty === false && !this.isDirty) {
      if (this.debug.check()) {
        this.debug("Scene.render() - no-op", {
          tree: buildTree(root, "console")
        });
      }
      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);
      return;
    }
    const renderCtx = {
      ctx,
      width: width2,
      height: height2,
      devicePixelRatio,
      debugNodes: {}
    };
    if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
      renderCtx.stats = {
        layersRendered: 0,
        layersSkipped: 0,
        nodesRendered: 0,
        nodesSkipped: 0,
        opsPerformed: 0,
        opsSkipped: 0
      };
    }
    prepareSceneNodeHighlight(renderCtx);
    let canvasCleared = false;
    if (rootDirty !== false || resized) {
      canvasCleared = true;
      canvas.clear();
    }
    if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */)) {
      const { dirtyTree, paths } = buildDirtyTree(root);
      Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */)("Scene.render() - dirtyTree", { dirtyTree, paths });
    }
    if (root && canvasCleared) {
      if (root.visible) {
        root.preRender(renderCtx);
      }
      if (this.debug.check()) {
        const tree = buildTree(root, "console");
        this.debug("Scene.render() - before", {
          canvasCleared,
          tree
        });
      }
      if (root.visible) {
        try {
          ctx.save();
          root.render(renderCtx);
          ctx.restore();
        } catch (e) {
          this.canvas.reset();
          throw e;
        }
      }
    }
    debugSplitTimes["\u270D\uFE0F"] = performance.now() - renderStartTime;
    ctx.verifyDepthZero?.();
    this.isDirty = false;
    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);
    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
    if (root && this.debug.check()) {
      this.debug("Scene.render() - after", {
        tree: buildTree(root, "console"),
        canvasCleared
      });
    }
  }
  toSVG() {
    const { root, width: width2, height: height2 } = this;
    if (root == null)
      return;
    return Node2.toSVG(root, width2, height2);
  }
  /** Alternative to destroy() that preserves re-usable resources. */
  strip() {
    const { context, pixelRatio } = this.canvas;
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.layersManager.clear();
    this.setRoot(null);
    this.isDirty = false;
    this.clear();
  }
  destroy() {
    this.strip();
    this.canvas.destroy();
    this.imageLoader.destroy();
    this.cleanup.flush();
    Object.assign(this, { canvas: void 0 });
  }
};
Scene.className = "Scene";

// packages/ag-charts-community/src/chart/annotation/annotationManager.ts
import { isArray as isArray9 } from "ag-charts-core";
var AnnotationManager = class {
  constructor(eventsHub, annotationRoot, fireChartEvent) {
    this.eventsHub = eventsHub;
    this.annotationRoot = annotationRoot;
    this.fireChartEvent = fireChartEvent;
    this.mementoOriginatorKey = "annotations";
    this.annotations = [];
  }
  createMemento() {
    return this.annotations;
  }
  guardMemento(blob) {
    return blob == null || isArray9(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    this.annotations = this.cleanData(memento ?? []).map((annotation) => {
      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);
      return mergeDefaults(annotation, annotationTheme);
    });
    this.eventsHub.emit("annotations:restore", { annotations: this.annotations });
  }
  updateData(annotations) {
    this.annotations = this.cleanData(annotations ?? []);
  }
  fireChangedEvent() {
    this.fireChartEvent({ type: "annotations", annotations: deepClone([...this.annotations]) });
  }
  attachNode(node) {
    this.annotationRoot.append(node);
    return () => {
      this.annotationRoot?.removeChild(node);
      return this;
    };
  }
  setAnnotationStyles(styles) {
    this.styles = styles;
  }
  getAnnotationTypeStyles(type) {
    return this.styles?.[type];
  }
  cleanData(annotations) {
    for (const annotation of annotations) {
      if ("textAlign" in annotation)
        delete annotation.textAlign;
    }
    return annotations;
  }
};

// packages/ag-charts-community/src/chart/axis/axisManager.ts
var AxisManager = class {
  constructor(eventsHub, sceneRoot) {
    this.eventsHub = eventsHub;
    this.sceneRoot = sceneRoot;
    this.axes = /* @__PURE__ */ new Map();
    this.axisGridGroup = new Group({ name: "Axes-Grids", zIndex: 2 /* AXIS_GRID */ });
    this.axisGroup = new Group({ name: "Axes", zIndex: 3 /* AXIS */ });
    this.axisLabelGroup = new Group({ name: "Axes-Labels", zIndex: 15 /* SERIES_LABEL */ });
    this.axisCrosslineRangeGroup = new Group({
      name: "Axes-Crosslines-Range",
      zIndex: 6 /* SERIES_CROSSLINE_RANGE */
    });
    this.axisCrosslineLineGroup = new Group({
      name: "Axes-Crosslines-Line",
      zIndex: 10 /* SERIES_CROSSLINE_LINE */
    });
    this.axisCrosslineLabelGroup = new Group({
      name: "Axes-Crosslines-Label",
      zIndex: 15 /* SERIES_LABEL */
    });
    this.sceneRoot.appendChild(this.axisGroup);
    this.sceneRoot.appendChild(this.axisGridGroup);
    this.sceneRoot.appendChild(this.axisLabelGroup);
    this.sceneRoot.appendChild(this.axisCrosslineRangeGroup);
    this.sceneRoot.appendChild(this.axisCrosslineLineGroup);
    this.sceneRoot.appendChild(this.axisCrosslineLabelGroup);
  }
  updateAxes(oldAxes, newAxes) {
    const axisNodes = {
      axisNode: this.axisGroup,
      gridNode: this.axisGridGroup,
      labelNode: this.axisLabelGroup,
      crossLineRangeNode: this.axisCrosslineRangeGroup,
      crossLineLineNode: this.axisCrosslineLineGroup,
      crossLineLabelNode: this.axisCrosslineLabelGroup
    };
    for (const axis of oldAxes) {
      if (newAxes.includes(axis))
        continue;
      axis.detachAxis(axisNodes);
      axis.destroy();
    }
    for (const axis of newAxes) {
      if (oldAxes?.includes(axis))
        continue;
      axis.attachAxis(axisNodes);
    }
    this.axes.clear();
    for (const axis of newAxes) {
      const ctx = axis.createAxisContext();
      if (this.axes.has(ctx.direction)) {
        this.axes.get(ctx.direction)?.push(ctx);
      } else {
        this.axes.set(ctx.direction, [ctx]);
      }
    }
    this.eventsHub.emit("axis:change", null);
  }
  getAxisContext(direction) {
    return this.axes.get(direction) ?? [];
  }
  destroy() {
    this.axes.clear();
    this.sceneRoot.removeChild(this.axisGroup);
    this.sceneRoot.removeChild(this.axisGridGroup);
  }
};

// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {
  ChartUpdateType2[ChartUpdateType2["FULL"] = 0] = "FULL";
  ChartUpdateType2[ChartUpdateType2["UPDATE_DATA"] = 1] = "UPDATE_DATA";
  ChartUpdateType2[ChartUpdateType2["PROCESS_DATA"] = 2] = "PROCESS_DATA";
  ChartUpdateType2[ChartUpdateType2["PROCESS_DOMAIN"] = 3] = "PROCESS_DOMAIN";
  ChartUpdateType2[ChartUpdateType2["PERFORM_LAYOUT"] = 4] = "PERFORM_LAYOUT";
  ChartUpdateType2[ChartUpdateType2["SERIES_UPDATE"] = 5] = "SERIES_UPDATE";
  ChartUpdateType2[ChartUpdateType2["PRE_SCENE_RENDER"] = 6] = "PRE_SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["SCENE_RENDER"] = 7] = "SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["NONE"] = 8] = "NONE";
  return ChartUpdateType2;
})(ChartUpdateType || {});

// packages/ag-charts-community/src/chart/data/dataService.ts
import { Logger as Logger23, throttle } from "ag-charts-core";
var DataService = class {
  constructor(eventsHub, caller, animationManager) {
    this.eventsHub = eventsHub;
    this.caller = caller;
    this.animationManager = animationManager;
    this.dispatchOnlyLatest = true;
    this.dispatchThrottle = 0;
    this.requestThrottle = 300;
    this.isLoadingInitialData = false;
    this.isLoadingData = false;
    this.freshRequests = [];
    this.requestCounter = 0;
    this.pendingData = void 0;
    this.debug = Debug.create(true, "data-model", "data-source");
    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
  }
  updateCallback(dataSourceCallback) {
    if (typeof dataSourceCallback !== "function")
      return;
    this.debug("DataService - updated data source callback");
    this.dataSourceCallback = dataSourceCallback;
    this.isLoadingInitialData = true;
    this.animationManager.skip();
    this.eventsHub.emit("data:source-change", null);
  }
  clearCallback() {
    this.dataSourceCallback = void 0;
  }
  load(params) {
    const { pendingData } = this;
    if (pendingData != null && pendingData.params.windowStart?.valueOf() === params.windowStart?.valueOf() && pendingData.params.windowEnd?.valueOf() === params.windowEnd?.valueOf()) {
      const id = this.requestCounter++;
      this.isLoadingInitialData = false;
      this.dispatch(id, pendingData.data);
      return;
    }
    this.isLoadingData = true;
    this.throttledFetch(params);
  }
  isLazy() {
    return this.dataSourceCallback != null;
  }
  isLoading() {
    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);
  }
  async getData() {
    const { latestRequest } = this;
    if (!latestRequest)
      return;
    const { params, fetchRequest } = latestRequest;
    const data = await fetchRequest;
    return { params, data };
  }
  restoreData(data) {
    this.pendingData = data;
  }
  createThrottledFetch(requestThrottle) {
    return throttle(
      (params) => this.fetch(params).catch((e) => Logger23.error("callback failed", e)),
      requestThrottle,
      { leading: false, trailing: true }
    );
  }
  createThrottledDispatch(dispatchThrottle) {
    return throttle((id, data) => this.dispatch(id, data), dispatchThrottle, {
      leading: true,
      trailing: true
    });
  }
  dispatch(id, data) {
    this.debug(`DataService - dispatching 'data-load' | ${id}`);
    this.eventsHub.emit("data:load", { data });
  }
  async fetch(params) {
    if ("context" in this.caller) {
      params.context = this.caller.context;
    }
    const fetchRequest = Promise.resolve().then(async () => {
      if (!this.dataSourceCallback) {
        throw new Error("DataService - [dataSource.getData] callback not initialised");
      }
      const start2 = performance.now();
      const id = this.requestCounter++;
      this.debug(`DataService - requesting | ${id}`);
      let response;
      try {
        response = await this.dataSourceCallback(params);
        this.debug(`DataService - response | ${performance.now() - start2}ms | ${id}`);
      } catch (error) {
        this.debug(`DataService - request failed | ${id}`);
        Logger23.errorOnce(`DataService - request failed | [${error}]`);
      }
      this.isLoadingInitialData = false;
      const requestIndex = this.freshRequests.indexOf(fetchRequest);
      if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
        this.debug(`DataService - discarding stale request | ${id}`);
        return response;
      }
      this.freshRequests = this.freshRequests.slice(requestIndex + 1);
      if (this.freshRequests.length === 0) {
        this.isLoadingData = false;
      }
      if (Array.isArray(response)) {
        this.throttledDispatch(id, response);
      } else {
        this.eventsHub.emit("data:error", null);
      }
      return response;
    });
    this.latestRequest = { params, fetchRequest };
    this.freshRequests.push(fetchRequest);
    await fetchRequest;
  }
};
__decorateClass([
  ActionOnSet({
    newValue(dispatchThrottle) {
      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
    }
  })
], DataService.prototype, "dispatchThrottle", 2);
__decorateClass([
  ActionOnSet({
    newValue(requestThrottle) {
      this.throttledFetch = this.createThrottledFetch(requestThrottle);
    }
  })
], DataService.prototype, "requestThrottle", 2);

// packages/ag-charts-community/src/chart/fonts/fontManager.ts
var FontManager = class {
  constructor(domManager, updateService) {
    this.domManager = domManager;
    this.updateService = updateService;
    this.observers = [];
  }
  updateFonts(fonts) {
    if (!fonts || fonts.size === 0)
      return;
    this.loadFonts(fonts);
    fonts.forEach((font2) => {
      this.observeFontStatus(font2);
    });
  }
  destroy() {
    for (const observer of this.observers) {
      observer.disconnect();
    }
    this.observers = [];
  }
  loadFonts(fonts) {
    const fontStrings = Array.from(fonts).map((font2) => encodeURIComponent(font2));
    const fontStyle = ":wght@100;200;300;400;500;600;700;800;900";
    const joinString = `${fontStyle}&family=`;
    const css = `@import url('https://fonts.googleapis.com/css2?family=${fontStrings.join(joinString)}${fontStyle}&display=swap');
`;
    this.domManager.addStyles(`google-font-${fontStrings.join("-")}`, css);
  }
  observeFontStatus(font2) {
    const fontCheckElement = window.document.createElement("div");
    fontCheckElement.style.setProperty("position", "absolute");
    fontCheckElement.style.setProperty("top", "0");
    fontCheckElement.style.setProperty("margin", "0");
    fontCheckElement.style.setProperty("padding", "0");
    fontCheckElement.style.setProperty("overflow", "hidden");
    fontCheckElement.style.setProperty("visibility", "hidden");
    fontCheckElement.style.setProperty("width", "auto");
    fontCheckElement.style.setProperty("max-width", "none");
    fontCheckElement.style.setProperty("font-synthesis", "none");
    fontCheckElement.style.setProperty("font-family", font2);
    fontCheckElement.style.setProperty("font-size", "16px");
    fontCheckElement.style.setProperty("white-space", "nowrap");
    fontCheckElement.textContent = "UVWxyz";
    this.domManager.addChild("canvas-container", `font-check-${encodeURIComponent(font2)}`, fontCheckElement);
    const fontCheckObserver = new ResizeObserver((entries7) => {
      const width2 = entries7?.at(0)?.contentBoxSize.at(0)?.inlineSize;
      if (width2 != null && width2 > 0) {
        CachedTextMeasurerPool.clear();
        this.updateService.update(4 /* PERFORM_LAYOUT */);
      }
    });
    fontCheckObserver.observe(fontCheckElement);
    this.observers.push(fontCheckObserver);
  }
};

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
import { EventEmitter as EventEmitter3, Logger as Logger25, getWindow as getWindow14 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/interaction/animationBatch.ts
import { Logger as Logger24 } from "ag-charts-core";
var AnimationBatch = class {
  constructor(maxAnimationTime) {
    this.maxAnimationTime = maxAnimationTime;
    this.debug = Debug.create(true, "animation");
    this.controllers = /* @__PURE__ */ new Map();
    this.stoppedCbs = /* @__PURE__ */ new Set();
    this.currentPhase = 0;
    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));
    this.skipAnimations = false;
    this.animationTimeConsumed = 0;
    /** Guard against premature animation execution. */
    this.isReady = false;
  }
  get size() {
    return this.controllers.size;
  }
  get consumedTimeMs() {
    return this.animationTimeConsumed;
  }
  isActive() {
    return this.controllers.size > 0;
  }
  getActiveControllers() {
    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];
  }
  checkOverlappingId(id) {
    if (id != null && this.controllers.has(id)) {
      this.controllers.get(id).stop();
      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);
      this.skip();
    }
  }
  addAnimation(animation) {
    if (animation.isComplete)
      return;
    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);
    if (animationPhaseIdx < this.currentPhase) {
      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);
      animation.stop();
      return;
    }
    this.controllers.set(animation.id, animation);
    this.phases.get(animation.phase)?.push(animation);
  }
  removeAnimation(animation) {
    this.controllers.delete(animation.id);
    const phase = this.phases.get(animation.phase);
    const index = phase?.indexOf(animation);
    if (index != null && index >= 0) {
      phase?.splice(index, 1);
    }
  }
  progress(deltaTime) {
    if (!this.isReady)
      return;
    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
    const refresh = () => {
      const phase2 = PHASE_ORDER[this.currentPhase];
      return {
        phaseControllers: [...this.getActiveControllers()],
        phase: phase2,
        phaseMeta: PHASE_METADATA[phase2]
      };
    };
    let { phase, phaseControllers, phaseMeta } = refresh();
    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;
    const progressPhase = () => {
      ({ phase, phaseControllers, phaseMeta } = refresh());
      while (!arePhasesComplete() && phaseControllers.length === 0) {
        this.currentPhase++;
        ({ phase, phaseControllers, phaseMeta } = refresh());
        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);
      }
    };
    const total = this.controllers.size;
    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);
    do {
      const phaseDeltaTime = unusedTime;
      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;
      let completeCount = 0;
      for (const controller of phaseControllers) {
        if (skipPhase) {
          controller.stop();
        } else {
          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
        }
        if (controller.isComplete) {
          completeCount++;
          this.removeAnimation(controller);
        }
      }
      this.animationTimeConsumed += phaseDeltaTime - unusedTime;
      this.debug(
        `AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`,
        phaseControllers
      );
      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);
      progressPhase();
    } while (unusedTime > 0 && !arePhasesComplete());
    if (this.animationTimeConsumed > this.maxAnimationTime) {
      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);
      this.stop();
    }
  }
  ready() {
    if (this.isReady)
      return;
    this.isReady = true;
    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);
    let skipAll = true;
    for (const [, controller] of this.controllers) {
      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {
        skipAll = false;
        break;
      }
    }
    if (!skipAll) {
      for (const [, controller] of this.controllers) {
        if (controller.autoplay) {
          controller.play(true);
        }
      }
    }
  }
  skip(skip = true) {
    if (this.skipAnimations === false && skip === true) {
      for (const controller of this.controllers.values()) {
        controller.stop();
      }
      this.controllers.clear();
    }
    this.skipAnimations = skip;
  }
  play() {
    for (const controller of this.controllers.values()) {
      controller.play();
    }
  }
  stop() {
    for (const controller of this.controllers.values()) {
      try {
        controller.stop();
        this.removeAnimation(controller);
      } catch (error) {
        Logger24.error("Error during animation stop", error);
      }
    }
    this.dispatchStopped();
  }
  stopByAnimationId(id) {
    if (id != null && this.controllers.has(id)) {
      const controller = this.controllers.get(id);
      if (controller) {
        controller.stop();
        this.removeAnimation(controller);
      }
    }
  }
  stopByAnimationGroupId(id) {
    for (const controller of this.controllers.values()) {
      if (controller.groupId === id) {
        this.stopByAnimationId(controller.id);
      }
    }
  }
  dispatchStopped() {
    this.stoppedCbs.forEach((cb) => cb());
    this.stoppedCbs.clear();
  }
  isSkipped() {
    return this.skipAnimations;
  }
  getRemainingTime(restrictPhase) {
    if (!this.isActive())
      return 0;
    let total = 0;
    for (const [phase, controllers] of this.phases) {
      if (controllers.length === 0)
        continue;
      if (restrictPhase != null && restrictPhase !== phase)
        continue;
      total += Math.max(...controllers.map((c) => c.isComplete ? 0 : c.delay + c.duration - (c.elapsed ?? 0)));
    }
    return total;
  }
  destroy() {
    this.stop();
    this.controllers.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var InteractionManager = class {
  constructor() {
    this.stateQueue = 32 /* Default */ | 2 /* Animation */;
  }
  pushState(state) {
    this.stateQueue |= state;
  }
  popState(state) {
    this.stateQueue &= ~state;
  }
  isState(allowedStates) {
    return !!(this.stateQueue & -this.stateQueue & allowedStates);
  }
};

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
function validAnimationDuration(testee) {
  if (testee == null)
    return true;
  return !isNaN(testee) && testee >= 0 && testee <= 2;
}
var AnimationManager = class {
  constructor(interactionManager, chartUpdateMutex) {
    this.interactionManager = interactionManager;
    this.chartUpdateMutex = chartUpdateMutex;
    this.defaultDuration = 1e3;
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    this.debug = Debug.create(true, "animation");
    this.events = new EventEmitter3();
    this.rafAvailable = typeof requestAnimationFrame !== "undefined";
    this.isPlaying = true;
    this.requestId = null;
    this.skipAnimations = true;
    this.currentAnonymousAnimationId = 0;
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  /**
   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
   * with the same `id`, immediately stop it.
   */
  animate(opts) {
    const batch = this.batch;
    try {
      batch.checkOverlappingId(opts.id);
    } catch (error) {
      this.failsafeOnError(error);
      return;
    }
    let { id } = opts;
    if (id == null) {
      id = `__${this.currentAnonymousAnimationId}`;
      this.currentAnonymousAnimationId += 1;
    }
    const skip = this.isSkipped() || opts.phase === "none";
    if (skip) {
      this.debug("AnimationManager - skipping animation");
    }
    const { delay, duration } = opts;
    if (!validAnimationDuration(delay)) {
      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);
    }
    if (!validAnimationDuration(duration)) {
      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);
    }
    const animation = new Animation({
      ...opts,
      id,
      skip,
      autoplay: this.isPlaying ? opts.autoplay : false,
      phase: opts.phase,
      defaultDuration: this.defaultDuration
    });
    if (this.forceTimeJump(animation, this.defaultDuration)) {
      return;
    }
    this.batch.addAnimation(animation);
    return animation;
  }
  play() {
    if (this.isPlaying) {
      return;
    }
    this.isPlaying = true;
    this.debug("AnimationManager.play()");
    try {
      this.batch.play();
    } catch (error) {
      this.failsafeOnError(error);
    }
    this.requestAnimation();
  }
  stop() {
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.stop()");
    this.batch.stop();
  }
  stopByAnimationId(id) {
    try {
      this.batch.stopByAnimationId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  stopByAnimationGroupId(id) {
    try {
      this.batch.stopByAnimationGroupId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  reset() {
    if (this.isPlaying) {
      this.stop();
      this.play();
    } else {
      this.stop();
    }
  }
  skip(skip = true) {
    this.skipAnimations = skip;
  }
  isSkipped() {
    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
  }
  isActive() {
    return this.isPlaying && this.batch.isActive();
  }
  getRemainingTime(phase) {
    return this.batch.getRemainingTime(phase);
  }
  skipCurrentBatch() {
    if (this.debug.check()) {
      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });
    }
    this.batch.skip();
  }
  /** Mocking point for tests to guarantee that animation updates happen. */
  isSkippingFrames() {
    return true;
  }
  /** Mocking point for tests to capture requestAnimationFrame callbacks. */
  scheduleAnimationFrame(cb) {
    this.requestId = getWindow14().requestAnimationFrame((t) => {
      cb(t).catch((e) => Logger25.error(e));
    });
  }
  /** Mocking point for tests to skip animations to a specific point in time. */
  forceTimeJump(_animation, _defaultDuration) {
    return false;
  }
  requestAnimation() {
    if (!this.rafAvailable)
      return;
    if (!this.batch.isActive() || this.requestId !== null)
      return;
    let prevTime;
    const onAnimationFrame = async (time2) => {
      await this.debug.group("AnimationManager.onAnimationFrame()", async () => {
        const executeAnimationFrame = () => {
          const deltaTime = time2 - (prevTime ?? time2);
          prevTime = time2;
          this.debug("AnimationManager", {
            controllersCount: this.batch.size,
            deltaTime
          });
          this.interactionManager.pushState(2 /* Animation */);
          try {
            this.batch.progress(deltaTime);
          } catch (error) {
            this.failsafeOnError(error);
          }
          this.events.emit("animation-frame", {
            type: "animation-frame",
            deltaMs: deltaTime
          });
        };
        if (this.isSkippingFrames()) {
          await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
        } else {
          await this.chartUpdateMutex.acquire(executeAnimationFrame);
        }
        if (this.batch.isActive()) {
          this.scheduleAnimationFrame(onAnimationFrame);
        } else {
          this.batch.stop();
          this.events.emit("animation-stop", {
            type: "animation-stop",
            deltaMs: this.batch.consumedTimeMs
          });
        }
      });
    };
    this.events.emit("animation-start", {
      type: "animation-start",
      deltaMs: 0
    });
    this.scheduleAnimationFrame(onAnimationFrame);
  }
  cancelAnimation() {
    if (this.requestId === null)
      return;
    cancelAnimationFrame(this.requestId);
    this.events.emit("animation-stop", {
      type: "animation-stop",
      deltaMs: this.batch.consumedTimeMs
    });
    this.requestId = null;
    this.startBatch();
  }
  failsafeOnError(error, cancelAnimation = true) {
    Logger25.error("Error during animation, skipping animations", error);
    if (cancelAnimation) {
      this.cancelAnimation();
    }
  }
  startBatch(skipAnimations) {
    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);
    this.reset();
    this.batch.destroy();
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    if (skipAnimations === true) {
      this.batch.skip();
    }
  }
  endBatch() {
    if (this.batch.isActive()) {
      this.batch.ready();
      this.requestAnimation();
    } else {
      this.interactionManager.popState(2 /* Animation */);
      if (this.batch.isSkipped()) {
        this.batch.skip(false);
      }
    }
  }
  onBatchStop(cb) {
    this.batch.stoppedCbs.add(cb);
  }
  destroy() {
    this.stop();
    this.events.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuTypes.ts
var ContextMenuBuiltinItems = class {
  constructor() {
    this.download = {
      type: "action",
      showOn: "always",
      label: "contextMenuDownload",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["zoom-to-cursor"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuZoomToCursor",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["pan-to-cursor"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuPanToCursor",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["reset-zoom"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuResetZoom",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["toggle-series-visibility"] = {
      type: "action",
      showOn: "legend-item",
      label: "contextMenuToggleSeriesVisibility",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["toggle-other-series"] = {
      type: "action",
      showOn: "legend-item",
      label: "contextMenuToggleOtherSeries",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["separator"] = {
      type: "separator",
      showOn: "always",
      label: "separator",
      enabled: true,
      action: void 0,
      items: void 0
    };
  }
};
var ContextMenuBuiltinItemLists = class {
  constructor() {
    this.defaults = [
      "download",
      "zoom-to-cursor",
      "pan-to-cursor",
      "reset-zoom",
      "toggle-series-visibility",
      "toggle-other-series"
    ];
  }
};
var ContextMenuBuiltins = class {
  constructor() {
    this.items = new ContextMenuBuiltinItems();
    this.lists = new ContextMenuBuiltinItemLists();
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.builtins = new ContextMenuBuiltins();
    this.hiddenActions = /* @__PURE__ */ new Set();
    this.setVisible("zoom-to-cursor", false);
    this.setVisible("pan-to-cursor", false);
    this.setVisible("reset-zoom", false);
  }
  static check(showOn, event) {
    return event.showOn == showOn;
  }
  static checkCallback(desiredShowOn, showOn, _callback) {
    return desiredShowOn === showOn;
  }
  dispatchContext(showOn, pointerEvent, context, position) {
    const { widgetEvent } = pointerEvent;
    if (widgetEvent.sourceEvent.defaultPrevented) {
      return;
    }
    const x = position?.x ?? pointerEvent.canvasX;
    const y = position?.y ?? pointerEvent.canvasY;
    const event = { showOn, x, y, context, widgetEvent };
    this.eventsHub.emit("context-menu:setup", event);
    this.eventsHub.emit("context-menu:complete", event);
  }
  isVisible(id) {
    return !this.hiddenActions.has(id);
  }
  setVisible(id, visible) {
    if (visible) {
      this.hiddenActions.delete(id);
    } else {
      this.hiddenActions.add(id);
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.highlightStates = new StateTracker();
  }
  updateHighlight(callerId, highlightedDatum) {
    const previousHighlight = this.getActiveHighlight();
    this.highlightStates.set(callerId, highlightedDatum);
    const currentHighlight = this.getActiveHighlight();
    if (!this.isEqual(currentHighlight, previousHighlight)) {
      this.eventsHub.emit("highlight:change", { callerId, currentHighlight, previousHighlight });
    }
  }
  getActiveHighlight() {
    return this.highlightStates.stateValue();
  }
  isEqual(a, b) {
    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;
  }
};

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
import { CleanupRegistry as CleanupRegistry12 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/series/util.ts
import { findMaxIndex as findMaxIndex3, findMinIndex as findMinIndex3 } from "ag-charts-core";
function datumBoundaryPoints(datum, domain) {
  if (datum == null || domain.length === 0) {
    return [false, false];
  }
  const datumValue = datum.valueOf();
  const d0 = domain[0];
  const d1 = domain[domain.length - 1];
  if (typeof d0 === "string") {
    return [datumValue === d0, datumValue === d1];
  }
  let min = d0.valueOf();
  let max = d1.valueOf();
  if (min > max) {
    [min, max] = [max, min];
  }
  return [datumValue === min, datumValue === max];
}
function datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain) {
  const [min, max] = datumBoundaryPoints(yValue, yDomain);
  const [first2, last] = datumBoundaryPoints(xValue, xDomain);
  return {
    xKey,
    yKey,
    xValue,
    yValue,
    first: first2,
    last,
    min,
    max
  };
}
function visibleRangeIndices(sortOrder, length, [range0, range1], xRange) {
  let xMinIndex = findMinIndex3(0, length - 1, (i) => {
    const index = sortOrder === 1 ? i : length - i;
    const x1 = xRange(index)?.[1] ?? NaN;
    return !Number.isFinite(x1) || x1 > range0;
  }) ?? 0;
  let xMaxIndex = findMaxIndex3(0, length - 1, (i) => {
    const index = sortOrder === 1 ? i : length - i;
    const x0 = xRange(index)?.[0] ?? NaN;
    return !Number.isFinite(x0) || x0 < range1;
  }) ?? length - 1;
  if (sortOrder === -1) {
    [xMinIndex, xMaxIndex] = [length - xMaxIndex, length - xMinIndex];
  }
  xMinIndex = Math.max(xMinIndex, 0);
  xMaxIndex = Math.min(xMaxIndex + 1, length);
  return [xMinIndex, xMaxIndex];
}
function getDatumRefPoint(series, datum, movedBounds) {
  if (movedBounds) {
    const { x, y, width: width2, height: height2 } = movedBounds;
    return { canvasX: x + width2 / 2, canvasY: y + height2 / 2 };
  }
  const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? series.datumMidPoint?.(datum);
  if (refPoint) {
    const { x, y } = Transformable.toCanvasPoint(series.contentGroup, refPoint.x, refPoint.y);
    return { canvasX: Math.round(x), canvasY: Math.round(y) };
  }
}
function countExpandingSearch(min, max, start2, countUntil, iteratee) {
  let i = -1;
  let count = 0;
  let shift = 0;
  let reachedAnEnd = false;
  while (count < countUntil && i <= max - min) {
    i += 1;
    const index = start2 + shift;
    if (!reachedAnEnd)
      shift *= -1;
    if (shift >= 0)
      shift += 1;
    if (reachedAnEnd && shift < 0)
      shift -= 1;
    if (index < min || index > max) {
      reachedAnEnd = true;
      continue;
    }
    if (iteratee(index))
      count += 1;
  }
  return count;
}

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var TooltipManager = class {
  constructor(eventsHub, localeManager, domManager, tooltip) {
    this.domManager = domManager;
    this.tooltip = tooltip;
    this.stateTracker = new StateTracker();
    this.suppressState = new StateTracker(false);
    this.appliedState = null;
    this.cleanup = new CleanupRegistry12();
    this.cleanup.register(
      tooltip.setup(localeManager, domManager),
      eventsHub.on("dom:hidden", () => this.tooltip.hide())
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  updateTooltip(callerId, meta, content, pagination) {
    content ?? (content = this.stateTracker.get(callerId)?.content);
    this.stateTracker.set(callerId, { meta, content, pagination });
    this.applyStates();
  }
  removeTooltip(callerId) {
    this.stateTracker.delete(callerId);
    this.applyStates();
  }
  suppressTooltip(callerId) {
    this.suppressState.set(callerId, true);
  }
  unsuppressTooltip(callerId) {
    this.suppressState.delete(callerId);
  }
  applyStates() {
    const id = this.stateTracker.stateId();
    const state = id ? this.stateTracker.get(id) : void 0;
    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {
      this.appliedState = null;
      this.tooltip.hide();
      return;
    }
    const canvasRect = this.domManager.getBoundingClientRect();
    const boundingRect = this.tooltip.bounds === "extended" ? this.domManager.getOverlayClientRect() : canvasRect;
    if (objectsEqual(this.appliedState?.content, state?.content) && objectsEqual(this.appliedState?.pagination, state?.pagination)) {
      const renderInstantly = this.tooltip.isVisible();
      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, void 0, renderInstantly);
    } else {
      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content, state?.pagination);
    }
    this.appliedState = state;
  }
  static makeTooltipMeta(event, series, datum, movedBounds) {
    const { canvasX, canvasY } = event;
    const tooltip = series.properties.tooltip;
    const { placement, anchorTo, xOffset, yOffset } = tooltip.position;
    const refPoint = getDatumRefPoint(series, datum, movedBounds);
    const meta = {
      canvasX,
      canvasY,
      nodeCanvasX: refPoint?.canvasX ?? canvasX,
      nodeCanvasY: refPoint?.canvasY ?? canvasY,
      enableInteraction: tooltip.interaction?.enabled ?? false,
      showArrow: tooltip.showArrow,
      position: {
        placement,
        anchorTo,
        xOffset,
        yOffset
      }
    };
    return meta;
  }
};

// packages/ag-charts-community/src/chart/interaction/dragInterpreter.ts
import { CleanupRegistry as CleanupRegistry13, EventEmitter as EventEmitter4 } from "ag-charts-core";
var DRAG_THRESHOLD_PX = 3;
var DOUBLE_TAP_TIMER_MS = 505;
var DOUBLE_TAP_THRESHOLD_PX = 30;
function makeSynthetic(type, event) {
  const { device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent } = event;
  return { type, device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };
}
function checkDragDistance(dx, dy) {
  const distanceSquared = dx * dx + dy * dy;
  const thresholdSquared = DRAG_THRESHOLD_PX * DRAG_THRESHOLD_PX;
  return distanceSquared >= thresholdSquared;
}
function checkDoubleTapDistance(t1, t2) {
  const dx = t1.clientX - t2.clientX;
  const dy = t1.clientY - t2.clientY;
  const distanceSquared = dx * dx + dy * dy;
  const thresholdSquared = DOUBLE_TAP_THRESHOLD_PX * DOUBLE_TAP_THRESHOLD_PX;
  return distanceSquared < thresholdSquared;
}
var DragInterpreter = class {
  constructor(widget) {
    this.cleanup = new CleanupRegistry13();
    this.events = new EventEmitter4();
    this.isDragging = false;
    this.touch = { distanceTravelledX: 0, distanceTravelledY: 0, clientX: 0, clientY: 0 };
    this.cleanup.register(
      widget.addListener("touchstart", this.onTouchStart.bind(this)),
      widget.addListener("touchmove", this.onTouchMove.bind(this)),
      widget.addListener("touchend", this.onTouchEnd.bind(this)),
      widget.addListener("mousemove", this.onMouseMove.bind(this)),
      widget.addListener("dblclick", this.onDblClick.bind(this)),
      widget.addListener("drag-start", this.onDragStart.bind(this)),
      widget.addListener("drag-move", this.onDragMove.bind(this)),
      widget.addListener("drag-end", this.onDragEnd.bind(this))
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  onTouchStart(e) {
    const { clientX, clientY } = e.sourceEvent.targetTouches[0] ?? { clientX: Infinity, clientY: Infinity };
    this.touch.distanceTravelledX = 0;
    this.touch.distanceTravelledY = 0;
    this.touch.clientX = clientX;
    this.touch.clientY = clientY;
  }
  onTouchMove(e) {
    const { clientX, clientY } = e.sourceEvent.targetTouches[0] ?? { clientX: Infinity, clientY: Infinity };
    this.touch.distanceTravelledX += Math.abs(this.touch.clientX - clientX);
    this.touch.distanceTravelledY += Math.abs(this.touch.clientY - clientY);
    this.touch.clientX = clientX;
    this.touch.clientY = clientY;
  }
  onTouchEnd(event) {
    event.sourceEvent.preventDefault();
  }
  onMouseMove(event) {
    this.events.emit("mousemove", event);
  }
  onDblClick(event) {
    this.events.emit("dblclick", event);
  }
  onDragStart(event) {
    this.dragStartEvent = event;
  }
  onDragMove(event) {
    if (this.dragStartEvent != null) {
      if (checkDragDistance(event.originDeltaX, event.originDeltaY)) {
        this.events.emit("drag-start", this.dragStartEvent);
        this.events.emit("drag-move", { ...this.dragStartEvent, type: "drag-move" });
        this.dragStartEvent = void 0;
        this.isDragging = true;
      }
    }
    if (this.isDragging) {
      this.events.emit("drag-move", event);
    }
  }
  onDragEnd(event) {
    if (this.isDragging) {
      this.events.emit("drag-end", event);
      this.isDragging = false;
      return;
    }
    if (event.device === "mouse") {
      const click = makeSynthetic("click", event);
      this.events.emit("click", click);
    } else if (event.sourceEvent.type === "touchend") {
      if (checkDragDistance(this.touch.distanceTravelledX, this.touch.distanceTravelledY)) {
        return;
      }
      const click = makeSynthetic("click", event);
      this.events.emit("click", click);
      const now = Date.now();
      if (this.lastClick !== void 0 && now - this.lastClick.time <= DOUBLE_TAP_TIMER_MS && checkDoubleTapDistance(this.lastClick, event)) {
        const dblClick = makeSynthetic("dblclick", event);
        this.events.emit("dblclick", dblClick);
        this.lastClick = void 0;
      } else {
        this.lastClick = { time: now, clientX: event.clientX, clientY: event.clientY };
      }
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/widgetSet.ts
var DOMManagerWidget = class extends NativeWidget {
  constructor(elem) {
    super(elem);
  }
  addChildToDOM() {
  }
  removeChildFromDOM() {
  }
};
var WidgetSet = class {
  constructor(domManager, opts) {
    this.seriesWidget = new DOMManagerWidget(domManager.getParent("series-area"));
    this.chartWidget = new DOMManagerWidget(domManager.getParent("canvas-proxy"));
    this.containerWidget = new DOMManagerWidget(domManager.getParent("canvas-container"));
    this.containerWidget.addChild(this.chartWidget);
    this.chartWidget.addChild(this.seriesWidget);
    if (opts.withDragInterpretation) {
      this.seriesDragInterpreter = new DragInterpreter(this.seriesWidget);
    }
  }
  destroy() {
    this.seriesDragInterpreter?.destroy();
    this.seriesWidget.destroy();
    this.chartWidget.destroy();
    this.containerWidget.destroy();
  }
};

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
import {
  Logger as Logger26,
  attachDescription as attachDescription2,
  defined as defined3,
  isFiniteNumber as isFiniteNumber2,
  isObject as isObject5,
  validate as validate2
} from "ag-charts-core";

// packages/ag-charts-community/src/util/panToBBox.ts
import { clamp as clamp13 } from "ag-charts-core";

// packages/ag-charts-community/src/util/vector4.ts
var Vec4 = {
  bottomCenter,
  center,
  clone,
  collides,
  end,
  from,
  height,
  round,
  start,
  topCenter,
  origin,
  width
};
function start(a) {
  return { x: a.x1, y: a.y1 };
}
function end(a) {
  return { x: a.x2, y: a.y2 };
}
function topCenter(a) {
  return { x: (a.x1 + a.x2) / 2, y: Math.min(a.y1, a.y2) };
}
function center(a) {
  return { x: (a.x1 + a.x2) / 2, y: (a.y1 + a.y2) / 2 };
}
function bottomCenter(a) {
  return { x: (a.x1 + a.x2) / 2, y: Math.max(a.y1, a.y2) };
}
function width(a) {
  return Math.abs(a.x2 - a.x1);
}
function height(a) {
  return Math.abs(a.y2 - a.y1);
}
function round(a) {
  return { x1: Math.round(a.x1), y1: Math.round(a.y1), x2: Math.round(a.x2), y2: Math.round(a.y2) };
}
function clone(a) {
  return { x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2 };
}
function collides(a, b) {
  const an = normalise(a);
  const bn = normalise(b);
  return an.x1 <= bn.x2 && an.x2 >= bn.x1 && an.y1 <= bn.y2 && an.y2 >= bn.y1;
}
function normalise(a) {
  return { x1: Math.min(a.x1, a.x2), x2: Math.max(a.x1, a.x2), y1: Math.min(a.y1, a.y2), y2: Math.max(a.y1, a.y2) };
}
function from(a, b, c, d) {
  if (typeof a === "number") {
    return { x1: a, y1: b, x2: c, y2: d };
  }
  if ("width" in a) {
    return normalise({
      x1: a.x,
      y1: a.y,
      x2: a.x + a.width,
      y2: a.y + a.height
    });
  }
  throw new Error(`Values can not be converted into a vector4: [${JSON.stringify(a)}] [${b}] [${c}] [${d}]`);
}
function origin() {
  return { x1: 0, y1: 0, x2: 0, y2: 0 };
}

// packages/ag-charts-community/src/util/panToBBox.ts
function normalize(screenMin, min, screenMax, max, target) {
  return min + (max - min) * ((target - screenMin) / (screenMax - screenMin));
}
function unnormalize(screenMin, min, screenMax, max, ratio8) {
  return screenMin + (ratio8 - min) * ((screenMax - screenMin) / (max - min));
}
function calcWorldAxis(viewportMin, viewportMax, ratio8) {
  return [
    unnormalize(viewportMin, ratio8.min, viewportMax, ratio8.max, 0),
    unnormalize(viewportMin, ratio8.min, viewportMax, ratio8.max, 1)
  ];
}
function calcWorldVec4(viewport, ratioX, ratioY) {
  const [x1, x2] = calcWorldAxis(viewport.x1, viewport.x2, ratioX);
  const [y1, y2] = calcWorldAxis(viewport.y1, viewport.y2, ratioY);
  return { x1, x2, y1, y2 };
}
function panAxesUnnormalized(worldMin, worldMax, viewportMin, viewportMax, targetMin, targetMax) {
  if (viewportMin <= targetMin && targetMax <= viewportMax)
    return viewportMin;
  const minDiff = targetMin - viewportMin;
  const maxDiff = targetMax - viewportMax;
  const diff2 = Math.abs(minDiff) < Math.abs(maxDiff) ? minDiff : maxDiff;
  return clamp13(worldMin, viewportMin + diff2, worldMax);
}
function calcPanToBBoxRatios(viewportBBox, ratios, targetBBox) {
  const { x: ratioX = { min: 0, max: 1 }, y: ratioY = { min: 0, max: 1 } } = ratios;
  const target = Vec4.from(targetBBox);
  const viewport = Vec4.from(viewportBBox);
  const world = calcWorldVec4(viewport, ratioX, ratioY);
  const x = panAxesUnnormalized(world.x1, world.x2, viewport.x1, viewport.x2, target.x1, target.x2);
  const y = panAxesUnnormalized(world.y1, world.y2, viewport.y1, viewport.y2, target.y1, target.y2);
  const result = {
    x: {
      min: normalize(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x),
      max: normalize(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x + viewportBBox.width)
    },
    y: {
      min: normalize(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y),
      max: normalize(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y + viewportBBox.height)
    }
  };
  const diffX = result.x.max - result.x.min;
  const diffY = result.y.max - result.y.min;
  result.x.min = clamp13(0, result.x.min, 1 - diffX);
  result.x.max = result.x.min + diffX;
  result.y.min = clamp13(0, result.y.min, 1 - diffY);
  result.y.max = result.y.min + diffY;
  return result;
}

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var ZoomManagerAutoScaleAxis = class {
  constructor() {
    this.enabled = false;
    this.padding = 0;
    this.manuallyAdjusted = false;
  }
};
var rangeValidator2 = (axis) => attachDescription2((value, { options }) => {
  if (!ContinuousScale.is(axis?.scale) && !DiscreteTimeScale.is(axis?.scale))
    return true;
  if (value == null || options.end == null)
    return true;
  return value < options.end;
}, `to be less than end`);
var ZoomManager = class extends BaseManager {
  constructor(eventsHub, fireChartEvent) {
    super();
    this.eventsHub = eventsHub;
    this.fireChartEvent = fireChartEvent;
    this.mementoOriginatorKey = "zoom";
    this.axisZoomManagers = /* @__PURE__ */ new Map();
    this.state = new StateTracker(void 0, "initial");
    this.axes = [];
    this.didLayoutAxes = false;
    this.autoScaleYAxis = new ZoomManagerAutoScaleAxis();
    this.lastRestoredState = void 0;
    this.independentAxes = false;
    this.navigatorModule = false;
    this.zoomModule = false;
    // The initial state memento can not be restored until the chart has performed its first layout. Instead save it as
    // pending and restore then delete it on the first layout.
    this.pendingMemento = void 0;
    this.boundFireOnceChartEvent = this.fireOnceChartEvent.bind(this);
    this.cleanup.register(
      eventsHub.on("layout:complete", () => {
        this.didLayoutAxes = true;
        const { pendingMemento } = this;
        if (pendingMemento) {
          this.restoreMemento(pendingMemento.version, pendingMemento.mementoVersion, pendingMemento.memento);
        }
        this.autoScaleYZoom("zoom-manager");
      })
    );
  }
  createMemento() {
    return this.getMementoRanges();
  }
  guardMemento(blob, messages) {
    if (blob == null)
      return true;
    if (!isObject5(blob))
      return false;
    const primaryX = this.getPrimaryAxis("x" /* X */);
    const primaryY = this.getPrimaryAxis("y" /* Y */);
    const zoomMementoDefs = {
      rangeX: { start: rangeValidator2(primaryX), end: defined3 },
      rangeY: { start: rangeValidator2(primaryY), end: defined3 },
      ratioX: { start: defined3, end: defined3 },
      ratioY: { start: defined3, end: defined3 },
      autoScaledAxes: defined3
    };
    const { invalid } = validate2(blob, zoomMementoDefs);
    if (invalid.length > 0) {
      messages.push(...invalid.map(String));
      return false;
    }
    return true;
  }
  restoreMemento(version, mementoVersion, memento) {
    const { independentAxes } = this;
    if (!this.axes || !this.didLayoutAxes) {
      this.pendingMemento = { version, mementoVersion, memento };
      return;
    }
    this.pendingMemento = void 0;
    const zoom = this.getDefinedZoom();
    if (memento?.rangeX) {
      zoom.x = this.rangeToRatio(memento.rangeX, "x" /* X */) ?? { min: 0, max: 1 };
    } else if (memento?.ratioX) {
      zoom.x = {
        min: memento.ratioX.start ?? 0,
        max: memento.ratioX.end ?? 1
      };
    } else {
      zoom.x = { min: 0, max: 1 };
    }
    if (!this.navigatorModule || this.zoomModule) {
      let yAutoScale = memento?.autoScaledAxes?.includes("y");
      if (memento?.rangeY) {
        yAutoScale ?? (yAutoScale = false);
        zoom.y = this.rangeToRatio(memento.rangeY, "y" /* Y */) ?? { min: 0, max: 1 };
      } else if (memento?.ratioY) {
        yAutoScale ?? (yAutoScale = false);
        zoom.y = {
          min: memento.ratioY.start ?? 0,
          max: memento.ratioY.end ?? 1
        };
      } else {
        yAutoScale ?? (yAutoScale = true);
        const autoZoomY = yAutoScale ? this.getAutoScaleYZoom(zoom.x) : void 0;
        zoom.y = autoZoomY ?? { min: 0, max: 1 };
      }
      zoom.autoScaleYAxis = yAutoScale;
    }
    this.lastRestoredState = zoom;
    if (independentAxes !== true) {
      this.updateZoom("zoom-manager", zoom);
      return;
    }
    const primaryX = this.getPrimaryAxis("x" /* X */);
    const primaryY = this.getPrimaryAxis("y" /* Y */);
    for (const axis of [primaryX, primaryY]) {
      if (!axis)
        continue;
      this.updateAxisZoom("zoom-manager", axis.id, zoom[axis.direction]);
    }
  }
  updateAxes(axes) {
    this.axes = axes;
    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));
    this.axisZoomManagers.clear();
    for (const axis of axes) {
      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));
    }
    if (this.state.size > 0 && axes.length > 0) {
      this.updateZoom(this.state.stateId(), this.state.stateValue());
    }
  }
  setIndependentAxes(independent = true) {
    this.independentAxes = independent;
  }
  setAutoScaleYAxis(enabled, padding2) {
    this.autoScaleYAxis.enabled = enabled;
    this.autoScaleYAxis.padding = padding2;
    if (enabled) {
      this.autoScaleYZoom("toggle-auto-scale");
    }
  }
  setNavigatorEnabled(enabled = true) {
    this.navigatorModule = enabled;
  }
  setZoomModuleEnabled(enabled = true) {
    this.zoomModule = enabled;
  }
  isNavigatorEnabled() {
    return this.navigatorModule;
  }
  isZoomEnabled() {
    return this.zoomModule;
  }
  updateZoom(callerId, newZoom) {
    if (newZoom?.x && (newZoom.x.min < 0 || newZoom.x.max > 1)) {
      Logger26.warnOnce(
        `Attempted to update x-axis zoom to an invalid ratio of [{ min: ${newZoom.x.min}, max: ${newZoom.x.max} }], expecting a ratio of 0 to 1, ignoring.`
      );
      newZoom.x = void 0;
    }
    if (newZoom?.y && (newZoom.y.min < 0 || newZoom.y.max > 1)) {
      Logger26.warnOnce(
        `Attempted to update y-axis zoom to an invalid ratio of [{ min: ${newZoom.y.min}, max: ${newZoom.y.max} }], expecting a ratio of 0 to 1, ignoring.`
      );
      newZoom.y = void 0;
    }
    if (this.axisZoomManagers.size === 0) {
      const stateId = this.state.stateId();
      if (stateId === "initial" || stateId === callerId) {
        this.state.set(callerId, newZoom);
      }
      return;
    }
    this.state.set(callerId, newZoom);
    const autoScaleYAxis = newZoom?.autoScaleYAxis;
    if (autoScaleYAxis != null) {
      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
    }
    this.axisZoomManagers.forEach((axis) => {
      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);
    });
    this.applyChanges(callerId);
  }
  updateAxisZoom(callerId, axisId, newZoom) {
    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);
    this.applyChanges(callerId);
  }
  resetZoom(callerId) {
    this.autoScaleYAxis.manuallyAdjusted = false;
    const zoom = this.getRestoredZoom();
    this.updateZoom(callerId, {
      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },
      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 },
      autoScaleYAxis: zoom?.autoScaleYAxis ?? true
    });
  }
  resetAxisZoom(callerId, axisId) {
    const axisZoomManager = this.axisZoomManagers.get(axisId);
    const direction = axisZoomManager?.getDirection();
    if (direction == null)
      return;
    const restoredZoom = this.getRestoredZoom();
    if (direction === "y" /* Y */) {
      const autoScaleYAxis = restoredZoom?.autoScaleYAxis ?? true;
      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
    }
    for (const axis of this.axes) {
      if (axis.direction !== direction)
        continue;
      this.updateAxisZoom(callerId, axis.id, restoredZoom?.[direction] ?? { min: 0, max: 1 });
    }
  }
  setAxisManuallyAdjusted(_callerId, axisId) {
    const direction = this.axisZoomManagers.get(axisId)?.getDirection();
    if (direction !== "y" /* Y */)
      return;
    this.autoScaleYAxis.manuallyAdjusted = true;
  }
  updatePrimaryAxisZoom(callerId, direction, newZoom) {
    const primaryAxis = this.getPrimaryAxis(direction);
    if (!primaryAxis)
      return;
    this.updateAxisZoom(callerId, primaryAxis.id, newZoom);
  }
  panToBBox(callerId, seriesRect, target) {
    if (!this.isZoomEnabled() && !this.isNavigatorEnabled())
      return false;
    const zoom = this.getZoom();
    if (zoom === void 0 || !zoom.x && !zoom.y)
      return false;
    const panIsPossible = seriesRect.width > 0 && seriesRect.height > 0 && Math.abs(target.width) <= Math.abs(seriesRect.width) && Math.abs(target.height) <= Math.abs(seriesRect.height);
    if (!panIsPossible) {
      Logger26.warnOnce(`cannot pan to target BBox - chart too small?`);
      return false;
    }
    const newZoom = calcPanToBBoxRatios(seriesRect, zoom, target);
    if (this.independentAxes) {
      this.updatePrimaryAxisZoom(callerId, "x" /* X */, newZoom.x);
      this.updatePrimaryAxisZoom(callerId, "y" /* Y */, newZoom.y);
    } else {
      this.updateZoom(callerId, newZoom);
    }
    return true;
  }
  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.
  fireZoomPanStartEvent(callerId) {
    this.eventsHub.emit("zoom:pan-start", { callerId });
  }
  extendToEnd(callerId, direction, extent2) {
    return this.extendWith(callerId, direction, (end2) => Number(end2) - extent2);
  }
  extendWith(callerId, direction, fn) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainExtents(axis);
    if (!extents)
      return;
    const [, end2] = extents;
    const start2 = fn(end2);
    const ratio8 = this.rangeToRatio({ start: start2, end: end2 }, direction);
    if (!ratio8)
      return;
    this.updateZoom(callerId, { [direction]: ratio8 });
  }
  updateWith(callerId, direction, fn) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainExtents(axis);
    if (!extents)
      return;
    let [start2, end2] = extents;
    [start2, end2] = fn(start2, end2);
    const ratio8 = this.rangeToRatio({ start: start2, end: end2 }, direction);
    if (!ratio8)
      return;
    this.updateZoom(callerId, { [direction]: ratio8 });
  }
  getZoom() {
    let x;
    let y;
    this.axisZoomManagers.forEach((axis) => {
      if (axis.getDirection() === "x" /* X */) {
        x ?? (x = axis.getZoom());
      } else if (axis.getDirection() === "y" /* Y */) {
        y ?? (y = axis.getZoom());
      }
    });
    if (x || y) {
      return { x, y };
    }
  }
  getAxisZoom(axisId) {
    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };
  }
  getAxisZooms() {
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = {
        direction: axis.getDirection(),
        zoom: axis.getZoom()
      };
    }
    return axes;
  }
  getRestoredZoom() {
    return this.lastRestoredState;
  }
  getPrimaryAxisId(direction) {
    return this.getPrimaryAxis(direction)?.id;
  }
  isVisibleItemsCountAtLeast(zoom, minVisibleItems) {
    const { autoScaleYAxis } = this;
    const xAxis = this.getPrimaryAxis("x" /* X */);
    const yAxis = this.getPrimaryAxis("y" /* Y */);
    let boundSeries;
    if (this.independentAxes) {
      const xBoundSeries = new Set(xAxis?.boundSeries ?? []);
      const yBoundSeries = new Set(yAxis?.boundSeries ?? []);
      boundSeries = /* @__PURE__ */ new Set();
      for (const series of xBoundSeries) {
        if (yBoundSeries.has(series)) {
          boundSeries.add(series);
        }
      }
    } else {
      boundSeries = /* @__PURE__ */ new Set([...xAxis?.boundSeries ?? [], ...yAxis?.boundSeries ?? []]);
    }
    const xVisibleRange = [zoom.x.min, zoom.x.max];
    const yVisibleRange = autoScaleYAxis.enabled && !autoScaleYAxis.manuallyAdjusted ? void 0 : [zoom.y.min, zoom.y.max];
    let visibleItemsCount = 0;
    for (const series of boundSeries) {
      const remainingItems = minVisibleItems - (visibleItemsCount ?? 0);
      const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);
      visibleItemsCount += seriesVisibleItems;
      if (visibleItemsCount >= minVisibleItems)
        return true;
    }
    return boundSeries.size === 0;
  }
  getMementoRanges() {
    const zoom = this.getDefinedZoom();
    let autoScaledAxes;
    if (this.autoScaleYAxis.enabled) {
      autoScaledAxes = this.autoScaleYAxis.manuallyAdjusted ? [] : ["y"];
    }
    const memento = {
      rangeX: this.getRangeDirection(zoom.x, "x" /* X */),
      rangeY: this.getRangeDirection(zoom.y, "y" /* Y */),
      ratioX: { start: zoom.x.min, end: zoom.x.max },
      ratioY: { start: zoom.y.min, end: zoom.y.max },
      autoScaledAxes
    };
    return memento;
  }
  getAutoScaleYZoom(zoomX) {
    if (!this.isZoomEnabled())
      return;
    const { independentAxes, autoScaleYAxis } = this;
    if (!autoScaleYAxis.enabled || autoScaleYAxis.manuallyAdjusted)
      return;
    const { padding: padding2 } = autoScaleYAxis;
    if (zoomX?.min === 0 && zoomX?.max === 1) {
      return { min: 0, max: 1 };
    } else if (independentAxes) {
      return this.primaryAxisZoom("y" /* Y */, zoomX, { padding: padding2 });
    } else {
      return this.combinedAxisZoom("y" /* Y */, zoomX, { padding: padding2 });
    }
  }
  autoScaleYZoom(callerId, applyChanges = true) {
    const { independentAxes } = this;
    const zoom = this.getZoom();
    if (zoom?.x == null)
      return;
    const zoomY = this.getAutoScaleYZoom(zoom.x);
    if (zoomY == null || objectsEqual(zoom.y, zoomY))
      return;
    if (independentAxes) {
      const primaryAxis = this.getPrimaryAxis("y" /* Y */);
      const primaryAxisManager = primaryAxis == null ? void 0 : this.axisZoomManagers.get(primaryAxis.id);
      primaryAxisManager?.updateZoom("zoom-manager", zoomY);
    } else {
      for (const axisZoomManager of this.axisZoomManagers.values()) {
        if (axisZoomManager.getDirection() === "y" /* Y */) {
          axisZoomManager.updateZoom("zoom-manager", zoomY);
        }
      }
    }
    if (applyChanges) {
      this.applyChanges(callerId);
    }
  }
  applyChanges(callerId) {
    this.autoScaleYZoom(callerId, false);
    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).includes(true);
    if (!changed) {
      return;
    }
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = axis.getZoom();
    }
    this.eventsHub.emit("zoom:change", { ...this.getZoom(), axes, callerId });
    this.eventsHub.on("layout:complete", this.boundFireOnceChartEvent);
  }
  fireOnceChartEvent() {
    this.fireChartEvent({ type: "zoom", ...this.getMementoRanges() });
    this.eventsHub.off("layout:complete", this.boundFireOnceChartEvent);
  }
  getRangeDirection(ratio8, direction) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis || !ContinuousScale.is(axis.scale) && !DiscreteTimeScale.is(axis.scale))
      return;
    const extents = this.getDomainPixelExtents(axis);
    if (!extents)
      return;
    const [d0, d1] = extents;
    let start2;
    let end2;
    if (d0 <= d1) {
      start2 = axis.scale.invert(0);
      end2 = axis.scale.invert(d0 + (d1 - d0) * ratio8.max);
    } else {
      start2 = axis.scale.invert(d0 - (d0 - d1) * ratio8.min);
      end2 = axis.scale.invert(0);
    }
    return { start: start2, end: end2 };
  }
  rangeToRatio(range3, direction) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainPixelExtents(axis);
    if (!extents)
      return;
    const [d0, d1] = extents;
    const { scale: scale2 } = axis;
    const { start: start2, end: end2 } = range3;
    const [startAlignment = 0 /* Leading */, endAlignment = 1 /* Trailing */] = rangeAlignment(
      start2,
      end2
    );
    let r0 = range3.start == null ? d0 : scale2.convert(range3.start, { alignment: startAlignment });
    let r1 = range3.end == null ? d1 : scale2.convert(range3.end, { alignment: endAlignment }) + (scale2.bandwidth ?? 0);
    if (!isFiniteNumber2(r0) || !isFiniteNumber2(r1))
      return;
    const [dMin, dMax] = [Math.min(d0, d1), Math.max(d0, d1)];
    if (r0 < dMin || r0 > dMax) {
      Logger26.warnOnce(
        `Invalid range start [${range3.start}], expecting a value between [${scale2.invert(d0)}] and [${scale2.invert?.(d1)}], ignoring.`
      );
      return;
    }
    if (r1 < dMin || r1 > dMax) {
      Logger26.warnOnce(
        `Invalid range end [${range3.end}], expecting a value between [${scale2.invert(d0)}] and [${scale2.invert?.(d1)}], ignoring.`
      );
      return;
    }
    r0 = Math.min(dMax, Math.max(dMin, r0));
    r1 = Math.min(dMax, Math.max(dMin, r1));
    const diff2 = d1 - d0;
    const min = Math.abs((r0 - d0) / diff2);
    const max = Math.abs((r1 - d0) / diff2);
    return { min, max };
  }
  getPrimaryAxis(direction) {
    return this.axes?.find((a) => a.direction === direction);
  }
  getDomainExtents(axis) {
    const { domain } = axis.scale;
    const d0 = domain.at(0);
    const d1 = domain.at(-1);
    if (d0 == null || d1 == null)
      return;
    return [d0, d1];
  }
  getDomainPixelExtents(axis) {
    const [d0, d1] = axis.scale.range;
    if (!isFiniteNumber2(d0) || !isFiniteNumber2(d1))
      return;
    return [d0, d1];
  }
  getDefinedZoom() {
    const zoom = this.getZoom();
    return {
      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },
      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 }
    };
  }
  zoomBounds(xAxis, yAxis, zoom, padding2) {
    const xScale = xAxis.scale;
    const xScaleRange = xScale.range;
    xScale.range = [0, 1];
    const yScale = yAxis.scale;
    const yScaleRange = yScale.range;
    yScale.range = [0, 1];
    let min = 1;
    let minPadding = false;
    let max = 0;
    let maxPadding = false;
    for (const series of yAxis.boundSeries) {
      if (!series.visible)
        continue;
      const { connectsToYAxis } = series;
      const yValues = series.getRange("y" /* Y */, [zoom.min, zoom.max]);
      for (const yValue of yValues) {
        const y = yScale.convert(yValue);
        if (!Number.isFinite(y))
          continue;
        if (y < min) {
          min = y;
          minPadding = !connectsToYAxis || yValue < 0;
        }
        if (y > max) {
          max = y;
          maxPadding = !connectsToYAxis || yValue > 0;
        }
      }
    }
    if (isFiniteNumber2(yAxis.min)) {
      min = 0;
    }
    if (isFiniteNumber2(yAxis.max)) {
      max = 1;
    }
    xScale.range = xScaleRange;
    yScale.range = yScaleRange;
    if (min >= max)
      return;
    const totalPadding = (minPadding ? padding2 : 0) + (maxPadding ? padding2 : 0);
    const paddedDelta = Math.min((max - min) * (1 + totalPadding), 1);
    if (paddedDelta <= 0)
      return;
    if (minPadding && maxPadding) {
      const mid = (max + min) / 2;
      min = mid - paddedDelta / 2;
      max = mid + paddedDelta / 2;
    } else if (!minPadding && maxPadding) {
      max = min + paddedDelta;
    } else if (minPadding && !maxPadding) {
      min = max - paddedDelta;
    }
    if (min < 0) {
      max += -min;
      min = 0;
    } else if (max > 1) {
      min -= max - 1;
      max = 1;
    }
    return { min, max };
  }
  primaryAxisZoom(direction, zoom, { padding: padding2 = 0 } = {}) {
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const xAxis = this.getPrimaryAxis(crossDirection);
    const yAxis = this.getPrimaryAxis(direction);
    if (xAxis == null || yAxis == null)
      return;
    return this.zoomBounds(xAxis, yAxis, zoom, padding2);
  }
  combinedAxisZoom(direction, zoom, { padding: padding2 = 0 } = {}) {
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const seriesXAxes = /* @__PURE__ */ new Map();
    for (const xAxis of this.axes) {
      if (xAxis.direction !== crossDirection)
        continue;
      for (const series of xAxis.boundSeries) {
        seriesXAxes.set(series, xAxis);
      }
    }
    let min = 1;
    let max = 0;
    for (const yAxis of this.axes) {
      if (yAxis.direction !== direction)
        continue;
      for (const series of yAxis.boundSeries) {
        const xAxis = seriesXAxes.get(series);
        if (xAxis == null)
          continue;
        const bounds = this.zoomBounds(xAxis, yAxis, zoom, padding2);
        if (bounds == null)
          return;
        min = Math.min(min, bounds.min);
        max = Math.max(max, bounds.max);
      }
    }
    const delta3 = 1e-6;
    if (min < delta3)
      min = 0;
    if (max > 1 - delta3)
      max = 1;
    if (min > max)
      return;
    return { min, max };
  }
};
var AxisZoomManager = class {
  constructor(axis) {
    this.axis = axis;
    const [min = 0, max = 1] = axis.visibleRange;
    this.state = new StateTracker({ min, max });
    this.currentZoom = this.state.stateValue();
  }
  getDirection() {
    return this.axis.direction;
  }
  updateZoom(callerId, newZoom) {
    this.state.set(callerId, newZoom);
  }
  getZoom() {
    return deepClone(this.state.stateValue());
  }
  hasChanges() {
    const currentZoom = this.currentZoom;
    const pendingZoom = this.state.stateValue();
    return currentZoom.min !== pendingZoom.min || currentZoom.max !== pendingZoom.max;
  }
  applyChanges() {
    const hasChanges = this.hasChanges();
    this.currentZoom = this.state.stateValue();
    return hasChanges;
  }
};

// packages/ag-charts-community/src/chart/layout/layoutManager.ts
var LayoutElement = /* @__PURE__ */ ((LayoutElement2) => {
  LayoutElement2[LayoutElement2["Caption"] = 0] = "Caption";
  LayoutElement2[LayoutElement2["Legend"] = 1] = "Legend";
  LayoutElement2[LayoutElement2["ToolbarLeft"] = 2] = "ToolbarLeft";
  LayoutElement2[LayoutElement2["ToolbarBottom"] = 3] = "ToolbarBottom";
  LayoutElement2[LayoutElement2["Navigator"] = 4] = "Navigator";
  LayoutElement2[LayoutElement2["Overlay"] = 5] = "Overlay";
  return LayoutElement2;
})(LayoutElement || {});
var LayoutManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.elements = /* @__PURE__ */ new Map();
  }
  registerElement(element2, listener) {
    if (this.elements.has(element2)) {
      this.elements.get(element2).add(listener);
    } else {
      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));
    }
    return () => this.elements.get(element2)?.delete(listener);
  }
  createContext(width2, height2) {
    const context = new LayoutContext(width2, height2);
    for (const element2 of Object.values(LayoutElement)) {
      if (typeof element2 !== "number")
        continue;
      this.elements.get(element2)?.forEach((listener) => listener(context));
    }
    return context;
  }
  emitLayoutComplete(context, options) {
    const { width: width2, height: height2 } = context;
    this.eventsHub.emit("layout:complete", {
      axes: options.axes ?? [],
      chart: { width: width2, height: height2 },
      clipSeries: options.clipSeries ?? false,
      series: options.series
    });
  }
};
var LayoutContext = class {
  constructor(width2, height2) {
    this.width = width2;
    this.height = height2;
    this.layoutBox = new BBox(0, 0, width2, height2);
  }
};

// packages/ag-charts-community/src/chart/layout/seriesLabelLayoutManager.ts
var SeriesLabelLayoutManager = class {
  constructor() {
    this.labelData = /* @__PURE__ */ new Map();
  }
  updateLabels(placedLabelSeries, padding2, seriesRect = BBox.zero) {
    const bounds = {
      x: -padding2.left,
      y: -padding2.top,
      width: seriesRect.width + padding2.left + padding2.right,
      height: seriesRect.height + padding2.top + padding2.bottom
    };
    const expectedSeriesId = new Set(placedLabelSeries.map((s) => s.id));
    for (const seriesId of this.labelData.keys()) {
      if (!expectedSeriesId.has(seriesId)) {
        this.labelData.delete(seriesId);
      }
    }
    for (const series of placedLabelSeries) {
      const labelData = series.getLabelData();
      if (labelData.every(isPointLabelDatum)) {
        this.labelData.set(series.id, labelData);
      }
    }
    const placedLabels = placeLabels(this.labelData, bounds, 5);
    for (const series of placedLabelSeries) {
      series.updatePlacedLabelData?.(placedLabels.get(series.id) ?? []);
    }
  }
};

// packages/ag-charts-community/src/chart/legend/legendManager.ts
import { Logger as Logger27, isArray as isArray10 } from "ag-charts-core";
var LegendManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.mementoOriginatorKey = "legend";
    this.legendDataMap = /* @__PURE__ */ new Map();
  }
  createMemento() {
    return this.getData().filter(({ hideInLegend, isFixed }) => !hideInLegend && !isFixed).map(({ enabled, seriesId, itemId, legendItemName }) => ({
      visible: enabled,
      seriesId,
      itemId,
      legendItemName
    }));
  }
  guardMemento(blob) {
    return blob == null || isArray10(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    memento?.forEach((datum) => {
      const { seriesId, data } = this.getRestoredData(datum) ?? {};
      if (!seriesId || !data) {
        return;
      }
      this.updateData(seriesId, data);
    });
    this.update();
  }
  getRestoredData(datum) {
    const { seriesId, itemId, legendItemName, visible } = datum;
    if (seriesId) {
      const legendData = this.legendDataMap.get(seriesId) ?? [];
      const data = legendData.map((d) => {
        const match = d.seriesId === seriesId && (!itemId || d.itemId === itemId);
        if (match && d.isFixed) {
          this.warnFixed(d.seriesId, d.itemId);
        }
        return !d.isFixed && match ? { ...d, enabled: visible } : d;
      });
      return { seriesId, data };
    }
    if (itemId == null && legendItemName == null) {
      return;
    }
    for (const legendDatum of this.getData()) {
      if (itemId != null && legendDatum.itemId !== itemId || legendItemName != null && legendDatum.legendItemName !== legendItemName) {
        continue;
      }
      if (legendDatum.isFixed) {
        this.warnFixed(legendDatum.seriesId, itemId);
        return;
      }
      const seriesLegendData = (this.legendDataMap.get(legendDatum.seriesId) ?? []).map(
        (d) => d.itemId === itemId || d.legendItemName === legendItemName ? { ...d, enabled: visible } : d
      );
      return {
        seriesId: legendDatum.seriesId,
        data: seriesLegendData
      };
    }
  }
  warnFixed(seriesId, itemId) {
    Logger27.warnOnce(
      `The legend item with seriesId [${seriesId}] and itemId [${itemId}] is not configurable, this series item cannot be toggled through the legend.`
    );
  }
  update(data) {
    this.eventsHub.emit("legend:change", {
      legendData: data ?? this.getData()
    });
  }
  updateData(seriesId, data = []) {
    this.legendDataMap.set(seriesId, data);
  }
  clearData() {
    this.legendDataMap.clear();
  }
  toggleItem(enabled, seriesId, itemId, legendItemName) {
    if (legendItemName) {
      this.getData().forEach((datum) => {
        const newData = (this.legendDataMap.get(datum.seriesId) ?? []).map(
          (d) => d.legendItemName === legendItemName ? { ...d, enabled } : d
        );
        this.updateData(datum.seriesId, newData);
      });
      return;
    }
    const seriesLegendData = this.getData(seriesId);
    const singleLegendItem = seriesLegendData.length === 1;
    const data = seriesLegendData.map(
      (datum) => itemId == null && singleLegendItem || datum.itemId === itemId ? { ...datum, enabled } : datum
    );
    this.updateData(seriesId, data);
  }
  getData(seriesId) {
    if (seriesId) {
      return this.legendDataMap.get(seriesId) ?? [];
    }
    return [...this.legendDataMap].reduce(
      (data, [_, legendData]) => data.concat(legendData),
      []
    );
  }
  getDatum({ seriesId, itemId } = {}) {
    return this.getData(seriesId).find((datum) => datum.itemId === itemId);
  }
  getSeriesEnabled(seriesId) {
    const data = this.getData(seriesId);
    if (data.length > 0) {
      return data.some((d) => d.enabled);
    }
  }
  getItemEnabled({ seriesId, itemId } = {}) {
    return this.getDatum({ seriesId, itemId })?.enabled ?? true;
  }
};

// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager = class {
  constructor() {
    this.groups = /* @__PURE__ */ new Map();
  }
  registerSeries({ internalId, seriesGrouping, visible, type }) {
    if (!seriesGrouping)
      return;
    let group = this.groups.get(type);
    if (group == null) {
      group = /* @__PURE__ */ new Map();
      this.groups.set(type, group);
    }
    group.set(internalId, { grouping: seriesGrouping, visible });
  }
  updateSeries({ internalId, seriesGrouping, visible, type }) {
    if (!seriesGrouping)
      return;
    const entry = this.groups.get(type)?.get(internalId);
    if (entry) {
      entry.grouping = seriesGrouping;
      entry.visible = visible;
    }
  }
  deregisterSeries({ internalId, type }) {
    const group = this.groups.get(type);
    if (group == null)
      return;
    group.delete(internalId);
    if (group.size === 0) {
      this.groups.delete(type);
    }
  }
  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {
    if (!seriesGrouping) {
      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };
    }
    const visibleGroupsSet = /* @__PURE__ */ new Set();
    const visibleSameStackSet = /* @__PURE__ */ new Set();
    const group = this.groups.get(type);
    for (const entry of group?.values() ?? []) {
      if (!entry.visible)
        continue;
      visibleGroupsSet.add(entry.grouping.groupIndex);
      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
        visibleSameStackSet.add(entry.grouping.stackIndex);
      }
    }
    const visibleGroups = Array.from(visibleGroupsSet);
    visibleGroups.sort((a, b) => a - b);
    return {
      visibleGroupCount: visibleGroups.length,
      visibleSameStackCount: visibleSameStackSet.size,
      index: visibleGroups.indexOf(seriesGrouping.groupIndex)
    };
  }
};

// packages/ag-charts-community/src/chart/updateService.ts
import { EventEmitter as EventEmitter5 } from "ag-charts-core";
var UpdateService = class {
  constructor(updateCallback) {
    this.updateCallback = updateCallback;
    this.events = new EventEmitter5();
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  destroy() {
    this.events.clear();
  }
  update(type = 0 /* FULL */, options) {
    this.updateCallback(type, options);
  }
  dispatchUpdateComplete(apiUpdate) {
    this.events.emit("update-complete", { type: "update-complete", apiUpdate });
  }
  dispatchPreDomUpdate() {
    this.events.emit("pre-dom-update", { type: "pre-dom-update" });
  }
  dispatchPreSceneRender() {
    this.events.emit("pre-scene-render", { type: "pre-scene-render" });
  }
  dispatchProcessData({ series }) {
    this.events.emit("process-data", { type: "process-data", series });
  }
};

// packages/ag-charts-community/src/chart/chartContext.ts
var ChartContext = class {
  constructor(chart, vars) {
    this.eventsHub = new EventEmitter6();
    this.callbackCache = new CallbackCache();
    this.highlightManager = new HighlightManager(this.eventsHub);
    this.formatManager = new FormatManager();
    this.layoutManager = new LayoutManager(this.eventsHub);
    this.localeManager = new LocaleManager(this.eventsHub);
    this.seriesStateManager = new SeriesStateManager();
    this.stateManager = new StateManager();
    this.seriesLabelLayoutManager = new SeriesLabelLayoutManager();
    this.cleanup = new CleanupRegistry14();
    this.contextModules = [];
    const {
      scene,
      root,
      syncManager,
      container,
      fireEvent,
      updateCallback,
      updateMutex,
      styleContainer,
      chartType,
      domMode,
      withDragInterpretation
    } = vars;
    this.chartService = chart;
    this.syncManager = syncManager;
    this.domManager = new DOMManager(this.eventsHub, this.chartService, container, styleContainer, domMode);
    this.widgets = new WidgetSet(this.domManager, { withDragInterpretation });
    const canvasElement = this.domManager.addChild(
      "canvas",
      "scene-canvas",
      scene?.canvas.element
    );
    this.scene = scene ?? new Scene({ canvasElement });
    this.scene.setRoot(root);
    this.cleanup.register(
      this.scene.on("scene-changed", () => {
        this.updateService.update(7 /* SCENE_RENDER */);
      })
    );
    this.axisManager = new AxisManager(this.eventsHub, root);
    this.legendManager = new LegendManager(this.eventsHub);
    this.annotationManager = new AnnotationManager(this.eventsHub, chart.annotationRoot, fireEvent);
    this.chartTypeOriginator = new ChartTypeOriginator(chart);
    this.interactionManager = new InteractionManager();
    this.contextMenuRegistry = new ContextMenuRegistry(this.eventsHub);
    this.updateService = new UpdateService(updateCallback);
    this.proxyInteractionService = new ProxyInteractionService(this.eventsHub, this.localeManager, this.domManager);
    this.fontManager = new FontManager(this.domManager, this.updateService);
    this.historyManager = new HistoryManager(this.eventsHub);
    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);
    this.dataService = new DataService(this.eventsHub, chart, this.animationManager);
    this.tooltipManager = new TooltipManager(this.eventsHub, this.localeManager, this.domManager, chart.tooltip);
    this.zoomManager = new ZoomManager(this.eventsHub, fireEvent);
    for (const module of moduleRegistry.byType("context")) {
      if (!module.chartTypes.includes(chartType))
        continue;
      const moduleInstance = module.moduleFactory(this);
      this.contextModules.push(moduleInstance);
      this[module.contextKey] = moduleInstance;
    }
  }
  destroy() {
    this.animationManager.destroy();
    this.axisManager.destroy();
    this.callbackCache.invalidateCache();
    this.domManager.destroy();
    this.fontManager.destroy();
    this.proxyInteractionService.destroy();
    this.tooltipManager.destroy();
    this.zoomManager.destroy();
    this.widgets.destroy();
    this.contextModules.forEach((m) => m.destroy());
    this.cleanup.flush();
  }
};

// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.range = "tooltip";
  }
};
__decorateClass([
  Property
], ChartHighlight.prototype, "range", 2);

// packages/ag-charts-community/src/chart/data/caching.ts
import { arraysEqual as arraysEqual3 } from "ag-charts-core";
function setsEqual(a, b) {
  if (a.size !== b.size)
    return false;
  for (const value of a) {
    if (!b.has(value))
      return false;
  }
  return true;
}
function idsMapEqual(a, b) {
  if (a == null || b == null)
    return a === b;
  if (a.size !== b.size)
    return false;
  for (const [key, aValue] of a) {
    const bValue = b.get(key);
    if (bValue == null)
      return false;
    if (!setsEqual(aValue, bValue))
      return false;
  }
  return true;
}
function propsEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i += 1) {
    const { type: typeA, idsMap: idsMapA, scopes: scopesA, data: dataA, ...propA } = a[i];
    const { type: typeB, idsMap: idsMapB, scopes: scopesB, data: dataB, ...propB } = b[i];
    if (typeA !== typeB)
      return false;
    if (scopesA && scopesB && !arraysEqual3(scopesA, scopesB))
      return false;
    if (dataA && dataB && dataA !== dataB)
      return false;
    if (!objectsEqual(propA, propB) || !idsMapEqual(idsMapA, idsMapB))
      return false;
  }
  return true;
}
function optsEqual(a, b) {
  const { props: propsA, ...restA } = a;
  const { props: propsB, ...restB } = b;
  return objectsEqual(restA, restB) && propsEqual(propsA, propsB);
}
function canReuseCachedData(cachedDataItem, data, ids, opts) {
  return data === cachedDataItem.data && arraysEqual3(ids, cachedDataItem.ids) && optsEqual(opts, cachedDataItem.opts);
}

// packages/ag-charts-community/src/chart/data/dataController.ts
import { getWindow as getWindow15 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/data/dataModel.ts
import { Logger as Logger28, first, isNegative, isObject as isObject6, iterate } from "ag-charts-core";

// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DiscreteDomain = class _DiscreteDomain {
  constructor() {
    this.domain = /* @__PURE__ */ new Set();
  }
  static is(value) {
    return value instanceof _DiscreteDomain;
  }
  extend(val) {
    this.domain.add(val);
  }
  getDomain() {
    return Array.from(this.domain);
  }
};
var ContinuousDomain = class _ContinuousDomain {
  constructor() {
    this.domain = [Infinity, -Infinity];
  }
  static is(value) {
    return value instanceof _ContinuousDomain;
  }
  static extendDomain(values, domain = [Infinity, -Infinity]) {
    for (const value of values) {
      if (typeof value !== "number") {
        continue;
      }
      if (domain[0] > value) {
        domain[0] = value;
      }
      if (domain[1] < value) {
        domain[1] = value;
      }
    }
    return domain;
  }
  extend(value) {
    if (this.domain[0] > value) {
      this.domain[0] = value;
    }
    if (this.domain[1] < value) {
      this.domain[1] = value;
    }
  }
  getDomain() {
    return [...this.domain];
  }
};

// packages/ag-charts-community/src/chart/data/rangeLookup.ts
var MIN = 0;
var MAX = 1;
var SPAN = 2;
var RangeLookup = class {
  constructor(allValues) {
    const dataLength = allValues.reduce((acc, v) => Math.max(acc, v.length), 0);
    const sizePower = 32 - Math.clz32(dataLength);
    let maxLevelSize = 1 << sizePower;
    if (dataLength === maxLevelSize / 2) {
      maxLevelSize = maxLevelSize >>> 1;
    }
    this.maxLevelSize = maxLevelSize;
    const buffer = new Float64Array((maxLevelSize * 2 - 1) * 2).fill(NaN);
    for (const values of allValues) {
      for (let i = 0; i < values.length; i += 1) {
        const value = Number(values[i]);
        const bufferIndex = maxLevelSize + i - 1;
        const bufferMinIndex = (bufferIndex * SPAN | 0) + MIN;
        const bufferMaxIndex = (bufferIndex * SPAN | 0) + MAX;
        const prevMinValue = buffer[bufferMinIndex];
        const prevMaxValue = buffer[bufferMaxIndex];
        if (!Number.isFinite(prevMinValue) || value < prevMinValue) {
          buffer[bufferMinIndex] = value;
        }
        if (!Number.isFinite(prevMaxValue) || value > prevMaxValue) {
          buffer[bufferMaxIndex] = value;
        }
      }
    }
    for (let size = maxLevelSize / 2 | 0; size >= 1; size = size / 2 | 0) {
      const start2 = size - 1 | 0;
      const end2 = start2 + size | 0;
      for (let i = 0; i < size; i += 1) {
        const nodeIndex = start2 + i;
        const leftIndex = end2 + i * 2;
        const rightIndex = leftIndex + 1;
        const aMin = buffer[(leftIndex * SPAN | 0) + MIN];
        const bMin = buffer[(rightIndex * SPAN | 0) + MIN];
        buffer[(nodeIndex * SPAN | 0) + MIN] = !Number.isFinite(bMin) || aMin < bMin ? aMin : bMin;
        const aMax = buffer[(leftIndex * SPAN | 0) + MAX];
        const bMax = buffer[(rightIndex * SPAN | 0) + MAX];
        buffer[(nodeIndex * SPAN | 0) + MAX] = !Number.isFinite(bMax) || aMax > bMax ? aMax : bMax;
      }
    }
    this.buffer = buffer;
  }
  computeRangeInto(buffer, start2, end2, bufferIndex, currentStart, step, into) {
    const currentEnd = currentStart + step - 1;
    if (currentEnd < start2 || currentStart >= end2)
      return into;
    if (currentStart >= start2 && currentEnd < end2) {
      const min = buffer[(bufferIndex * SPAN | 0) + MIN];
      const max = buffer[(bufferIndex * SPAN | 0) + MAX];
      if (Number.isFinite(min))
        into[0] = Math.min(into[0], min);
      if (Number.isFinite(max))
        into[1] = Math.max(into[1], max);
    } else if (step > 1) {
      bufferIndex = bufferIndex * 2 | 0;
      step = step / 2 | 0;
      this.computeRangeInto(buffer, start2, end2, bufferIndex + 1 | 0, currentStart, step, into);
      this.computeRangeInto(buffer, start2, end2, bufferIndex + 2 | 0, currentStart + step, step, into);
    }
    return into;
  }
  rangeBetween(start2, end2) {
    if (start2 > end2)
      return [NaN, NaN];
    const { maxLevelSize, buffer } = this;
    const range3 = [Infinity, -Infinity];
    this.computeRangeInto(buffer, start2, end2, 0, 0, maxLevelSize, range3);
    return range3;
  }
  get range() {
    const { buffer } = this;
    return [buffer[MIN], buffer[MAX]];
  }
};

// packages/ag-charts-community/src/chart/data/sortOrder.ts
function valuesSortOrder(values) {
  if (values.length <= 1)
    return 1;
  let order = 0;
  let v0 = values[0];
  for (let i = 1; i < values.length; i++) {
    const v1 = values[i];
    if (v1 == null)
      continue;
    const primitive = v1.valueOf();
    if (typeof primitive !== "number")
      return;
    const diff2 = Math.sign(v1 - v0);
    if (diff2 !== 0) {
      if (order !== 0 && order !== diff2)
        return;
      order = diff2;
    }
    v0 = v1;
  }
  return order === 0 ? 1 : order;
}

// packages/ag-charts-community/src/chart/data/dataModel.ts
var KEY_SORT_ORDERS = Symbol("key-sort-orders");
var COLUMN_SORT_ORDERS = Symbol("column-sort-orders");
var DOMAIN_RANGES = Symbol("domain-ranges");
function toKeyString(keys) {
  return keys.map((key) => isObject6(key) ? JSON.stringify(key) : key).join("-");
}
function fixNumericExtent(extent2) {
  const numberExtent = extent2?.map(Number);
  return numberExtent?.every(Number.isFinite) ? numberExtent : [];
}
function getMissCount(scopeProvider, missMap) {
  return missMap?.get(scopeProvider.id) ?? 0;
}
function isScoped(obj) {
  return "scopes" in obj && Array.isArray(obj.scopes);
}
function createArray(length, value) {
  const out = [];
  for (let i = 0; i < length; i += 1) {
    out[i] = value;
  }
  return out;
}
function datumKeys(keys, columnScope, datumIndex) {
  const out = [];
  for (const k of keys) {
    const key = k.get(columnScope)?.[datumIndex];
    if (key == null)
      return;
    out.push(key);
  }
  return out;
}
function getPathComponents(path) {
  const components = [];
  let matchIndex = 0;
  let matchGroup;
  const regExp = /((?:(?:^|\.)\s*\w+|\[\s*(?:'(?:[^']|(?<!\\)\\')*'|"(?:[^"]|(?<!\\)\\")*"|-?\d+)\s*\])\s*)/g;
  while (matchGroup = regExp.exec(path)) {
    if (matchGroup.index !== matchIndex) {
      return;
    }
    matchIndex = matchGroup.index + matchGroup[0].length;
    const match = matchGroup[1].trim();
    if (match.startsWith(".")) {
      components.push(match.slice(1).trim());
    } else if (match.startsWith("[")) {
      const accessor = match.slice(1, -1).trim();
      if (accessor.startsWith(`'`)) {
        components.push(accessor.slice(1, -1).replace(/(?<!\\)\\'/g, `'`));
      } else if (accessor.startsWith(`"`)) {
        components.push(accessor.slice(1, -1).replace(/(?<!\\)\\"/g, `"`));
      } else {
        components.push(accessor);
      }
    } else {
      components.push(match);
    }
  }
  if (matchIndex !== path.length)
    return;
  return components;
}
function createPathAccessor(components) {
  return (datum) => {
    let current = datum;
    for (const component of components) {
      current = current[component];
    }
    return current;
  };
}
var DataModel = class {
  constructor(opts, mode = "standalone", suppressFieldDotNotation = false) {
    this.opts = opts;
    this.mode = mode;
    this.suppressFieldDotNotation = suppressFieldDotNotation;
    this.debug = Debug.create(true, "data-model");
    this.scopeCache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.values = [];
    this.aggregates = [];
    this.groupProcessors = [];
    this.propertyProcessors = [];
    this.reducers = [];
    this.processors = [];
    this.markScopeDatumInvalid = function(scopes, data, datumIndex, invalidData) {
      for (const scope of scopes) {
        if (!invalidData.has(scope)) {
          invalidData.set(scope, createArray(data.length, false));
        }
        invalidData.get(scope)[datumIndex] = true;
      }
    };
    let keys = true;
    for (const next of opts.props) {
      if (next.type === "key" && !keys) {
        throw new Error("AG Charts - internal config error: keys must come before values.");
      }
      if (next.type === "value" && keys) {
        keys = false;
      }
    }
    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {
      for (const matchGroupId of matchGroupIds) {
        if (this.values.every((def) => def.groupId !== matchGroupId)) {
          throw new Error(
            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`
          );
        }
      }
    };
    const keyScopes = /* @__PURE__ */ new Set();
    const valueScopes = /* @__PURE__ */ new Set();
    for (const def of opts.props) {
      const scopes = def.type === "key" ? keyScopes : valueScopes;
      if (isScoped(def)) {
        def.scopes?.forEach((s) => scopes.add(s));
      }
      switch (def.type) {
        case "key":
          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "value":
          if (def.property == null) {
            throw new Error(
              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(
                def
              )}`
            );
          }
          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "aggregate":
          verifyMatchGroupId(def);
          this.aggregates.push({ ...def, index: this.aggregates.length });
          break;
        case "group-value-processor":
          verifyMatchGroupId(def);
          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });
          break;
        case "property-value-processor":
          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });
          break;
        case "reducer":
          this.reducers.push({ ...def, index: this.reducers.length });
          break;
        case "processor":
          this.processors.push({ ...def, index: this.processors.length });
          break;
      }
    }
    if (!!this.opts.groupByKeys || this.opts.groupByFn != null) {
      const ungroupedScopes = new Set(valueScopes.values());
      keyScopes.forEach((s) => ungroupedScopes.delete(s));
      if (ungroupedScopes.size > 0) {
        throw new Error(
          `AG Charts - scopes missing key for grouping, illegal configuration: ${[...ungroupedScopes.values()]}`
        );
      }
    }
  }
  resolveProcessedDataDefById(scope, searchId) {
    const def = this.scopeCache.get(scope.id)?.get(searchId);
    if (!def) {
      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);
    }
    return { index: def.index, def };
  }
  resolveProcessedDataIndexById(scope, searchId) {
    return this.resolveProcessedDataDefById(scope, searchId).index;
  }
  resolveKeysById(scope, searchId, processedData) {
    const index = this.resolveProcessedDataIndexById(scope, searchId);
    const keys = processedData.keys[index];
    if (keys == null) {
      throw new Error(`AG Charts - didn't find keys for [${searchId}, ${scope.id}]`);
    }
    return keys.get(scope.id);
  }
  hasColumnById(scope, searchId) {
    return this.scopeCache.get(scope.id)?.get(searchId) != null;
  }
  resolveColumnById(scope, searchId, processedData) {
    const index = this.resolveProcessedDataIndexById(scope, searchId);
    const column = processedData.columns?.[index];
    if (column == null) {
      throw new Error(`AG Charts - didn't find column for [${searchId}, ${scope.id}]`);
    }
    return column;
  }
  /**
   * Provides a convenience iterator to iterate over all of the extract datum values in a
   * specific DataGroup.
   *
   * @param scope to which datums should belong
   * @param group containing the datums
   * @param processedData containing the group
   */
  *forEachDatum(scope, processedData, group) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    for (const datumIndex of group.datumIndices[columnIndex] ?? []) {
      yield processedData.columns[columnIndex][datumIndex];
    }
  }
  /**
   * Provides a convenience iterator to iterate over all of the extracted datum values in a
   * GroupedData.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */
  *forEachGroupDatum(scope, processedData) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    const output = {
      groupIndex: 0,
      columnIndex
    };
    const empty = [];
    for (const group of processedData.groups) {
      output.group = group;
      for (const datumIndex of group.datumIndices[columnIndex] ?? empty) {
        output.datumIndex = datumIndex;
        yield output;
      }
      output.groupIndex++;
    }
  }
  /**
   * Provides a window-based convenience iterator to iterate over all of the extracted datum
   * values in a GroupedData, including the previous and next entries relative to each datum.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */
  *forEachGroupDatumTuple(scope, processedData) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    const output = { columnIndex, datumIndexes: [void 0, void 0, void 0] };
    for (const next of this.forEachGroupDatum(scope, processedData)) {
      output.group = output.nextGroup;
      output.groupIndex = output.nextGroupIndex;
      output.nextGroup = next.group;
      output.nextGroupIndex = next.groupIndex;
      output.datumIndexes[0] = output.datumIndexes[1];
      output.datumIndexes[1] = output.datumIndexes[2];
      output.datumIndexes[2] = next.datumIndex;
      if (output.group != null && output.datumIndexes[1] != null) {
        yield output;
      }
    }
    output.group = output.nextGroup;
    output.groupIndex = output.nextGroupIndex;
    output.nextGroup = void 0;
    output.nextGroupIndex = void 0;
    output.datumIndexes[0] = output.datumIndexes[1];
    output.datumIndexes[1] = output.datumIndexes[2];
    output.datumIndexes[2] = void 0;
    if (output.group != null && output.datumIndexes[1] != null) {
      yield output;
    }
  }
  getDomain(scope, searchId, type, processedData) {
    const domains = this.getDomainsByType(type ?? "value", processedData);
    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];
  }
  getDomainBetweenRange(scope, searchIds, [i0, i1], processedData) {
    const columnIndices = searchIds.map((searchId) => this.resolveProcessedDataIndexById(scope, searchId));
    const cacheKey = columnIndices.join(":");
    const domainRanges = processedData[DOMAIN_RANGES];
    let rangeLookup = domainRanges.get(cacheKey);
    if (rangeLookup == null) {
      const values = columnIndices.map((columnIndex) => processedData.columns[columnIndex]);
      rangeLookup = new RangeLookup(values);
      domainRanges.set(cacheKey, rangeLookup);
    }
    return rangeLookup.rangeBetween(i0, i1);
  }
  getSortOrder(values, index, sortOrders) {
    let sortOrder = sortOrders.get(index);
    if (sortOrder == null) {
      sortOrder = { sortOrder: valuesSortOrder(values) };
      sortOrders.set(index, sortOrder);
    }
    return sortOrder.sortOrder;
  }
  getKeySortOrder(scope, searchId, processedData) {
    const columnIndex = this.resolveProcessedDataIndexById(scope, searchId);
    const keys = processedData.keys[columnIndex]?.get(scope.id);
    return keys ? this.getSortOrder(keys, columnIndex, processedData[KEY_SORT_ORDERS]) : void 0;
  }
  getColumnSortOrder(scope, searchId, processedData) {
    const columnIndex = this.resolveProcessedDataIndexById(scope, searchId);
    return this.getSortOrder(processedData.columns[columnIndex], columnIndex, processedData[COLUMN_SORT_ORDERS]);
  }
  getDomainsByType(type, processedData) {
    switch (type) {
      case "key":
        return processedData.domain.keys;
      case "value":
        return processedData.domain.values;
      case "aggregate":
        return processedData.domain.aggValues;
      case "group-value-processor":
        return processedData.domain.groups;
      default:
        return null;
    }
  }
  processData(sources) {
    const {
      opts: { groupByKeys, groupByFn },
      aggregates,
      groupProcessors,
      reducers,
      processors,
      propertyProcessors
    } = this;
    const start2 = performance.now();
    if (groupByKeys && this.keys.length === 0) {
      return;
    }
    let processedData = this.extractData(sources);
    if (groupByKeys) {
      processedData = this.groupData(processedData);
    } else if (groupByFn) {
      processedData = this.groupData(processedData, groupByFn(processedData));
    }
    if (groupProcessors.length > 0 && processedData.type === "grouped") {
      this.postProcessGroups(processedData);
    }
    if (aggregates.length > 0 && processedData.type === "ungrouped") {
      this.aggregateUngroupedData(processedData);
    } else if (aggregates.length > 0 && processedData.type === "grouped") {
      this.aggregateGroupedData(processedData);
    }
    if (propertyProcessors.length > 0) {
      this.postProcessProperties(processedData);
    }
    if (reducers.length > 0) {
      this.reduceData(processedData);
    }
    if (processors.length > 0) {
      this.postProcessData(processedData);
    }
    this.warnDataMissingProperties(sources);
    const end2 = performance.now();
    processedData.time = end2 - start2;
    if (this.debug.check()) {
      logProcessedData(processedData);
    }
    this.processScopeCache();
    return processedData;
  }
  warnDataMissingProperties(sources) {
    if (sources.size === 0)
      return;
    for (const def of iterate(this.keys, this.values)) {
      for (const [scope, missCount] of def.missing) {
        if (missCount < (sources.get(scope)?.length ?? Infinity))
          continue;
        const scopeHint = scope == null ? "" : ` for ${scope}`;
        Logger28.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);
      }
    }
  }
  processScopeCache() {
    this.scopeCache.clear();
    for (const def of iterate(this.keys, this.values, this.aggregates)) {
      if (!def.idsMap)
        continue;
      for (const [scope, ids] of def.idsMap) {
        for (const id of ids) {
          if (!this.scopeCache.has(scope)) {
            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));
          } else if (this.scopeCache.get(scope)?.has(id)) {
            throw new Error("duplicate definition ids on the same scope are not allowed.");
          } else {
            this.scopeCache.get(scope).set(id, def);
          }
        }
      }
    }
  }
  valueGroupIdxLookup({ matchGroupIds }) {
    const result = [];
    for (const [index, def] of this.values.entries()) {
      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {
        result.push(index);
      }
    }
    return result;
  }
  valueIdxLookup(scopes, prop) {
    const noScopesToMatch = scopes == null || scopes.length === 0;
    const propId = typeof prop === "string" ? prop : prop.id;
    const hasMatchingScopeId = (def) => {
      if (def.idsMap) {
        for (const [scope, ids] of def.idsMap) {
          if (scopes?.includes(scope) && ids.has(propId)) {
            return true;
          }
        }
      }
      return false;
    };
    const result = this.values.reduce((res, def, index) => {
      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));
      if (validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def))) {
        res.push(index);
      }
      return res;
    }, []);
    if (result.length === 0) {
      throw new Error(
        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(
          scopes
        )}`
      );
    }
    return result;
  }
  extractData(sources) {
    const { dataDomain, processValue, allScopesHaveSameDefs } = this.initDataDomainProcessor();
    const { keys: keyDefs, values: valueDefs } = this;
    const { invalidData, invalidKeys, invalidKeyCount, allKeyMappings } = this.extractKeys(
      keyDefs,
      sources,
      processValue
    );
    const { columns, columnScopes, partialValidDataCount, maxDataLength } = this.extractValues(
      invalidData,
      valueDefs,
      sources,
      invalidKeys,
      processValue
    );
    const propertyDomain = (def) => {
      const defDomain = dataDomain.get(def);
      const result = defDomain.getDomain();
      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {
        return [];
      }
      return result;
    };
    return {
      type: "ungrouped",
      input: { count: maxDataLength },
      scopes: new Set(sources.keys()),
      dataSources: sources,
      aggregation: void 0,
      keys: [...allKeyMappings.values()],
      columns,
      columnScopes,
      invalidKeys,
      invalidKeyCount,
      invalidData,
      domain: {
        keys: keyDefs.map(propertyDomain),
        values: valueDefs.map(propertyDomain)
      },
      defs: {
        allScopesHaveSameDefs,
        keys: keyDefs,
        values: valueDefs
      },
      partialValidDataCount,
      time: 0,
      [DOMAIN_RANGES]: /* @__PURE__ */ new Map(),
      [KEY_SORT_ORDERS]: /* @__PURE__ */ new Map(),
      [COLUMN_SORT_ORDERS]: /* @__PURE__ */ new Map()
    };
  }
  extractKeys(keyDefs, sources, processValue) {
    const invalidKeys = /* @__PURE__ */ new Map();
    const invalidData = /* @__PURE__ */ new Map();
    const invalidKeyCount = /* @__PURE__ */ new Map();
    const allKeys = /* @__PURE__ */ new Map();
    let keyDefKeys;
    let scopeDataProcessed;
    const cloneScope = (source, target) => {
      const sourceScope = scopeDataProcessed.get(source);
      keyDefKeys.set(target, keyDefKeys.get(sourceScope));
      if (invalidKeys.has(sourceScope)) {
        invalidKeys.set(target, invalidKeys.get(sourceScope));
        invalidData.set(target, invalidData.get(sourceScope));
      }
    };
    for (const keyDef of keyDefs) {
      const { invalidValue, scopes: keyScopes } = keyDef;
      keyDefKeys = /* @__PURE__ */ new Map();
      scopeDataProcessed = /* @__PURE__ */ new Map();
      allKeys.set(keyDef, keyDefKeys);
      for (const scope of keyScopes ?? []) {
        const data = sources.get(scope) ?? [];
        if (scopeDataProcessed.has(data)) {
          cloneScope(data, scope);
          continue;
        }
        const keys = [];
        keyDefKeys.set(scope, keys);
        scopeDataProcessed.set(data, scope);
        let invalidScopeKeys;
        let invalidScopeData;
        let missingKeys = 0;
        for (let datumIndex = 0; datumIndex < data.length; datumIndex++) {
          if (data[datumIndex] == null || typeof data[datumIndex] !== "object")
            continue;
          const result = processValue(keyDef, data[datumIndex], datumIndex, scope);
          if (result.valid) {
            keys.push(result.value);
            continue;
          }
          keys.push(invalidValue);
          invalidScopeKeys ?? (invalidScopeKeys = createArray(data.length, false));
          invalidScopeData ?? (invalidScopeData = createArray(data.length, false));
          missingKeys += 1;
          invalidScopeKeys[datumIndex] = true;
          invalidScopeData[datumIndex] = true;
        }
        if (invalidScopeKeys && invalidScopeData) {
          invalidKeys.set(scope, invalidScopeKeys);
          invalidData.set(scope, invalidScopeData);
          invalidKeyCount.set(scope, missingKeys);
        }
      }
    }
    return { invalidData, invalidKeys, invalidKeyCount, allKeyMappings: allKeys };
  }
  extractValues(invalidData, valueDefs, sources, scopeInvalidKeys, processValue) {
    let partialValidDataCount = 0;
    const columns = [];
    const allColumnScopes = [];
    let maxDataLength = 0;
    for (const def of valueDefs) {
      const { invalidValue } = def;
      const valueSources = new Set(def.scopes.map((s) => sources.get(s)));
      if (valueSources.size > 1) {
        throw new Error(`AG Charts - more than one data source for: ${JSON.stringify(def)}`);
      }
      const columnScopes = new Set(def.scopes);
      const columnScope = first(def.scopes);
      const columnSource = sources.get(columnScope);
      const column = new Array();
      const invalidKeys = scopeInvalidKeys.get(columnScope);
      for (let datumIndex = 0; datumIndex < columnSource.length; datumIndex++) {
        if (columnSource[datumIndex] == null || typeof columnSource[datumIndex] !== "object")
          continue;
        const valueDatum = columnSource[datumIndex];
        const invalidKey = invalidKeys != null ? invalidKeys[datumIndex] : false;
        const result = processValue(def, valueDatum, datumIndex, def.scopes);
        let value = result.value;
        if (invalidKey || !result.valid) {
          this.markScopeDatumInvalid(def.scopes, columnSource, datumIndex, invalidData);
        }
        if (invalidKey) {
          value = invalidValue;
        } else if (!result.valid) {
          partialValidDataCount += 1;
          value = invalidValue;
        }
        column[datumIndex] = value;
      }
      columns.push(column);
      allColumnScopes.push(columnScopes);
      maxDataLength = Math.max(maxDataLength, column.length);
    }
    return { columns, columnScopes: allColumnScopes, partialValidDataCount, maxDataLength };
  }
  groupData(data, groupingFn) {
    var _a;
    const { keys: dataKeys, columns: allColumns, columnScopes, invalidKeys, invalidData } = data;
    const allScopes = data.scopes;
    const resultGroups = [];
    const resultData = [];
    const processedColumnIndexes = /* @__PURE__ */ new Set();
    const groups = allScopes.size !== 1 || groupingFn != null ? /* @__PURE__ */ new Map() : void 0;
    for (const scope of allScopes) {
      const scopeColumnIndexes = allColumns.map((_, idx) => idx).filter((idx) => !processedColumnIndexes.has(idx) && columnScopes[idx].has(scope));
      if (scopeColumnIndexes.length === 0)
        continue;
      for (const idx of scopeColumnIndexes) {
        processedColumnIndexes.add(idx);
      }
      const siblingScopes = /* @__PURE__ */ new Set();
      for (const columnIdx of scopeColumnIndexes) {
        for (const columnScope of columnScopes[columnIdx]) {
          siblingScopes.add(columnScope);
        }
      }
      const scopeKeys = dataKeys.map((k) => k.get(scope)).filter((k) => k != null);
      const firstColumn = allColumns[first(scopeColumnIndexes)];
      const scopeInvalidData = invalidData?.get(scope);
      const scopeInvalidKeys = invalidKeys?.get(scope);
      for (let datumIndex = 0; datumIndex < firstColumn.length; datumIndex++) {
        if (scopeInvalidKeys?.[datumIndex] === true)
          continue;
        const keys = scopeKeys.map((k) => k[datumIndex]);
        if (keys == null || keys.length === 0) {
          throw new Error("AG Charts - no keys found for scope: " + scope);
        }
        const group = groupingFn?.(keys) ?? keys;
        const groupStr = groups != null ? toKeyString(group) : void 0;
        let outputGroup = groups?.get(groupStr);
        if (outputGroup == null) {
          outputGroup = {
            keys: group,
            datumIndices: [],
            aggregation: [],
            validScopes: allScopes
          };
          groups?.set(groupStr, outputGroup);
          resultGroups.push(outputGroup.keys);
          resultData.push(outputGroup);
        }
        if (scopeInvalidData?.[datumIndex] === true) {
          if (outputGroup.validScopes === allScopes) {
            outputGroup.validScopes = new Set(allScopes.values());
          }
          for (const invalidScope of siblingScopes) {
            outputGroup.validScopes.delete(invalidScope);
          }
        }
        for (const columnIdx of scopeColumnIndexes) {
          (_a = outputGroup.datumIndices)[columnIdx] ?? (_a[columnIdx] = []);
          outputGroup.datumIndices[columnIdx].push(datumIndex);
        }
      }
    }
    return {
      ...data,
      type: "grouped",
      domain: {
        ...data.domain,
        groups: resultGroups
      },
      groups: resultData
    };
  }
  aggregateUngroupedData(processedData) {
    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);
    processedData.domain.aggValues = domainAggValues;
    const { keys, columns, dataSources } = processedData;
    const onlyScope = first(dataSources.keys());
    const rawData = dataSources.get(onlyScope);
    processedData.aggregation = rawData?.map((_, datumIndex) => {
      const aggregation = [];
      for (const [index, def] of this.aggregates.entries()) {
        const indices = this.valueGroupIdxLookup(def);
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        const valuesToAgg = indices.map((columnIndex) => columns[columnIndex][datumIndex]);
        const k = datumKeys(keys, onlyScope, datumIndex);
        const valuesAgg = k != null ? def.aggregateFunction(valuesToAgg, k) : void 0;
        if (valuesAgg) {
          groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
        }
        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;
        aggregation[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
      }
      return aggregation;
    });
  }
  aggregateGroupedData(processedData) {
    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);
    processedData.domain.aggValues = domainAggValues;
    const { columns } = processedData;
    for (const [index, def] of this.aggregates.entries()) {
      const indices = this.valueGroupIdxLookup(def);
      for (const group of processedData.groups) {
        group.aggregation ?? (group.aggregation = []);
        const groupKeys = group.keys;
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        const maxDatumIndex = Math.max(
          ...indices.map((columnIndex) => group.datumIndices[columnIndex]?.length ?? 0)
        );
        for (let datumIndex = 0; datumIndex < maxDatumIndex; datumIndex++) {
          const valuesToAgg = indices.map(
            (columnIndex) => columns[columnIndex][group.datumIndices[columnIndex]?.[datumIndex]]
          );
          const valuesAgg = def.aggregateFunction(valuesToAgg, groupKeys);
          if (valuesAgg) {
            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
          }
        }
        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;
        group.aggregation[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
      }
    }
  }
  postProcessGroups(processedData) {
    const { groupProcessors } = this;
    const { columnScopes, columns, invalidData } = processedData;
    for (const processor of groupProcessors) {
      const valueIndexes = this.valueGroupIdxLookup(processor);
      const adjustFn = processor.adjust()();
      for (const dataGroup of processedData.groups) {
        adjustFn(columns, valueIndexes, dataGroup);
      }
      for (const valueIndex of valueIndexes) {
        const valueDef = this.values[valueIndex];
        const isDiscrete = valueDef.valueType === "category";
        const column = columns[valueIndex];
        const columnScope = first(columnScopes[valueIndex]);
        const invalidDatums = invalidData?.get(columnScope);
        const domain = isDiscrete ? new DiscreteDomain() : new ContinuousDomain();
        for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {
          if (invalidDatums?.[datumIndex] === true)
            continue;
          domain.extend(column[datumIndex]);
        }
        processedData.domain.values[valueIndex] = domain.getDomain();
      }
    }
  }
  postProcessProperties(processedData) {
    for (const { adjust, property, scopes } of this.propertyProcessors) {
      for (const idx of this.valueIdxLookup(scopes, property)) {
        adjust()(processedData, idx);
      }
    }
  }
  reduceData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    const { dataSources, keys } = processedData;
    for (const def of this.reducers) {
      const reducer = def.reducer();
      let accValue = def.initialValue;
      if (processedData.type === "grouped") {
        for (const group of processedData.groups) {
          accValue = reducer(accValue, group.keys);
        }
      } else {
        const onlyScope = first(dataSources.keys());
        const keyColumns = keys.map((k) => k.get(onlyScope)).filter((k) => k != null);
        const keysParam = keyColumns.map(() => void 0);
        const rawData = dataSources.get(onlyScope);
        for (let datumIndex = 0; datumIndex < rawData.length; datumIndex += 1) {
          for (let keyIdx = 0; keyIdx < keysParam.length; keyIdx++) {
            keysParam[keyIdx] = keyColumns[keyIdx]?.[datumIndex];
          }
          accValue = reducer(accValue, keysParam);
        }
      }
      processedData.reduced[def.property] = accValue;
    }
  }
  postProcessData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    for (const def of this.processors) {
      processedData.reduced[def.property] = def.calculate(
        processedData,
        processedData.reduced[def.property]
      );
    }
  }
  initDataDomainProcessor() {
    const { keys: keyDefs, values: valueDefs } = this;
    const scopes = /* @__PURE__ */ new Set();
    for (const valueDef of valueDefs) {
      if (!valueDef.scopes)
        continue;
      for (const scope of valueDef.scopes) {
        scopes.add(scope);
      }
    }
    const dataDomain = /* @__PURE__ */ new Map();
    const processorFns = /* @__PURE__ */ new Map();
    let allScopesHaveSameDefs = true;
    const initDataDomain = () => {
      for (const def of iterate(keyDefs, valueDefs)) {
        if (def.valueType === "category") {
          dataDomain.set(def, new DiscreteDomain());
        } else {
          dataDomain.set(def, new ContinuousDomain());
          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes?.length ?? 0) === scopes.size);
        }
      }
    };
    initDataDomain();
    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));
    const reusableResult = {
      value: void 0,
      missing: false,
      valid: false
    };
    const processValue = (def, datum, idx, valueScopes) => {
      let valueInDatum;
      let value;
      if (accessors.has(def.property)) {
        try {
          value = accessors.get(def.property)(datum);
        } catch {
        }
        valueInDatum = value != null;
      } else {
        valueInDatum = def.property in datum;
        value = valueInDatum ? datum[def.property] : def.missingValue;
      }
      if (def.forceValue != null) {
        const valueNegative = valueInDatum && isNegative(value);
        value = valueNegative ? -1 * def.forceValue : def.forceValue;
        valueInDatum = true;
      }
      reusableResult.missing = !valueInDatum;
      const missingValueDef = "missingValue" in def;
      if (!valueInDatum && !missingValueDef) {
        if (typeof valueScopes === "string") {
          const missCount = def.missing.get(valueScopes) ?? 0;
          def.missing.set(valueScopes, missCount + 1);
        } else {
          for (const scope of valueScopes) {
            const missCount = def.missing.get(scope) ?? 0;
            def.missing.set(scope, missCount + 1);
          }
        }
      }
      if (!dataDomain.has(def)) {
        initDataDomain();
      }
      if (valueInDatum && def.validation?.(value, datum, idx) === false) {
        reusableResult.valid = false;
        if ("invalidValue" in def) {
          value = def.invalidValue;
        } else {
          if (this.mode !== "integrated") {
            Logger28.warnOnce(
              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,
              `[${value}]`
            );
          }
          reusableResult.value = void 0;
          return reusableResult;
        }
      } else {
        reusableResult.valid = true;
      }
      if (def.processor) {
        let processor = processorFns.get(def);
        if (processor == null) {
          processor = def.processor();
          processorFns.set(def, processor);
        }
        value = processor(value, idx);
      }
      dataDomain.get(def)?.extend(value);
      reusableResult.value = value;
      return reusableResult;
    };
    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };
  }
  buildAccessors(defs) {
    const result = /* @__PURE__ */ new Map();
    if (this.suppressFieldDotNotation) {
      return result;
    }
    for (const def of defs) {
      const isPath = def.property.includes(".") || def.property.includes("[");
      if (!isPath)
        continue;
      const components = getPathComponents(def.property);
      if (components == null) {
        Logger28.warnOnce("Invalid property path [%s]", def.property);
        continue;
      }
      const accessor = createPathAccessor(components);
      result.set(def.property, accessor);
    }
    return result;
  }
};
function logProcessedData(processedData) {
  const logValues = (name, data) => {
    if (data.length > 0) {
      Logger28.log(`DataModel.processData() - ${name}`);
      Logger28.table(data);
    }
  };
  Logger28.log("DataModel.processData() - processedData", processedData);
  logValues("Key Domains", processedData.domain.keys);
  logValues("Group Domains", processedData.domain.groups ?? []);
  logValues("Value Domains", processedData.domain.values);
  logValues("Aggregate Domains", processedData.domain.aggValues ?? []);
}

// packages/ag-charts-community/src/chart/data/dataController.ts
var _DataController = class _DataController {
  constructor(mode, suppressFieldDotNotation) {
    this.mode = mode;
    this.suppressFieldDotNotation = suppressFieldDotNotation;
    this.debug = Debug.create(true, "data-model");
    this.requested = [];
    this.status = "setup";
  }
  async request(id, data, opts) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    return new Promise((resolve, reject) => {
      this.requested.push({ id, opts, data, resolve, reject });
    });
  }
  execute(cachedData) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    this.status = "executed";
    this.debug("DataController.execute() - requested", this.requested);
    const valid = this.validateRequests(this.requested);
    this.debug("DataController.execute() - validated", valid);
    const merged = this.mergeRequested(valid);
    this.debug("DataController.execute() - merged", merged);
    if (this.debug.check()) {
      getWindow15().processedData = [];
    }
    const nextCachedData = [];
    for (const { data, ids, opts, resolves, rejects } of merged) {
      const reusableCache = cachedData?.find((cacheItem) => canReuseCachedData(cacheItem, data, ids, opts));
      let dataModel;
      let processedData;
      if (reusableCache == null) {
        try {
          dataModel = new DataModel(opts, this.mode, this.suppressFieldDotNotation);
          const sources = new Map(valid.map((v) => [v.id, v.data]));
          processedData = dataModel.processData(sources);
        } catch (error) {
          rejects.forEach((cb) => cb(error));
          continue;
        }
      } else {
        ({ dataModel, processedData } = reusableCache);
      }
      nextCachedData.push({ opts, data, ids, dataModel, processedData });
      if (this.debug.check()) {
        getWindow15("processedData").push(processedData);
      }
      if (processedData?.partialValidDataCount === 0) {
        resolves.forEach(
          (resolve) => resolve({
            dataModel,
            processedData
          })
        );
      } else if (processedData) {
        this.splitResult(dataModel, processedData, ids, resolves);
      } else {
        rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));
      }
    }
    return nextCachedData;
  }
  validateRequests(requested) {
    const valid = [];
    for (const [index, request] of requested.entries()) {
      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false && request.opts.groupByKeys === false) {
        request.reject(
          new Error("all series[].data arrays must be of the same length and have matching keys.")
        );
      } else {
        valid.push(request);
      }
    }
    return valid;
  }
  mergeRequested(requested) {
    const grouped = [];
    for (const request of requested) {
      const match = grouped.find(_DataController.groupMatch(request));
      if (match) {
        match.push(request);
      } else {
        grouped.push([request]);
      }
    }
    return grouped.map(_DataController.mergeRequests);
  }
  splitResult(dataModel, processedData, scopes, resolves) {
    for (let i = 0; i < scopes.length; i++) {
      const resolve = resolves[i];
      resolve({
        dataModel,
        processedData
      });
    }
  }
  static groupMatch({ data, opts }) {
    function keys(props2) {
      return props2.filter((p) => p.type === "key").map((p) => p.property).join(";");
    }
    const { groupByData, groupByKeys = false, groupByFn, props } = opts;
    const propsKeys = keys(props);
    return ([group]) => (groupByData === false || group.data === data) && (group.opts.groupByKeys ?? false) === groupByKeys && group.opts.groupByFn === groupByFn && keys(group.opts.props) === propsKeys;
  }
  static mergeRequests(requests) {
    const result = {
      ids: [],
      rejects: [],
      resolves: [],
      data: requests[0].data,
      opts: { ...requests[0].opts, props: [] }
    };
    const optsByTypeAndDataId = /* @__PURE__ */ new Map();
    const dataIds = /* @__PURE__ */ new Map();
    let nextDataId = 0;
    for (const request of requests) {
      const {
        id,
        data,
        resolve,
        reject,
        opts: { props, ...opts }
      } = request;
      result.ids.push(id);
      result.rejects.push(reject);
      result.resolves.push(resolve);
      result.data ?? (result.data = data);
      result.opts ?? (result.opts = { ...opts, props: [] });
      for (const prop of props) {
        const clone2 = { ...prop, scopes: [id], data };
        _DataController.createIdsMap(id, clone2);
        let dataId;
        if (_DataController.crossScopeMergableTypes.has(clone2.type)) {
          dataId = -1;
        } else if (dataIds.has(data)) {
          dataId = dataIds.get(data);
        } else {
          dataId = nextDataId++;
          dataIds.set(data, dataId);
        }
        const matchKey = `${clone2.type}-${dataId}-${clone2.groupId}`;
        const matches = optsByTypeAndDataId.get(matchKey);
        const match = matches?.find((existing) => _DataController.deepEqual(existing, clone2));
        if (matches == null) {
          result.opts.props.push(clone2);
          optsByTypeAndDataId.set(matchKey, [clone2]);
          continue;
        } else if (match == null) {
          result.opts.props.push(clone2);
          matches.push(clone2);
          continue;
        }
        if (clone2.scopes != null) {
          match.scopes ?? (match.scopes = []);
          match.scopes.push(...clone2.scopes);
        }
        if ((match.type === "key" || match.type === "value") && clone2.idsMap?.size) {
          match.idsMap ?? (match.idsMap = /* @__PURE__ */ new Map());
          _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);
        }
      }
    }
    return result;
  }
  static mergeIdsMap(fromMap, toMap) {
    for (const [scope, ids] of fromMap) {
      const toMapValue = toMap.get(scope);
      if (toMapValue == null) {
        toMap.set(scope, new Set(ids));
      } else {
        for (const id of ids) {
          toMapValue.add(id);
        }
      }
    }
  }
  static createIdsMap(scope, prop) {
    if (prop.id == null)
      return;
    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());
    if (prop.idsMap.has(scope)) {
      prop.idsMap.get(scope).add(prop.id);
    } else {
      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));
    }
  }
  static deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) {
        return false;
      }
      let i, length;
      if (Array.isArray(a)) {
        length = a.length;
        if (length !== b.length) {
          return false;
        }
        for (i = length - 1; i >= 0; i--) {
          if (!_DataController.deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      const keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) {
        return false;
      }
      for (i = length - 1; i >= 0; i--) {
        const key = keys[i];
        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
};
_DataController.crossScopeMergableTypes = /* @__PURE__ */ new Set(["key", "group-value-processor"]);
// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times
_DataController.skipKeys = /* @__PURE__ */ new Set(["id", "idsMap", "type", "scopes", "data"]);
var DataController = _DataController;

// packages/ag-charts-community/src/chart/factory/axisRegistry.ts
var AxisRegistry = class {
  constructor() {
    this.axesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(axisType, module) {
    this.axesMap.set(axisType, module.moduleFactory);
    if (module.themeTemplate) {
      this.setThemeTemplate(axisType, module.themeTemplate);
    }
  }
  create(axisType, moduleContext) {
    const axisFactory = this.axesMap.get(axisType);
    if (axisFactory) {
      return axisFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown axis type: ${axisType}`);
  }
  has(axisType) {
    return this.axesMap.has(axisType);
  }
  keys() {
    return this.axesMap.keys();
  }
  setThemeTemplate(axisType, themeTemplate) {
    this.themeTemplates.set(axisType, themeTemplate);
    return this;
  }
  getThemeTemplate(axisType) {
    return this.themeTemplates.get(axisType);
  }
};
var axisRegistry = new AxisRegistry();

// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
var EXPECTED_ENTERPRISE_MODULES = [
  {
    type: "root",
    optionsKey: "animation",
    chartTypes: ["cartesian", "polar", "topology", "standalone"]
  },
  { type: "root", optionsKey: "annotations", chartTypes: ["cartesian"] },
  {
    type: "root",
    optionsKey: "background",
    chartTypes: ["cartesian", "polar", "topology", "standalone"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "foreground",
    chartTypes: ["cartesian", "polar", "topology", "standalone"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "chartToolbar",
    chartTypes: ["cartesian"]
  },
  {
    type: "root",
    optionsKey: "contextMenu",
    chartTypes: ["cartesian", "polar", "topology", "standalone"]
  },
  { type: "root", optionsKey: "statusBar", chartTypes: ["cartesian"], identifier: "status-bar" },
  {
    type: "root",
    optionsKey: "dataSource",
    chartTypes: ["cartesian", "polar", "topology", "standalone"]
  },
  { type: "root", optionsKey: "sync", chartTypes: ["cartesian"] },
  { type: "root", optionsKey: "zoom", chartTypes: ["cartesian", "topology"] },
  { type: "root", optionsKey: "ranges", chartTypes: ["cartesian"] },
  {
    type: "legend",
    optionsKey: "gradientLegend",
    chartTypes: ["cartesian", "polar", "topology", "standalone"],
    identifier: "gradient"
  },
  { type: "root", optionsKey: "navigator", chartTypes: ["cartesian"] },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["cartesian"], identifier: "ordinal-time" },
  { type: "axis-option", optionsKey: "crosshair", chartTypes: ["cartesian"] },
  { type: "axis-option", optionsKey: "bandHighlight", chartTypes: ["cartesian"] },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "box-plot" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "candlestick" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "cone-funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "ohlc" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "heatmap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "waterfall" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "nightingale" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-column" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-marker" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "pyramid" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "linear-gauge" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "radial-gauge" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "sunburst" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "treemap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "chord" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "sankey" },
  { type: "series-option", optionsKey: "errorBar", chartTypes: ["cartesian"], identifier: "error-bars" },
  { type: "context", contextKey: "sharedToolbar", chartTypes: ["cartesian"] }
];
function getEnterpriseSeriesChartTypes(type) {
  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)?.chartTypes;
}
function isEnterpriseCartesian(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "cartesian");
  return type === "cartesian";
}
function isEnterprisePolar(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "polar");
  return type === "polar";
}
function isEnterpriseTopology(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "topology");
  return type === "topology";
}
function isEnterpriseStandalone(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "standalone");
  return type === "standalone";
}

// packages/ag-charts-community/src/chart/factory/legendRegistry.ts
var LegendRegistry = class {
  constructor() {
    this.legendMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {
    this.legendMap.set(legendType, { optionsKey, moduleFactory });
    this.themeTemplates.set(optionsKey, themeTemplate);
  }
  create(legendType, moduleContext) {
    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;
    if (legendFactory) {
      return legendFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown legend type: ${legendType}`);
  }
  getThemeTemplates() {
    return Object.fromEntries(this.themeTemplates);
  }
  getKeys() {
    return Array.from(this.legendMap.entries()).reduce(
      (result, [legendType, record]) => {
        result[legendType] = record.optionsKey;
        return result;
      },
      {}
    );
  }
};
var legendRegistry = new LegendRegistry();

// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var ChartTypes = class extends Map {
  get(seriesType) {
    return super.get(seriesType) ?? "unknown";
  }
  isCartesian(seriesType) {
    return this.get(seriesType) === "cartesian";
  }
  isPolar(seriesType) {
    return this.get(seriesType) === "polar";
  }
  isTopology(seriesType) {
    return this.get(seriesType) === "topology";
  }
  isStandalone(seriesType) {
    return this.get(seriesType) === "standalone";
  }
  get seriesTypes() {
    return Array.from(this.keys());
  }
  get cartesianTypes() {
    return this.seriesTypes.filter((t) => this.isCartesian(t));
  }
  get polarTypes() {
    return this.seriesTypes.filter((t) => this.isPolar(t));
  }
  get topologyTypes() {
    return this.seriesTypes.filter((t) => this.isTopology(t));
  }
  get standaloneTypes() {
    return this.seriesTypes.filter((t) => this.isStandalone(t));
  }
};
var ChartDefaults = class extends Map {
  set(chartType, defaults) {
    return super.set(chartType, mergeDefaults(defaults, this.get(chartType)));
  }
};
var chartTypes3 = new ChartTypes();
var publicChartTypes = new ChartTypes();
var chartDefaults = new ChartDefaults();

// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts
var SeriesRegistry = class {
  constructor() {
    this.seriesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(seriesType, {
    chartTypes: [chartType],
    moduleFactory,
    defaultAxes,
    themeTemplate,
    solo,
    stackable,
    groupable,
    stackedByDefault,
    hidden
  }) {
    this.setThemeTemplate(seriesType, themeTemplate);
    this.seriesMap.set(seriesType, {
      moduleFactory,
      defaultAxes,
      solo,
      stackable,
      groupable,
      stackedByDefault
    });
    chartTypes3.set(seriesType, chartType);
    if (!hidden) {
      publicChartTypes.set(seriesType, chartType);
    }
  }
  create(seriesType, moduleContext) {
    const seriesFactory = this.seriesMap.get(seriesType)?.moduleFactory;
    if (seriesFactory) {
      return seriesFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown series type: ${seriesType}`);
  }
  cloneDefaultAxes(seriesType) {
    const defaultAxes = this.seriesMap.get(seriesType)?.defaultAxes;
    if (defaultAxes == null)
      return null;
    return { axes: deepClone(defaultAxes) };
  }
  setThemeTemplate(seriesType, themeTemplate) {
    const currentTemplate = this.themeTemplates.get(seriesType);
    this.themeTemplates.set(seriesType, mergeDefaults(themeTemplate, currentTemplate));
  }
  getThemeTemplate(seriesType) {
    return this.themeTemplates.get(seriesType);
  }
  isSolo(seriesType) {
    return this.seriesMap.get(seriesType)?.solo ?? false;
  }
  isGroupable(seriesType) {
    return this.seriesMap.get(seriesType)?.groupable ?? false;
  }
  isStackable(seriesType) {
    return this.seriesMap.get(seriesType)?.stackable ?? false;
  }
  isStackedByDefault(seriesType) {
    return this.seriesMap.get(seriesType)?.stackedByDefault ?? false;
  }
};
var seriesRegistry = new SeriesRegistry();

// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager = class _SyncManager {
  constructor(chart) {
    this.chart = chart;
  }
  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    let syncGroup = this.get(groupId);
    if (!syncGroup) {
      syncGroup = { members: /* @__PURE__ */ new Set() };
      _SyncManager.chartsGroups.set(groupId, syncGroup);
    }
    syncGroup.members.add(this.chart);
    return this;
  }
  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    const groupState = this.get(groupId);
    groupState?.members.delete(this.chart);
    delete groupState?.domains?.x?.sources?.[this.chart.id];
    delete groupState?.domains?.y?.sources?.[this.chart.id];
    return this;
  }
  getChart() {
    return this.chart;
  }
  getGroupState(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.get(groupId);
  }
  getGroupMembers(groupId = _SyncManager.DEFAULT_GROUP) {
    const syncGroup = this.get(groupId);
    return syncGroup ? Array.from(syncGroup.members) : [];
  }
  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.getGroupMembers(groupId).filter((chart) => chart !== this.chart);
  }
  getGroupSyncMode(groupId = _SyncManager.DEFAULT_GROUP) {
    if (this.getGroupMembers(groupId).some((c) => c.series.length > 1)) {
      return "multi-series";
    }
    return "single-series";
  }
  get(groupId) {
    return _SyncManager.chartsGroups.get(groupId);
  }
};
_SyncManager.chartsGroups = /* @__PURE__ */ new Map();
_SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
var SyncManager = _SyncManager;

// packages/ag-charts-community/src/chart/keyboard.ts
var Keyboard = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Property
], Keyboard.prototype, "enabled", 2);
__decorateClass([
  Property
], Keyboard.prototype, "tabIndex", 2);

// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
var CartesianAxisPositions = ["top", "right", "bottom", "left"];
function isAxisPosition(position) {
  return typeof position === "string" && CartesianAxisPositions.includes(position);
}
function guessInvalidPositions(axes) {
  const invalidAxes = [];
  const usedPositions = [];
  const guesses = [...CartesianAxisPositions];
  for (const axis of axes) {
    if (axis instanceof CartesianAxis) {
      if (isAxisPosition(axis.position)) {
        usedPositions.push(axis.position);
      } else {
        invalidAxes.push(axis);
      }
    }
  }
  for (const axis of invalidAxes) {
    let nextGuess;
    do {
      nextGuess = guesses.pop();
    } while (nextGuess && usedPositions.includes(nextGuess));
    if (nextGuess == null)
      break;
    axis.position = nextGuess;
  }
}

// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
var MATCHING_KEYS = ["direction", "xKey", "yKey", "sizeKey", "angleKey", "radiusKey", "normalizedTo"];
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
  const generateKey = (type, i, opts) => {
    const result = [type];
    for (const key of MATCHING_KEYS) {
      if (key in i && i[key] != null)
        result.push(`${key}=${i[key]}`);
    }
    if (opts?.seriesGrouping) {
      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);
    }
    return result.join(";");
  };
  const seriesMap = /* @__PURE__ */ new Map();
  let idx = 0;
  for (const s of series) {
    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);
    if (!seriesMap.has(key)) {
      seriesMap.set(key, []);
    }
    seriesMap.get(key)?.push([s, idx++]);
  }
  const optsMap = /* @__PURE__ */ new Map();
  idx = 0;
  for (const o of optSeries) {
    const key = generateKey(o.type, o, o);
    if (!optsMap.has(key)) {
      optsMap.set(key, []);
    }
    optsMap.get(key)?.push([o, idx++]);
  }
  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));
  if (!overlap) {
    return { status: "no-overlap", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };
  }
  const changes = [];
  for (const [key, optsTuples] of optsMap.entries()) {
    for (const [opts, targetIdx] of optsTuples) {
      const seriesArray = seriesMap.get(key);
      if (seriesArray == null || seriesArray.length < 1) {
        changes.push({ opts, targetIdx, idx: targetIdx, status: "add" });
        seriesMap.delete(key);
        continue;
      }
      const [outputSeries, currentIdx] = seriesArray.shift();
      const previousOpts = oldOptsSeries?.[currentIdx] ?? {};
      const diff2 = jsonDiff(previousOpts, opts ?? {});
      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};
      if (groupIndex != null || stackIndex != null) {
        changes.push({
          opts,
          series: outputSeries,
          diff: diff2,
          targetIdx,
          idx: currentIdx,
          status: "series-grouping"
        });
      } else if (diff2) {
        changes.push({
          opts,
          series: outputSeries,
          diff: diff2,
          targetIdx,
          idx: currentIdx,
          status: "update"
        });
      } else {
        changes.push({ opts, series: outputSeries, targetIdx, idx: currentIdx, status: "no-op" });
      }
      if (seriesArray.length === 0) {
        seriesMap.delete(key);
      }
    }
  }
  for (const seriesArray of seriesMap.values()) {
    for (const [outputSeries, currentIdx] of seriesArray) {
      changes.push({ series: outputSeries, idx: currentIdx, targetIdx: -1, status: "remove" });
    }
  }
  return { status: "overlap", changes };
}

// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
  const { series } = input;
  return series?.[0]?.type ?? "line";
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgTopologyChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);
}
function isAgStandaloneChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);
}

// packages/ag-charts-community/src/chart/modulesManager.ts
var ModulesManager = class extends ModuleMap {
  applyOptions(options) {
    for (const m of this.moduleMap.values()) {
      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {
        m.moduleInstance.set(options[m.module.optionsKey]);
      }
    }
  }
  *legends() {
    for (const { module, moduleInstance } of this.moduleMap.values()) {
      if (module.type !== "legend")
        continue;
      yield {
        legendType: module.identifier,
        legend: moduleInstance
      };
    }
  }
};

// packages/ag-charts-community/src/chart/overlay/overlay.ts
import { createElement as createElement10, isArray as isArray11 } from "ag-charts-core";
var DEFAULT_OVERLAY_CLASS = "ag-charts-overlay";
var DEFAULT_OVERLAY_DARK_CLASS = "ag-charts-dark-overlay";
var Overlay = class extends BaseProperties {
  constructor(className, defaultMessageId) {
    super();
    this.className = className;
    this.defaultMessageId = defaultMessageId;
    this.enabled = true;
  }
  getText(localeManager) {
    if (isArray11(this.text)) {
      return this.text.map((s) => s.text).join("");
    }
    return localeManager.t(this.text ?? this.defaultMessageId);
  }
  getElement(callers, animationManager, localeManager, rect) {
    this.content?.remove();
    this.focusBox = rect;
    if (this.renderer) {
      const params = {};
      const htmlContent = callWithContext(callers, this.renderer, params);
      if (htmlContent instanceof HTMLElement) {
        this.content = htmlContent;
      } else {
        const tempDiv = createElement10("div");
        tempDiv.innerHTML = htmlContent;
        const { firstElementChild } = tempDiv;
        if (firstElementChild instanceof HTMLElement && tempDiv.childElementCount === 1) {
          this.content = firstElementChild;
        } else {
          this.content = tempDiv;
        }
      }
    } else {
      const content = createElement10("div", {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxSizing: "border-box",
        height: "100%",
        margin: "8px",
        fontFamily: "var(--ag-charts-font-family)",
        fontSize: "var(--ag-charts-font-size)",
        fontWeight: "var(--ag-charts-font-weight)"
      });
      if (isArray11(this.text)) {
        const container = createElement10("div");
        for (const segment of this.text) {
          const el = createElement10("span", {
            color: segment.color,
            fontSize: `${segment.fontSize}px`,
            fontFamily: segment.fontFamily ?? "inherit",
            fontWeight: String(segment.fontWeight),
            fontStyle: segment.fontStyle
          });
          el.innerText = segment.text;
          container.appendChild(el);
        }
        content.appendChild(container);
      } else {
        content.innerText = this.getText(localeManager);
      }
      this.content = content;
      animationManager?.animate({
        from: 0,
        to: 1,
        id: "overlay",
        phase: "add",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          content.style.opacity = "1";
        }
      });
    }
    return this.content;
  }
  removeElement(cleanup = () => this.content?.remove(), animationManager) {
    if (!this.content)
      return;
    if (animationManager) {
      const { content } = this;
      animationManager.animate({
        from: 1,
        to: 0,
        phase: "remove",
        id: "overlay",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          cleanup?.();
        }
      });
    } else {
      cleanup?.();
    }
    this.content = void 0;
    this.focusBox = void 0;
  }
};
__decorateClass([
  Property
], Overlay.prototype, "enabled", 2);
__decorateClass([
  Property
], Overlay.prototype, "text", 2);
__decorateClass([
  Property
], Overlay.prototype, "renderer", 2);

// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var ChartOverlays = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.darkTheme = false;
    this.loading = new Overlay("ag-charts-loading-overlay", "overlayLoadingData");
    this.noData = new Overlay("ag-charts-no-data-overlay", "overlayNoData");
    this.noVisibleSeries = new Overlay("ag-charts-no-visible-series", "overlayNoVisibleSeries");
    this.unsupportedBrowser = new Overlay("ag-charts-unsupported-browser", "overlayUnsupportedBrowser");
  }
  getFocusInfo(localeManager) {
    for (const overlay of [this.loading, this.noData, this.noVisibleSeries, this.unsupportedBrowser]) {
      if (overlay.focusBox !== void 0) {
        return { text: overlay.getText(localeManager), rect: overlay.focusBox };
      }
    }
    return void 0;
  }
  destroy() {
    this.loading.removeElement();
    this.noData.removeElement();
    this.noVisibleSeries.removeElement();
    this.unsupportedBrowser.removeElement();
  }
};
__decorateClass([
  Property
], ChartOverlays.prototype, "darkTheme", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "loading", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "noData", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "noVisibleSeries", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "unsupportedBrowser", 2);

// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts
import { createElement as createElement11 } from "ag-charts-core";
function getLoadingSpinner(text, defaultDuration) {
  const { animationDuration } = PHASE_METADATA["add"];
  const duration = animationDuration * defaultDuration;
  const container = createElement11("div", `${DEFAULT_OVERLAY_CLASS}--loading`, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    height: "100%",
    boxSizing: "border-box",
    font: "13px Verdana, sans-serif",
    // FONT_SIZE.MEDIUM
    userSelect: "none",
    animation: `ag-charts-loading ${duration}ms linear 50ms both`
  });
  const matrix = createElement11("span", {
    width: "45px",
    height: "40px",
    backgroundImage: [
      "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
    ].join(""),
    backgroundSize: "10px 400%",
    backgroundRepeat: "no-repeat",
    animation: "ag-charts-loading-matrix 1s infinite linear"
  });
  const label = createElement11("p", { marginTop: "1em" });
  label.innerText = text;
  const background = createElement11("div", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {
    position: "absolute",
    inset: "0",
    opacity: "0.5",
    zIndex: "-1"
  });
  const animationStyles = createElement11("style");
  animationStyles.innerText = [
    "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
    "@keyframes ag-charts-loading-matrix {",
    "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
    "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
    "}"
  ].join(" ");
  container.replaceChildren(animationStyles, matrix, label, background);
  return container;
}

// packages/ag-charts-community/src/chart/series/series.ts
import {
  CleanupRegistry as CleanupRegistry15,
  EventEmitter as EventEmitter7,
  Logger as Logger30,
  createId as createId7,
  isEmptyObject
} from "ag-charts-core";

// packages/ag-charts-community/src/chart/series/seriesProperties.ts
import {
  Logger as Logger29
} from "ag-charts-core";
var SeriesItemHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "lineDash", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
var HighlightProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.range = "tooltip";
    this.bringToFront = false;
    this.highlightedItem = {};
    this.unhighlightedItem = {};
    this.highlightedSeries = {};
    this.unhighlightedSeries = {};
  }
  getItemHighlightStyle(highlightState) {
    switch (highlightState) {
      case 1 /* Item */:
        return this.highlightedItem;
      case 4 /* OtherItem */:
        return this.unhighlightedItem;
      case 2 /* Series */:
        return this.highlightedSeries;
      case 3 /* OtherSeries */:
        return this.unhighlightedSeries;
    }
  }
  getSeriesHighlightStyle(highlightState) {
    switch (highlightState) {
      case 1 /* Item */:
      case 4 /* OtherItem */:
      case 2 /* Series */:
        return this.highlightedSeries;
      case 3 /* OtherSeries */:
        return this.unhighlightedSeries;
    }
  }
  getStyle(highlightState) {
    return mergeDefaults(
      this.getItemHighlightStyle(highlightState),
      this.getSeriesHighlightStyle(highlightState)
    );
  }
};
__decorateClass([
  Property
], HighlightProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "range", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "bringToFront", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "highlightedItem", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "unhighlightedItem", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "highlightedSeries", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "unhighlightedSeries", 2);
var SeriesHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "dimOpacity", 2);
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "enabled", 2);
var TextHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Property
], TextHighlightStyle.prototype, "color", 2);
var FillGradientDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "gradient";
    this.colorStops = [];
    this.bounds = "item";
    this.gradient = "linear";
    this.rotation = 0;
    this.reverse = false;
  }
};
__decorateClass([
  Property
], FillGradientDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "colorStops", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "bounds", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "gradient", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "reverse", 2);
var FillPatternDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "pattern";
    this.colorStops = [];
    this.bounds = "item";
    this.gradient = "linear";
    this.rotation = 0;
    this.scale = 1;
    this.reverse = false;
    this.pattern = "forward-slanted-lines";
    this.width = 26;
    this.height = 26;
    this.padding = 6;
    this.fill = "black";
    this.fillOpacity = 1;
    this.backgroundFill = "white";
    this.backgroundFillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
  }
};
__decorateClass([
  Property
], FillPatternDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "colorStops", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "bounds", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "gradient", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "scale", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "reverse", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "path", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "pattern", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "width", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "height", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "padding", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "fill", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "backgroundFill", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "stroke", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "strokeWidth", 2);
var FillImageDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "image";
    this.url = "";
    this.rotation = 0;
    this.scale = 1;
    this.backgroundFill = "black";
    this.backgroundFillOpacity = 1;
    this.repeat = "no-repeat";
    this.fit = "contain";
  }
};
__decorateClass([
  Property
], FillImageDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "url", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "scale", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "backgroundFill", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "repeat", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "fit", 2);
var HighlightStyle = class extends BaseProperties {
  constructor(deprecated = true) {
    super();
    this.deprecated = deprecated;
    this.item = new SeriesItemHighlightStyle();
    this.series = new SeriesHighlightStyle();
    this.text = new TextHighlightStyle();
  }
  set(properties) {
    if (this.deprecated) {
      Logger29.warnOnce("highlightStyle is deprecated, use highlight instead.");
    }
    return super.set(properties);
  }
};
__decorateClass([
  Property
], HighlightStyle.prototype, "item", 2);
__decorateClass([
  Property
], HighlightStyle.prototype, "series", 2);
__decorateClass([
  Property
], HighlightStyle.prototype, "text", 2);
var SeriesProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.focusPriority = Infinity;
    this.showInLegend = true;
    this.cursor = "default";
    this.nodeClickRange = "exact";
    this.highlight = new HighlightProperties();
    this.highlightStyle = new HighlightStyle();
  }
  handleUnknownProperties(unknownKeys, properties) {
    if ("context" in properties) {
      this.context = properties.context;
      unknownKeys.delete("context");
    }
  }
};
__decorateClass([
  Property
], SeriesProperties.prototype, "id", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "visible", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "focusPriority", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "showInLegend", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "cursor", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "nodeClickRange", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "highlight", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "highlightStyle", 2);

// packages/ag-charts-community/src/chart/series/shapeUtil.ts
function getShapeFill(fill, defaultGradient, defaultPattern, defaultImage) {
  if (isGradientFill(fill)) {
    return {
      type: "gradient",
      gradient: fill.gradient ?? defaultGradient.gradient,
      colorStops: fill.colorStops ?? defaultGradient.colorStops,
      bounds: fill.bounds ?? defaultGradient.bounds,
      rotation: fill.rotation ?? defaultGradient.rotation,
      reverse: fill.reverse ?? defaultGradient.reverse
    };
  }
  if (isPatternFill(fill)) {
    const pattern = fill.pattern ?? defaultPattern.pattern;
    let strokeWidth = fill.strokeWidth;
    if (pattern === "backward-slanted-lines" || pattern === "forward-slanted-lines" || pattern === "horizontal-lines" || pattern === "vertical-lines") {
      strokeWidth ?? (strokeWidth = defaultPattern.strokeWidth);
    } else {
      strokeWidth ?? (strokeWidth = 0);
    }
    const width2 = fill.width ?? fill.height ?? defaultPattern.width;
    const height2 = fill.height ?? fill.width ?? defaultPattern.height;
    return {
      type: "pattern",
      pattern,
      width: width2,
      height: height2,
      path: fill.path,
      padding: fill.padding ?? defaultPattern.padding,
      fill: fill.fill ?? defaultPattern.fill,
      fillOpacity: fill.fillOpacity ?? defaultPattern.fillOpacity,
      backgroundFill: fill.backgroundFill ?? defaultPattern.backgroundFill,
      backgroundFillOpacity: fill.backgroundFillOpacity ?? defaultPattern.backgroundFillOpacity,
      stroke: fill.stroke ?? defaultPattern.stroke,
      strokeOpacity: fill.strokeOpacity ?? defaultPattern.strokeOpacity,
      strokeWidth,
      rotation: fill.rotation ?? defaultPattern.rotation,
      scale: fill.scale ?? defaultPattern.scale
    };
  }
  if (isImageFill(fill)) {
    return {
      type: "image",
      url: fill.url,
      width: fill.width,
      height: fill.height,
      backgroundFill: fill.backgroundFill ?? defaultImage.backgroundFill,
      backgroundFillOpacity: fill.backgroundFillOpacity ?? defaultImage.backgroundFillOpacity,
      rotation: fill.rotation ?? defaultImage.rotation,
      repeat: fill.repeat ?? defaultImage.repeat,
      fit: fill.fit ?? defaultImage.fit
    };
  }
  return fill;
}
function getShapeStyle(style, defaultGradient, defaultPattern, defaultImage) {
  if (!isGradientFill(style?.fill) && !isPatternFill(style?.fill) && !isImageFill(style?.fill))
    return style;
  return {
    ...style,
    fill: getShapeFill(style.fill, defaultGradient, defaultPattern, defaultImage)
  };
}
function applyShapeFillBBox(shape, fill, fillBBox, fillParams) {
  if (fillBBox == null || !isGradientFill(fill) || fill.bounds == null || fill.bounds === "item") {
    shape.fillBBox = void 0;
  } else {
    shape.fillBBox = fillBBox[fill.bounds];
  }
  shape.fillParams = fillParams;
}
function applyShapeStyle(shape, style, fillBBox, fillParams) {
  const opacity = style?.opacity ?? 1;
  shape.fill = style?.fill;
  applyShapeFillBBox(shape, shape.fill, fillBBox, fillParams);
  shape.fillOpacity = (style?.fillOpacity ?? 1) * opacity;
  shape.stroke = style?.stroke;
  shape.strokeOpacity = (style?.strokeOpacity ?? 1) * opacity;
  shape.strokeWidth = style?.strokeWidth ?? 0;
  shape.lineDash = style?.lineDash;
  shape.lineDashOffset = style?.lineDashOffset ?? 0;
}

// packages/ag-charts-community/src/chart/series/series.ts
var CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;
var CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;
var SeriesNodeEvent = class {
  constructor(type, event, nodeDatum, series) {
    this.type = type;
    this.event = event;
    this.defaultPrevented = false;
    this.datum = nodeDatum.datum;
    this.seriesId = series.id;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
};
var SeriesGroupingChangedEvent = class {
  constructor(series, seriesGrouping) {
    this.series = series;
    this.seriesGrouping = seriesGrouping;
    this.type = "groupingChanged";
  }
};
function propertyAxisDirection(property) {
  switch (property) {
    case "x":
      return "x" /* X */;
    case "y":
      return "y" /* Y */;
    case "angle":
      return "angle" /* Angle */;
    case "radius":
      return "radius" /* Radius */;
  }
}
function axisDirectionProperty(direction) {
  switch (direction) {
    case "x" /* X */:
      return "x";
    case "y" /* Y */:
      return "y";
    case "angle" /* Angle */:
      return "angle";
    case "radius" /* Radius */:
      return "radius";
  }
}
var Series = class extends Observable {
  constructor(seriesOpts) {
    super();
    this.cleanup = new CleanupRegistry15();
    this.usesPlacedLabels = false;
    this.hasChangesOnHighlight = false;
    this.seriesGrouping = void 0;
    this.NodeEvent = SeriesNodeEvent;
    this.internalId = createId7(this);
    // The group node that contains the series rendering in its default (non-highlighted) state.
    this.contentGroup = new TranslatableGroup({
      name: `${this.internalId}-content`,
      zIndex: 1 /* ANY_CONTENT */
    });
    // The group node that contains all highlighted series items. This is a performance optimisation
    // for large-scale data-sets, where the only thing that routinely varies is the currently
    // highlighted node.
    this.highlightGroup = new TranslatableGroup({
      name: `${this.internalId}-highlight`,
      zIndex: 1 /* ANY_CONTENT */
    });
    // Error bars etc.
    this.annotationGroup = new TranslatableGroup({
      name: `${this.internalId}-annotation`
    });
    // Lazily initialised labelGroup for label presentation.
    this.labelGroup = new TranslatableGroup({
      name: `${this.internalId}-series-labels`
    });
    this.axes = {};
    this.directions = ["x" /* X */, "y" /* Y */];
    // Flag to determine if we should recalculate node data.
    this.nodeDataRefresh = true;
    this.moduleMap = new ModuleMap();
    this.datumCallbackCache = /* @__PURE__ */ new Map();
    this.connectsToYAxis = false;
    this.declarationOrder = -1;
    this._broughtToFront = false;
    this.events = new EventEmitter7();
    this._pickNodeCache = new LRUCache();
    // Use a wrapper to comply with the @typescript-eslint/unbound-method rule.
    this.fireEventWrapper = (event) => super.fireEvent(event);
    const {
      moduleCtx,
      pickModes,
      propertyKeys = {},
      propertyNames = {},
      canHaveAxes = false,
      usesPlacedLabels = false
    } = seriesOpts;
    this.ctx = moduleCtx;
    this.propertyKeys = propertyKeys;
    this.propertyNames = propertyNames;
    this.canHaveAxes = canHaveAxes;
    this.usesPlacedLabels = usesPlacedLabels;
    this.pickModes = pickModes;
    this.cleanup.register(this.ctx?.eventsHub.on("highlight:change", (event) => this.onChangeHighlight(event)));
  }
  get pickModeAxis() {
    return "main";
  }
  get id() {
    return this.properties?.id ?? this.internalId;
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get focusable() {
    return true;
  }
  get data() {
    return this._data ?? this._chartData;
  }
  set visible(newVisibility) {
    this.properties.visible = newVisibility;
    this.ctx.legendManager.toggleItem(newVisibility, this.id);
    this.ctx.legendManager.update();
    this.visibleMaybeChanged();
  }
  get visible() {
    return this.ctx.legendManager.getSeriesEnabled(this.id) ?? this.properties.visible;
  }
  get hasData() {
    return this.data != null && this.data.length > 0;
  }
  get tooltipEnabled() {
    return this.properties.tooltip?.enabled;
  }
  onDataChange() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
  }
  setOptionsData(input) {
    this._data = input;
    this.onDataChange();
  }
  setChartData(input) {
    this._chartData = input;
    if (this.data === input) {
      this.onDataChange();
    }
  }
  onSeriesGroupingChange(prev, next) {
    const { internalId, type, visible } = this;
    if (prev) {
      this.ctx.seriesStateManager.deregisterSeries(this);
    }
    if (next) {
      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });
    }
    this.fireEvent(new SeriesGroupingChangedEvent(this, next));
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0 };
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    seriesContentNode.appendChild(this.contentGroup);
    seriesNode.appendChild(this.highlightGroup);
    seriesNode.appendChild(this.labelGroup);
    annotationNode?.appendChild(this.annotationGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    seriesContentNode?.removeChild(this.contentGroup);
    seriesNode.removeChild(this.highlightGroup);
    seriesNode.removeChild(this.labelGroup);
    annotationNode?.removeChild(this.annotationGroup);
  }
  setSeriesIndex(index, forceUpdate = false) {
    const bringToFront = this.bringToFront();
    if (!forceUpdate && index === this.declarationOrder && bringToFront === this._broughtToFront)
      return false;
    this.declarationOrder = index;
    this._broughtToFront = bringToFront;
    this.setZIndex(bringToFront ? Number.MAX_VALUE : index);
    this.fireEvent(new SeriesGroupingChangedEvent(this, this.seriesGrouping));
    return true;
  }
  setZIndex(zIndex) {
    this.contentGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */];
    this.highlightGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 1 /* HIGHLIGHT */];
    this.labelGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 2 /* LABEL */];
    this.annotationGroup.zIndex = zIndex;
  }
  renderToOffscreenCanvas() {
    return false;
  }
  addEventListener(type, listener) {
    return super.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    return super.removeEventListener(type, listener);
  }
  hasEventListener(type) {
    return super.hasEventListener(type);
  }
  addChartEventListeners() {
    return;
  }
  updatedDomains() {
  }
  destroy() {
    this.cleanup.flush();
    this.resetDatumCallbackCache();
    this.ctx.seriesStateManager.deregisterSeries(this);
  }
  getPropertyValues(property, properties) {
    const direction = propertyAxisDirection(property);
    const resolvedProperty = direction != null ? axisDirectionProperty(this.resolveKeyDirection(direction)) : property;
    const keys = properties?.[resolvedProperty];
    const values = [];
    if (!keys) {
      return values;
    }
    const addValues = (...items) => {
      for (const value of items) {
        if (Array.isArray(value)) {
          addValues(...value);
        } else if (typeof value === "object") {
          addValues(...Object.values(value));
        } else {
          values.push(value);
        }
      }
    };
    addValues(...keys.map((key) => this.properties[key]));
    return values;
  }
  getKeys(direction) {
    return this.getPropertyValues(axisDirectionProperty(direction), this.propertyKeys);
  }
  getKeyProperties(direction) {
    return this.propertyKeys[this.resolveKeyDirection(direction)] ?? [];
  }
  getNames(direction) {
    return this.getPropertyValues(axisDirectionProperty(direction), this.propertyNames);
  }
  getFormatterContext(property) {
    const { id: seriesId } = this;
    const keys = this.getPropertyValues(property, this.propertyKeys);
    const names = this.getPropertyValues(property, this.propertyNames);
    const out = [];
    for (let idx = 0; idx < keys.length; idx++) {
      out.push({ seriesId, key: keys[idx], name: names[idx] });
    }
    return out;
  }
  resolveKeyDirection(direction) {
    return direction;
  }
  // The union of the series domain ('community') and series-option domains ('enterprise').
  getDomain(direction) {
    const seriesDomain = this.getSeriesDomain(direction);
    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction)).flat();
    return moduleDomains.length !== 0 ? seriesDomain.concat(moduleDomains) : seriesDomain;
  }
  getRange(direction, visibleRange) {
    return this.getSeriesRange(direction, visibleRange);
  }
  getVisibleItems(_xVisibleRange, _yVisibleRange, _minVisibleItems) {
    return Infinity;
  }
  // Indicate that something external changed and we should recalculate nodeData.
  markNodeDataDirty() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    this.visibleMaybeChanged();
  }
  visibleMaybeChanged() {
    this.ctx.seriesStateManager.updateSeries(this);
  }
  getOpacity() {
    const defaultOpacity = 1;
    if (!this.properties.highlight) {
      return defaultOpacity;
    }
    const { opacity = defaultOpacity } = this.getHighlightStyle();
    return opacity;
  }
  getHighlightState(datum, isHighlight, datumIndex, legendItemValues) {
    if (isHighlight) {
      return 1 /* Item */;
    }
    if (datum?.series == null) {
      return 0 /* None */;
    }
    if (this.isSeriesHighlighted(datum, legendItemValues)) {
      const itemHighlighted = this.isItemHighlighted(datum, datumIndex);
      if (itemHighlighted == null) {
        return 2 /* Series */;
      }
      if (itemHighlighted) {
        return 2 /* Series */;
      }
      return 4 /* OtherItem */;
    }
    return 3 /* OtherSeries */;
  }
  getHighlightStateString(datum, isHighlight, datumIndex, legendItemValues) {
    const state = this.getHighlightState(datum, isHighlight, datumIndex, legendItemValues);
    switch (state) {
      case 1 /* Item */:
        return "highlighted-item";
      case 4 /* OtherItem */:
        return "unhighlighted-item";
      case 2 /* Series */:
        return "highlighted-series";
      case 3 /* OtherSeries */:
        return "unhighlighted-series";
      case 0 /* None */:
      default:
        return "none";
    }
  }
  onChangeHighlight(event) {
    const previousHighlightedDatum = event.previousHighlight;
    const currentHighlightedDatum = event.currentHighlight;
    const currentHighlightState = this.getHighlightState(currentHighlightedDatum);
    const previousHighlightState = this.getHighlightState(previousHighlightedDatum);
    this.setSeriesIndex(this.declarationOrder);
    if (currentHighlightState === previousHighlightState) {
      this.hasChangesOnHighlight = false;
      return;
    }
    const { highlightedSeries, unhighlightedItem, unhighlightedSeries } = this.properties.highlight;
    const hasItemStylers = this.hasItemStylers();
    this.hasChangesOnHighlight = hasItemStylers || !isEmptyObject(highlightedSeries) || !isEmptyObject(unhighlightedItem) || !isEmptyObject(unhighlightedSeries);
  }
  bringToFront() {
    return this.properties.highlight.bringToFront && this.isSeriesHighlighted(this.ctx.highlightManager.getActiveHighlight());
  }
  isSeriesHighlighted(highlightedDatum, _legendItemValues) {
    return highlightedDatum?.series === this;
  }
  isItemHighlighted(highlightedDatum, datumIndex) {
    if (highlightedDatum?.datumIndex == null || datumIndex == null)
      return;
    return highlightedDatum.datumIndex === datumIndex;
  }
  getHighlightStyle(isHighlight, datumIndex, legendItemValues) {
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const highlightState = this.getHighlightState(highlightedDatum, isHighlight, datumIndex, legendItemValues);
    return this.properties.highlight.getStyle(highlightState);
  }
  getModuleTooltipParams() {
    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});
  }
  pickNodes(point, intent, exactMatchOnly = false) {
    const { pickModes, pickModeAxis, visible, contentGroup } = this;
    if (!visible || !contentGroup.visible)
      return;
    if (intent === "highlight" && !this.properties.highlight.enabled)
      return;
    if (intent === "highlight-tooltip" && !this.properties.highlight.enabled)
      return;
    let maxDistance = Infinity;
    if (intent === "tooltip" || intent === "highlight-tooltip") {
      const { tooltip } = this.properties;
      maxDistance = typeof tooltip.range === "number" ? tooltip.range : Infinity;
      exactMatchOnly || (exactMatchOnly = tooltip.range === "exact");
    } else if (intent === "event" || intent === "context-menu") {
      const { nodeClickRange } = this.properties;
      maxDistance = typeof nodeClickRange === "number" ? nodeClickRange : Infinity;
      exactMatchOnly || (exactMatchOnly = nodeClickRange === "exact");
    }
    const selectedPickModes = pickModes.filter(
      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */
    );
    const { x, y } = point;
    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });
    if (this._pickNodeCache.has(key)) {
      return this._pickNodeCache.get(key);
    }
    for (const pickMode of selectedPickModes) {
      let result;
      switch (pickMode) {
        case 0 /* EXACT_SHAPE_MATCH */: {
          const exact = this.pickNodesExactShape(point);
          result = exact.length === 0 ? void 0 : { datums: exact, distance: 0 };
          break;
        }
        case 1 /* NEAREST_NODE */: {
          const closest = this.pickNodeClosestDatum(point);
          const exact = closest?.distance === 0 ? this.pickNodesExactShape(point) : void 0;
          if (exact != null && exact.length !== 0) {
            result = { datums: exact, distance: 0 };
          } else if (closest) {
            result = { datums: [closest.datum], distance: closest.distance };
          } else {
            result = void 0;
          }
          break;
        }
        case 2 /* AXIS_ALIGNED */: {
          const closest = pickModeAxis != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === "main-category") : void 0;
          result = closest != null ? { datums: [closest.datum], distance: closest.distance } : void 0;
          break;
        }
      }
      if (result && result.distance <= maxDistance) {
        return this._pickNodeCache.set(key, { pickMode, datums: result.datums, distance: result.distance });
      }
    }
    return this._pickNodeCache.set(key, void 0);
  }
  pickNodesExactShape(point) {
    const datums = [];
    for (const node of this.contentGroup.pickNodes(point.x, point.y)) {
      const datum = node.closestDatum();
      if (datum != null && datum.missing !== true) {
        datums.push(datum);
      }
    }
    return datums;
  }
  pickNodeClosestDatum(_point) {
    throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
  }
  pickNodeNearestDistantObject(point, items) {
    const match = nearestSquared(point.x, point.y, items);
    const datum = match.nearest?.closestDatum();
    if (datum != null && datum.missing !== true) {
      return { datum, distance: Math.sqrt(match.distanceSquared) };
    }
  }
  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
    throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
  }
  getLabelData() {
    return [];
  }
  updatePlacedLabelData(_labels) {
    return;
  }
  fireEvent(event) {
    callWithContext([this.properties, this.ctx.chartService], this.fireEventWrapper, event);
  }
  fireNodeClickEvent(event, datum) {
    const clickEvent = new this.NodeEvent("seriesNodeClick", event, datum, this);
    this.fireEvent(clickEvent);
    return !clickEvent.defaultPrevented;
  }
  fireNodeDoubleClickEvent(event, datum) {
    const clickEvent = new this.NodeEvent("seriesNodeDoubleClick", event, datum, this);
    this.fireEvent(clickEvent);
    return !clickEvent.defaultPrevented;
  }
  createNodeContextMenuActionEvent(event, datum) {
    return new this.NodeEvent("nodeContextMenuAction", event, datum, this);
  }
  onLegendInitialState(legendType, initialState) {
    const { visible = true, itemId, legendItemName } = initialState ?? {};
    this.toggleSeriesItem(visible, legendType, itemId, legendItemName);
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendType } = event;
    const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
    const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
      this.toggleSeriesItem(enabled, legendType, itemId, legendItemName, event);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems, legendType } = event;
    const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
    const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
      this.toggleSeriesItem(true, legendType, itemId, legendItemName, event);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(true, legendType, void 0, legendItemName);
    } else {
      this.toggleSeriesItem(false, legendType, void 0, legendItemName);
    }
  }
  toggleSeriesItem(enabled, legendType, itemId, legendItemName, legendEvent) {
    const seriesId = this.id;
    if (enabled || legendType !== "category") {
      this.visible = enabled;
    }
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    const event = {
      type: "seriesVisibilityChange",
      seriesId,
      itemId,
      legendItemName: legendEvent?.legendItemName ?? legendItemName,
      visible: enabled
    };
    this.fireEvent(event);
    this.ctx.legendManager.toggleItem(enabled, seriesId, itemId, legendItemName);
  }
  isEnabled() {
    return this.visible;
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    return { ...this.ctx, series: this };
  }
  getAxisValueText(axis, source, value, datum, key, legendItemName) {
    const { id: seriesId, properties } = this;
    return axis.formatDatum(properties, value, source, seriesId, legendItemName, datum, key);
  }
  getLabelText(value, datum, key, property, domain, label, baseParams) {
    if (value == null)
      return "";
    const { axes, canHaveAxes, ctx, id: seriesId, properties } = this;
    const source = "series-label";
    const legendItemName = "legendItemName" in properties ? properties.legendItemName : void 0;
    const params = {
      seriesId: this.id,
      ...baseParams
    };
    const direction = canHaveAxes ? propertyAxisDirection(property) : void 0;
    const axis = direction != null ? axes[this.resolveKeyDirection(direction)] : void 0;
    if (axis != null) {
      return axis.formatDatum(
        properties,
        value,
        source,
        seriesId,
        legendItemName,
        datum,
        key,
        domain,
        label,
        params
      );
    }
    const { formatManager } = ctx;
    const formatInContext = this.callWithContext.bind(this);
    const format = (formatParams) => label.formatValue(formatInContext, formatParams.type, formatParams.value, params) ?? formatManager.format(formatInContext, formatParams) ?? String(value);
    const boundSeries = this.getFormatterContext(property);
    switch (property) {
      case "y":
      case "color":
      case "size": {
        const fractionDigits = void 0;
        return format({
          type: "number",
          value,
          datum,
          seriesId,
          legendItemName,
          key,
          source,
          property,
          domain,
          boundSeries,
          fractionDigits
        });
      }
      case "x":
      case "radius":
      case "angle":
      case "label":
      case "secondaryLabel":
      case "calloutLabel":
      case "sectorLabel":
      case "legendItem":
        return format({
          type: "category",
          value,
          datum,
          seriesId,
          legendItemName,
          key,
          source,
          property,
          domain,
          boundSeries
        });
    }
  }
  getMarkerStyle(marker, { datumIndex, datum, point }, params, isHighlight = false, defaultOverrideStyle = { size: point?.size ?? marker.size ?? 0 }, inheritedStyle, checkForHighlight = true) {
    const { itemStyler, fillGradientDefaults, fillPatternDefaults, fillImageDefaults } = marker;
    const highlightStyle = checkForHighlight ? this.getHighlightStyle(isHighlight, datumIndex) : void 0;
    const baseStyle = mergeDefaults(highlightStyle, defaultOverrideStyle, marker.getStyle(), inheritedStyle);
    let markerStyle = getShapeStyle(baseStyle, fillGradientDefaults, fillPatternDefaults, fillImageDefaults);
    if (itemStyler && params) {
      const highlight5 = this.ctx.highlightManager?.getActiveHighlight();
      const highlightState = this.getHighlightStateString(highlight5, isHighlight, datumIndex);
      const style = this.cachedCallWithContext(itemStyler, {
        seriesId: this.id,
        ...markerStyle,
        ...params,
        highlighted: isHighlight,
        highlightState,
        datum
      });
      markerStyle = getShapeStyle(
        mergeDefaults(style, markerStyle),
        fillGradientDefaults,
        fillPatternDefaults,
        fillImageDefaults
      );
    }
    return markerStyle;
  }
  applyMarkerStyle(style, markerNode, point, fillBBox, { applyTranslation = true, selected = true } = {}) {
    const { shape, size = 0 } = style;
    const visible = this.visible && size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
    applyShapeStyle(markerNode, style, fillBBox);
    if (applyTranslation) {
      markerNode.setProperties({
        visible,
        shape,
        size,
        x: point?.x,
        y: point?.y,
        scalingCenterX: point?.x,
        scalingCenterY: point?.y
      });
    } else {
      markerNode.setProperties({ visible, shape, size });
    }
    if (!selected) {
      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;
      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;
    }
    if (typeof shape === "function" && !markerNode.dirtyPath) {
      markerNode.path.clear(true);
      markerNode.updatePath();
      markerNode.checkPathDirty();
      const bb = markerNode.getBBox();
      if (point != null && bb.isFinite()) {
        const center2 = bb.computeCenter();
        const [dx, dy] = ["x", "y"].map(
          (key) => (style.strokeWidth ?? 0) + Math.abs(center2[key] - point[key])
        );
        point.focusSize = Math.max(bb.width + dx, bb.height + dy);
      }
    }
  }
  get nodeDataDependencies() {
    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };
  }
  checkResize(newSeriesRect) {
    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };
    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
      this.markNodeDataDirty();
    }
    return resize;
  }
  pickFocus(_opts) {
    return void 0;
  }
  resetDatumCallbackCache() {
    this.datumCallbackCache.clear();
  }
  cachedDatumCallback(id, fn) {
    const { datumCallbackCache } = this;
    const existing = datumCallbackCache.get(id);
    if (existing != null)
      return existing;
    try {
      const value = fn();
      datumCallbackCache.set(id, value);
      return value;
    } catch (error) {
      Logger30.error(String(error));
    }
  }
  cachedCallWithContext(fn, ...params) {
    return this.ctx.callbackCache.call([this.properties, this.ctx.chartService], fn, ...params);
  }
  callWithContext(fn, ...params) {
    return callWithContext([this.properties, this.ctx.chartService], fn, ...params);
  }
  formatTooltipWithContext(tooltip, content, params) {
    return tooltip.formatTooltip([this.properties, this.ctx.chartService], content, params);
  }
  // @todo(AG-13777) - Remove this function (see CartesianSeries.ts)
  minTimeInterval() {
    return;
  }
};
__decorateClass([
  ActionOnSet({
    changeValue: function(newVal, oldVal) {
      this.onSeriesGroupingChange(oldVal, newVal);
    }
  })
], Series.prototype, "seriesGrouping", 2);

// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
import { clamp as clamp15, createId as createId8 } from "ag-charts-core";

// packages/ag-charts-community/src/dom/focusIndicator.ts
import { createElement as createElement12, createSvgElement as createSvgElement13, getWindow as getWindow16 } from "ag-charts-core";
var FocusIndicator = class {
  constructor(swapChain) {
    this.swapChain = swapChain;
    this.hasBeenActivated = false;
    this.div = createElement12("div");
    this.svg = createSvgElement13("svg");
    this.outerPath = createSvgElement13("path");
    this.innerPath = createSvgElement13("path");
    this.svg.append(this.outerPath);
    this.svg.append(this.innerPath);
    this.outerPath.classList.add("ag-charts-focus-svg-outer-path");
    this.innerPath.classList.add("ag-charts-focus-svg-inner-path");
    this.element = createElement12("div", "ag-charts-focus-indicator");
    this.element.ariaHidden = "true";
    this.element.append(this.svg);
    this.swapChain.addListener("swap", (parent) => this.onSwap(parent));
  }
  clear() {
  }
  update(focus, rect, clip) {
    if (rect == null)
      return;
    if (focus instanceof Path) {
      const transform = (localX, localY) => {
        let { x, y } = Transformable.toCanvasPoint(focus, localX, localY);
        x -= rect.x ?? 0;
        y -= rect.y ?? 0;
        return { x, y };
      };
      const d = focus.svgPathData(transform);
      this.outerPath.setAttribute("d", d);
      this.innerPath.setAttribute("d", d);
      this.show(this.svg);
    } else {
      let bbox;
      if (clip) {
        const x0 = Math.max(focus.x - rect.x, 0);
        const y0 = Math.max(focus.y - rect.y, 0);
        const x1 = Math.min(focus.x + focus.width - rect.x, rect.width);
        const y1 = Math.min(focus.y + focus.height - rect.y, rect.height);
        bbox = new BBox(x0, y0, x1 - x0, y1 - y0);
      } else {
        bbox = new BBox(focus.x - rect.x, focus.y - rect.y, focus.width, focus.height);
      }
      setElementBBox(this.div, bbox);
      this.show(this.div);
    }
  }
  onSwap(newParent) {
    if (newParent === this.element.parentElement)
      return;
    this.element.remove();
    newParent.appendChild(this.element);
    this.overrideFocusVisible(this.focusVisible);
  }
  show(child) {
    this.hasBeenActivated = true;
    this.element.innerHTML = "";
    this.element.append(child);
  }
  overrideFocusVisible(focusVisible) {
    this.focusVisible = focusVisible;
    const opacity = { true: "1", false: "0", undefined: "" };
    const parent = this.element.parentElement;
    parent?.style.setProperty("opacity", opacity[`${focusVisible}`]);
  }
  // Get the `:focus-visible` CSS state.
  isFocusVisible(force = false) {
    if (!force && !this.hasBeenActivated)
      return false;
    const parent = this.element.parentElement;
    return parent != null && getWindow16().getComputedStyle(parent).opacity === "1";
  }
};

// packages/ag-charts-community/src/dom/focusSwapChain.ts
import {
  createElement as createElement13,
  createElementId,
  setAttribute as setAttribute11,
  setAttributes,
  setElementStyle as setElementStyle4
} from "ag-charts-core";
var FocusSwapChain = class {
  constructor(label1, label2, announcerRole, initialAltText) {
    this.label1 = label1;
    this.label2 = label2;
    this.hasFocus = false;
    this.skipDispatch = false;
    this.listeners = {
      blur: [],
      focus: [],
      swap: []
    };
    this.onBlur = (e) => {
      setElementStyle4(e.target, "pointer-events", void 0);
      return !this.skipDispatch && this.dispatch("blur", e);
    };
    this.onFocus = (e) => {
      setElementStyle4(e.target, "pointer-events", "auto");
      return !this.skipDispatch && this.dispatch("focus", e);
    };
    setAttribute11(this.label1, "id", createElementId());
    setAttribute11(this.label2, "id", createElementId());
    setElementStyle4(this.label1, "display", "none");
    setElementStyle4(this.label2, "display", "none");
    this.label1.textContent = initialAltText;
    this.label2.textContent = initialAltText;
    this.activeAnnouncer = this.createAnnouncer(announcerRole);
    this.inactiveAnnouncer = this.createAnnouncer(announcerRole);
    setAttribute11(this.activeAnnouncer, "tabindex", 0);
    this.label2.insertAdjacentElement("afterend", this.activeAnnouncer);
    this.label2.insertAdjacentElement("afterend", this.inactiveAnnouncer);
    this.swap(initialAltText);
  }
  createAnnouncer(role) {
    const announcer = createElement13("div");
    announcer.role = role;
    announcer.className = "ag-charts-swapchain";
    announcer.addEventListener("blur", this.onBlur);
    announcer.addEventListener("focus", this.onFocus);
    return announcer;
  }
  destroy() {
    for (const announcer of [this.activeAnnouncer, this.inactiveAnnouncer]) {
      announcer.removeEventListener("blur", this.onBlur);
      announcer.removeEventListener("focus", this.onFocus);
      announcer.remove();
    }
  }
  focus(opts) {
    this.focusOptions = opts;
    this.activeAnnouncer.focus(opts);
    this.focusOptions = void 0;
  }
  update(newLabel) {
    this.skipDispatch = true;
    this.swap(newLabel);
    if (this.hasFocus) {
      this.activeAnnouncer.focus(this.focusOptions);
    }
    this.skipDispatch = false;
  }
  addListener(type, handler) {
    this.listeners[type].push(handler);
    if (type === "swap") {
      const swapHandler = handler;
      swapHandler(this.activeAnnouncer);
    }
  }
  dispatch(type, param) {
    if (type === "focus")
      this.hasFocus = true;
    else if (type === "blur")
      this.hasFocus = false;
    this.listeners[type].forEach((fn) => fn(param));
  }
  swap(newLabel) {
    const userTabIndex = this.activeAnnouncer.tabIndex;
    this.label2.textContent = newLabel;
    [this.inactiveAnnouncer, this.activeAnnouncer] = [this.activeAnnouncer, this.inactiveAnnouncer];
    [this.label1, this.label2] = [this.label2, this.label1];
    setAttributes(this.inactiveAnnouncer, {
      "aria-labelledby": this.label1.id,
      "aria-hidden": true,
      tabindex: void 0
    });
    setAttributes(this.activeAnnouncer, {
      "aria-labelledby": this.label1.id,
      "aria-hidden": false,
      tabindex: userTabIndex
    });
    this.dispatch("swap", this.activeAnnouncer);
  }
};

// packages/ag-charts-community/src/chart/interaction/keyBindings.ts
import { entries as entries4 } from "ag-charts-core";
var KEY_BINDINGS = {
  arrowdown: { bindings: [{ code: "ArrowDown" }] },
  arrowleft: { bindings: [{ code: "ArrowLeft" }] },
  arrowright: { bindings: [{ code: "ArrowRight" }] },
  arrowup: { bindings: [{ code: "ArrowUp" }] },
  delete: { bindings: [{ key: "Backspace" }, { key: "Delete" }], activatesFocusIndicator: false },
  redo: {
    bindings: [
      { key: "y", ctrlOrMeta: true },
      { key: "z", ctrlOrMeta: true, shift: true }
    ],
    activatesFocusIndicator: false
  },
  undo: { bindings: [{ key: "z", ctrlOrMeta: true }], activatesFocusIndicator: false },
  submit: { bindings: [{ key: "Enter" }, { code: "Enter" }, { code: "Space" }] },
  zoomin: { bindings: [{ key: "+" }, { code: "ZoomIn" }, { code: "Add" }], activatesFocusIndicator: false },
  zoomout: { bindings: [{ key: "-" }, { code: "ZoomOut" }, { code: "Substract" }], activatesFocusIndicator: false }
};
function matchesKeyBinding(e, bindings) {
  for (const kb of bindings) {
    if ("code" in kb) {
      if (kb.code === e.code)
        return true;
    } else {
      const matches = kb.key === e.key && (kb.shift === void 0 || kb.shift === e.shiftKey) && (kb.ctrlOrMeta === void 0 || kb.ctrlOrMeta === e.ctrlKey || kb.ctrlOrMeta === e.metaKey);
      if (matches)
        return true;
    }
  }
  return false;
}
function mapKeyboardEventToAction(event) {
  for (const [actionName, { activatesFocusIndicator = true, bindings }] of entries4(KEY_BINDINGS)) {
    if (matchesKeyBinding(event, bindings)) {
      return { name: actionName, activatesFocusIndicator };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/keyboardUtil.ts
function computeCenter(series, hoverRect, pick) {
  const refPoint = getDatumRefPoint(series, pick.datum, pick.movedBounds);
  if (refPoint != null)
    return { x: refPoint.canvasX, y: refPoint.canvasY };
  const bboxOrPath = pick.bounds;
  if (bboxOrPath == null)
    return;
  if (bboxOrPath instanceof BBox) {
    const { x: centerX, y: centerY } = bboxOrPath.computeCenter();
    return {
      x: hoverRect.x + centerX,
      y: hoverRect.y + centerY
    };
  }
  return Transformable.toCanvas(bboxOrPath).computeCenter();
}
function getPickedFocusBBox({ bounds }) {
  if (bounds instanceof BBox)
    return bounds;
  if (bounds != null)
    return Transformable.toCanvas(bounds);
  return BBox.NaN;
}
function makeKeyboardPointerEvent(series, hoverRect, pick) {
  const { x: canvasX, y: canvasY } = computeCenter(series, hoverRect, pick) ?? {};
  if (canvasX !== void 0 && canvasY !== void 0) {
    return { type: "keyboard", canvasX, canvasY };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
import { CleanupRegistry as CleanupRegistry16, clamp as clamp14, getWindow as getWindow17 } from "ag-charts-core";

// packages/ag-charts-community/src/util/placement.ts
function calculatePlacement(naturalWidth, naturalHeight, container, bounds) {
  let { top, right, bottom, left, width: width2, height: height2 } = bounds;
  if (left != null) {
    if (width2 != null) {
      right = container.width - left + width2;
    } else if (right != null) {
      width2 = container.width - left - right;
    }
  } else if (right != null && width2 != null) {
    left = container.width - right - width2;
  }
  if (top != null) {
    if (height2 != null) {
      bottom = container.height - top - height2;
    } else if (bottom != null) {
      height2 = container.height - bottom - top;
    }
  } else if (bottom != null && height2 != null) {
    top = container.height - bottom - height2;
  }
  if (width2 == null) {
    if (height2 == null) {
      height2 = naturalHeight;
      width2 = naturalWidth;
    } else {
      width2 = Math.ceil(naturalWidth * height2 / naturalHeight);
    }
  } else {
    height2 ?? (height2 = Math.ceil(naturalHeight * width2 / naturalWidth));
  }
  if (left == null) {
    if (right == null) {
      left = Math.floor((container.width - width2) / 2);
    } else {
      left = container.width - right - width2;
    }
  }
  if (top == null) {
    if (bottom == null) {
      top = Math.floor((container.height - height2) / 2);
    } else {
      top = container.height - height2 - bottom;
    }
  }
  return { x: left, y: top, width: width2, height: height2 };
}

// packages/ag-charts-community/src/chart/tooltip/springAnimation.ts
import { EventEmitter as EventEmitter8 } from "ag-charts-core";
var M = 0.1;
var K = 200;
var C = 12;
var DELTA = 0.5;
var SpringAnimation = class {
  constructor() {
    this.events = new EventEmitter8();
    this.x1 = NaN;
    this.y1 = NaN;
    this.x = NaN;
    this.y = NaN;
    this.vx = 0;
    this.vy = 0;
    this.t0 = NaN;
    this.animationFrameHandle = void 0;
  }
  reset() {
    this.x = NaN;
    this.y = NaN;
    if (this.animationFrameHandle != null) {
      cancelAnimationFrame(this.animationFrameHandle);
      this.animationFrameHandle = void 0;
    }
  }
  update(x, y) {
    if (Number.isNaN(this.x) || Number.isNaN(this.y)) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.emitUpdate();
      if (this.animationFrameHandle != null) {
        cancelAnimationFrame(this.animationFrameHandle);
        this.animationFrameHandle = void 0;
      }
      return;
    }
    this.x1 = x;
    this.y1 = y;
    this.t0 = Date.now();
    this.animationFrameHandle ?? (this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this)));
  }
  onFrame() {
    this.animationFrameHandle = void 0;
    const { x1, y1, t0 } = this;
    const t1 = Date.now();
    const dt = t1 - t0;
    this.t0 = t1;
    const stepT = 1e-3;
    const iterations = Math.ceil(dt / (stepT * 1e3)) | 0;
    let { x, y, vx, vy } = this;
    for (let i = 0; i < iterations; i += 1) {
      const dx = x - x1;
      const dy = y - y1;
      const ax = -(K * dx + C * vx) / M;
      const ay = -(K * dy + C * vy) / M;
      vx += ax * stepT;
      vy += ay * stepT;
      x += vx * stepT;
      y += vy * stepT;
    }
    if (Math.hypot(x - x1, y - y1) < DELTA) {
      this.x = this.x1;
      this.y = this.y1;
      this.vx = 0;
      this.vy = 0;
    } else {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));
    }
    this.emitUpdate();
  }
  emitUpdate() {
    this.events.emit("update", { x: this.x, y: this.y });
  }
};

// packages/ag-charts-community/src/util/sanitize.ts
import { createElement as createElement14 } from "ag-charts-core";
var element = null;
function sanitizeHtml(text) {
  if (text === "") {
    return "";
  }
  element ?? (element = createElement14("div"));
  element.textContent = String(text);
  return element.innerHTML.replace(/\n/g, "<br>");
}

// packages/ag-charts-community/src/chart/marker/shapes.ts
function drawMarkerUnitPolygon(params, moves) {
  const { path, size } = params;
  const { x: x0, y: y0 } = params;
  path.clear();
  let didMove = false;
  for (const [dx, dy] of moves) {
    const x = x0 + (dx - 0.5) * size;
    const y = y0 + (dy - 0.5) * size;
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
    }
    didMove = true;
  }
  path.closePath();
}
var MARKER_SHAPES = {
  circle({ path, x, y, size }) {
    const r = size / 2;
    path.arc(x, y, r, 0, Math.PI * 2);
    path.closePath();
  },
  cross(params) {
    drawMarkerUnitPolygon(params, [
      [0.25, 0],
      [0.5, 0.25],
      [0.75, 0],
      [1, 0.25],
      [0.75, 0.5],
      [1, 0.75],
      [0.75, 1],
      [0.5, 0.75],
      [0.25, 1],
      [0, 0.75],
      [0.25, 0.5],
      [0, 0.25]
    ]);
  },
  diamond(params) {
    drawMarkerUnitPolygon(params, [
      [0.5, 0],
      [1, 0.5],
      [0.5, 1],
      [0, 0.5]
    ]);
  },
  heart({ path, x, y, size }) {
    const r = size / 4;
    y = y + r / 2;
    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
    path.lineTo(x, y + r);
    path.closePath();
  },
  pin({ path, x, y, size: s }) {
    const cx = 0.5;
    const cy = 0.5;
    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
    path.cubicCurveTo(
      x + (0.15625 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.307741 - cx) * s,
      y + (0 - cy) * s,
      x + (0.5 - cx) * s,
      y + (0 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.692259 - cx) * s,
      y + (0 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.84375 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.784625 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.716461 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.699009 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.681271 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.663785 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.611893 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.562228 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.528896 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.524075 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.512663 - cx) * s,
      y + (1 - cy) * s,
      x + (0.5 - cx) * s,
      y + (1 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.437772 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.388107 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.336215 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.318729 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.300991 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.283539 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.215375 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.closePath();
  },
  plus(params) {
    drawMarkerUnitPolygon(params, [
      [1 / 3, 0],
      [2 / 3, 0],
      [2 / 3, 1 / 3],
      [1, 1 / 3],
      [1, 2 / 3],
      [2 / 3, 2 / 3],
      [2 / 3, 1],
      [1 / 3, 1],
      [1 / 3, 2 / 3],
      [0, 2 / 3],
      [0, 1 / 3],
      [1 / 3, 1 / 3]
    ]);
  },
  square({ path, x, y, size, pixelRatio }) {
    const hs = size / 2;
    path.moveTo(align(pixelRatio, x - hs), align(pixelRatio, y - hs));
    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y - hs));
    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y + hs));
    path.lineTo(align(pixelRatio, x - hs), align(pixelRatio, y + hs));
    path.closePath();
  },
  star({ path, x, y, size }) {
    const spikes = 5;
    const outerRadius = size / 2;
    const innerRadius = outerRadius / 2;
    const rotation = Math.PI / 2;
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = i * Math.PI / spikes - rotation;
      const xCoordinate = x + Math.cos(angle) * radius;
      const yCoordinate = y + Math.sin(angle) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  },
  triangle(params) {
    drawMarkerUnitPolygon(params, [
      [0.5, 0],
      [1, 0.87],
      [0, 0.87]
    ]);
  }
};

// packages/ag-charts-community/src/chart/marker/marker.ts
var InternalMarker = class extends Path {
  constructor() {
    super(...arguments);
    this.shape = "square";
    this.x = 0;
    this.y = 0;
    this.size = 12;
  }
  isPointInPath(x, y) {
    return this.distanceSquared(x, y) <= 0;
  }
  distanceSquared(x, y) {
    const anchor = Marker.anchor(this.shape);
    return Math.max(
      Math.hypot(x - this.x + (anchor.x - 0.5) * this.size, y - this.y + (anchor.y - 0.5) * this.size) - this.size / 2,
      0
    );
  }
  updatePath() {
    const { path, shape, x, y, size } = this;
    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
    const anchor = Marker.anchor(shape);
    const drawParams = {
      path,
      x: x - (anchor.x - 0.5) * size,
      y: y - (anchor.y - 0.5) * size,
      size,
      pixelRatio
    };
    path.clear();
    if (typeof shape === "string") {
      MARKER_SHAPES[shape](drawParams);
    } else if (typeof shape === "function") {
      shape(drawParams);
    }
  }
  computeBBox() {
    const { x, y, size } = this;
    const anchor = Marker.anchor(this.shape);
    return new BBox(x - size * anchor.x, y - size * anchor.y, size, size);
  }
  executeFill(ctx, path) {
    if (!path)
      return;
    return super.executeFill(ctx, path);
  }
  executeStroke(ctx, path) {
    if (!path)
      return;
    return super.executeStroke(ctx, path);
  }
};
__decorateClass([
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], InternalMarker.prototype, "shape", 2);
__decorateClass([
  SceneChangeDetection()
], InternalMarker.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], InternalMarker.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ convertor: Math.abs })
], InternalMarker.prototype, "size", 2);
var Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {
  static anchor(shape) {
    if (shape === "pin") {
      return { x: 0.5, y: 1 };
    } else if (typeof shape === "function" && "anchor" in shape) {
      return shape.anchor;
    }
    return { x: 0.5, y: 0.5 };
  }
  constructor(options) {
    super(options);
    if (options?.shape != null) {
      this.shape = options.shape;
    }
  }
};

// packages/ag-charts-community/src/chart/legend/legendSymbol.ts
function legendSymbolSvg(symbol, size, lineSize = size * (5 / 3)) {
  const group = new Group();
  const markerStrokeWidth = Math.min(symbol.marker.strokeWidth ?? 1, 2);
  const lineStrokeWidth = Math.min(symbol.line?.strokeWidth ?? 0, 2);
  const width2 = Math.max(symbol.marker.enabled === false ? 0 : size, symbol.line == null ? 0 : lineSize);
  const height2 = Math.max(symbol.marker.enabled === false ? 0 : size, lineStrokeWidth);
  if (symbol.line != null) {
    const { stroke: stroke2, strokeOpacity, lineDash } = symbol.line;
    const line = new Line();
    line.x1 = 0;
    line.y1 = height2 / 2;
    line.x2 = width2;
    line.y2 = height2 / 2;
    line.stroke = stroke2;
    line.strokeOpacity = strokeOpacity;
    line.strokeWidth = lineStrokeWidth;
    line.lineDash = lineDash;
    group.append(line);
  }
  if (symbol.marker.enabled !== false) {
    const { shape, fill, fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = symbol.marker;
    const marker = new Marker();
    marker.shape = shape ?? "square";
    marker.size = size;
    marker.fill = fill;
    marker.fillOpacity = fillOpacity ?? 1;
    marker.stroke = stroke2;
    marker.strokeOpacity = strokeOpacity ?? 1;
    marker.strokeWidth = markerStrokeWidth;
    marker.lineDash = lineDash;
    marker.lineDashOffset = lineDashOffset ?? 0;
    const anchor = Marker.anchor(shape);
    const x = width2 / 2 + (anchor.x - 0.5) * size;
    const y = height2 / 2 + (anchor.y - 0.5) * size;
    const scale2 = size / (size + markerStrokeWidth);
    marker.x = x;
    marker.y = y;
    marker.scalingCenterX = x;
    marker.scalingCenterY = y;
    marker.scalingX = scale2;
    marker.scalingY = scale2;
    group.append(marker);
  }
  return Group.toSVG(group, width2, height2);
}

// packages/ag-charts-community/src/chart/tooltip/tooltipContent.ts
var DEFAULT_TOOLTIP_CLASS = "ag-charts-tooltip";
var DEFAULT_TOOLTIP_DARK_CLASS = "ag-charts-tooltip--dark";
function aggregateTooltipContent(content) {
  const out = [];
  const groupedContents = /* @__PURE__ */ new Map();
  for (const item of content) {
    if (item.type === "structured") {
      const { heading } = item;
      const insertionTarget = heading != null ? groupedContents.get(heading) : void 0;
      const groupedItem = { type: "structured", heading, items: [item] };
      if (insertionTarget == null) {
        groupedContents.set(heading, groupedItem);
        out.push(groupedItem);
      } else {
        insertionTarget.items.push(item);
      }
    } else {
      out.push(item);
    }
  }
  return out;
}
function tooltipContentAriaLabel(ungroupedContent) {
  const content = aggregateTooltipContent(ungroupedContent);
  const ariaLabel = [];
  content.forEach((c) => {
    if (c.type === "raw")
      return "";
    if (c.heading != null)
      ariaLabel.push(c.heading);
    c.items.forEach((i) => {
      if (i.title != null)
        ariaLabel.push(i.title);
      i.data?.forEach((datum) => {
        ariaLabel.push(datum.label ?? datum.fallbackLabel, datum.value);
      });
    });
  });
  return ariaLabel.join("; ");
}
function dataHtml(label, value, inline) {
  let rowHtml = "";
  if (label == null) {
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-label">${sanitizeHtml(value)}</span>`;
  } else {
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-label">${sanitizeHtml(label)}</span>`;
    rowHtml += " ";
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-value">${sanitizeHtml(value)}</span>`;
  }
  const rowClassNames = [`${DEFAULT_TOOLTIP_CLASS}-row`];
  if (inline)
    rowClassNames.push(`${DEFAULT_TOOLTIP_CLASS}-row--inline`);
  rowHtml = `<div class="${rowClassNames.join(" ")}">${rowHtml}</div>`;
  return rowHtml;
}
function tooltipRowContentHtml(content) {
  let html = "";
  if (content.data?.length && content.data.every((datum) => datum.value == null || datum.value === "")) {
    return html;
  }
  const dataInline = content.title == null && content.data?.length === 1;
  const symbol = content.symbol == null ? void 0 : legendSymbolSvg(content.symbol, 12);
  if (symbol != null && (content.title != null || content.data?.length)) {
    html += `<span class="${DEFAULT_TOOLTIP_CLASS}-symbol">${symbol}</span>`;
  }
  if (content.title != null) {
    html += `<span class="${DEFAULT_TOOLTIP_CLASS}-title">${sanitizeHtml(content.title)}</span>`;
    html += " ";
  }
  content.data?.forEach((datum) => {
    html += dataHtml(datum.label ?? datum.fallbackLabel, datum.value, dataInline);
    html += " ";
  });
  return html;
}
function tooltipPaginationContentHtml(localeManager, pagination) {
  if (localeManager == null || pagination.length === 1)
    return;
  const text = localeManager?.t("tooltipPaginationStatus", {
    index: pagination.index + 1,
    count: pagination.length
  });
  return `<div class="${DEFAULT_TOOLTIP_CLASS}-footer">${text}</div>`;
}
function tooltipContentHtml(localeManager, content, mode, pagination) {
  const singleItem = content.items.length === 1 ? content.items[0] : void 0;
  let compact;
  let compactTitle;
  let compactFallbackLabel;
  switch (mode) {
    case "compact":
      compact = true;
      compactTitle = singleItem?.title;
      break;
    case "single":
      compact = singleItem != null && (content.heading == null || singleItem.title == null) && singleItem.data?.length === 1 && singleItem.data[0].label == null && singleItem.data[0].value != null;
      compactFallbackLabel = content.heading ?? singleItem?.title;
      break;
    case "shared":
      compact = false;
  }
  let html = "";
  if (compact && singleItem != null) {
    if (compactTitle != null) {
      html += dataHtml(void 0, compactTitle, false);
    }
    singleItem.data?.forEach((datum) => {
      html += dataHtml(datum.label ?? compactFallbackLabel, datum.value, false);
      html += " ";
    });
  } else {
    if (content.heading != null) {
      html += `<span class="${DEFAULT_TOOLTIP_CLASS}-heading">${sanitizeHtml(content.heading)}</span>`;
      html += " ";
    }
    content.items.forEach((item) => {
      html += tooltipRowContentHtml(item);
    });
  }
  if (html.length === 0)
    return;
  const paginationContent = mode !== "compact" && pagination != null ? tooltipPaginationContentHtml(localeManager, pagination) : void 0;
  if (paginationContent + null) {
    html += paginationContent;
  }
  html = `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${html.trimEnd()}</div>`;
  return html;
}
function tooltipPaginationHtml(localeManager, pagination) {
  const paginationContent = pagination == null ? void 0 : tooltipPaginationContentHtml(localeManager, pagination);
  if (paginationContent == null)
    return "";
  return `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${paginationContent}</div>`;
}
function tooltipHtml(localeManager, content, mode, pagination) {
  const aggregatedContent = aggregateTooltipContent(content);
  if (aggregatedContent.length === 0)
    return;
  if (aggregatedContent.length === 1 && aggregatedContent[0].type === "structured") {
    return tooltipContentHtml(localeManager, aggregatedContent[0], mode, pagination);
  } else {
    const htmlRows = aggregatedContent.map((c) => {
      return c.type === "structured" ? tooltipContentHtml(localeManager, c, mode) : c.rawHtmlString;
    });
    if (pagination != null) {
      htmlRows.push(tooltipPaginationHtml(localeManager, pagination) ?? "");
    }
    return htmlRows.join("");
  }
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var horizontalAlignments = {
  left: -1,
  "top-left": -1,
  "bottom-left": -1,
  top: 0,
  center: 0,
  bottom: 0,
  right: 1,
  "top-right": 1,
  "bottom-right": 1
};
var verticalAlignments = {
  "top-left": -1,
  top: -1,
  "top-right": -1,
  left: 0,
  center: 0,
  right: 0,
  "bottom-left": 1,
  bottom: 1,
  "bottom-right": 1
};
var arrowPositions = {
  left: 3 /* Right */,
  "top-left": void 0,
  "bottom-left": void 0,
  top: 2 /* Bottom */,
  center: void 0,
  bottom: 1 /* Top */,
  right: 0 /* Left */,
  "top-right": void 0,
  "bottom-right": void 0
};
var directionChecks = {
  top: 2 /* Vertical */,
  bottom: 2 /* Vertical */,
  left: 1 /* Horizontal */,
  right: 1 /* Horizontal */,
  "top-right": 3 /* Both */,
  "top-left": 3 /* Both */,
  "bottom-right": 3 /* Both */,
  "bottom-left": 3 /* Both */,
  center: 0 /* None */
};
var defaultPlacements = {
  pointer: "top",
  node: "top",
  chart: "top-left"
};
var TooltipPosition = class extends BaseProperties {
  constructor() {
    super(...arguments);
    /** The horizontal offset in pixels for the position of the tooltip. */
    this.xOffset = 0;
    /** The vertical offset in pixels for the position of the tooltip. */
    this.yOffset = 0;
  }
};
__decorateClass([
  Property
], TooltipPosition.prototype, "xOffset", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "yOffset", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "anchorTo", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "placement", 2);
var Tooltip = class extends BaseProperties {
  constructor() {
    super();
    this.enabled = true;
    this.mode = "single";
    this.delay = 0;
    this.range = void 0;
    this.wrapping = "hyphenate";
    this.position = new TooltipPosition();
    this.pagination = false;
    this.darkTheme = false;
    this.bounds = "extended";
    this.cleanup = new CleanupRegistry16();
    this.springAnimation = new SpringAnimation();
    this.enableInteraction = false;
    this.wrapTypes = ["always", "hyphenate", "on-space", "never"];
    this.sizeMonitor = new SizeMonitor();
    // Reading the element size is expensive, so cache the result
    this._elementSize = void 0;
    this._showTimeout = void 0;
    this.arrowPosition = void 0;
    this._visible = false;
    this.positionParams = void 0;
    this.localeManager = void 0;
    this.cleanup.register(this.springAnimation.events.on("update", this.updateTooltipPosition.bind(this)));
  }
  get interactive() {
    return this.enableInteraction;
  }
  setup(localeManager, domManager) {
    if ("togglePopover" in getWindow17().HTMLElement.prototype) {
      this.element = domManager.addChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
      this.element.setAttribute("popover", "manual");
      this.element.className = DEFAULT_TOOLTIP_CLASS;
      this.element.style.positionAnchor = domManager.anchorName;
      this.sizeMonitor.observe(this.element, (size) => {
        this._elementSize = size;
        this.updateTooltipPosition();
      });
    }
    this.localeManager = localeManager;
    return () => {
      domManager.removeChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
      this.cleanup.flush();
      if (this.element) {
        this.sizeMonitor.unobserve(this.element);
      }
    };
  }
  isVisible() {
    return this._visible;
  }
  contains(node) {
    return this.element?.contains(node) ?? false;
  }
  updateTooltipPosition() {
    const { element: element2, _elementSize: elementSize, positionParams } = this;
    if (element2 == null || elementSize == null || positionParams == null)
      return;
    const { canvasRect, relativeRect, meta } = positionParams;
    const { x: canvasX, y: canvasY } = this.springAnimation;
    const anchorTo = meta.position?.anchorTo ?? "pointer";
    let placements2 = meta.position?.placement ?? defaultPlacements[anchorTo];
    if (!Array.isArray(placements2)) {
      placements2 = [placements2];
    }
    const xOffset = meta.position?.xOffset ?? 0;
    const yOffset = meta.position?.yOffset ?? 0;
    const minX = relativeRect.x;
    const minY = relativeRect.y;
    const maxX = relativeRect.width - elementSize.width - 1 + minX;
    const maxY = relativeRect.height - elementSize.height + minY;
    let i = 0;
    let placement;
    let position;
    let constrained = false;
    do {
      placement = placements2[i];
      i += 1;
      const tooltipBounds = this.getTooltipBounds({
        elementSize,
        placement,
        anchorTo,
        canvasX,
        canvasY,
        yOffset,
        xOffset,
        canvasRect
      });
      position = calculatePlacement(elementSize.width, elementSize.height, relativeRect, tooltipBounds);
      constrained = false;
      if (directionChecks[placement] & 1 /* Horizontal */) {
        constrained || (constrained = position.x < minX || position.x > maxX);
      }
      if (directionChecks[placement] & 2 /* Vertical */) {
        constrained || (constrained = position.y < minY || position.y > maxY);
      }
    } while (i < placements2.length && constrained);
    const left = clamp14(minX, position.x, maxX);
    const top = clamp14(minY, position.y, maxY);
    constrained || (constrained = left !== position.x || top !== position.y);
    const defaultShowArrow = anchorTo !== "chart" && !constrained && !xOffset && !yOffset;
    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;
    this.arrowPosition = showArrow ? arrowPositions[placement] : void 0;
    this.updateClassModifiers();
    element2.style.translate = `${left}px ${top}px`;
  }
  /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */
  show(boundingRect, canvasRect, meta, content, pagination, instantly = false) {
    const { element: element2 } = this;
    if (element2 != null && content != null && content.length !== 0) {
      const html = tooltipHtml(this.localeManager, content, this.mode, this.pagination ? pagination : void 0);
      if (html == null) {
        this.toggle(false);
        return;
      }
      element2.innerHTML = html;
    } else if (element2 == null || element2.innerHTML === "") {
      this.toggle(false);
      return;
    }
    const relativeRect = {
      x: boundingRect.x - canvasRect.x,
      y: boundingRect.y - canvasRect.y,
      width: boundingRect.width,
      height: boundingRect.height
    };
    this.positionParams = {
      canvasRect,
      relativeRect,
      meta
    };
    const anchorTo = meta.position?.anchorTo ?? "pointer";
    switch (anchorTo) {
      case "node":
        this.springAnimation.update(meta.nodeCanvasX ?? meta.canvasX, meta.nodeCanvasY ?? meta.canvasY);
        break;
      case "pointer":
        this.springAnimation.update(meta.canvasX, meta.canvasY);
        break;
      case "chart":
        this.springAnimation.reset();
    }
    if (meta.enableInteraction) {
      this.enableInteraction = true;
      element2.style.pointerEvents = "auto";
      element2.removeAttribute("aria-hidden");
      element2.tabIndex = -1;
    } else {
      this.enableInteraction = false;
      element2.style.pointerEvents = "none";
      element2.setAttribute("aria-hidden", "true");
      element2.removeAttribute("tabindex");
    }
    element2.style.setProperty("--top", `${canvasRect.top}px`);
    element2.style.setProperty("--left", `${canvasRect.left}px`);
    this.updateClassModifiers();
    this.toggle(true, instantly);
  }
  hide() {
    this.toggle(false);
  }
  maybeEnterInteractiveTooltip({ relatedTarget }, callback5) {
    const { interactive, interactiveLeave, enabled, element: element2 } = this;
    if (element2 == null)
      return false;
    if (interactiveLeave)
      return true;
    const isEntering = interactive && enabled && this.isVisible() && relatedTarget instanceof Node && this.contains(relatedTarget);
    if (isEntering) {
      this.interactiveLeave = {
        callback: callback5,
        listener: (popoverEvent) => {
          const isLeaving = popoverEvent.relatedTarget == null || popoverEvent.relatedTarget instanceof Node && !this.contains(popoverEvent.relatedTarget);
          if (isLeaving) {
            this.popInteractiveLeaveCallback();
          }
        }
      };
      element2.addEventListener("focusout", this.interactiveLeave.listener);
      element2.addEventListener("mouseout", this.interactiveLeave.listener);
    }
    return isEntering;
  }
  popInteractiveLeaveCallback() {
    const { interactiveLeave, element: element2 } = this;
    this.interactiveLeave = void 0;
    if (interactiveLeave) {
      if (element2) {
        element2.removeEventListener("focusout", interactiveLeave.listener);
        element2.removeEventListener("mouseout", interactiveLeave.listener);
      }
      interactiveLeave.callback();
    }
  }
  toggle(visible, instantly = false) {
    const { delay } = this;
    if (visible && delay > 0 && !instantly) {
      this._showTimeout ?? (this._showTimeout = setTimeout(() => {
        this._showTimeout = void 0;
        this.toggleCallback(true);
      }, delay));
    } else {
      clearTimeout(this._showTimeout);
      this._showTimeout = void 0;
      this.toggleCallback(visible);
    }
  }
  toggleCallback(visible) {
    if (!this.element?.isConnected)
      return;
    if (this._visible === visible)
      return;
    this._visible = visible;
    this.element.togglePopover(visible);
    if (visible) {
      this.updateTooltipPosition();
    } else {
      this.springAnimation.reset();
      this.popInteractiveLeaveCallback();
    }
  }
  updateClassModifiers() {
    if (!this.element?.isConnected)
      return;
    const { classList } = this.element;
    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--${name}`, include);
    toggleClass("no-interaction", !this.enableInteraction);
    toggleClass("arrow-top", this.arrowPosition === 1 /* Top */);
    toggleClass("arrow-right", this.arrowPosition === 3 /* Right */);
    toggleClass("arrow-bottom", this.arrowPosition === 2 /* Bottom */);
    toggleClass("arrow-left", this.arrowPosition === 0 /* Left */);
    toggleClass("compact", this.mode === "compact");
    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
    for (const wrapType of this.wrapTypes) {
      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--wrap-${wrapType}`, wrapType === this.wrapping);
    }
  }
  getTooltipBounds(opts) {
    const { elementSize, anchorTo, placement, canvasX, canvasY, yOffset, xOffset, canvasRect } = opts;
    const { width: tooltipWidth, height: tooltipHeight } = elementSize;
    const bounds = { width: tooltipWidth, height: tooltipHeight };
    if (anchorTo === "node" || anchorTo === "pointer") {
      const horizontalAlignment = horizontalAlignments[placement];
      const verticalAlignment = verticalAlignments[placement];
      bounds.top = canvasY + yOffset + tooltipHeight * (verticalAlignment - 1) / 2 + 8 * verticalAlignment;
      bounds.left = canvasX + xOffset + tooltipWidth * (horizontalAlignment - 1) / 2 + 8 * horizontalAlignment;
      return bounds;
    }
    switch (placement) {
      case "top": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "right": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "left": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "bottom": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "top-left": {
        bounds.top = yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "top-right": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-right": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-left": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
    }
    return bounds;
  }
};
__decorateClass([
  Property
], Tooltip.prototype, "enabled", 2);
__decorateClass([
  Property
], Tooltip.prototype, "mode", 2);
__decorateClass([
  Property
], Tooltip.prototype, "showArrow", 2);
__decorateClass([
  Property
], Tooltip.prototype, "delay", 2);
__decorateClass([
  Property
], Tooltip.prototype, "range", 2);
__decorateClass([
  Property
], Tooltip.prototype, "wrapping", 2);
__decorateClass([
  Property
], Tooltip.prototype, "position", 2);
__decorateClass([
  Property
], Tooltip.prototype, "pagination", 2);
__decorateClass([
  Property
], Tooltip.prototype, "darkTheme", 2);
__decorateClass([
  Property
], Tooltip.prototype, "bounds", 2);

// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
function pickedNodesEqual(a, b) {
  return a.series === b.series && objectsEqual(a.datumIndex, b.datumIndex);
}
var PickedNodeState = class {
  constructor() {
    this.candidates = [];
  }
  get current() {
    return this.active;
  }
  reset() {
    this.candidates.length = 0;
    this.active = void 0;
  }
  update(nextCandidates, previousActive) {
    this.candidates = nextCandidates;
    let nextIndex = previousActive != null ? nextCandidates.findIndex((c) => pickedNodesEqual(c, previousActive)) : -1;
    if (nextIndex === -1)
      nextIndex = 0;
    this.active = nextCandidates[nextIndex];
    return { current: this.active, index: nextIndex, length: nextCandidates.length };
  }
  next() {
    const { candidates, active } = this;
    const hoverIndex = active == null ? -1 : candidates.findIndex((c) => pickedNodesEqual(c, active));
    if (hoverIndex === -1)
      return void 0;
    let nextIndex = hoverIndex + 1;
    if (nextIndex >= candidates.length) {
      nextIndex = 0;
    }
    this.active = candidates[nextIndex];
    return { current: this.active, index: nextIndex, length: this.candidates.length };
  }
};
var SeriesAreaManager = class extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
    this.id = createId8(this);
    this.series = [];
    this.announceMode = "when-changed";
    this.highlight = {
      /** Last received event that still needs to be applied. */
      pendingHoverEvent: void 0,
      /** Last applied event. */
      appliedHoverEvent: void 0,
      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */
      stashedHoverEvent: void 0
    };
    this.tooltip = {
      lastHover: void 0
    };
    /**
     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):
     *
     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.
     *
     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.
     *       (this is decided by the browser).
     *
     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on
     *       the currently (or newly) focused datum.
     *
     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match
     *       for the mouse event offsets.
     */
    this.hoverDevice = "pointer";
    /**
     * This is the "second last" input event. It can be useful for keydown
     * events that for which don't to set the isFocusVisible state
     * (e.g. Backspace/Delete key on FC annotations, see AG-13041).
     *
     * Use with caution! The focus indicator must ALWAYS be visible for
     * keyboard-only users.
     */
    this.previousInputDevice = "keyboard";
    this.focus = {
      sortedSeries: [],
      series: void 0,
      seriesIndex: 0,
      datumIndex: 0,
      datum: void 0
    };
    this.cachedTooltipContent = void 0;
    this.hoverScheduler = debouncedAnimationFrame(() => {
      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)
        return;
      if (this.chart.getUpdateType() <= 5 /* SERIES_UPDATE */) {
        this.hoverScheduler.schedule();
        return;
      }
      if (this.highlight.pendingHoverEvent) {
        this.handleHoverHighlight(false);
      }
      if (this.tooltip.lastHover) {
        this.handleHoverTooltip(this.tooltip.lastHover, false);
      }
    });
    this.tooltipCandidates = new PickedNodeState();
    const initialAltText = chart.ctx.localeManager.t("ariaInitSeriesArea");
    const label1 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label1");
    const label2 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label2");
    this.swapChain = new FocusSwapChain(label1, label2, "img", initialAltText);
    this.swapChain.addListener("blur", (event) => this.onBlur(event));
    this.swapChain.addListener("focus", () => this.onFocus());
    if (chart.ctx.domManager.mode === "normal") {
      this.focusIndicator = new FocusIndicator(this.swapChain);
      this.focusIndicator.overrideFocusVisible(chart.mode === "integrated" ? false : void 0);
    }
    const { seriesDragInterpreter, seriesWidget, containerWidget } = chart.ctx.widgets;
    seriesWidget.setTabIndex(-1);
    this.cleanup.register(
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label1"),
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label2"),
      seriesWidget.addListener("focus", () => this.swapChain.focus({ preventScroll: true })),
      seriesWidget.addListener("mousemove", (event) => this.onHover(event, seriesWidget)),
      seriesWidget.addListener("wheel", (event) => this.onWheel(event)),
      seriesWidget.addListener("mouseleave", (event) => this.onLeave(event)),
      seriesWidget.addListener("keydown", (event) => this.onKeyDown(event)),
      seriesWidget.addListener("contextmenu", (event, current) => this.onContextMenu(event, current)),
      containerWidget.addListener("contextmenu", (event, current) => this.onContextMenu(event, current)),
      containerWidget.addListener("click", (event, current) => this.onClick(event, current)),
      containerWidget.addListener("dblclick", (event, current) => this.onClick(event, current)),
      chart.ctx.animationManager.addListener("animation-start", () => this.clearAll()),
      chart.ctx.eventsHub.on("dom:resize", () => this.clearAll()),
      chart.ctx.eventsHub.on("highlight:change", (event) => this.changeHighlightDatum(event)),
      chart.ctx.eventsHub.on("layout:complete", (event) => this.layoutComplete(event)),
      chart.ctx.updateService.addListener("pre-scene-render", () => this.preSceneRender()),
      chart.ctx.updateService.addListener("update-complete", () => this.updateComplete()),
      chart.ctx.eventsHub.on("zoom:change", () => this.clearAll()),
      chart.ctx.eventsHub.on("zoom:pan-start", () => this.clearAll())
    );
    if (seriesDragInterpreter) {
      this.cleanup.register(
        seriesDragInterpreter.events.on("drag-move", (event) => this.onDragMove(event, seriesWidget)),
        seriesDragInterpreter.events.on("click", (event) => this.onClick(event, seriesWidget)),
        seriesDragInterpreter.events.on("dblclick", (event) => this.onClick(event, seriesWidget))
      );
    }
  }
  get bbox() {
    return (this.seriesRect ?? BBox.zero).clone();
  }
  isState(allowedStates) {
    return this.chart.ctx.interactionManager.isState(allowedStates);
  }
  isIgnoredTouch(event) {
    if (event.device !== "touch" || event.type === "click")
      return false;
    if (this.chart.ctx.chartService.touch.dragAction === "hover")
      return false;
    if (this.chart.ctx.chartService.touch.dragAction === "drag") {
      if (this.isState(9 /* AnnotationsMoveable */)) {
        return false;
      }
    }
    return true;
  }
  dataChanged() {
    var _a;
    this.cachedTooltipContent = void 0;
    if (this.highlight.appliedHoverEvent) {
      (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);
      this.clearHighlight();
    }
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.focusIndicator?.clear();
  }
  preSceneRender() {
    if (this.highlight.stashedHoverEvent != null) {
      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;
      this.highlight.stashedHoverEvent = void 0;
      this.handleHoverHighlight(true);
    }
    if (this.tooltip.lastHover != null) {
      this.handleHoverTooltip(this.tooltip.lastHover, true);
    }
  }
  updateComplete() {
    if (this.isState(34 /* Focusable */) && this.focusIndicator?.isFocusVisible()) {
      if (this.announceMode !== "always") {
        this.announceMode = "never";
      }
      this.handleFocus(0, 0);
    }
  }
  update(type, opts) {
    this.chart.ctx.updateService.update(type, opts);
  }
  seriesChanged(series) {
    this.focus.sortedSeries = [...series].sort((a, b) => {
      let fpA = a.properties.focusPriority ?? Infinity;
      let fpB = b.properties.focusPriority ?? Infinity;
      if (fpA === fpB) {
        [fpA, fpB] = [a.declarationOrder, b.declarationOrder];
      }
      if (fpA < fpB) {
        return -1;
      } else if (fpA > fpB) {
        return 1;
      }
      return 0;
    });
    this.series = series;
  }
  layoutComplete(event) {
    this.seriesRect = event.series.rect;
    this.hoverRect = event.series.rect;
    this.chart.ctx.widgets.seriesWidget.setBounds(event.series.rect);
    if (this.chart.ctx.domManager.mode === "normal") {
      this.chart.ctx.widgets.chartWidget.setBounds(event.chart);
    }
  }
  onContextMenu(event, current) {
    const { sourceEvent } = event;
    if (sourceEvent.currentTarget != current.getElement())
      return;
    if (sourceEvent.target == this.chart.ctx.widgets.containerWidget.getElement()) {
      if (this.isState(36 /* ContextMenuable */)) {
        const { currentX: canvasX2, currentY: canvasY2 } = event;
        this.chart.ctx.contextMenuRegistry.dispatchContext(
          "always",
          { widgetEvent: event, canvasX: canvasX2, canvasY: canvasY2 },
          void 0
        );
      }
      return;
    }
    let pickedNode;
    let position;
    if (this.focusIndicator?.isFocusVisible()) {
      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();
      if (pickedNode && this.seriesRect && pickedNode.midPoint) {
        position = Transformable.toCanvasPoint(
          pickedNode.series.contentGroup,
          pickedNode.midPoint.x,
          pickedNode.midPoint.y
        );
      }
    } else if (this.isState(36 /* ContextMenuable */)) {
      const pick = this.pickNodes({ x: event.currentX, y: event.currentY }, "context-menu");
      if (pick) {
        this.chart.ctx.highlightManager.updateHighlight(this.id);
        pickedNode = pick.matches[0].datum;
      }
    }
    const pickedSeries = pickedNode?.series;
    this.clearAll();
    const canvasX = event.currentX + current.cssLeft();
    const canvasY = event.currentY + current.cssTop();
    if (pickedSeries && pickedNode) {
      this.chart.ctx.contextMenuRegistry.dispatchContext(
        "series-node",
        { widgetEvent: event, canvasX, canvasY },
        { pickedSeries, pickedNode },
        position
      );
    } else {
      this.chart.ctx.contextMenuRegistry.dispatchContext(
        "series-area",
        { widgetEvent: event, canvasX, canvasY },
        void 0,
        position
      );
    }
  }
  onLeave(event) {
    if (!this.isState(41 /* Clickable */))
      return;
    const relatedTarget = event.sourceEvent.relatedTarget;
    if (relatedTarget?.className === "ag-charts-text-input__textarea") {
      return;
    }
    if (this.maybeEnterInteractiveTooltip(event.sourceEvent)) {
      return;
    }
    this.chart.ctx.domManager.updateCursor(this.id);
    if (this.hoverDevice !== "keyboard")
      this.clearAll();
  }
  onWheel(_event) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.focusIndicator?.overrideFocusVisible(false);
    this.previousInputDevice = "pointer";
  }
  onDragMove(event, current) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.focusIndicator?.overrideFocusVisible(false);
    this.onHoverLikeEvent(event, current);
  }
  onHover(event, current) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.onHoverLikeEvent(event, current);
  }
  onHoverLikeEvent(event, current) {
    if (this.isIgnoredTouch(event))
      return;
    if (event.device === "touch" && this.chart.ctx.chartService.touch.dragAction === "hover") {
      event.sourceEvent.preventDefault();
    }
    if (current !== this.chart.ctx.widgets.seriesWidget)
      return;
    if (event.device === "touch" || excludesType(event, "drag-move")) {
      this.tooltip.lastHover = event;
    }
    this.hoverDevice = "pointer";
    this.previousInputDevice = "pointer";
    this.highlight.pendingHoverEvent = event;
    this.hoverScheduler.schedule();
    if (this.isState(32 /* Default */)) {
      const { currentX: x, currentY: y } = event;
      const matches = this.pickNodes({ x, y }, "event")?.matches;
      const found = matches?.[0];
      if (found?.series.hasEventListener("seriesNodeClick") || found?.series.hasEventListener("seriesNodeDoubleClick") || matches != null && matches.length > 1 && this.chart.tooltip.pagination) {
        this.chart.ctx.domManager.updateCursor(this.id, "pointer");
      } else {
        this.chart.ctx.domManager.updateCursor(this.id);
      }
    }
  }
  onClick(event, current) {
    if (event.device === "keyboard") {
      return;
    }
    if (current === this.chart.ctx.widgets.seriesWidget && this.chart.ctx.animationManager.isActive()) {
      this.chart.ctx.animationManager.skipCurrentBatch();
    }
    if (event.device === "touch" && current === this.chart.ctx.widgets.seriesWidget) {
      this.swapChain.focus({ preventScroll: true });
    }
    if (!this.isState(41 /* Clickable */))
      return;
    if (current === this.chart.ctx.widgets.seriesWidget) {
      if (!current.getElement().contains(event.sourceEvent.target)) {
        return;
      }
    } else if (event.sourceEvent.target != current.getElement()) {
      return;
    }
    this.focusIndicator?.overrideFocusVisible(false);
    this.onHoverLikeEvent(event, current);
    if (!this.isState(32 /* Default */))
      return;
    if (current == this.chart.ctx.widgets.seriesWidget && this.checkSeriesNodeClick(event)) {
      this.update(5 /* SERIES_UPDATE */);
      event.sourceEvent.preventDefault();
      return;
    }
    const newEvent = { type: event.type === "click" ? "click" : "doubleClick", event: event.sourceEvent };
    this.chart.fireEvent(newEvent);
  }
  onFocus() {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = this.focusIndicator?.isFocusVisible(true) ? "keyboard" : "pointer";
    this.handleFocus(0, 0);
  }
  onBlur(event) {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = "pointer";
    if (!this.maybeEnterInteractiveTooltip(event)) {
      this.clearAll();
    }
    this.focusIndicator?.overrideFocusVisible(void 0);
  }
  onKeyDown(widgetEvent) {
    if (!this.isState(43 /* Keyable */))
      return;
    const action = mapKeyboardEventToAction(widgetEvent.sourceEvent);
    if (action?.activatesFocusIndicator === false) {
      this.focusIndicator?.overrideFocusVisible(this.previousInputDevice === "keyboard");
    }
    switch (action?.name) {
      case "redo":
        return this.chart.ctx.eventsHub.emit("series:redo", null);
      case "undo":
        return this.chart.ctx.eventsHub.emit("series:undo", null);
      case "zoomin":
        return this.chart.ctx.eventsHub.emit("series:keynav-zoom", { delta: 1, widgetEvent });
      case "zoomout":
        return this.chart.ctx.eventsHub.emit("series:keynav-zoom", { delta: -1, widgetEvent });
      case "arrowup":
        return this.onArrow(-1, 0, widgetEvent);
      case "arrowdown":
        return this.onArrow(1, 0, widgetEvent);
      case "arrowleft":
        return this.onArrow(0, -1, widgetEvent);
      case "arrowright":
        return this.onArrow(0, 1, widgetEvent);
      case "submit":
        return this.onSubmit(widgetEvent);
    }
  }
  onArrow(seriesIndexDelta, datumIndexDelta, event) {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = "keyboard";
    this.previousInputDevice = "keyboard";
    this.focusIndicator?.overrideFocusVisible(true);
    this.focus.seriesIndex += seriesIndexDelta;
    this.focus.datumIndex += datumIndexDelta;
    this.handleFocus(seriesIndexDelta, datumIndexDelta);
    event.sourceEvent.preventDefault();
    this.chart.ctx.eventsHub.emit("series:focus-change", null);
  }
  onSubmit(event) {
    if (!this.isState(34 /* Focusable */))
      return;
    const { series, datum } = this.focus;
    const sourceEvent = event.sourceEvent;
    if (series != null && datum != null) {
      series.fireNodeClickEvent(sourceEvent, datum);
    } else {
      this.chart.fireEvent({
        type: "click",
        event: sourceEvent
      });
    }
    sourceEvent.preventDefault();
  }
  checkSeriesNodeClick(event) {
    var _a;
    const result = this.pickNodes({ x: event.currentX, y: event.currentY }, "event");
    if (result == null || result.matches.length === 0)
      return;
    const paginationUpdate = this.chart.tooltip.pagination ? this.tooltipCandidates.update(result.matches, this.tooltipCandidates.current)?.current : void 0;
    const { series, datum } = paginationUpdate ?? result.matches[0];
    const distance = paginationUpdate == null ? result.distance : 0;
    if (event.type === "click") {
      const defaultBehavior = series.fireNodeClickEvent(event.sourceEvent, datum);
      const nextTooltipCandidate = defaultBehavior && this.chart.tooltip.pagination ? this.tooltipCandidates.next() : void 0;
      if (nextTooltipCandidate != null) {
        event.sourceEvent.preventDefault();
        const { currentX, currentY } = event;
        const canvasX = currentX + (this.hoverRect?.x ?? 0);
        const canvasY = currentY + (this.hoverRect?.y ?? 0);
        (_a = this.highlight).pendingHoverEvent ?? (_a.pendingHoverEvent = this.highlight.appliedHoverEvent);
        this.handleHoverHighlight(false);
        this.showTooltip(nextTooltipCandidate.current, canvasX, canvasY, {
          index: nextTooltipCandidate.index,
          length: nextTooltipCandidate.length
        });
      }
      return true;
    }
    if (event.type === "dblclick") {
      event.preventZoomDblClick = distance === 0;
      series.fireNodeDoubleClickEvent(event.sourceEvent, datum);
      return true;
    }
    return false;
  }
  handleFocus(seriesIndexDelta, datumIndexDelta) {
    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);
    if (overlayFocus == null) {
      if (this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta) === 0 /* SUCCESS */) {
        this.announceMode = "when-changed";
      } else {
        this.announceMode = "always";
      }
    } else {
      this.focusIndicator?.update(overlayFocus.rect, this.seriesRect, false);
      this.swapChain.update(overlayFocus.text);
      this.announceMode = "always";
    }
  }
  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {
    if (this.chart.chartType === "standalone") {
      return this.handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta);
    }
    const { focus } = this;
    const visibleSeries = focus.sortedSeries.filter((s) => s.visible && s.focusable);
    if (visibleSeries.length === 0)
      return 1 /* SERIES_NOT_FOUND */;
    const oldDatumIndex = focus.datumIndex - datumIndexDelta;
    const oldOtherIndex = focus.seriesIndex - otherIndexDelta;
    focus.seriesIndex = clamp15(0, focus.seriesIndex, visibleSeries.length - 1);
    focus.series = visibleSeries[focus.seriesIndex];
    const datumIndex = this.focus.datumIndex;
    const otherIndex = this.focus.seriesIndex;
    return this.updatePickedFocus(
      datumIndex,
      datumIndexDelta,
      oldDatumIndex,
      otherIndex,
      otherIndexDelta,
      oldOtherIndex
    );
  }
  handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta) {
    this.focus.series = this.focus.sortedSeries[0];
    const datumIndex = this.focus.datumIndex;
    const otherIndex = this.focus.seriesIndex;
    const oldDatumIndex = this.focus.datumIndex - datumIndexDelta;
    const oldOtherIndex = this.focus.seriesIndex - otherIndexDelta;
    return this.updatePickedFocus(
      datumIndex,
      datumIndexDelta,
      oldDatumIndex,
      otherIndex,
      otherIndexDelta,
      oldOtherIndex
    );
  }
  updatePickedFocus(datumIndex, datumIndexDelta, oldDatumIndex, otherIndex, otherIndexDelta, oldOtherIndex) {
    const { focus, hoverRect, seriesRect } = this;
    if (focus.series == null || hoverRect == null)
      return 1 /* SERIES_NOT_FOUND */;
    const pick = focus?.series?.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });
    if (!pick)
      return 2 /* DATUM_NOT_FOUND */;
    const { datum } = pick;
    focus.datum = datum;
    focus.datumIndex = pick.datumIndex;
    if (pick.otherIndex != null) {
      focus.seriesIndex = pick.otherIndex;
    }
    if (this.focusIndicator?.isFocusVisible()) {
      this.chart.ctx.animationManager.reset();
      const focusBBox = getPickedFocusBBox(pick);
      const { x, y } = focusBBox.computeCenter();
      if (!hoverRect.containsPoint(x, y)) {
        const panSuccess = this.chart.ctx.zoomManager.panToBBox(this.id, hoverRect, focusBBox);
        if (panSuccess) {
          return 3 /* PAN_REQUIRED */;
        }
      }
      const { x1, x2, y1, y2 } = Vec4.from(focusBBox);
      const nw = hoverRect.containsPoint(x1, y1);
      const ne = hoverRect.containsPoint(x2, y1);
      const sw = hoverRect.containsPoint(x1, y2);
      const se = hoverRect.containsPoint(x2, y2);
      if (!(nw || ne || sw || se)) {
        const hoverBounds = Vec4.from(hoverRect);
        pick.movedBounds = focusBBox.clone();
        if (x1 < hoverBounds.x1 && x2 < hoverBounds.x1) {
          pick.movedBounds.x = hoverBounds.x1 - 2;
          pick.movedBounds.width = 4;
        } else if (x1 > hoverBounds.x2 && x2 > hoverBounds.x2) {
          pick.movedBounds.x = hoverBounds.x2 - 2;
          pick.movedBounds.width = 4;
        }
        if (y1 < hoverBounds.y1 && y2 < hoverBounds.y1) {
          pick.movedBounds.y = hoverBounds.y1 - 2;
          pick.movedBounds.height = 4;
        } else if (y1 > hoverBounds.y2 && y2 > hoverBounds.y2) {
          pick.movedBounds.y = hoverBounds.y2 - 2;
          pick.movedBounds.height = 4;
        }
      }
    }
    this.focusIndicator?.update(pick.movedBounds ?? pick.bounds, this.seriesRect, pick.clipFocusBox);
    const keyboardEvent = makeKeyboardPointerEvent(focus.series, hoverRect, pick);
    if (keyboardEvent != null && this.hoverDevice === "keyboard") {
      this.tooltip.lastHover = void 0;
      this.highlight.appliedHoverEvent = void 0;
      this.highlight.pendingHoverEvent = void 0;
      this.highlight.stashedHoverEvent = void 0;
      const tooltipContent = this.getTooltipContent(focus.series, datum.datumIndex, datum, "aria-label");
      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, focus.series, datum, pick.movedBounds);
      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
      if (this.isTooltipEnabled(focus.series)) {
        this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent);
      }
      this.maybeAnnouncePickedFocus(
        datumIndexDelta,
        oldDatumIndex,
        otherIndexDelta,
        oldOtherIndex,
        pick,
        tooltipContent
      );
    }
    return 0 /* SUCCESS */;
  }
  maybeAnnouncePickedFocus(datumIndexDelta, oldDatumIndex, otherIndexDelta, oldOtherIndex, pick, tooltipContent) {
    const { focus } = this;
    let mode;
    if (this.announceMode === "when-changed") {
      const shouldAnnouncePick = datumIndexDelta === 0 && otherIndexDelta === 0 || oldDatumIndex !== pick.datumIndex || oldOtherIndex !== (pick.otherIndex ?? focus.seriesIndex);
      if (shouldAnnouncePick) {
        mode = "always";
      } else {
        mode = "never";
      }
    } else {
      mode = this.announceMode;
    }
    if (mode === "always") {
      this.swapChain.update(this.getDatumAriaText(pick.datum, tooltipContent));
    }
  }
  getDatumAriaText(datum, tooltipContent) {
    const description = tooltipContent == null ? "" : tooltipContentAriaLabel(tooltipContent);
    return this.chart.ctx.localeManager.t("ariaAnnounceHoverDatum", {
      datum: datum.series.getDatumAriaText?.(datum, description) ?? description
    });
  }
  clearHighlight() {
    this.highlight.pendingHoverEvent = void 0;
    this.highlight.appliedHoverEvent = void 0;
    this.chart.ctx.highlightManager.updateHighlight(this.id);
  }
  clearTooltip() {
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.tooltip.lastHover = void 0;
  }
  clearAll() {
    this.clearHighlight();
    this.clearTooltip();
    this.focusIndicator?.clear();
  }
  handleHoverHighlight(redisplay) {
    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;
    this.highlight.pendingHoverEvent = void 0;
    const event = this.highlight.appliedHoverEvent;
    if (!event || !this.isState(41 /* Clickable */))
      return;
    const { currentX, currentY } = event;
    const canvasX = event.currentX + (this.hoverRect?.x ?? 0);
    const canvasY = event.currentY + (this.hoverRect?.y ?? 0);
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {
      this.clearHighlight();
      return;
    }
    const { range: range3 } = this.chart.highlight;
    const intent = range3 === "tooltip" ? "highlight-tooltip" : "highlight";
    const pick = this.pickNodes({ x: currentX, y: currentY }, intent);
    if (!pick || pick.matches.length === 0) {
      this.chart.ctx.highlightManager.updateHighlight(this.id);
      return;
    }
    const { current: tooltipPick } = this.tooltipCandidates;
    const tooltipMatch = tooltipPick == null ? void 0 : pick.matches.find((m) => pickedNodesEqual(m, tooltipPick));
    const datum = tooltipMatch?.datum ?? pick.matches[0].datum;
    this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
    this.hoverDevice = "pointer";
  }
  handleHoverTooltip(event, redisplay) {
    const { current: previousHover } = this.tooltipCandidates;
    this.tooltipCandidates.reset();
    if (!this.isState(41 /* Clickable */))
      return;
    const { currentX, currentY } = event;
    const canvasX = currentX + (this.hoverRect?.x ?? 0);
    const canvasY = currentY + (this.hoverRect?.y ?? 0);
    const targetElement = event.sourceEvent.target;
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {
      if (this.hoverDevice == "pointer")
        this.clearTooltip();
      return;
    }
    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, "canvas-overlay", DEFAULT_TOOLTIP_CLASS)) {
      return;
    }
    const pick = this.pickNodes({ x: event.currentX, y: event.currentY }, "tooltip");
    if (!pick || pick.matches.length === 0) {
      if (this.hoverDevice == "pointer")
        this.clearTooltip();
      return;
    }
    this.hoverDevice = "pointer";
    if (pick.distance === 0) {
      const { current, index, length } = this.tooltipCandidates.update(
        pick.matches,
        this.chart.tooltip.pagination ? previousHover : void 0
      );
      this.showTooltip(current, canvasX, canvasY, { index, length });
    } else {
      this.showTooltip(pick.matches[0], canvasX, canvasY);
    }
  }
  showTooltip({ series, datum, datumIndex }, canvasX, canvasY, pagination) {
    const tooltipContent = this.getTooltipContent(series, datumIndex, datum, "tooltip");
    const shouldUpdateTooltip = tooltipContent != null;
    if (shouldUpdateTooltip) {
      const meta = TooltipManager.makeTooltipMeta(
        { type: "pointermove", canvasX, canvasY },
        series,
        datum,
        void 0
      );
      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent, pagination);
    } else {
      this.chart.ctx.tooltipManager.removeTooltip(this.id);
    }
  }
  maybeEnterInteractiveTooltip(event) {
    return this.chart.tooltip.maybeEnterInteractiveTooltip(event, () => {
      this.tooltip.lastHover = void 0;
      this.chart.ctx.tooltipManager.removeTooltip(this.id);
      this.chart.ctx.highlightManager.updateHighlight(this.id);
    });
  }
  changeHighlightDatum(event) {
    const lastSeries = event.previousHighlight?.series;
    const newSeries = event.currentHighlight?.series;
    if (lastSeries?.properties.cursor && event.previousHighlight?.datum) {
      this.chart.ctx.domManager.updateCursor(lastSeries.id);
    }
    if (newSeries?.properties.cursor && newSeries.properties.cursor !== "default" && event.currentHighlight?.datum) {
      this.chart.ctx.domManager.updateCursor(newSeries.id, newSeries.properties.cursor);
    }
    if (newSeries == null || lastSeries == null) {
      this.update(5 /* SERIES_UPDATE */);
    } else {
      this.update(5 /* SERIES_UPDATE */, {
        seriesToUpdate: new Set([lastSeries, newSeries].filter(Boolean))
      });
    }
  }
  pickNodes(point, intent, exactMatchOnly) {
    const reverseSeries = [...this.series].reverse();
    let result;
    for (const series of reverseSeries) {
      if (!series.visible || !series.contentGroup.visible)
        continue;
      const pick = series.pickNodes(point, intent, exactMatchOnly);
      if (pick == null || pick.datums.length === 0)
        continue;
      const { datums, distance } = pick;
      if (pick.datums.length === 0)
        continue;
      if (distance === 0) {
        if (result?.distance !== 0) {
          result = { matches: [], distance: 0 };
        }
        for (const datum of datums) {
          const { datumIndex } = datum;
          result.matches.push({ series, datum, datumIndex });
        }
      } else if (result == null || result.distance > distance) {
        const [datum] = datums;
        const { datumIndex } = datum;
        result = { matches: [{ series, datum, datumIndex }], distance };
      }
    }
    return result;
  }
  isTooltipEnabled(series) {
    return series.tooltipEnabled ?? this.chart.tooltip.enabled;
  }
  getTooltipContent(series, datumIndex, datum, purpose) {
    let result;
    if (purpose === "aria-label" || this.isTooltipEnabled(series)) {
      const { cachedTooltipContent } = this;
      if (cachedTooltipContent != null && cachedTooltipContent.series === series && cachedTooltipContent.datumIndex === datumIndex) {
        result = cachedTooltipContent.content;
      } else {
        const content = this.chart.getTooltipContent(series, datumIndex, datum);
        this.cachedTooltipContent = { series, datumIndex, content };
        result = content;
      }
      purpose;
      result;
    } else {
      this.cachedTooltipContent = void 0;
      purpose;
      result;
    }
    return result;
  }
};
function excludesType(obj, excluded) {
  return obj.type !== excluded;
}

// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts
import { clamp as clamp16 } from "ag-charts-core";
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
var SeriesLayerManager = class {
  constructor(seriesRoot) {
    this.seriesRoot = seriesRoot;
    this.groups = /* @__PURE__ */ new Map();
    this.series = /* @__PURE__ */ new Map();
    this.expectedSeriesCount = 1;
    this.mode = "normal";
  }
  setSeriesCount(count) {
    this.expectedSeriesCount = count;
  }
  getGroupIndex(seriesConfig) {
    const { internalId, seriesGrouping } = seriesConfig;
    return seriesGrouping?.groupIndex ?? internalId;
  }
  getGroupType(seriesConfig, bringToFront) {
    return bringToFront ? "top" : seriesConfig.type;
  }
  requestGroup(seriesConfig) {
    const { internalId, contentGroup: seriesContentGroup } = seriesConfig;
    const bringToFront = seriesConfig.bringToFront();
    const type = this.getGroupType(seriesConfig, bringToFront);
    const groupIndex = this.getGroupIndex(seriesConfig);
    const seriesInfo = this.series.get(internalId);
    if (seriesInfo != null) {
      throw new Error(`AG Charts - series already has an allocated layer: ${JSON.stringify(seriesInfo)}`);
    }
    if (this.series.size === 0) {
      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
    }
    let group = this.groups.get(type);
    if (group == null) {
      group = /* @__PURE__ */ new Map();
      this.groups.set(type, group);
    }
    const lookupIndex = this.lookupIdx(groupIndex);
    let groupInfo = group.get(lookupIndex);
    if (groupInfo == null) {
      groupInfo = {
        type,
        id: lookupIndex,
        seriesIds: [],
        group: this.seriesRoot.appendChild(
          new Group({
            name: `${seriesConfig.contentGroup.name ?? type}-managed-layer`,
            zIndex: seriesConfig.contentGroup.zIndex,
            // Set in updateLayerCompositing
            renderToOffscreenCanvas: false
          })
        )
      };
      group.set(lookupIndex, groupInfo);
    }
    this.series.set(internalId, { layerState: groupInfo, seriesConfig, bringToFront });
    groupInfo.seriesIds.push(internalId);
    groupInfo.group.appendChild(seriesContentGroup);
    return groupInfo.group;
  }
  changeGroup(seriesConfig) {
    const { internalId, contentGroup } = seriesConfig;
    const bringToFront = seriesConfig.bringToFront();
    const type = this.getGroupType(seriesConfig, bringToFront);
    const oldGroup = this.series.get(internalId);
    const oldType = oldGroup ? this.getGroupType(oldGroup.seriesConfig, oldGroup.bringToFront) : void 0;
    const groupIndex = this.getGroupIndex(seriesConfig);
    const lookupIndex = this.lookupIdx(groupIndex);
    const groupInfo = this.groups.get(type)?.get(lookupIndex);
    if (oldType === type && groupInfo?.seriesIds.includes(internalId) === true) {
      return;
    }
    if (this.series.has(internalId)) {
      this._releaseGroup({ internalId, contentGroup, type: oldType });
    }
    return this.requestGroup(seriesConfig);
  }
  releaseGroup(seriesConfig) {
    const { internalId, contentGroup } = seriesConfig;
    const type = this.getGroupType(seriesConfig, seriesConfig.bringToFront());
    this._releaseGroup({ internalId, contentGroup, type });
  }
  _releaseGroup(seriesConfig) {
    const { internalId, contentGroup, type } = seriesConfig;
    if (!this.series.has(internalId)) {
      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);
    }
    const groupInfo = this.series.get(internalId)?.layerState;
    if (groupInfo) {
      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);
      groupInfo.group.removeChild(contentGroup);
    }
    if (groupInfo?.seriesIds.length === 0) {
      this.seriesRoot.removeChild(groupInfo.group);
      this.groups.get(groupInfo.type)?.delete(groupInfo.id);
      this.groups.get(type)?.delete(internalId);
    } else if (groupInfo != null && groupInfo.seriesIds.length > 0) {
      groupInfo.group.zIndex = this.getLowestSeriesZIndex(groupInfo.seriesIds);
    }
    this.series.delete(internalId);
  }
  updateLayerCompositing() {
    this.groups.forEach((groups) => {
      groups.forEach((groupInfo) => {
        const { group, seriesIds } = groupInfo;
        let renderToOffscreenCanvas;
        if (seriesIds.length === 0) {
          renderToOffscreenCanvas = false;
        } else if (seriesIds.length > 1) {
          renderToOffscreenCanvas = true;
        } else {
          const series = this.series.get(seriesIds[0]);
          renderToOffscreenCanvas = series?.seriesConfig.renderToOffscreenCanvas() === true;
        }
        group.renderToOffscreenCanvas = renderToOffscreenCanvas;
        group.zIndex = this.getLowestSeriesZIndex(seriesIds);
      });
    });
  }
  lookupIdx(groupIndex) {
    if (this.mode === "normal") {
      return groupIndex;
    }
    if (typeof groupIndex === "string") {
      groupIndex = Number(groupIndex.split("-").at(-1));
      if (!Number.isFinite(groupIndex)) {
        return 0;
      }
    }
    return Math.floor(
      clamp16(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION
    );
  }
  destroy() {
    this.groups.forEach((groups) => {
      groups.forEach((groupInfo) => {
        this.seriesRoot.removeChild(groupInfo.group);
      });
    });
    this.groups.clear();
    this.series.clear();
  }
  getLowestSeriesZIndex(seriesIds) {
    let lowestSeriesZIndex = void 0;
    for (const seriesId of seriesIds) {
      const series = this.series.get(seriesId);
      const zIndex = series?.seriesConfig.contentGroup.zIndex ?? 1 /* ANY_CONTENT */;
      if (lowestSeriesZIndex == null || zIndex == null) {
        lowestSeriesZIndex = zIndex;
        continue;
      }
      lowestSeriesZIndex = compareZIndex(lowestSeriesZIndex, zIndex) <= 0 ? lowestSeriesZIndex : zIndex;
    }
    return lowestSeriesZIndex ?? 1 /* ANY_CONTENT */;
  }
};

// packages/ag-charts-community/src/chart/touch.ts
var Touch = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.dragAction = "drag";
  }
};
__decorateClass([
  Property
], Touch.prototype, "dragAction", 2);

// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts
import { CleanupRegistry as CleanupRegistry17 } from "ag-charts-core";
var DataWindowProcessor = class {
  constructor(chart, eventsHub, dataService, updateService, zoomManager, animationManager) {
    this.chart = chart;
    this.eventsHub = eventsHub;
    this.dataService = dataService;
    this.updateService = updateService;
    this.zoomManager = zoomManager;
    this.animationManager = animationManager;
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    this.lastAxisZooms = /* @__PURE__ */ new Map();
    this.cleanup = new CleanupRegistry17();
    this.cleanup.register(
      this.eventsHub.on("data:source-change", () => this.onDataSourceChange()),
      this.eventsHub.on("data:load", () => this.onDataLoad()),
      this.eventsHub.on("data:error", () => this.onDataError()),
      this.updateService.addListener("update-complete", (e) => this.onUpdateComplete(e)),
      this.eventsHub.on("zoom:change", () => this.onZoomChange())
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  onDataLoad() {
    this.animationManager.skip();
    this.updateService.update(1 /* UPDATE_DATA */);
  }
  onDataError() {
    this.updateService.update(4 /* PERFORM_LAYOUT */);
  }
  onDataSourceChange() {
    this.dirtyDataSource = true;
  }
  onUpdateComplete(event) {
    if (!event.apiUpdate && !this.dirtyZoom && !this.dirtyDataSource)
      return;
    this.updateWindow(event);
  }
  onZoomChange() {
    this.dirtyZoom = true;
  }
  updateWindow(event) {
    if (!this.dataService.isLazy())
      return;
    const axis = this.getValidAxis();
    let window2;
    let shouldRefresh = true;
    if (axis) {
      const zoom = this.zoomManager.getAxisZoom(axis.id);
      if (zoom.min !== 0 || zoom.max !== 1) {
        window2 = this.getAxisWindow(axis, zoom);
      }
      shouldRefresh = this.shouldRefresh(event, axis, zoom);
    }
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    if (!shouldRefresh)
      return;
    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });
  }
  getValidAxis() {
    return this.chart.axes.find((axis) => axis.type === "time");
  }
  shouldRefresh(event, axis, zoom) {
    if (event.apiUpdate)
      return true;
    if (this.dirtyDataSource)
      return true;
    if (!this.dirtyZoom)
      return false;
    const lastZoom = this.lastAxisZooms.get(axis.id);
    if (lastZoom && zoom.min === lastZoom.min && zoom.max === lastZoom.max) {
      return false;
    }
    this.lastAxisZooms.set(axis.id, zoom);
    return true;
  }
  getAxisWindow(axis, zoom) {
    const { domain } = axis.scale;
    if (!zoom || domain.length === 0 || isNaN(Number(domain[0])))
      return;
    const diff2 = Number(domain[1]) - Number(domain[0]);
    const min = new Date(Number(domain[0]) + diff2 * zoom.min);
    const max = new Date(Number(domain[0]) + diff2 * zoom.max);
    return { min, max };
  }
};

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
import { CleanupRegistry as CleanupRegistry18, setAttribute as setAttribute12 } from "ag-charts-core";

// packages/ag-charts-community/src/util/browser.ts
import { Logger as Logger31, getWindow as getWindow18 } from "ag-charts-core";
var isSafariRegexp = /^((?!chrome|android).)*safari/i;
var safariVersionRegexp = /Version\/(\d+(\.\d+)?)/;
var isChromeRegexp = /Chrome/;
var chromeVersionRegexp = /Chrome\/(\d+)/;
var isEdge = /Edg/;
var isOpera = /OPR/;
function isUnsupportedBrowser() {
  const { userAgent } = getWindow18("navigator");
  if (isSafariRegexp.test(userAgent)) {
    const versionExec = safariVersionRegexp.exec(userAgent);
    if (versionExec == null)
      return false;
    const version = parseFloat(versionExec[1]);
    const supported = Math.floor(version) > 16;
    if (!supported) {
      Logger31.warnOnce(`Unsupported Safari version: ${version}; ${userAgent}`);
    }
    return !supported;
  } else if (isChromeRegexp.test(userAgent) && !isEdge.test(userAgent) && !isOpera.test(userAgent)) {
    const versionExec = chromeVersionRegexp.exec(userAgent);
    if (versionExec == null)
      return false;
    const version = parseInt(versionExec[1], 10);
    const supported = version > 126;
    if (!supported) {
      Logger31.warnOnce(`Unsupported Chrome version: ${version}; ${userAgent}`);
    }
    return !supported;
  }
  return false;
}

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var visibleIgnoredSeries = /* @__PURE__ */ new Set(["map-shape-background", "map-line-background"]);
var OverlaysProcessor = class {
  constructor(chartLike, overlays, eventsHub, dataService, localeManager, animationManager, domManager) {
    this.chartLike = chartLike;
    this.overlays = overlays;
    this.eventsHub = eventsHub;
    this.dataService = dataService;
    this.localeManager = localeManager;
    this.animationManager = animationManager;
    this.domManager = domManager;
    this.cleanup = new CleanupRegistry18();
    this.overlayElem = this.domManager.addChild("canvas-overlay", "overlay");
    this.overlayElem.role = "status";
    this.overlayElem.ariaAtomic = "false";
    this.overlayElem.ariaLive = "polite";
    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);
    this.cleanup.register(this.eventsHub.on("layout:complete", (e) => this.onLayoutComplete(e)));
  }
  destroy() {
    this.cleanup.flush();
    this.domManager.removeChild("canvas-overlay", "overlay");
  }
  onLayoutComplete({ series: { rect } }) {
    const isLoading = this.dataService.isLoading();
    const hasData = this.chartLike.series.some((s) => s.hasData);
    const anySeriesVisible = this.chartLike.series.some((s) => s.visible && !visibleIgnoredSeries.has(s.type));
    if (this.overlays.darkTheme) {
      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);
    } else {
      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);
    }
    this.overlayElem.style.left = `${rect.x}px`;
    this.overlayElem.style.top = `${rect.y}px`;
    this.overlayElem.style.width = `${rect.width}px`;
    this.overlayElem.style.height = `${rect.height}px`;
    const loadingShown = isLoading;
    const noDataShown = !isLoading && !hasData;
    const noVisibleSeriesShown = hasData && !anySeriesVisible;
    const unsupportedBrowser = this.overlays.unsupportedBrowser.enabled && isUnsupportedBrowser();
    if (loadingShown) {
      this.showOverlay(this.overlays.loading, rect);
    } else {
      this.hideOverlay(this.overlays.loading);
    }
    if (noDataShown) {
      this.showOverlay(this.overlays.noData, rect);
    } else {
      this.hideOverlay(this.overlays.noData);
    }
    if (noVisibleSeriesShown) {
      this.showOverlay(this.overlays.noVisibleSeries, rect);
    } else {
      this.hideOverlay(this.overlays.noVisibleSeries);
    }
    if (unsupportedBrowser) {
      this.showOverlay(this.overlays.unsupportedBrowser, rect);
    } else {
      this.hideOverlay(this.overlays.unsupportedBrowser);
    }
    const shown = loadingShown || noDataShown || noVisibleSeriesShown || unsupportedBrowser;
    setAttribute12(this.overlayElem, "aria-hidden", !shown);
  }
  showOverlay(overlay, seriesRect) {
    if (!overlay.enabled)
      return;
    const element2 = overlay.getElement(this.chartLike, this.animationManager, this.localeManager, seriesRect);
    this.overlayElem.appendChild(element2);
  }
  hideOverlay(overlay) {
    overlay.removeElement(() => {
      this.overlayElem.innerText = "\xA0";
    }, this.animationManager);
  }
};

// packages/ag-charts-community/src/chart/chart.ts
var debug = Debug.create(true, "opts");
var _Chart = class _Chart extends Observable {
  constructor(options, resources) {
    var _a;
    super();
    this.id = createId9(this);
    this.seriesRoot = new TranslatableGroup({
      name: `${this.id}-series-root`,
      zIndex: 7 /* SERIES_LAYER */
    });
    this.annotationRoot = new TranslatableGroup({
      name: `${this.id}-annotation-root`,
      zIndex: 11 /* SERIES_ANNOTATION */
    });
    this.titleGroup = new Group({
      name: "titles",
      zIndex: 15 /* SERIES_LABEL */
    });
    this.debug = Debug.create();
    this.extraDebugStats = {};
    this.data = [];
    this._firstAutoSize = true;
    this._autoSizeNotify = new AsyncAwaitQueue();
    this.chartCaptions = new ChartCaptions();
    this.padding = new Padding(20);
    this.keyboard = new Keyboard();
    this.touch = new Touch();
    this.mode = "standalone";
    this.styleNonce = void 0;
    this.formatter = void 0;
    this.suppressFieldDotNotation = false;
    this.loadGoogleFonts = false;
    this.destroyed = false;
    this.cleanup = new CleanupRegistry19();
    this.chartAnimationPhase = "initial";
    this.modulesManager = new ModulesManager();
    this.processors = [];
    this.queuedUserOptions = [];
    this.queuedChartOptions = [];
    this.firstApply = true;
    this.syncStatus = "init";
    // Use a wrapper to comply with the @typescript-eslint/unbound-method rule.
    this.fireEventWrapper = (event) => super.fireEvent(event);
    this.apiUpdate = false;
    this._pendingFactoryUpdatesCount = 0;
    this._performUpdateSkipAnimations = false;
    this._performUpdateNotify = new AsyncAwaitQueue();
    this.performUpdateType = 8 /* NONE */;
    this.runningUpdateType = 8 /* NONE */;
    this.updateShortcutCount = 0;
    this.seriesToUpdate = /* @__PURE__ */ new Set();
    this.updateMutex = new Mutex();
    this.updateRequestors = {};
    this.performUpdateTrigger = debouncedCallback(({ count }) => {
      if (this.destroyed)
        return;
      this.updateMutex.acquire(async () => {
        try {
          await this.performUpdate(count);
        } catch (error) {
          Logger32.error("update error", error, error.stack);
        }
      }).catch((e) => Logger32.errorOnce(e));
    });
    this._performUpdateSplits = {};
    this.axes = [];
    this.series = [];
    this._cachedData = void 0;
    this.onSeriesNodeClick = (event) => {
      this.fireEvent(event);
    };
    this.onSeriesNodeDoubleClick = (event) => {
      this.fireEvent(event);
    };
    this.onSeriesVisibilityChange = (event) => {
      this.fireEvent(event);
    };
    this.seriesGroupingChanged = (event) => {
      if (!(event instanceof SeriesGroupingChangedEvent))
        return;
      const { series, seriesGrouping } = event;
      if (series.contentGroup.isRoot())
        return;
      const seriesContentNode = this.seriesLayerManager.changeGroup({
        internalId: series.internalId,
        type: series.type,
        contentGroup: series.contentGroup,
        bringToFront: () => series.bringToFront(),
        renderToOffscreenCanvas: () => series.renderToOffscreenCanvas(),
        seriesGrouping
      });
      if (seriesContentNode != null) {
        series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
      }
    };
    this.chartOptions = options;
    const scene = resources?.scene;
    const container = resources?.container ?? options.processedOptions.container ?? void 0;
    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;
    if (scene) {
      this._firstAutoSize = false;
      this._lastAutoSize = [scene.width, scene.height, scene.pixelRatio];
    }
    const root = new Group({ name: "root" });
    root.visible = false;
    root.append(this.seriesRoot);
    root.append(this.annotationRoot);
    root.append(this.titleGroup);
    this.titleGroup.append(this.title.node);
    this.titleGroup.append(this.subtitle.node);
    this.titleGroup.append(this.footnote.node);
    this.tooltip = new Tooltip();
    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);
    this.mode = options.userOptions.mode ?? this.mode;
    this.styleNonce = options.processedOptions.styleNonce;
    const ctx = this.ctx = new ChartContext(this, {
      chartType: this.getChartType(),
      scene,
      root,
      container,
      styleContainer,
      domMode: options.optionMetadata.domMode,
      withDragInterpretation: options.optionMetadata.withDragInterpretation ?? true,
      syncManager: new SyncManager(this),
      fireEvent: (event) => this.fireEvent(event),
      updateCallback: (type, opts) => this.update(type, opts),
      updateMutex: this.updateMutex
    });
    this.cleanup.register(ctx.eventsHub.on("dom:resize", () => this.parentResize(ctx.domManager.containerSize)));
    this.overlays = new ChartOverlays();
    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));
    this.processors = [
      new DataWindowProcessor(
        this,
        ctx.eventsHub,
        ctx.dataService,
        ctx.updateService,
        ctx.zoomManager,
        ctx.animationManager
      ),
      new OverlaysProcessor(
        this,
        this.overlays,
        ctx.eventsHub,
        ctx.dataService,
        ctx.localeManager,
        ctx.animationManager,
        ctx.domManager
      )
    ];
    this.highlight = new ChartHighlight();
    this.container = container;
    const moduleContext = this.getModuleContext();
    ctx.domManager.setDataBoolean("animating", false);
    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());
    this.cleanup.register(
      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {
        e.layoutBox.shrink(this.padding.toJson());
        this.chartCaptions.positionCaptions(e);
      }),
      ctx.eventsHub.on("layout:complete", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),
      ctx.eventsHub.on("data:load", (event) => {
        this.data = event.data;
      }),
      this.title.registerInteraction(moduleContext, "beforebegin"),
      this.subtitle.registerInteraction(moduleContext, "beforebegin"),
      this.footnote.registerInteraction(moduleContext, "afterend"),
      Widget.addWindowEvent("page-left", () => this.destroy()),
      ctx.animationManager.addListener("animation-frame", () => {
        this.update(7 /* SCENE_RENDER */);
      }),
      ctx.animationManager.addListener("animation-start", () => ctx.domManager.setDataBoolean("animating", true)),
      ctx.animationManager.addListener("animation-stop", () => ctx.domManager.setDataBoolean("animating", false)),
      ctx.eventsHub.on("zoom:change", () => {
        this.series.forEach((s) => s.animationState?.transition("updateData"));
        const skipAnimations = this.chartAnimationPhase !== "initial";
        this.update(4 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      })
    );
    this.parentResize(ctx.domManager.containerSize);
  }
  static getInstance(element2) {
    return _Chart.chartsInstances.get(element2);
  }
  /** NOTE: This is exposed for use by Integrated charts only. */
  get canvasElement() {
    return this.ctx.scene.canvas.element;
  }
  download(fileName, fileFormat) {
    this.ctx.scene.download(fileName, fileFormat);
  }
  getCanvasDataURL(fileFormat) {
    return this.ctx.scene.getDataURL(fileFormat);
  }
  toSVG() {
    return this.ctx.scene.toSVG();
  }
  get seriesAreaBoundingBox() {
    return this.seriesAreaManager.bbox;
  }
  getOptions() {
    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;
  }
  getChartOptions() {
    return this.queuedChartOptions.at(-1) ?? this.chartOptions;
  }
  overrideFocusVisible(visible) {
    this.seriesAreaManager.focusIndicator?.overrideFocusVisible(visible);
  }
  fireEvent(event) {
    callWithContext(this, this.fireEventWrapper, event);
  }
  initSeriesAreaDependencies() {
    const { ctx, tooltip, highlight: highlight5, overlays, seriesRoot, mode } = this;
    const chartType = this.getChartType();
    const fireEvent = this.fireEvent.bind(this);
    const getUpdateType = () => this.performUpdateType;
    const getTooltipContent = (series, datumIndex, removeThisDatum) => this.getTooltipContent(series, datumIndex, removeThisDatum);
    return {
      fireEvent,
      getUpdateType,
      getTooltipContent,
      chartType,
      ctx,
      tooltip,
      highlight: highlight5,
      overlays,
      seriesRoot,
      mode
    };
  }
  getModuleContext() {
    return this.ctx;
  }
  getTooltipContent(series, datumIndex, removeMeDatum) {
    const baseTooltipContent = series.properties.tooltip.enabled !== false ? series.getTooltipContent(datumIndex, removeMeDatum) : void 0;
    const tooltipContent = baseTooltipContent == null ? [] : [baseTooltipContent];
    if (this.tooltip.mode !== "shared" || this.series.length === 1) {
      return tooltipContent;
    }
    const categoryValue = series.getCategoryValue(datumIndex);
    if (categoryValue == null)
      return tooltipContent;
    return this.series.flatMap((s) => {
      if (s === series)
        return tooltipContent;
      if (!s.isEnabled() || s.properties.tooltip.enabled === false)
        return [];
      const seriesDatumIndex = s.datumIndexForCategoryValue(categoryValue);
      const seriesTooltipContent = seriesDatumIndex == null ? void 0 : s.getTooltipContent(seriesDatumIndex, void 0);
      return seriesTooltipContent == null ? [] : [seriesTooltipContent];
    });
  }
  getCaptionText() {
    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(". ");
  }
  getAriaLabel() {
    return this.ctx.localeManager.t("ariaAnnounceChart", { seriesCount: this.series.length });
  }
  resetAnimations() {
    this.chartAnimationPhase = "initial";
    for (const series of this.series) {
      series.resetAnimation(this.chartAnimationPhase);
    }
    for (const axis of this.axes) {
      axis.resetAnimation(this.chartAnimationPhase);
    }
    this.animationRect = void 0;
    this.ctx.animationManager.reset();
  }
  skipAnimations() {
    this.ctx.animationManager.skipCurrentBatch();
    this._performUpdateSkipAnimations = true;
  }
  detachAndClear() {
    this.container = void 0;
    this.ctx.scene.clearCanvas();
  }
  destroy(opts) {
    if (this.destroyed) {
      return;
    }
    const keepTransferableResources = opts?.keepTransferableResources;
    let result;
    this.performUpdateType = 8 /* NONE */;
    this.cleanup.flush();
    this.processors.forEach((p) => p.destroy());
    this.overlays.destroy();
    this.modulesManager.destroy();
    if (keepTransferableResources) {
      this.ctx.scene.strip();
      result = {
        container: this.container,
        scene: this.ctx.scene
      };
    } else {
      this.ctx.scene.destroy();
      this.container = void 0;
    }
    this.destroySeries(this.series);
    this.seriesLayerManager.destroy();
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this.animationRect = void 0;
    this.ctx.destroy();
    this.destroyed = true;
    Object.freeze(this);
    return result;
  }
  requestFactoryUpdate(cb) {
    if (this.destroyed)
      return;
    this._pendingFactoryUpdatesCount++;
    this.updateMutex.acquire(async () => {
      if (this.destroyed)
        return;
      try {
        await cb(this);
      } finally {
        if (!this.destroyed) {
          this._pendingFactoryUpdatesCount--;
        }
      }
    }).catch((e) => Logger32.errorOnce(e));
  }
  clearCallbackCache() {
    this.ctx.callbackCache.invalidateCache();
    for (const series of this.series) {
      series.resetDatumCallbackCache();
    }
  }
  update(type = 0 /* FULL */, opts) {
    if (this.destroyed)
      return;
    const {
      forceNodeDataRefresh = false,
      skipAnimations,
      seriesToUpdate = this.series,
      newAnimationBatch,
      apiUpdate = false
    } = opts ?? {};
    this.apiUpdate = apiUpdate;
    this.ctx.widgets.seriesWidget.setDragTouchEnabled(this.touch.dragAction !== "none");
    if (forceNodeDataRefresh) {
      this.series.forEach((series) => series.markNodeDataDirty());
    }
    for (const series of seriesToUpdate) {
      this.seriesToUpdate.add(series);
    }
    if (skipAnimations) {
      this.ctx.animationManager.skipCurrentBatch();
      this._performUpdateSkipAnimations = true;
    }
    if (newAnimationBatch && this.ctx.animationManager.isActive()) {
      this._performUpdateSkipAnimations = true;
    }
    if (this.debug.check()) {
      let stack = new Error().stack ?? "<unknown>";
      stack = stack.replace(/\([^)]*/g, "");
      this.updateRequestors[stack] = type;
    }
    if (type < this.performUpdateType) {
      this.performUpdateType = type;
      this.ctx.domManager.setDataBoolean("updatePending", true);
      this.performUpdateTrigger.schedule(opts?.backOffMs);
    }
  }
  async performUpdate(count) {
    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;
    const seriesToUpdate = [...this.seriesToUpdate];
    this.clearCallbackCache();
    this.performUpdateType = 8 /* NONE */;
    this.seriesToUpdate.clear();
    this.runningUpdateType = performUpdateType;
    if (this.updateShortcutCount === 0 && performUpdateType < 7 /* SCENE_RENDER */) {
      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);
      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = "ready");
    }
    this.ctx.scene.updateDebugFlags();
    this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
    let previousSplit = performance.now();
    splits.start ?? (splits.start = previousSplit);
    const updateSplits = (splitName) => {
      splits[splitName] ?? (splits[splitName] = 0);
      splits[splitName] += performance.now() - previousSplit;
      previousSplit = performance.now();
    };
    switch (performUpdateType) {
      case 0 /* FULL */:
        if (this.checkUpdateShortcut(0 /* FULL */))
          break;
        this.ctx.updateService.dispatchPreDomUpdate();
        this.updateDOM();
      case 1 /* UPDATE_DATA */:
        if (this.checkUpdateShortcut(1 /* UPDATE_DATA */))
          break;
        await this.updateData();
        updateSplits("\u2B07\uFE0F");
      case 2 /* PROCESS_DATA */:
        if (this.checkUpdateShortcut(2 /* PROCESS_DATA */))
          break;
        await this.processData();
        this.seriesAreaManager.dataChanged();
        updateSplits("\u{1F3ED}");
      case 3 /* PROCESS_DOMAIN */:
        if (this.checkUpdateShortcut(3 /* PROCESS_DOMAIN */))
          break;
        await this.processDomains();
        updateSplits("\u26F0\uFE0F");
      case 4 /* PERFORM_LAYOUT */:
        await this.checkFirstAutoSize();
        if (this.checkUpdateShortcut(4 /* PERFORM_LAYOUT */))
          break;
        await this.processLayout();
        updateSplits("\u2316");
      case 5 /* SERIES_UPDATE */: {
        if (this.checkUpdateShortcut(5 /* SERIES_UPDATE */))
          break;
        await this.updateSeries(seriesToUpdate);
        updateSplits("\u{1F914}");
        this.updateAriaLabels();
        this.seriesLayerManager.updateLayerCompositing();
      }
      case 6 /* PRE_SCENE_RENDER */:
        if (this.checkUpdateShortcut(6 /* PRE_SCENE_RENDER */))
          break;
        ctx.updateService.dispatchPreSceneRender();
        updateSplits("\u2196");
      case 7 /* SCENE_RENDER */:
        if (this.checkUpdateShortcut(7 /* SCENE_RENDER */))
          break;
        ctx.animationManager.endBatch();
        extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
        ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });
        this.extraDebugStats = {};
        for (const key of Object.keys(splits)) {
          delete splits[key];
        }
        this.ctx.domManager.incrementDataCounter("sceneRenders");
        this.ctx.domManager.postRenderUpdate();
      case 8 /* NONE */:
        this.updateShortcutCount = 0;
        this.updateRequestors = {};
        this._performUpdateSkipAnimations = false;
        ctx.animationManager.endBatch();
    }
    if (!this.destroyed) {
      ctx.updateService.dispatchUpdateComplete(this.apiUpdate);
      this.apiUpdate = false;
      this.ctx.domManager.setDataBoolean("updatePending", false);
      this.runningUpdateType = 8 /* NONE */;
      this.syncStatus = "ready";
    }
    this._performUpdateNotify.notify();
    const end2 = performance.now();
    this.debug("Chart.performUpdate() - end", {
      chart: this,
      durationMs: Math.round((end2 - splits["start"]) * 100) / 100,
      count,
      performUpdateType: ChartUpdateType[performUpdateType]
    });
  }
  updateThemeClassName() {
    const themeClassNamePrefix = "ag-charts-theme-";
    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];
    let themeClassName = validThemeClassNames[0];
    let isDark = false;
    let { theme } = this.chartOptions.processedOptions;
    while (typeof theme !== "string" && theme != null) {
      theme = theme.baseTheme;
    }
    if (typeof theme === "string") {
      themeClassName = theme.replace("ag-", themeClassNamePrefix);
      isDark = theme.includes("-dark");
    }
    if (!validThemeClassNames.includes(themeClassName)) {
      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];
    }
    this.ctx.domManager.setThemeClass(themeClassName);
  }
  updateDOM() {
    this.updateThemeClassName();
    const { enabled, tabIndex } = this.keyboard;
    this.ctx.domManager.setTabGuardIndex(enabled ? tabIndex ?? 0 : -1);
    this.ctx.domManager.setThemeParameters(this.chartOptions.themeParameters);
  }
  updateAriaLabels() {
    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());
  }
  checkUpdateShortcut(checkUpdateType) {
    const maxShortcuts = 3;
    if (this.destroyed)
      return true;
    if (this.updateShortcutCount > maxShortcuts) {
      Logger32.warn(
        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,
        this.updateRequestors
      );
      return false;
    }
    if (this.performUpdateType <= checkUpdateType) {
      this.updateShortcutCount++;
      return true;
    }
    return false;
  }
  async checkFirstAutoSize() {
    if (this.width != null && this.height != null) {
    } else if (!this._lastAutoSize) {
      const success = await this._autoSizeNotify.await(500);
      if (!success) {
        this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
      }
    }
  }
  onAxisChange(newValue, oldValue) {
    if (oldValue == null && newValue.length === 0)
      return;
    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);
  }
  onSeriesChange(newValue, oldValue) {
    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];
    this.destroySeries(seriesToDestroy);
    this.seriesLayerManager?.setSeriesCount(newValue.length);
    for (const series of newValue) {
      if (oldValue?.includes(series))
        continue;
      const seriesContentNode = this.seriesLayerManager.requestGroup(series);
      series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
      const chart = this;
      series.chart = {
        get mode() {
          return chart.mode;
        },
        get isMiniChart() {
          return false;
        },
        get seriesRect() {
          return chart.seriesRect;
        }
      };
      series.resetAnimation(this.chartAnimationPhase);
      this.addSeriesListeners(series);
      series.addChartEventListeners();
    }
    this.seriesAreaManager?.seriesChanged(newValue);
  }
  destroySeries(allSeries) {
    allSeries?.forEach((series) => {
      series.removeEventListener("seriesNodeClick", this.onSeriesNodeClick);
      series.removeEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
      series.removeEventListener("groupingChanged", this.seriesGroupingChanged);
      series.destroy();
      this.seriesLayerManager.releaseGroup(series);
      series.detachSeries(void 0, this.seriesRoot, this.annotationRoot);
      series.chart = void 0;
    });
  }
  addSeriesListeners(series) {
    if (this.hasEventListener("seriesNodeClick")) {
      series.addEventListener("seriesNodeClick", this.onSeriesNodeClick);
    }
    if (this.hasEventListener("seriesNodeDoubleClick")) {
      series.addEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
    }
    if (this.hasEventListener("seriesVisibilityChange")) {
      series.addEventListener("seriesVisibilityChange", this.onSeriesVisibilityChange);
    }
    series.addEventListener("groupingChanged", this.seriesGroupingChanged);
  }
  assignSeriesToAxes() {
    for (const axis of this.axes) {
      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);
    }
  }
  assignAxesToSeries() {
    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);
    for (const series of this.series) {
      for (const direction of series.directions) {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger32.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = directionAxes.find(
          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))
        );
        if (!newAxis) {
          Logger32.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      }
    }
  }
  parentResize(size) {
    if (size == null || this.width != null && this.height != null)
      return;
    let { width: width2, height: height2 } = size;
    const { pixelRatio } = size;
    width2 = Math.floor(width2);
    height2 = Math.floor(height2);
    if (width2 === 0 && height2 === 0)
      return;
    const [autoWidth = 0, autoHeight = 0, autoPixelRatio = 1] = this._lastAutoSize ?? [];
    if (autoWidth === width2 && autoHeight === height2 && autoPixelRatio === pixelRatio)
      return;
    this._lastAutoSize = [width2, height2, pixelRatio];
    this.resize("SizeMonitor", {});
  }
  resize(source, opts) {
    const { scene, animationManager } = this.ctx;
    const { inWidth, inHeight, inMinWidth, inMinHeight, inOverrideDevicePixelRatio } = opts;
    this.ctx.domManager.setSizeOptions(
      inMinWidth ?? this.minWidth,
      inMinHeight ?? this.minHeight,
      inWidth ?? this.width,
      inHeight ?? this.height
    );
    const width2 = inWidth ?? this.width ?? this._lastAutoSize?.[0];
    const height2 = inHeight ?? this.height ?? this._lastAutoSize?.[1];
    const pixelRatio = inOverrideDevicePixelRatio ?? this.overrideDevicePixelRatio ?? this._lastAutoSize?.[2];
    this.debug(`Chart.resize() from ${source}`, { width: width2, height: height2, pixelRatio, stack: new Error().stack });
    if (width2 == null || height2 == null || !isFiniteNumber3(width2) || !isFiniteNumber3(height2))
      return;
    if (scene.resize(width2, height2, pixelRatio)) {
      animationManager.reset();
      let skipAnimations = true;
      if ((this.width == null || this.height == null) && this._firstAutoSize) {
        skipAnimations = false;
        this._firstAutoSize = false;
      }
      this.update(4 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      this._autoSizeNotify.notify();
    }
  }
  async updateData() {
    this.series.forEach((s) => s.setChartData(this.data));
    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));
    await Promise.all(modulePromises);
  }
  async processData() {
    if (this.series.some((s) => s.canHaveAxes)) {
      this.assignAxesToSeries();
      this.assignSeriesToAxes();
    }
    const dataController = new DataController(this.mode, this.suppressFieldDotNotation);
    const seriesPromises = this.series.map((s) => s.processData(dataController));
    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));
    this._cachedData = dataController.execute(this._cachedData);
    await Promise.all([...seriesPromises, ...modulePromises]);
    this.updateLegends();
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async processDomains() {
    for (const axis of this.axes) {
      axis.processData();
    }
    for (const series of this.series) {
      series.updatedDomains();
    }
  }
  updateLegends(initialStateLegend) {
    for (const { legend, legendType } of this.modulesManager.legends()) {
      if (legendType === "category") {
        this.setCategoryLegendData(initialStateLegend);
      } else {
        this.setLegendData(legendType, legend);
      }
    }
  }
  setCategoryLegendData(initialState) {
    var _a;
    const {
      ctx: { legendManager, stateManager }
    } = this;
    if (initialState) {
      this.series.forEach((s) => {
        const seriesState = initialState.find((init) => init.seriesId === s.id);
        s.onLegendInitialState("category", seriesState);
      });
    }
    const legendData = this.series.flatMap((s) => {
      const seriesLegendData = s.getLegendData("category");
      legendManager.updateData(s.id, seriesLegendData);
      return seriesLegendData;
    });
    if (initialState) {
      stateManager.setStateAndRestore(legendManager, initialState);
      return;
    }
    if (this.mode !== "integrated") {
      const seriesMarkerFills = {};
      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));
      for (const {
        seriesId,
        symbol: { marker },
        label
      } of legendData.filter((d) => !d.hideInLegend)) {
        if (marker.fill == null)
          continue;
        const seriesType = seriesTypeMap.get(seriesId);
        const markerFill = seriesMarkerFills[seriesType] ?? (seriesMarkerFills[seriesType] = {});
        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);
        if (markerFill[label.text] !== marker.fill) {
          Logger32.warnOnce(
            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`
          );
        }
      }
    }
    legendManager.update();
  }
  setLegendData(legendType, legend) {
    legend.data = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));
  }
  async processLayout() {
    const oldRect = this.animationRect;
    const { width: width2, height: height2 } = this.ctx.scene;
    const ctx = this.ctx.layoutManager.createContext(width2, height2);
    await this.performLayout(ctx);
    if (oldRect && !this.animationRect?.equals(oldRect)) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
  }
  async updateSeries(seriesToUpdate) {
    const { seriesRect } = this;
    await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));
    this.ctx.seriesLabelLayoutManager.updateLabels(
      this.series.filter((s) => s.visible && s.usesPlacedLabels),
      this.padding,
      this.seriesRect
    );
  }
  async waitForUpdate(timeoutMs, failOnTimeout) {
    const agChartsDebugTimeout = getWindow19("agChartsDebugTimeout");
    if (agChartsDebugTimeout == null) {
      timeoutMs ?? (timeoutMs = 1e5);
      failOnTimeout ?? (failOnTimeout = false);
    } else {
      timeoutMs = agChartsDebugTimeout;
      failOnTimeout ?? (failOnTimeout = true);
    }
    const start2 = performance.now();
    while (this._pendingFactoryUpdatesCount > 0 || this.performUpdateType !== 8 /* NONE */ || this.runningUpdateType !== 8 /* NONE */ || this.ctx.scene.waitingForUpdate()) {
      if (this.destroyed)
        break;
      if (this._pendingFactoryUpdatesCount > 0) {
        await this.updateMutex.waitForClearAcquireQueue();
      }
      if (this.performUpdateType !== 8 /* NONE */ || this.runningUpdateType !== 8 /* NONE */) {
        await this._performUpdateNotify.await();
      }
      if (performance.now() - start2 > timeoutMs) {
        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;
        if (failOnTimeout) {
          throw new Error(message);
        } else {
          Logger32.warnOnce(message);
        }
      }
      if (isInputPending()) {
        await pause();
      }
      if (this.ctx.scene.waitingForUpdate()) {
        await pause(50);
      }
    }
  }
  filterMiniChartSeries(series) {
    return series?.filter((s) => s.showInMiniChart !== false);
  }
  applyOptions(newChartOptions) {
    const minimumUpdateType = 4 /* PERFORM_LAYOUT */;
    const deltaOptions = this.firstApply ? newChartOptions.processedOptions : newChartOptions.diffOptions(this.chartOptions);
    if (deltaOptions == null || Object.keys(deltaOptions).length === 0) {
      debug("Chart.applyOptions() - no delta, forcing re-layout", deltaOptions);
      this.update(minimumUpdateType, { apiUpdate: true, newAnimationBatch: true });
      return;
    }
    const oldOpts = this.firstApply ? {} : this.chartOptions.processedOptions;
    const newOpts = newChartOptions.processedOptions;
    debug("Chart.applyOptions() - applying delta", deltaOptions);
    const modulesChanged = this.applyModules(newOpts);
    const skip = [
      "type",
      "data",
      "series",
      "listeners",
      "preset",
      "theme",
      "legend.listeners",
      "navigator.miniChart.series",
      "navigator.miniChart.label",
      "locale.localeText",
      "axes",
      "topology",
      "nodes",
      "initialState",
      "styleContainer",
      "formatter"
    ];
    if (deltaOptions.listeners) {
      this.registerListeners(this, deltaOptions.listeners);
    }
    jsonApply(this, deltaOptions, { skip });
    let forceNodeDataRefresh = false;
    let seriesStatus = "no-op";
    if (deltaOptions.series != null) {
      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);
      forceNodeDataRefresh = true;
    }
    if (seriesStatus === "replaced") {
      this.resetAnimations();
    }
    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [])) {
      forceNodeDataRefresh = true;
    }
    if (deltaOptions.data) {
      this.data = deltaOptions.data;
    }
    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled("legend")) {
      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
    }
    if (deltaOptions.locale?.localeText) {
      this.modulesManager.getModule("locale").localeText = deltaOptions.locale?.localeText;
    }
    this.chartOptions = newChartOptions;
    const navigatorModule = this.modulesManager.getModule("navigator");
    const zoomModule = this.modulesManager.getModule("zoom");
    if (!navigatorModule?.enabled && !zoomModule?.enabled) {
      this.ctx.zoomManager.updateZoom("chart");
    }
    const miniChart = navigatorModule?.miniChart;
    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;
    if (miniChart?.enabled === true && miniChartSeries != null) {
      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);
    } else if (miniChart?.enabled === false) {
      miniChart.series = [];
      miniChart.axes = [];
    }
    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);
    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));
    const majorChange = forceNodeDataRefresh || modulesChanged;
    const updateType = majorChange ? 0 /* FULL */ : minimumUpdateType;
    this.maybeResetAnimations(seriesStatus);
    if (this.shouldClearLegendData(newOpts, oldOpts, seriesStatus)) {
      this.ctx.legendManager.clearData();
    }
    this.applyInitialState(newOpts);
    this.ctx.formatManager.setFormatter(newOpts.formatter);
    debug("Chart.applyOptions() - update type", ChartUpdateType[updateType], {
      seriesStatus,
      forceNodeDataRefresh
    });
    if (newChartOptions.optionsProcessingTime !== void 0) {
      this._performUpdateSplits["\u2699\uFE0F"] = newChartOptions.optionsProcessingTime;
      const optionsStartTime = performance.now() - newChartOptions.optionsProcessingTime;
      this._performUpdateSplits.start = optionsStartTime;
    }
    this.update(updateType, { apiUpdate: true, forceNodeDataRefresh, newAnimationBatch: true });
    this.firstApply = false;
  }
  applyInitialState(options) {
    const { annotationManager, chartTypeOriginator, historyManager, stateManager, zoomManager } = this.ctx;
    const { initialState } = options;
    if ("annotations" in options && options.annotations?.enabled && initialState?.annotations != null) {
      const annotations = initialState.annotations.map((annotation) => {
        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);
        return mergeDefaults(annotation, annotationTheme);
      });
      stateManager.setState(annotationManager, annotations);
    }
    if (initialState?.chartType != null) {
      stateManager.setState(chartTypeOriginator, initialState.chartType);
    }
    if ((options.navigator?.enabled || options.zoom?.enabled) && initialState?.zoom != null) {
      stateManager.setState(zoomManager, initialState.zoom);
    }
    if (initialState?.legend != null) {
      this.updateLegends(initialState.legend);
    }
    if (initialState != null) {
      historyManager.clear();
    }
  }
  maybeResetAnimations(seriesStatus) {
    if (this.mode !== "standalone")
      return;
    switch (seriesStatus) {
      case "series-grouping-change":
      case "replaced":
        this.resetAnimations();
        break;
      default:
    }
  }
  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {
    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
    const legendKeys = legendRegistry.getKeys();
    const optionsHaveLegend = Object.values(legendKeys).some(
      (legendKey) => deltaOptions[legendKey] != null
    );
    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null || deltaOptions.formatter != null;
    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
  }
  shouldClearLegendData(options, oldOpts, seriesStatus) {
    const seriesChanged = seriesStatus === "replaced" || seriesStatus === "series-grouping-change" || seriesStatus === "updated" && (options.series?.length !== oldOpts.series?.length || !options.series?.every((s, i) => s.type === oldOpts.series?.[i].type));
    const legendRemoved = oldOpts.legend != null && options.legend == null;
    return seriesChanged || legendRemoved;
  }
  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {
    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;
    const miniChartSeriesStatus = this.applySeries(
      miniChart,
      this.filterMiniChartSeries(miniChartSeries),
      this.filterMiniChartSeries(oldSeries)
    );
    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [
      "axes[].tick",
      "axes[].thickness",
      "axes[].title",
      "axes[].crosshair",
      "axes[].gridLine",
      "axes[].label"
    ]);
    const series = miniChart.series;
    for (const s of series) {
      s.properties.id = void 0;
    }
    const axes = miniChart.axes;
    const horizontalAxis = axes.find((axis) => axis.direction === "x" /* X */);
    for (const axis of axes) {
      axis.nice = false;
      axis.gridLine.enabled = false;
      axis.label.enabled = axis === horizontalAxis;
      axis.tick.enabled = false;
      axis.interactionEnabled = false;
    }
    if (horizontalAxis != null) {
      const miniChartOpts = completeOptions.navigator?.miniChart;
      const labelOptions = miniChartOpts?.label;
      const intervalOptions = miniChartOpts?.label?.interval;
      horizontalAxis.line.enabled = false;
      horizontalAxis.label.set(
        without(labelOptions, [
          "interval",
          "autoRotate",
          "autoRotateAngle",
          "itemStyler",
          "minSpacing",
          "rotation"
        ])
      );
      if (horizontalAxis.type === "grouped-category") {
        horizontalAxis.label.enabled = false;
        horizontalAxis.label.rotation = 0;
        const { depthOptions } = horizontalAxis;
        if (depthOptions.length === 0) {
          depthOptions.set([{ label: { enabled: true } }]);
        } else {
          for (let i = 1; i < depthOptions.length; i++) {
            depthOptions[i].label.enabled = false;
          }
        }
      } else if (horizontalAxis.type === "time" || horizontalAxis.type === "unit-time" || horizontalAxis.type === "ordinal-time") {
        horizontalAxis.parentLevel.enabled = false;
      }
      horizontalAxis.interval.step = intervalOptions?.step;
      horizontalAxis.interval.values = intervalOptions?.values;
      horizontalAxis.interval.minSpacing = intervalOptions?.minSpacing;
      horizontalAxis.interval.maxSpacing = intervalOptions?.maxSpacing;
    }
  }
  applyModules(options) {
    const { type: chartType } = this.constructor;
    let modulesChanged = false;
    for (const module of moduleRegistry.byType("root", "legend")) {
      const isConfigured = options[module.optionsKey] != null;
      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType);
      if (shouldBeEnabled === this.modulesManager.isEnabled(module))
        continue;
      if (shouldBeEnabled) {
        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));
        if (module.type === "legend") {
          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);
        }
        this[module.optionsKey] = this.modulesManager.getModule(module);
      } else {
        this.modulesManager.removeModule(module);
        delete this[module.optionsKey];
      }
      modulesChanged = true;
    }
    return modulesChanged;
  }
  initSeriesDeclarationOrder(series) {
    for (let idx = 0; idx < series.length; idx++) {
      series[idx].setSeriesIndex(idx);
    }
  }
  applySeries(chart, optSeries, oldOptSeries) {
    if (!optSeries) {
      return "no-change";
    }
    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
    if (matchResult.status === "no-overlap") {
      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);
      const chartSeries = optSeries.map((opts) => this.createSeries(opts));
      this.initSeriesDeclarationOrder(chartSeries);
      chart.series = chartSeries;
      return "replaced";
    }
    debug(`Chart.applySeries() - matchResult`, matchResult);
    const seriesInstances = [];
    let dataChanged = false;
    let groupingChanged = false;
    let isUpdated = false;
    const changes = matchResult.changes.toSorted((a, b) => a.targetIdx - b.targetIdx);
    for (const change of changes) {
      groupingChanged || (groupingChanged = change.status === "series-grouping");
      dataChanged || (dataChanged = change.diff?.data != null);
      isUpdated || (isUpdated = change.status !== "no-op");
      switch (change.status) {
        case "add": {
          const newSeries = this.createSeries(change.opts);
          seriesInstances.push(newSeries);
          debug(`Chart.applySeries() - created new series`, newSeries);
          break;
        }
        case "remove":
          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);
          break;
        case "no-op":
          seriesInstances.push(change.series);
          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);
          break;
        case "series-grouping":
        case "update":
        default: {
          const { series, diff: diff2, idx } = change;
          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);
          this.applySeriesValues(series, diff2);
          series.markNodeDataDirty();
          seriesInstances.push(series);
        }
      }
    }
    this.initSeriesDeclarationOrder(seriesInstances);
    debug(`Chart.applySeries() - final series instances`, seriesInstances);
    chart.series = seriesInstances;
    if (groupingChanged) {
      return "series-grouping-change";
    }
    if (dataChanged) {
      return "data-change";
    }
    return isUpdated ? "updated" : "no-op";
  }
  applyAxes(chart, options, oldOpts, seriesStatus, skip = []) {
    if (!("axes" in options) || !options.axes) {
      return false;
    }
    skip = ["axes[].type", ...skip];
    const axes = options.axes;
    const forceRecreate = seriesStatus === "replaced";
    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);
    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
      chart.axes.forEach((axis, index) => {
        const previousOpts = oldOpts.axes?.[index] ?? {};
        const axisDiff = jsonDiff(previousOpts, axes[index]);
        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);
        const path = `axes[${index}]`;
        jsonApply(axis, axisDiff, { path, skip });
      });
      return true;
    }
    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);
    chart.axes = this.createAxis(axes, skip);
    return true;
  }
  createSeries(seriesOptions) {
    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());
    this.applySeriesOptionModules(seriesInstance, seriesOptions);
    this.applySeriesValues(seriesInstance, seriesOptions);
    return seriesInstance;
  }
  applySeriesOptionModules(series, options) {
    const moduleContext = series.createModuleContext();
    const moduleMap = series.getModuleMap();
    for (const module of moduleRegistry.byType("series-option")) {
      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {
        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));
      }
    }
  }
  applySeriesValues(target, options) {
    const moduleMap = target.getModuleMap();
    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;
    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {
      if (moduleDef.type !== "series-option")
        continue;
      if (moduleDef.optionsKey in seriesOptions) {
        const module = moduleMap.getModule(moduleDef.optionsKey);
        if (module) {
          const moduleOptions = seriesOptions[moduleDef.optionsKey];
          delete seriesOptions[moduleDef.optionsKey];
          module.properties.set(moduleOptions);
        }
      }
    }
    if (seriesOptions.visible != null) {
      target.visible = seriesOptions.visible;
    }
    target.properties.set(seriesOptions);
    if ("data" in options) {
      target.setOptionsData(data);
    }
    if (listeners) {
      this.registerListeners(target, listeners);
    }
    if ("seriesGrouping" in options) {
      if (seriesGrouping == null) {
        target.seriesGrouping = void 0;
      } else {
        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };
      }
    }
  }
  createAxis(options, skip) {
    const newAxes = [];
    const moduleContext = this.getModuleContext();
    for (let index = 0; index < options.length; index++) {
      const axisOptions = options[index];
      const axis = axisRegistry.create(axisOptions.type, moduleContext);
      this.applyAxisModules(axis, axisOptions);
      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });
      newAxes.push(axis);
    }
    guessInvalidPositions(newAxes);
    return newAxes;
  }
  applyAxisModules(axis, options) {
    const moduleContext = axis.createModuleContext();
    const moduleMap = axis.getModuleMap();
    for (const module of moduleRegistry.byType("axis-option")) {
      const shouldBeEnabled = options[module.optionsKey] != null;
      if (shouldBeEnabled === moduleMap.isEnabled(module))
        continue;
      if (shouldBeEnabled) {
        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));
        axis[module.optionsKey] = moduleMap.getModule(module);
      } else {
        moduleMap.removeModule(module);
        delete axis[module.optionsKey];
      }
    }
  }
  registerListeners(source, listeners) {
    source.clearEventListeners();
    for (const [property, listener] of entries5(listeners)) {
      source.addEventListener(property, listener);
    }
  }
};
_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    newValue(value) {
      if (this.destroyed)
        return;
      this.ctx.domManager.setContainer(value);
      _Chart.chartsInstances.set(value, this);
    },
    oldValue(value) {
      _Chart.chartsInstances.delete(value);
    }
  })
], _Chart.prototype, "container", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("width option", { inWidth: value });
    }
  })
], _Chart.prototype, "width", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("height option", { inHeight: value });
    }
  })
], _Chart.prototype, "height", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minWidth option", { inMinWidth: value });
    }
  })
], _Chart.prototype, "minWidth", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minHeight option", { inMinHeight: value });
    }
  })
], _Chart.prototype, "minHeight", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("overrideDevicePixelRatio option", { inOverrideDevicePixelRatio: value });
    }
  })
], _Chart.prototype, "overrideDevicePixelRatio", 2);
__decorateClass([
  Property
], _Chart.prototype, "padding", 2);
__decorateClass([
  Property
], _Chart.prototype, "keyboard", 2);
__decorateClass([
  Property
], _Chart.prototype, "touch", 2);
__decorateClass([
  Property
], _Chart.prototype, "mode", 2);
__decorateClass([
  Property
], _Chart.prototype, "styleNonce", 2);
__decorateClass([
  ProxyProperty("chartCaptions.title")
], _Chart.prototype, "title", 2);
__decorateClass([
  ProxyProperty("chartCaptions.subtitle")
], _Chart.prototype, "subtitle", 2);
__decorateClass([
  ProxyProperty("chartCaptions.footnote")
], _Chart.prototype, "footnote", 2);
__decorateClass([
  Property
], _Chart.prototype, "formatter", 2);
__decorateClass([
  Property
], _Chart.prototype, "suppressFieldDotNotation", 2);
__decorateClass([
  Property
], _Chart.prototype, "loadGoogleFonts", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onAxisChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "axes", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "series", 2);
var Chart = _Chart;

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
import { findMaxIndex as findMaxIndex4, findMinIndex as findMinIndex4, isFiniteNumber as isFiniteNumber4 } from "ag-charts-core";

// packages/ag-charts-community/src/scale/logScale.ts
import { isInteger } from "ag-charts-core";
var logFunctions = {
  2: (_base, x) => Math.log2(x),
  [Math.E]: (_base, x) => Math.log(x),
  10: (_base, x) => Math.log10(x)
};
var DEFAULT_LOG = (base, x) => Math.log(x) / Math.log(base);
function log(base, domain, x) {
  const start2 = Math.min(...domain);
  const fn = logFunctions[base] ?? DEFAULT_LOG;
  return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var powFunctions = {
  [Math.E]: (_base, x) => Math.exp(x),
  10: (_base, x) => x >= 0 ? 10 ** x : 1 / 10 ** -x
};
var DEFAULT_POW = (base, x) => base ** x;
function pow(base, domain, x) {
  const start2 = Math.min(...domain);
  const fn = powFunctions[base] ?? DEFAULT_POW;
  return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor(d = [1, 10], r = [0, 1]) {
    super(d, r);
    this.type = "log";
    // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.
    this.defaultClamp = true;
    this.base = 10;
    this.log = (x) => log(this.base, this.domain, x);
    this.pow = (x) => pow(this.base, this.domain, x);
  }
  static is(value) {
    return value instanceof _LogScale;
  }
  transform(x) {
    const [min, max] = findMinMax(this.domain);
    if (min >= 0 !== max >= 0)
      return NaN;
    return min >= 0 ? Math.log(x) : -Math.log(-x);
  }
  transformInvert(x) {
    const [min, max] = findMinMax(this.domain);
    if (min >= 0 !== max >= 0)
      return NaN;
    return min >= 0 ? Math.exp(x) : -Math.exp(-x);
  }
  toDomain(d) {
    return d;
  }
  niceDomain(_ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    const { base } = this;
    const [d0, d1] = domain;
    const roundStart = d0 > d1 ? Math.ceil : Math.floor;
    const roundStop = d0 > d1 ? Math.floor : Math.ceil;
    const n0 = pow(base, domain, roundStart(log(base, domain, d0)));
    const n1 = pow(base, domain, roundStop(log(base, domain, d1)));
    return [n0, n1];
  }
  ticks({ interval, tickCount = ContinuousScale.defaultTickCount }, domain = this.domain, visibleRange) {
    if (!domain || domain.length < 2 || tickCount < 1) {
      return;
    }
    const base = this.base;
    const [d0, d1] = domain;
    const start2 = Math.min(d0, d1);
    const stop = Math.max(d0, d1);
    let p0 = this.log(start2);
    let p1 = this.log(stop);
    if (interval) {
      const inBounds = (tick) => tick >= start2 && tick <= stop;
      const step = Math.min(Math.abs(interval), Math.abs(p1 - p0));
      const { ticks: rangeTicks, count, firstTickIndex } = range(p0, p1, step, visibleRange);
      const ticks2 = rangeTicks.map(this.pow).filter(inBounds);
      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {
        return { ticks: ticks2, count, firstTickIndex };
      }
    }
    if (!isInteger(base) || p1 - p0 >= tickCount) {
      const step = Math.min(p1 - p0, tickCount);
      const { ticks: ticks2, count, firstTickIndex } = createTicks(p0, p1, step, void 0, void 0, visibleRange);
      return {
        ticks: ticks2.map(this.pow),
        count,
        firstTickIndex
      };
    }
    const ticks = [];
    const isPositive = start2 > 0;
    p0 = Math.floor(p0) - 1;
    p1 = Math.round(p1) + 1;
    const availableSpacing = findRangeExtent(this.range) / tickCount;
    let lastTickPosition = Infinity;
    for (let p = p0; p <= p1; p++) {
      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
      for (let k = 1; k < base; k++) {
        const q = isPositive ? k : base - k + 1;
        const t = this.pow(p) * q;
        const tickPosition = this.convert(t);
        const prevSpacing = Math.abs(lastTickPosition - tickPosition);
        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
        if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {
          ticks.push(t);
          lastTickPosition = tickPosition;
        }
      }
    }
    return filterVisibleTicks(ticks, isPositive, visibleRange);
  }
};

// packages/ag-charts-community/src/scene/util/quadtree.ts
var QuadtreeNearest = class {
  constructor(capacity, maxdepth, boundary) {
    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);
  }
  clear(boundary) {
    this.root.clear(boundary);
  }
  addValue(hitTester, value) {
    const elem = {
      hitTester,
      value,
      distanceSquared: (x, y) => {
        return hitTester.distanceSquared(x, y);
      }
    };
    this.root.addElem(elem);
  }
  find(x, y) {
    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };
    this.root.find(x, y, arg);
    return arg.best;
  }
};
var QuadtreeSubdivisions = class {
  constructor(nw, ne, sw, se) {
    this.nw = nw;
    this.ne = ne;
    this.sw = sw;
    this.se = se;
  }
  addElem(elem) {
    this.nw.addElem(elem);
    this.ne.addElem(elem);
    this.sw.addElem(elem);
    this.se.addElem(elem);
  }
  find(x, y, arg) {
    this.nw.find(x, y, arg);
    this.ne.find(x, y, arg);
    this.sw.find(x, y, arg);
    this.se.find(x, y, arg);
  }
};
var QuadtreeNode = class {
  constructor(capacity, maxdepth, boundary) {
    this.capacity = capacity;
    this.maxdepth = maxdepth;
    this.boundary = boundary ?? BBox.NaN;
    this.elems = [];
    this.subdivisions = void 0;
  }
  clear(boundary) {
    this.elems.length = 0;
    this.boundary = boundary;
    this.subdivisions = void 0;
  }
  addElem(e) {
    if (this.addCondition(e)) {
      if (this.subdivisions === void 0) {
        if (this.maxdepth === 0 || this.elems.length < this.capacity) {
          this.elems.push(e);
        } else {
          this.subdivide(e);
        }
      } else {
        this.subdivisions.addElem(e);
      }
    }
  }
  find(x, y, arg) {
    if (this.findCondition(x, y, arg)) {
      if (this.subdivisions === void 0) {
        this.findAction(x, y, arg);
      } else {
        this.subdivisions.find(x, y, arg);
      }
    }
  }
  subdivide(newElem) {
    this.subdivisions = this.makeSubdivisions();
    for (const e of this.elems) {
      this.subdivisions.addElem(e);
    }
    this.subdivisions.addElem(newElem);
    this.elems.length = 0;
  }
  makeSubdivisions() {
    const { x, y, width: width2, height: height2 } = this.boundary;
    const { capacity } = this;
    const depth = this.maxdepth - 1;
    const halfWidth = width2 / 2;
    const halfHeight = height2 / 2;
    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);
    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);
    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);
    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
    return new QuadtreeSubdivisions(
      this.child(capacity, depth, nwBoundary),
      this.child(capacity, depth, neBoundary),
      this.child(capacity, depth, swBoundary),
      this.child(capacity, depth, seBoundary)
    );
  }
};
var QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {
  addCondition(e) {
    const { x, y } = e.hitTester.midPoint;
    return this.boundary.containsPoint(x, y);
  }
  findCondition(x, y, arg) {
    const { best } = arg;
    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;
  }
  findAction(x, y, arg) {
    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);
    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {
      arg.best = other;
    }
  }
  child(capacity, depth, boundary) {
    return new _QuadtreeNodeNearest(capacity, depth, boundary);
  }
};

// packages/ag-charts-community/src/chart/axis/timeAxis.ts
import { Logger as Logger33 } from "ag-charts-core";
var TimeAxisParentLevel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.label = new AxisLabel();
    this.tick = new AxisTick();
  }
};
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "enabled", 2);
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "label", 2);
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "tick", 2);
var TimeAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new TimeScale());
    this.parentLevel = new TimeAxisParentLevel();
    this.min = void 0;
    this.max = void 0;
    this.minimumTimeGranularity = void 0;
  }
  // eslint-disable-next-line sonarjs/use-type-alias
  get _unit() {
    return void 0;
  }
  set _unit(_unit) {
    Logger33.warnOnce(`To use 'unit', use an axis with type 'unit-time' instead of 'time'.`);
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  isCategoryLike() {
    return false;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  normaliseDataDomain(d) {
    return normaliseTimeDataDomain(d, this.min, this.max);
  }
  processData() {
    super.processData();
    const { boundSeries, direction, min, max } = this;
    this.minimumTimeGranularity = minimumTimeAxisDatumGranularity(boundSeries, direction, min, max);
  }
  tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
    timeInterval3 ?? (timeInterval3 = lowestGranularityUnitForTicks(ticks));
    const truncateDate = dateTruncationForDomain(domain);
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return { type: "date", unit, step, epoch, truncateDate };
  }
  datumFormatParams(value, params, _fractionDigits, timeInterval3, style) {
    if (typeof value === "number")
      value = new Date(value);
    if (timeInterval3 == null) {
      const { minimumTimeGranularity } = this;
      const datumGranularity = lowestGranularityUnitForValue(value);
      if (minimumTimeGranularity != null && intervalMilliseconds(minimumTimeGranularity) < intervalMilliseconds(datumGranularity)) {
        timeInterval3 = minimumTimeGranularity;
      } else {
        timeInterval3 = datumGranularity;
      }
    }
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return {
      type: "date",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      unit,
      step,
      epoch,
      style
    };
  }
};
TimeAxis.className = "TimeAxis";
TimeAxis.type = "time";
__decorateClass([
  Property
], TimeAxis.prototype, "parentLevel", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "min", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "max", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("_unit")
], TimeAxis.prototype, "unit", 2);
function minimumTimeAxisDatumGranularity(boundSeries, direction, min, max) {
  const minTimeInterval = boundSeries.reduce((t, series) => {
    return Math.min(series.minTimeInterval() ?? Infinity, t);
  }, Infinity);
  if (Number.isFinite(minTimeInterval)) {
    return lowestGranularityForInterval(minTimeInterval);
  } else {
    return calculateDefaultUnit(boundSeries, direction, min, max)?.unit;
  }
}
function calculateDefaultUnit(boundSeries, direction, min, max) {
  let start2 = Infinity;
  let end2 = -Infinity;
  let interval;
  let maxDataCount = 0;
  const domainValues = [];
  for (const series of boundSeries) {
    if (!series.visible)
      continue;
    const { domain } = normaliseTimeDataDomain(series.getDomain(direction), void 0, void 0);
    if (domain.length === 0)
      continue;
    const d0 = domain[0].valueOf();
    const d1 = domain[domain.length - 1].valueOf();
    domainValues.push(d0, d1);
    start2 = Math.min(start2 ?? Infinity, d0, d1);
    end2 = Math.max(end2 ?? -Infinity, d0, d1);
    const domainExtent = Math.abs(d1 - d0);
    if (domainExtent === 0)
      continue;
    const dataCount = series.dataCount();
    maxDataCount = Math.max(maxDataCount, dataCount);
    if (dataCount <= 1)
      continue;
    const i = domainExtent / (dataCount - 1);
    interval = Math.min(interval ?? Infinity, i);
  }
  start2 = Math.min(start2, min?.valueOf() ?? Infinity, max?.valueOf() ?? Infinity);
  end2 = Math.max(end2, min?.valueOf() ?? -Infinity, max?.valueOf() ?? -Infinity);
  if (!Number.isFinite(start2) || !Number.isFinite(end2))
    return;
  interval ?? (interval = Math.abs(end2 - start2));
  interval = Math.min(interval, minNonZeroDifference(domainValues));
  const unit = lowestGranularityForInterval(interval);
  let step = interval / intervalMilliseconds(unit);
  if (maxDataCount <= 2) {
    step = Math.floor(step);
  } else {
    step = Math.round(step);
  }
  step = Math.max(step, 1);
  const epoch = step === 1 ? void 0 : intervalFloor(unit, start2);
  return { unit, step, epoch };
}
function minNonZeroDifference(values) {
  values.sort((a, b) => a - b);
  let minDiff = Infinity;
  for (let i = 1; i < values.length; i++) {
    const d0 = values[i - 1];
    const d1 = values[i];
    const delta3 = d1 - d0;
    if (delta3 > 0) {
      minDiff = Math.min(minDiff, Math.abs(d1 - d0));
    }
  }
  return minDiff;
}
function normaliseTimeDataDomain(d, min, max) {
  let clipped = false;
  if (typeof min === "number") {
    min = new Date(min);
  }
  if (typeof max === "number") {
    max = new Date(max);
  }
  const de = extent(d)?.map((x) => new Date(x));
  if (de == null) {
    return {
      domain: min != null && max != null && min.valueOf() <= max.valueOf() ? [min, max] : [],
      clipped: false
    };
  }
  let [d0, d1] = de;
  if (min instanceof Date) {
    clipped || (clipped = min > d0);
    d0 = min;
  }
  if (max instanceof Date) {
    clipped || (clipped = max < d1);
    d1 = max;
  }
  if (d0 > d1) {
    return { domain: [], clipped: false };
  }
  return { domain: [d0, d1], clipped };
}

// packages/ag-charts-community/src/chart/series/dataModelSeries.ts
import { clamp as clamp17 } from "ag-charts-core";
var DataModelSeries = class extends Series {
  constructor({ clipFocusBox, categoryKey, ...seriesOpts }) {
    super(seriesOpts);
    this.categoryKey = categoryKey;
    this.clipFocusBox = clipFocusBox ?? true;
  }
  dataCount() {
    return this.processedData?.dataSources?.get(this.id)?.length ?? 0;
  }
  getScaleInformation({
    xScale,
    yScale
  }) {
    const isContinuousX = ContinuousScale.is(xScale);
    const isContinuousY = ContinuousScale.is(yScale);
    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };
  }
  getModulePropertyDefinitions() {
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    return this.moduleMap.mapModules((mod) => mod.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();
  }
  // Request data, but with message dispatching to series-options (modules).
  async requestDataModel(dataController, data, opts) {
    opts.props.push(...this.getModulePropertyDefinitions());
    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);
    this.dataModel = dataModel;
    this.processedData = processedData;
    this.events.emit("data-processed", { dataModel, processedData });
    return { dataModel, processedData };
  }
  isProcessedDataAnimatable() {
    const { processedData } = this;
    if (!processedData)
      return false;
    const validationResults = processedData.reduced?.animationValidation;
    if (!validationResults)
      return true;
    const { orderedKeys, uniqueKeys } = validationResults;
    return orderedKeys && uniqueKeys;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  pickFocus(opts) {
    const nodeData = this.getNodeData();
    if (nodeData === void 0 || nodeData.length === 0) {
      return;
    }
    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);
    if (datumIndex === void 0) {
      return;
    }
    const { clipFocusBox } = this;
    const datum = nodeData[datumIndex];
    const derivedOpts = { ...opts, datumIndex };
    const bounds = this.computeFocusBounds(derivedOpts);
    if (bounds !== void 0) {
      return { bounds, clipFocusBox, datum, datumIndex };
    }
  }
  pickNodesExactShape(point) {
    const datums = super.pickNodesExactShape(point);
    datums.sort((a, b) => a.datumIndex - b.datumIndex);
    return datums;
  }
  isDatumEnabled(nodeData, datumIndex) {
    const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex];
    return !missing && enabled && focusable;
  }
  computeFocusDatumIndex(opts, nodeData) {
    const searchBackward = (datumIndex2, delta3) => {
      while (datumIndex2 >= 0 && !this.isDatumEnabled(nodeData, datumIndex2)) {
        datumIndex2 += delta3;
      }
      return datumIndex2 === -1 ? void 0 : datumIndex2;
    };
    const searchForward = (datumIndex2, delta3) => {
      while (datumIndex2 < nodeData.length && !this.isDatumEnabled(nodeData, datumIndex2)) {
        datumIndex2 += delta3;
      }
      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;
    };
    let datumIndex;
    const clampedIndex = clamp17(0, opts.datumIndex, nodeData.length - 1);
    if (opts.datumIndexDelta < 0) {
      datumIndex = searchBackward(clampedIndex, opts.datumIndexDelta);
    } else if (opts.datumIndexDelta > 0) {
      datumIndex = searchForward(clampedIndex, opts.datumIndexDelta);
    } else {
      datumIndex = searchForward(clampedIndex, 1) ?? searchBackward(clampedIndex, -1);
    }
    if (datumIndex === void 0) {
      if (opts.datumIndexDelta === 0) {
        return;
      } else {
        return opts.datumIndex - opts.datumIndexDelta;
      }
    } else {
      return datumIndex;
    }
  }
  // Workaround - it would be nice if this difference didn't exist
  dataModelPropertyIsKey(key) {
    const { processedData } = this;
    if (!processedData)
      return false;
    return processedData.defs.keys.some((def) => def.id === key && def.idsMap?.get(this.id)?.has(key) === true);
  }
  keysOrValues(xKey) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    return this.dataModelPropertyIsKey(xKey) ? dataModel.resolveKeysById(this, xKey, processedData) : dataModel.resolveColumnById(this, xKey, processedData);
  }
  sortOrder(xKey) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return;
    return this.dataModelPropertyIsKey(xKey) ? dataModel.getKeySortOrder(this, xKey, processedData) : dataModel.getColumnSortOrder(this, xKey, processedData);
  }
  getCategoryKey() {
    return this.categoryKey;
  }
  getCategoryValue(datumIndex) {
    const { processedData, dataModel } = this;
    const categoryKey = this.getCategoryKey();
    if (!processedData || !dataModel || !categoryKey)
      return;
    const invalid = processedData.invalidData?.get(this.id)?.[datumIndex] ?? false;
    return invalid ? void 0 : this.keysOrValues(categoryKey)[datumIndex];
  }
  datumIndexForCategoryValue(categoryValue) {
    const { processedData, dataModel } = this;
    const categoryKey = this.getCategoryKey();
    if (!processedData || !dataModel || !categoryKey)
      return;
    categoryValue = categoryValue.valueOf();
    const invalidValues = processedData.invalidData?.get(this.id);
    const xValues = this.keysOrValues(categoryKey);
    for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
      if (invalidValues?.[datumIndex] === true)
        continue;
      const xValue = xValues[datumIndex]?.valueOf();
      if (objectsEqual(categoryValue, xValue))
        return datumIndex;
    }
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_CARTESIAN_DIRECTION_KEYS = {
  ["x" /* X */]: ["xKey"],
  ["y" /* Y */]: ["yKey"]
};
var DEFAULT_CARTESIAN_DIRECTION_NAMES = {
  ["x" /* X */]: ["xName"],
  ["y" /* Y */]: ["yName"]
};
var CartesianSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yKey = series.properties.yKey;
  }
};
var CartesianSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.pickOutsideVisibleMinorAxis = false;
  }
};
__decorateClass([
  Property
], CartesianSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Property
], CartesianSeriesProperties.prototype, "pickOutsideVisibleMinorAxis", 2);
var RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD = 100;
var CartesianSeries = class extends DataModelSeries {
  constructor({
    pathsPerSeries = ["path"],
    pathsZIndexSubOrderOffset = [],
    datumSelectionGarbageCollection = true,
    animationAlwaysUpdateSelections = false,
    animationResetFns,
    propertyKeys,
    propertyNames,
    ...otherOpts
  }) {
    super({
      propertyKeys,
      propertyNames,
      canHaveAxes: true,
      ...otherOpts
    });
    this.NodeEvent = CartesianSeriesNodeEvent;
    this.dataNodeGroup = this.contentGroup.appendChild(
      new Group({ name: `${this.id}-series-dataNodes`, zIndex: 1 })
    );
    this.labelGroup = this.contentGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-series-labels` })
    );
    this.labelSelection = Selection.select(this.labelGroup, Text);
    this.highlightSelection = Selection.select(this.highlightGroup, () => this.nodeFactory());
    this.annotationSelections = /* @__PURE__ */ new Set();
    this.debug = Debug.create();
    if (!propertyKeys || !propertyNames)
      throw new Error(`Unable to initialise series type ${this.type}`);
    this.opts = {
      pathsPerSeries,
      pathsZIndexSubOrderOffset,
      propertyKeys,
      propertyNames,
      animationResetFns,
      animationAlwaysUpdateSelections,
      datumSelectionGarbageCollection
    };
    this.paths = pathsPerSeries.map((path) => {
      return new Path({ name: `${this.id}-${path}` });
    });
    this.datumSelection = Selection.select(
      this.dataNodeGroup,
      () => this.nodeFactory(),
      datumSelectionGarbageCollection
    );
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => {
              if (this.ctx.animationManager.isSkipped()) {
                this.resetAllAnimation(data);
              } else {
                this.animateWaitingUpdateReady(data);
              }
            }
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        disabled: {
          update: (data) => this.resetAllAnimation(data),
          reset: "empty"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  get contextNodeData() {
    return this._contextNodeData;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    this.attachPaths(this.paths);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    this.detachPaths(this.paths);
  }
  updatedDomains() {
    this.animationState.transition("updateData");
  }
  attachPaths(paths) {
    for (const path of paths) {
      this.contentGroup.appendChild(path);
    }
  }
  detachPaths(paths) {
    for (const path of paths) {
      this.contentGroup.removeChild(path);
    }
  }
  renderToOffscreenCanvas() {
    const nodeData = this.getNodeData();
    return nodeData != null && nodeData.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    } else if (phase === "disabled") {
      this.animationState.transition("disable");
    }
  }
  addChartEventListeners() {
    this.cleanup.register(
      this.ctx.eventsHub.on("legend:item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.eventsHub.on("legend:item-double-click", (event) => this.onLegendItemDoubleClick(event))
    );
  }
  destroy() {
    super.destroy();
    this._contextNodeData = void 0;
  }
  isSeriesHighlighted(highlightedDatum) {
    const { series, legendItemName: activeLegendItemName } = highlightedDatum ?? {};
    const { legendItemName } = this.properties;
    return series === this || legendItemName != null && legendItemName === activeLegendItemName;
  }
  strokewidthChange() {
    const unhighlightedStrokeWidth = ("strokeWidth" in this.properties && this.properties.strokeWidth) ?? 0;
    const highlightedSeriesStrokeWidth = this.properties.highlight.highlightedSeries.strokeWidth ?? unhighlightedStrokeWidth;
    const highlightedItemStrokeWidth = this.properties.highlight.highlightedItem?.strokeWidth ?? unhighlightedStrokeWidth;
    return unhighlightedStrokeWidth > highlightedItemStrokeWidth || highlightedSeriesStrokeWidth > highlightedItemStrokeWidth;
  }
  update({ seriesRect }) {
    const { _contextNodeData: previousContextData } = this;
    const resize = this.checkResize(seriesRect);
    const itemHighlighted = this.updateHighlightSelection();
    this.contentGroup.batchedUpdate(() => {
      const dataChanged = this.updateSelections();
      this.updateNodes(itemHighlighted, resize || dataChanged);
    });
    const animationData = this.getAnimationData(seriesRect, previousContextData);
    if (!animationData)
      return;
    if (resize) {
      this.animationState.transition("resize", animationData);
    }
    this.animationState.transition("update", animationData);
  }
  updateSelections() {
    var _a;
    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
    if (!this.visible && animationSkipUpdate) {
      return false;
    }
    const { nodeDataRefresh } = this;
    if (!nodeDataRefresh && !this.isPathOrSelectionDirty()) {
      return false;
    }
    if (nodeDataRefresh) {
      this.nodeDataRefresh = false;
      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);
      this.markQuadtreeDirty();
      this._contextNodeData = this.createNodeData();
      const animationValid = this.isProcessedDataAnimatable();
      if (this._contextNodeData) {
        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);
      }
      const { dataModel, processedData } = this;
      if (dataModel !== void 0 && processedData !== void 0) {
        this.events.emit("data-update", { dataModel, processedData });
      }
      this.updateSeriesSelections();
    }
    return nodeDataRefresh;
  }
  updateSeriesSelections() {
    const { datumSelection, labelSelection, paths } = this;
    const contextData = this._contextNodeData;
    if (!contextData)
      return;
    const { nodeData, labelData, itemId } = contextData;
    this.updatePaths({ itemId, contextData, paths });
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.labelGroup.batchedUpdate(() => {
      this.labelSelection = this.updateLabelSelection({ labelData, labelSelection }) ?? labelSelection;
    });
  }
  getShapeFillBBox() {
    const { axes } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const [axisX1, axisX2] = findMinMax(xAxis?.range ?? [0, 1]);
    const [axisY1, axisY2] = findMinMax(yAxis?.range ?? [0, 1]);
    const xSeriesDomain = this.getSeriesDomain("x" /* X */);
    const xSeriesRange = [xAxis?.scale.convert(xSeriesDomain.at(0)), xAxis?.scale.convert(xSeriesDomain.at(-1))];
    const ySeriesDomain = this.getSeriesDomain("y" /* Y */);
    const ySeriesRange = [yAxis?.scale.convert(ySeriesDomain.at(0)), yAxis?.scale.convert(ySeriesDomain.at(-1))];
    const [seriesX1, seriesX2] = findMinMax(xSeriesRange);
    const [seriesY1, seriesY2] = findMinMax(ySeriesRange);
    return {
      axis: new BBox(axisX1, axisY1, axisX2 - axisX1, axisY2 - axisY1),
      series: new BBox(seriesX1, seriesY1, seriesX2 - seriesX1, seriesY2 - seriesY1)
    };
  }
  updateNodes(itemHighlighted, nodeRefresh) {
    const { highlightSelection, datumSelection } = this;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const visible = this.visible && this._contextNodeData != null;
    this.contentGroup.visible = animationEnabled || visible;
    this.highlightGroup.visible = (animationEnabled || visible) && itemHighlighted;
    this.updateDatumNodes({
      datumSelection: highlightSelection,
      isHighlight: true
    });
    this.animationState.transition("highlight", highlightSelection);
    const { dataNodeGroup, labelSelection, paths, labelGroup } = this;
    const { itemId } = this.contextNodeData ?? {};
    this.updatePathNodes({
      itemId,
      paths,
      visible,
      animationEnabled
    });
    dataNodeGroup.visible = animationEnabled || visible;
    labelGroup.visible = visible;
    if (!dataNodeGroup.visible) {
      return;
    }
    const redrawAll = this.strokewidthChange() || this.hasChangesOnHighlight;
    if (nodeRefresh || redrawAll) {
      this.updateDatumNodes({ datumSelection, isHighlight: false });
      if (!this.usesPlacedLabels) {
        this.labelGroup.batchedUpdate(() => {
          this.updateLabelNodes({ labelSelection, isHighlight: false });
        });
      }
    }
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter(
      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId
    );
    return labelItems.length === 0 ? void 0 : labelItems;
  }
  getHighlightData(_nodeData, highlightedItem) {
    return highlightedItem ? [highlightedItem] : void 0;
  }
  updateHighlightSelection() {
    const { highlightSelection, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return false;
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const seriesHighlighted = this.isSeriesHighlighted(highlightedDatum);
    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;
    if (item == null)
      return false;
    const { nodeData } = contextNodeData;
    const highlightItems = this.getHighlightData(nodeData, item);
    this.highlightSelection = this.updateHighlightSelectionItem({
      items: highlightItems,
      highlightSelection
    });
    return true;
  }
  markQuadtreeDirty() {
    this.quadtree = void 0;
  }
  *datumNodesIter() {
    for (const { node } of this.datumSelection) {
      if (node.datum.missing === true)
        continue;
      yield node;
    }
  }
  getQuadTree() {
    if (this.quadtree === void 0) {
      const { width: width2, height: height2 } = this.ctx.scene.canvas;
      const canvasRect = new BBox(0, 0, width2, height2);
      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);
      this.initQuadTree(this.quadtree);
    }
    return this.quadtree;
  }
  initQuadTree(_quadtree) {
  }
  pickNodesExactShape(point) {
    const result = super.pickNodesExactShape(point);
    if (result.length !== 0) {
      return result;
    }
    const { x, y } = point;
    const { dataNodeGroup } = this;
    const matches = dataNodeGroup.pickNodes(x, y).filter((match) => match.datum.missing !== true);
    if (matches.length !== 0) {
      const datums = matches.map((match) => match.datum);
      return datums;
    }
    for (const mod of this.moduleMap.modules()) {
      const { datum } = mod.pickNodeExact(point) ?? {};
      if (datum == null)
        continue;
      if (datum?.missing === true)
        continue;
      return [datum];
    }
    return [];
  }
  pickNodeClosestDatum(point) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const hitPoint = { x, y };
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);
      if (!isInRange) {
        continue;
      }
      const distance = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);
      if (distance < minDistance) {
        minDistance = distance;
        closestDatum = datum;
      }
    }
    for (const mod of this.moduleMap.modules()) {
      const modPick = mod.pickNodeNearest(point);
      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
        minDistance = modPick.distanceSquared;
        closestDatum = modPick.datum;
        break;
      }
    }
    if (closestDatum) {
      const distance = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0) / 2, 0);
      return { datum: closestDatum, distance };
    }
  }
  pickNodeMainAxisFirst(point, requireCategoryAxis) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    const { pickOutsideVisibleMinorAxis } = this.properties;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (xAxis == null || yAxis == null)
      return;
    const directions2 = [xAxis, yAxis].filter((axis) => axis.isCategoryLike()).map((a) => a.direction);
    if (requireCategoryAxis && directions2.length === 0)
      return;
    const [majorDirection = "x" /* X */] = directions2;
    const hitPointCoords = [x, y];
    if (majorDirection !== "x" /* X */)
      hitPointCoords.reverse();
    const minDistance = [Infinity, Infinity];
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};
      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)
        continue;
      const visible = [xAxis?.inRange(datumX, 1), yAxis?.inRange(datumY, 1)];
      if (majorDirection !== "x" /* X */) {
        visible.reverse();
      }
      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])
        continue;
      const datumPoint = [datumX, datumY];
      if (majorDirection !== "x" /* X */) {
        datumPoint.reverse();
      }
      let newMinDistance = true;
      for (let i = 0; i < datumPoint.length; i++) {
        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);
        if (dist > minDistance[i]) {
          newMinDistance = false;
          break;
        } else if (dist < minDistance[i]) {
          minDistance[i] = dist;
          minDistance.fill(Infinity, i + 1, minDistance.length);
        }
      }
      if (newMinDistance) {
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      let closestDistanceSquared = Math.max(
        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),
        0
      );
      for (const mod of this.moduleMap.modules()) {
        const modPick = mod.pickNodeMainAxisFirst(point, majorDirection);
        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
          closestDatum = modPick.datum;
          closestDistanceSquared = modPick.distanceSquared;
          break;
        }
      }
      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };
    }
  }
  isPathOrSelectionDirty() {
    return false;
  }
  shouldFlipXY() {
    return false;
  }
  visibleRangeIndices(axisKey, visibleRange, indices, sortOrderParams) {
    let sortOrder;
    if (sortOrderParams == null) {
      const { processedData, dataModel } = this;
      sortOrder = dataModel.getColumnSortOrder(this, axisKey, processedData) ?? 1;
    } else {
      sortOrder = sortOrderParams.sortOrder;
    }
    const xValues = this.keysOrValues(axisKey);
    const pixelSize = 0;
    const [start2, end2] = visibleRangeIndices(
      sortOrder,
      indices?.length ?? xValues.length,
      visibleRange,
      (topIndex) => {
        const datumIndex = indices?.[topIndex] ?? topIndex;
        return this.xCoordinateRange(xValues[datumIndex], pixelSize, datumIndex);
      }
    );
    return start2 < end2 ? [start2, end2] : [end2, start2];
  }
  domainForVisibleRange(_direction, axisKeys, crossAxisKey, visibleRange, indices) {
    const { processedData, dataModel } = this;
    const [r0, r1] = visibleRange;
    const crossAxisValues = this.keysOrValues(crossAxisKey);
    const sortOrder = this.sortOrder(crossAxisKey);
    if (sortOrder != null) {
      const crossAxisRange = this.visibleRangeIndices(crossAxisKey, visibleRange, indices, { sortOrder });
      return dataModel.getDomainBetweenRange(this, axisKeys, crossAxisRange, processedData);
    }
    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));
    let axisMin = Infinity;
    let axisMax = -Infinity;
    crossAxisValues.forEach((crossAxisValue, i) => {
      const [x0, x1] = this.xCoordinateRange(crossAxisValue, 0, i);
      if (x1 < r0 || x0 > r1)
        return;
      for (let j = 0; j < axisKeys.length; j++) {
        const axisValue = allAxisValues[j][i];
        axisMin = Math.min(axisMin, axisValue);
        axisMax = Math.max(axisMax, axisValue);
      }
    });
    if (axisMin > axisMax)
      return [NaN, NaN];
    return [axisMin, axisMax];
  }
  domainForClippedRange(direction, axisKeys, crossAxisKey) {
    const { processedData, dataModel, axes } = this;
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossAxisRange = axisExtent(axes[crossDirection]);
    if (!crossAxisRange) {
      return axisKeys.flatMap((axisKey) => dataModel.getDomain(this, axisKey, "value", processedData));
    }
    const crossAxisValues = this.keysOrValues(crossAxisKey);
    const sortOrder = dataModel.getColumnSortOrder(this, crossAxisKey, processedData);
    if (sortOrder != null) {
      const crossRange = clippedRangeIndices(
        sortOrder,
        crossAxisValues.length,
        crossAxisRange,
        (index) => crossAxisValues[index]
      );
      return dataModel.getDomainBetweenRange(this, axisKeys, crossRange, processedData);
    }
    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));
    const range0 = crossAxisRange[0].valueOf();
    const range1 = crossAxisRange[1].valueOf();
    const axisValues = [];
    crossAxisValues.forEach((crossAxisValue, i) => {
      const c = crossAxisValue.valueOf();
      if (c < range0 || c > range1)
        return;
      const values = allAxisValues.map((v) => v[i]);
      if (c >= range0) {
        axisValues.push(...values);
      }
      if (c <= range1) {
        axisValues.push(...values);
      }
    });
    return axisValues;
  }
  countVisibleItems(crossAxisKey, axisKeys, xVisibleRange, yVisibleRange, minVisibleItems) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return Infinity;
    const crossValues = this.keysOrValues(crossAxisKey);
    const allAxisValues = axisKeys.map((axisKey) => dataModel.resolveColumnById(this, axisKey, processedData));
    const crossAxis = this.axes["x" /* X */];
    const axis = this.axes["y" /* Y */];
    const shouldFlipXY = this.shouldFlipXY();
    if (yVisibleRange == null) {
      const sortOrder = this.sortOrder(crossAxisKey);
      if (sortOrder == null) {
        yVisibleRange = [0, 1];
      } else {
        const crossScale = crossAxis.scale;
        const crossScaleRange = crossScale.range;
        crossScale.range = [0, 1];
        let [r0, r1] = this.visibleRangeIndices(crossAxisKey, xVisibleRange, void 0, { sortOrder });
        const xValues = this.keysOrValues(crossAxisKey);
        const pixelSize2 = 0;
        if (this.xCoordinateRange(xValues[r0], pixelSize2, r0)[0] < xVisibleRange[0]) {
          r0 += 1;
        }
        if (r1 < xValues.length && this.xCoordinateRange(xValues[r1], pixelSize2, r1)[1] > xVisibleRange[1]) {
          r1 -= 1;
        }
        const xItemsVisible = Math.abs(r1 - r0);
        crossScale.range = crossScaleRange;
        return xItemsVisible;
      }
    }
    const convert = (d, r, v) => {
      return d[0] + (v - r[0]) / (r[1] - r[0]) * (d[1] - d[0]);
    };
    const crossAxisRange = crossAxis.range;
    const range3 = axis.range;
    const crossMin = convert(crossAxisRange, crossAxis.visibleRange, xVisibleRange[0]);
    const crossMax = convert(crossAxisRange, crossAxis.visibleRange, xVisibleRange[1]);
    const axisMin = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[0] : yVisibleRange[1]);
    const axisMax = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[1] : yVisibleRange[0]);
    const startIndex = Math.round(
      (xVisibleRange[0] + (xVisibleRange[1] - xVisibleRange[0]) / 2) * crossValues.length
    );
    const pixelSize = 0;
    return countExpandingSearch(0, crossValues.length - 1, startIndex, minVisibleItems, (index) => {
      let [x0, x1] = this.xCoordinateRange(crossValues[index], pixelSize, index);
      let [y0, y1] = this.yCoordinateRange(
        allAxisValues.map((axisValues) => axisValues[index]),
        pixelSize,
        index
      );
      if (!isFiniteNumber4(x0) || !isFiniteNumber4(x1) || !isFiniteNumber4(y0) || !isFiniteNumber4(y1)) {
        return false;
      }
      if (shouldFlipXY)
        [x0, x1, y0, y1] = [y0, y1, x0, x1];
      return x0 >= crossMin && x1 <= crossMax && y0 >= axisMin && y1 <= axisMax;
    });
  }
  // @todo(AG-13777) - Remove this function.
  // We need data model updates to know if a data set is sorted & unique - and at the same time
  // it should generate the equivalent of `SMALLEST_KEY_INTERVAL`. We'll use that value here
  minTimeInterval() {
    let xValues;
    try {
      xValues = this.keysOrValues("xValue");
    } catch {
    }
    if (xValues == null || xValues.length > 1e3)
      return;
    let minInterval = Infinity;
    let x0 = xValues[0];
    let sortOrder;
    for (let i = 1; i < xValues.length; i++) {
      const x1 = xValues[i];
      if (x1 != null && x0 != null) {
        const interval = x1.valueOf() - x0.valueOf();
        const sign = Math.sign(interval);
        if (sign === 0)
          continue;
        if (sortOrder !== void 0 && sign !== sortOrder)
          return;
        minInterval = Math.min(minInterval, Math.abs(interval));
        sortOrder = sign;
      }
      x0 = x1;
    }
    if (Number.isFinite(minInterval))
      return minInterval;
  }
  updateHighlightSelectionItem(opts) {
    const { items, highlightSelection } = opts;
    const nodeData = items ?? [];
    return this.updateDatumSelection({
      nodeData,
      datumSelection: highlightSelection
    });
  }
  updateHighlightSelectionLabel(opts) {
    return this.updateLabelSelection({
      labelData: opts.items ?? [],
      labelSelection: opts.highlightLabelSelection
    });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection;
  }
  updateDatumNodes(_opts) {
  }
  updatePaths(opts) {
    opts.paths.forEach((p) => p.visible = false);
  }
  updatePathNodes(opts) {
    const { paths, visible } = opts;
    for (const path of paths) {
      path.visible = visible;
    }
  }
  resetPathAnimation(data) {
    const { path } = this.opts?.animationResetFns ?? {};
    if (path) {
      data.paths.forEach((paths) => {
        resetMotion([paths], path);
      });
    }
  }
  resetDatumAnimation(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data.datumSelection], datum);
    }
  }
  resetLabelAnimation(data) {
    const { label } = this.opts?.animationResetFns ?? {};
    if (label) {
      resetMotion([data.labelSelection], label);
    }
  }
  resetAllAnimation(data) {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.resetPathAnimation(data);
    this.resetDatumAnimation(data);
    this.resetLabelAnimation(data);
    if (data.contextData?.animationValid === false) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data], datum);
    }
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  getAnimationData(seriesRect, previousContextData) {
    const { _contextNodeData: contextData } = this;
    if (!contextData)
      return;
    const animationData = {
      datumSelection: this.datumSelection,
      labelSelection: this.labelSelection,
      annotationSelections: [...this.annotationSelections],
      contextData,
      previousContextData,
      paths: this.paths,
      seriesRect
    };
    return animationData;
  }
  updateLabelSelection(opts) {
    return opts.labelSelection;
  }
  getScaling(scale2) {
    if (scale2 instanceof LogScale) {
      const { range: range3, domain } = scale2;
      return {
        type: "log",
        convert: (d) => scale2.convert(d),
        domain: [domain[0], domain[1]],
        range: [range3[0], range3[1]]
      };
    } else if (scale2 instanceof ContinuousScale) {
      const { range: range3, domain } = scale2;
      return {
        type: "continuous",
        domain: [domain[0], domain[1]],
        range: [range3[0], range3[1]]
      };
    } else if (scale2 instanceof BandScale) {
      const domain = scale2 instanceof UnitTimeScale ? scale2.bands : scale2.domain;
      return {
        type: "category",
        domain,
        inset: scale2.inset,
        step: scale2.step
      };
    }
  }
  calculateScaling() {
    const result = {};
    for (const direction of Object.values(ChartAxisDirection)) {
      const axis = this.axes[direction];
      if (!axis)
        continue;
      const scalingResult = this.getScaling(axis.scale);
      if (scalingResult != null) {
        result[direction] = scalingResult;
      }
    }
    return result;
  }
};
function axisExtent(axis) {
  let min;
  let max;
  if (axis instanceof NumberAxis || axis instanceof TimeAxis) {
    ({ min, max } = axis);
  }
  if (min == null && max == null)
    return;
  min ?? (min = -Infinity);
  max ?? (max = Infinity);
  return [min, max];
}
function clippedRangeIndices(sortOrder, length, range3, xValue) {
  const range0 = range3[0].valueOf();
  const range1 = range3[1].valueOf();
  let xMinIndex = findMinIndex4(0, length - 1, (i) => {
    const index = sortOrder === 1 ? i : length - i;
    const x = xValue(index)?.valueOf();
    return !Number.isFinite(x) || x >= range0;
  });
  let xMaxIndex = findMaxIndex4(0, length - 1, (i) => {
    const index = sortOrder === 1 ? i : length - i;
    const x = xValue(index)?.valueOf();
    return !Number.isFinite(x) || x <= range1;
  });
  if (xMinIndex == null || xMaxIndex == null)
    return [0, 0];
  if (sortOrder === -1) {
    [xMinIndex, xMaxIndex] = [length - xMaxIndex, length - xMinIndex];
  }
  xMinIndex = Math.max(xMinIndex, 0);
  xMaxIndex = Math.min(xMaxIndex + 1, length);
  return [xMinIndex, xMaxIndex];
}

// packages/ag-charts-community/src/chart/cartesianChart.ts
var directions = ["top", "right", "bottom", "left"];
var _CartesianChart = class _CartesianChart extends Chart {
  constructor(options, resources) {
    super(options, resources);
    // TODO should come from theme
    /** Integrated Charts feature state - not used in Standalone Charts. */
    this.paired = true;
    this.lastUpdateClipRect = void 0;
    this.lastLayoutWidth = NaN;
    this.lastLayoutHeight = NaN;
  }
  onAxisChange(newValue, oldValue) {
    super.onAxisChange(newValue, oldValue);
    this.syncAxisChanges(newValue, oldValue);
    if (this.ctx != null) {
      this.ctx.zoomManager.updateAxes(newValue);
    }
  }
  destroySeries(series) {
    super.destroySeries(series);
    this.lastLayoutWidth = NaN;
    this.lastLayoutHeight = NaN;
  }
  getChartType() {
    return "cartesian";
  }
  setRootClipRects(clipRect) {
    const { seriesRoot, annotationRoot } = this;
    seriesRoot.setClipRect(clipRect);
    annotationRoot.setClipRect(clipRect);
  }
  async processData() {
    await super.processData();
    if (this.syncStatus === "init") {
      this.syncStatus = "domains-calculated";
    }
    this.ctx.updateService.dispatchProcessData({ series: { shouldFlipXY: this.shouldFlipXY() } });
  }
  async processDomains() {
    await super.processDomains();
    for (const axis of this.axes) {
      const syncedDomain = await this.getSyncedDomain(axis);
      if (syncedDomain != null) {
        axis.setDomains(syncedDomain);
      }
    }
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot } = this;
    const { clipSeries, seriesRect, visible } = this.updateAxes(ctx.layoutBox);
    this.seriesRoot.visible = visible;
    this.seriesRect = seriesRect;
    this.animationRect = ctx.layoutBox;
    const { x, y } = seriesRect;
    if (ctx.width !== this.lastLayoutWidth || ctx.height !== this.lastLayoutHeight) {
      for (const group of [seriesRoot, annotationRoot]) {
        group.translationX = Math.floor(x);
        group.translationY = Math.floor(y);
      }
    } else {
      const { translationX, translationY } = seriesRoot;
      staticFromToMotion(
        this.id,
        "seriesRect",
        this.ctx.animationManager,
        [seriesRoot, annotationRoot],
        { translationX, translationY },
        { translationX: Math.floor(x), translationY: Math.floor(y) },
        { phase: "update" }
      );
    }
    this.lastLayoutWidth = ctx.width;
    this.lastLayoutHeight = ctx.height;
    const seriesArea = this.modulesManager.getModule("seriesArea");
    const seriesPaddedRect = seriesRect.clone().grow(seriesArea.getPadding());
    const clipRect = seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;
    const { lastUpdateClipRect } = this;
    this.lastUpdateClipRect = clipRect;
    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {
      this.ctx.animationManager.animate({
        id: this.id,
        groupId: "clip-rect",
        phase: "update",
        from: lastUpdateClipRect,
        to: seriesPaddedRect,
        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),
        onComplete: () => this.setRootClipRects(clipRect)
      });
    } else {
      this.setRootClipRects(clipRect);
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      axes: this.axes.map((axis) => axis.getLayoutState()),
      series: {
        visible,
        rect: seriesRect,
        paddedRect: seriesPaddedRect
      },
      clipSeries
    });
  }
  updateAxes(layoutBox) {
    const { clipSeries, seriesRect, overflows } = this.resolveAxesLayout(layoutBox);
    for (const axis of this.axes) {
      axis.update();
      axis.setCrossLinesVisible(!overflows);
      this.clipAxis(axis, seriesRect, layoutBox);
    }
    return { clipSeries, seriesRect, visible: !overflows };
  }
  // Iteratively try to resolve axis widths - since X axis width affects Y axis range,
  // and vice-versa, we need to iteratively try and find a fit for the axes and their
  // ticks/labels.
  resolveAxesLayout(layoutBox) {
    let newState;
    let prevState;
    let iterations = 0;
    const maxIterations = 10;
    do {
      prevState = newState ?? this.getDefaultState();
      newState = this.updateAxesPass(new Map(prevState.axisAreaWidths), layoutBox.clone());
      if (iterations++ > maxIterations) {
        Logger34.warn("Max iterations reached. Unable to stabilize axes layout.");
        break;
      }
    } while (!this.isLayoutStable(newState, prevState));
    this.lastAreaWidths = newState.axisAreaWidths;
    return newState;
  }
  updateAxesPass(axisAreaWidths, axisAreaBound) {
    const axisWidths = /* @__PURE__ */ new Map();
    const primaryTickCounts = {};
    let overflows = false;
    let clipSeries = false;
    for (const dir of directions) {
      const padding2 = this.modulesManager.getModule("seriesArea").getPadding()[dir];
      const axis = this.axes.findLast((a) => a.position === dir);
      if (axis) {
        axis.seriesAreaPadding = padding2;
      } else {
        axisAreaBound.shrink(padding2, dir);
      }
    }
    const totalWidth = (axisAreaWidths.get("left") ?? 0) + (axisAreaWidths.get("right") ?? 0);
    const totalHeight = (axisAreaWidths.get("top") ?? 0) + (axisAreaWidths.get("bottom") ?? 0);
    const crossLinePadding = this.buildCrossLinePadding(axisAreaWidths);
    const crossLineHPadding = crossLinePadding.left + crossLinePadding.right;
    const crossLineVPadding = crossLinePadding.top + crossLinePadding.bottom;
    if (axisAreaBound.width <= totalWidth + crossLineHPadding || axisAreaBound.height <= totalHeight + crossLineVPadding) {
      overflows = true;
    } else {
      axisAreaBound.shrink(crossLinePadding);
    }
    const { scene } = this.ctx;
    const seriesRect = axisAreaBound.clone().shrink(Object.fromEntries(axisAreaWidths));
    for (const axis of this.axes) {
      const { position = "left", direction } = axis;
      const isVertical = direction === "y" /* Y */;
      let axisWidth;
      this.sizeAxis(axis, seriesRect, position);
      if (axis.thickness == null) {
        const availableSize = getSize(isVertical, scene);
        axisWidth = availableSize * (axis.maxThicknessRatio ?? 1);
      } else {
        axisWidth = axis.thickness;
      }
      const { primaryTickCount, bbox } = axis.calculateLayout(
        axis.nice ? primaryTickCounts[direction] : void 0,
        { sizeLimit: axisWidth, padding: this.padding }
      );
      primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);
      clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
      if (axis.thickness == null) {
        axisWidth = Math.min(getSize(isVertical, bbox) ?? 0, axisWidth);
      }
      axisWidths.set(axis.id, Math.ceil(axisWidth));
    }
    const axisGroups = groupBy2(this.axes, (axis) => axis.position ?? "left");
    const newAxisAreaWidths = /* @__PURE__ */ new Map();
    const axisOffsets = /* @__PURE__ */ new Map();
    for (const [position, axes] of entries6(axisGroups)) {
      let currentOffset = getSize(position !== "left" && position !== "right", scene) % scene.pixelRatio;
      let totalAxisWidth = 0;
      for (const axis of axes ?? []) {
        axisOffsets.set(axis.id, currentOffset);
        const axisThickness = axisWidths.get(axis.id) ?? 0;
        totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);
        if (axis.layoutConstraints.stacked) {
          currentOffset += axisThickness + _CartesianChart.AxesPadding;
        }
      }
      newAxisAreaWidths.set(position, Math.ceil(totalAxisWidth));
    }
    for (const [position, axes] of entries6(axisGroups)) {
      this.positionAxes({
        axes: axes ?? [],
        position,
        axisWidths,
        axisOffsets,
        axisAreaWidths: newAxisAreaWidths,
        axisBound: axisAreaBound,
        seriesRect
      });
    }
    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, overflows };
  }
  buildCrossLinePadding(axisAreaSize) {
    const crossLinePadding = { top: 0, right: 0, bottom: 0, left: 0 };
    this.axes.forEach((axis) => {
      const { position, label } = axis;
      axis.crossLines?.forEach((crossLine) => {
        var _a;
        if (crossLine instanceof CartesianCrossLine) {
          crossLine.position = position ?? "top";
          (_a = crossLine.label).parallel ?? (_a.parallel = label.parallel);
        }
        crossLine.calculatePadding?.(crossLinePadding);
      });
    });
    for (const [side, padding2 = 0] of entries6(crossLinePadding)) {
      crossLinePadding[side] = Math.max(padding2 - (axisAreaSize.get(side) ?? 0), 0);
    }
    return crossLinePadding;
  }
  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
    const bound = dimension === "x" ? seriesRect.x : seriesRect.y;
    const size = dimension === "x" ? seriesRect.width : seriesRect.height;
    return direction === 1 ? Math.min(value, bound + size) : Math.max(value, bound);
  }
  async getSyncedDomain(axis) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    return await syncModule.getSyncedDomain(axis);
  }
  syncAxisChanges(newValue, oldValue) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    const removed = new Set(oldValue ?? []);
    for (const axis of newValue) {
      removed.delete(axis);
    }
    for (const removedAxis of removed) {
      syncModule.removeAxis(removedAxis);
    }
  }
  sizeAxis(axis, seriesRect, position) {
    const isNumberAxis = axis instanceof NumberAxis;
    const isLeftRight = position === "left" || position === "right";
    const { width: width2, height: height2 } = seriesRect;
    const maxEnd = isLeftRight ? height2 : width2;
    let start2 = 0;
    let end2 = maxEnd;
    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);
    const { width: axisWidth, unit, align: align2 } = axis.layoutConstraints;
    if (unit === "px") {
      end2 = start2 + axisWidth;
    } else {
      end2 = end2 * axisWidth / 100;
    }
    if (align2 === "end") {
      start2 = maxEnd - (end2 - start2);
      end2 = maxEnd;
    }
    if (isLeftRight) {
      if (isNumberAxis) {
        [start2, end2] = [end2, start2];
      } else {
        [min, max] = [1 - max, 1 - min];
      }
    }
    axis.range = [start2, end2];
    axis.visibleRange = [min, max];
    axis.gridLength = isLeftRight ? width2 : height2;
  }
  positionAxes(opts) {
    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;
    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;
    let mainDimension = "x";
    let minorDimension = "y";
    let direction = 1;
    if (position === "top" || position === "bottom") {
      mainDimension = "y";
      minorDimension = "x";
    }
    let axisBoundMainOffset = axisBound[mainDimension];
    if (position === "right" || position === "bottom") {
      direction = -1;
      axisBoundMainOffset += mainDimension === "x" ? axisBound.width : axisBound.height;
    }
    for (const axis of axes) {
      const minorOffset = axisAreaWidths.get(minorDimension === "x" ? "left" : "top") ?? 0;
      const axisThickness = axisWidths.get(axis.id) ?? 0;
      const axisOffset = axisOffsets.get(axis.id) ?? 0;
      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;
      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;
      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(
        seriesRect,
        axisBoundMainOffset + direction * (axisOffset + axisThickness),
        mainDimension,
        direction
      );
    }
  }
  shouldFlipXY() {
    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());
  }
  getDefaultState() {
    const axisAreaWidths = /* @__PURE__ */ new Map();
    if (this.lastAreaWidths) {
      for (const { position = "left" } of this.axes) {
        const areaWidth = this.lastAreaWidths.get(position);
        if (areaWidth != null) {
          axisAreaWidths.set(position, areaWidth);
        }
      }
    }
    return { axisAreaWidths, clipSeries: false, overflows: false };
  }
  isLayoutStable(newState, prevState) {
    if (prevState.overflows !== newState.overflows || prevState.clipSeries !== newState.clipSeries) {
      return false;
    }
    for (const key of newState.axisAreaWidths.keys()) {
      if (!prevState.axisAreaWidths.has(key)) {
        return false;
      }
    }
    for (const [p, w] of prevState.axisAreaWidths.entries()) {
      const otherW = newState.axisAreaWidths.get(p);
      if ((w != null || otherW != null) && w !== otherW) {
        return false;
      }
    }
    return true;
  }
  clipAxis(axis, seriesRect, layoutBBox) {
    const gridLinePadding = Math.ceil(axis.gridLine?.width ?? 0);
    const axisLinePadding = Math.ceil(axis.line?.width ?? 0);
    let { width: width2, height: height2 } = seriesRect;
    width2 += axis.direction === "x" /* X */ ? gridLinePadding : axisLinePadding;
    height2 += axis.direction === "y" /* Y */ ? gridLinePadding : axisLinePadding;
    axis.clipGrid(seriesRect.x, seriesRect.y, width2, height2);
    switch (axis.position) {
      case "left":
      case "right":
        axis.clipTickLines(
          layoutBBox.x,
          seriesRect.y - gridLinePadding,
          layoutBBox.width + gridLinePadding,
          seriesRect.height + gridLinePadding * 2
        );
        break;
      case "top":
      case "bottom":
        axis.clipTickLines(
          seriesRect.x - gridLinePadding,
          layoutBBox.y,
          seriesRect.width + gridLinePadding * 2,
          layoutBBox.height + gridLinePadding
        );
        break;
    }
  }
};
_CartesianChart.className = "CartesianChart";
_CartesianChart.type = "cartesian";
_CartesianChart.AxesPadding = 15;
var CartesianChart = _CartesianChart;
function getSize(isVertical, bounds) {
  return isVertical ? bounds?.width : bounds?.height;
}

// packages/ag-charts-community/src/chart/chartOptionsDefs.ts
import {
  array as array3,
  arrayLength as arrayLength3,
  arrayOfDefs as arrayOfDefs3,
  boolean as boolean7,
  defined as defined4,
  geoJson,
  htmlElement as htmlElement2,
  string as string7,
  undocumented as undocumented6,
  union as union5
} from "ag-charts-core";
var commonChartOptions = {
  mode: undocumented6(union5("integrated", "standalone")),
  container: htmlElement2,
  context: () => true,
  theme: defined4,
  series: array3,
  annotations: defined4,
  navigator: defined4,
  initialState: {
    chartType: string7,
    annotations: defined4,
    legend: arrayOfDefs3(
      {
        visible: boolean7,
        seriesId: string7,
        itemId: string7,
        legendItemName: string7
      },
      "legend state array"
    ),
    zoom: defined4
  }
};
var cartesianChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  axes: arrayLength3(2),
  data: array3
};
var polarChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  axes: arrayLength3(2),
  data: array3
};
var topologyChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: array3,
  topology: geoJson
};
var standaloneChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: array3
};

// packages/ag-charts-community/src/chart/cartesianChartModule.ts
var histogramAxisTypes = /* @__PURE__ */ new Set(["number", "log", "time"]);
var validHistogramAxis = (axis) => isObject7(axis) && !histogramAxisTypes.has(axis.type);
var CartesianChartModule = {
  type: "chart",
  name: "cartesian",
  options: cartesianChartOptionsDefs,
  detect: isAgCartesianChartOptions,
  create(options, resources) {
    return new CartesianChart(options, resources);
  },
  validate(options, optionsDefs4, path) {
    const additionalErrors = [];
    if (options?.series?.[0]?.type === "histogram") {
      if (options?.axes?.some(validHistogramAxis)) {
        additionalErrors.push(
          new ValidationError2(
            "invalid",
            "only continuous axis types when histogram series is used",
            options.axes,
            path,
            "axes"
          )
        );
        options = without(options, ["axes"]);
      }
    }
    const result = validate3(options, optionsDefs4, path);
    result.invalid.push(...additionalErrors);
    return result;
  }
};

// packages/ag-charts-community/src/chart/enterpriseChartModules.ts
var placeholderCreate = () => {
  throw new Error("Enterprise module placeholder cannot be initialised");
};
var StandaloneChartModule = {
  type: "chart",
  name: "standalone",
  placeholder: true,
  options: {},
  detect: isAgStandaloneChartOptions,
  create: placeholderCreate
};
var TopologyChartModule = {
  type: "chart",
  name: "topology",
  placeholder: true,
  options: {},
  detect: isAgTopologyChartOptions,
  create: placeholderCreate
};

// packages/ag-charts-community/src/chart/polarChartModule.ts
import { UnknownError, validate as validate4 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/polarChart.ts
import { iterate as iterate2 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis = class extends Axis {
  constructor() {
    super(...arguments);
    this.shape = "polygon";
    this.innerRadiusRatio = 0;
    this.defaultTickMinSpacing = 20;
  }
  layoutCrossLines() {
    const sideFlag = this.label.getSideFlag();
    const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    this.crossLines.forEach((crossLine) => {
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "angle" /* Angle */ : "radius" /* Radius */;
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.calculateLayout?.(crosslinesVisible, this.reverse);
    });
  }
  updatePosition() {
    super.updatePosition();
    const translationX = Math.floor(this.translation.x);
    const translationY = Math.floor(this.translation.y);
    this.tickLineGroup.translationX = translationX;
    this.tickLineGroup.translationY = translationY;
    this.tickLabelGroup.translationX = translationX;
    this.tickLabelGroup.translationY = translationY;
    this.crossLineRangeGroup.translationX = translationX;
    this.crossLineRangeGroup.translationY = translationY;
    this.crossLineLineGroup.translationX = translationX;
    this.crossLineLineGroup.translationY = translationY;
    this.crossLineLabelGroup.translationX = translationX;
    this.crossLineLabelGroup.translationY = translationY;
    this.tickLabelGroupSelection.each(resetAxisLabelSelectionFn());
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  computeRange() {
  }
  getAxisLinePoints() {
    return void 0;
  }
};
__decorateClass([
  Property
], PolarAxis.prototype, "shape", 2);
__decorateClass([
  Property
], PolarAxis.prototype, "innerRadiusRatio", 2);

// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var DEFAULT_POLAR_DIRECTION_KEYS = {
  ["angle" /* Angle */]: ["angleKey"],
  ["radius" /* Radius */]: ["radiusKey"]
};
var DEFAULT_POLAR_DIRECTION_NAMES = {
  ["angle" /* Angle */]: ["angleName"],
  ["radius" /* Radius */]: ["radiusName"]
};
var PolarSeries = class extends DataModelSeries {
  constructor({
    categoryKey,
    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
    canHaveAxes = false,
    animationResetFns,
    ...opts
  }) {
    super({
      ...opts,
      categoryKey,
      pickModes,
      canHaveAxes
    });
    this.directions = ["angle" /* Angle */, "radius" /* Radius */];
    this.itemGroup = this.contentGroup.appendChild(new Group());
    this.nodeData = [];
    this.itemSelection = Selection.select(
      this.itemGroup,
      () => this.nodeFactory(),
      false
    );
    this.labelSelection = Selection.select(
      this.labelGroup,
      () => this.labelFactory(),
      false
    );
    this.highlightSelection = Selection.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */
    this.centerX = 0;
    this.centerY = 0;
    /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */
    this.radius = 0;
    this.animationResetFns = animationResetFns;
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getItemNodes() {
    return [...this.itemGroup.children()];
  }
  getNodeData() {
    return this.nodeData;
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [zIndex, 1 /* FOREGROUND */];
    this.highlightGroup.zIndex = [zIndex, 2 /* HIGHLIGHT */];
    this.labelGroup.zIndex = [zIndex, 3 /* LABEL */];
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  labelFactory() {
    const text = new Text();
    text.pointerEvents = 1 /* None */;
    return text;
  }
  addChartEventListeners() {
    this.cleanup.register(
      this.ctx.eventsHub.on("legend:item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.eventsHub.on("legend:item-double-click", (event) => this.onLegendItemDoubleClick(event))
    );
  }
  getInnerRadius() {
    return 0;
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  getShapeFillBBox() {
    const outerRadius = this.radius;
    return {
      series: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2),
      axis: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2)
    };
  }
  resetAllAnimation() {
    const { item, label } = this.animationResetFns ?? {};
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (item) {
      resetMotion([this.itemSelection, this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.labelSelection], label);
    }
    this.itemSelection.cleanup();
    this.labelSelection.cleanup();
    this.highlightSelection.cleanup();
  }
  animateEmptyUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateWaitingUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateReadyHighlight(_data) {
    const { item } = this.animationResetFns ?? {};
    if (item) {
      resetMotion([this.highlightSelection], item);
    }
  }
  animateReadyHighlightMarkers(_data) {
  }
  animateReadyResize(_data) {
    this.resetAllAnimation();
  }
  animateClearingUpdateEmpty(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  computeFocusBounds(opts) {
    const datum = this.getNodeData()?.[opts.datumIndex];
    if (datum !== void 0) {
      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];
    }
    return void 0;
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  isSeriesHighlighted(highlightedDatum, legendItemValues) {
    const { series, legendItemName: activeLegendItemName, itemId } = highlightedDatum ?? {};
    const legendItemName = legendItemValues?.[itemId];
    return series === this || legendItemName != null && legendItemName === activeLegendItemName;
  }
};

// packages/ag-charts-community/src/chart/polarChart.ts
var PolarChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this.padding = new Padding(40);
    this.ctx.axisManager.axisGroup.zIndex = 8 /* AXIS_FOREGROUND */;
  }
  getChartType() {
    return "polar";
  }
  async performLayout(ctx) {
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone().shrink(this.modulesManager.getModule("seriesArea").getPadding());
    this.seriesRect = seriesRect;
    this.animationRect = seriesRect;
    this.seriesRoot.translationX = seriesRect.x;
    this.seriesRoot.translationY = seriesRect.y;
    await this.computeCircle(seriesRect);
    this.axes.forEach((axis) => axis.update());
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  updateAxes(seriesBox, cx, cy, radius) {
    const angleAxis = this.axes.find((axis) => axis.direction === "angle" /* Angle */);
    const radiusAxis = this.axes.find((axis) => axis.direction === "radius" /* Radius */);
    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))
      return;
    const angleScale = angleAxis.scale;
    const innerRadiusRatio = radiusAxis.innerRadiusRatio;
    angleAxis.innerRadiusRatio = innerRadiusRatio;
    angleAxis.computeRange();
    angleAxis.gridLength = radius;
    radiusAxis.gridAngles = angleScale.ticks({
      nice: angleAxis.nice,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    })?.ticks?.map((value) => angleScale.convert(value));
    radiusAxis.gridRange = angleAxis.range;
    radiusAxis.range = [radius, radius * innerRadiusRatio];
    [angleAxis, radiusAxis].forEach((axis) => {
      axis.translation.x = seriesBox.x + cx;
      axis.translation.y = seriesBox.y + cy;
      axis.calculateLayout();
    });
  }
  async computeCircle(seriesBox) {
    const polarSeries = this.series.filter(isPolarSeries);
    const polarAxes = this.axes.filter(isPolarAxis);
    const setSeriesCircle = (cx, cy, r) => {
      this.updateAxes(seriesBox, cx, cy, r);
      polarSeries.forEach((series) => {
        series.centerX = cx;
        series.centerY = cy;
        series.radius = r;
      });
      const pieSeries = polarSeries.filter((s) => s.type === "donut" || s.type === "pie");
      if (pieSeries.length > 1) {
        const innerRadii = pieSeries.map((series) => {
          const innerRadius = series.getInnerRadius();
          return { series, innerRadius };
        }).sort((a, b) => a.innerRadius - b.innerRadius);
        innerRadii.at(-1).series.surroundingRadius = void 0;
        for (let i = 0; i < innerRadii.length - 1; i++) {
          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
        }
      }
    };
    const centerX = seriesBox.width / 2;
    const centerY = seriesBox.height / 2;
    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
    let radius = initialRadius;
    setSeriesCircle(centerX, centerY, radius);
    const shake = async ({ hideWhenNecessary = false } = {}) => {
      const labelBoxes = [];
      for (const series of iterate2(polarAxes, polarSeries)) {
        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);
        if (box) {
          labelBoxes.push(box);
        }
      }
      if (labelBoxes.length === 0) {
        setSeriesCircle(centerX, centerY, initialRadius);
        return;
      }
      const labelBox = BBox.merge(labelBoxes);
      const refined = this.refineCircle(labelBox, radius, seriesBox);
      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
      radius = refined.radius;
    };
    await shake();
    await shake();
    await shake();
    await shake({ hideWhenNecessary: true });
    await shake({ hideWhenNecessary: true });
    for (const series of iterate2(polarAxes, polarSeries)) {
      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);
    }
    return { radius, centerX, centerY };
  }
  refineCircle(labelsBox, radius, seriesBox) {
    const minCircleRatio = 0.5;
    const circleLeft = -radius;
    const circleTop = -radius;
    const circleRight = radius;
    const circleBottom = radius;
    let padLeft = Math.max(0, circleLeft - labelsBox.x);
    let padTop = Math.max(0, circleTop - labelsBox.y);
    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
    padLeft = padRight = Math.max(padLeft, padRight);
    padTop = padBottom = Math.max(padTop, padBottom);
    const availCircleWidth = seriesBox.width - padLeft - padRight;
    const availCircleHeight = seriesBox.height - padTop - padBottom;
    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
    if (newRadius < minRadius) {
      newRadius = minRadius;
      const horizontalPadding = padLeft + padRight;
      const verticalPadding = padTop + padBottom;
      if (2 * newRadius + verticalPadding > seriesBox.height) {
        const padHeight = seriesBox.height - 2 * newRadius;
        if (Math.min(padTop, padBottom) * 2 > padHeight) {
          padTop = padHeight / 2;
          padBottom = padHeight / 2;
        } else if (padTop > padBottom) {
          padTop = padHeight - padBottom;
        } else {
          padBottom = padHeight - padTop;
        }
      }
      if (2 * newRadius + horizontalPadding > seriesBox.width) {
        const padWidth = seriesBox.width - 2 * newRadius;
        if (Math.min(padLeft, padRight) * 2 > padWidth) {
          padLeft = padWidth / 2;
          padRight = padWidth / 2;
        } else if (padLeft > padRight) {
          padLeft = padWidth - padRight;
        } else {
          padRight = padWidth - padLeft;
        }
      }
    }
    const newWidth = padLeft + 2 * newRadius + padRight;
    const newHeight = padTop + 2 * newRadius + padBottom;
    return {
      centerX: (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
      centerY: (seriesBox.height - newHeight) / 2 + padTop + newRadius,
      radius: newRadius
    };
  }
};
PolarChart.className = "PolarChart";
PolarChart.type = "polar";
function isPolarSeries(series) {
  return series instanceof PolarSeries;
}
function isPolarAxis(axis) {
  return axis instanceof PolarAxis;
}

// packages/ag-charts-community/src/chart/polarChartModule.ts
var PolarChartModule = {
  type: "chart",
  name: "polar",
  options: polarChartOptionsDefs,
  detect: isAgPolarChartOptions,
  create(options, resources) {
    return new PolarChart(options, resources);
  },
  validate(options, optionsDefs4, path) {
    const additionalErrors = [];
    const baseType = options?.series?.[0]?.type;
    if (baseType === "pie" || baseType === "donut") {
      if (options?.axes) {
        additionalErrors.push(new UnknownError([], options.axes, path, "axes"));
        options = without(options, ["axes"]);
      }
    }
    const result = validate4(options, optionsDefs4, path);
    result.invalid.push(...additionalErrors);
    return result;
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
import { isDefined } from "ag-charts-core";

// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
  const animate = (phase, path, collapsable, updateFn) => {
    animationManager.animate({
      id: `${groupId}_${subId}_${path.id}_${phase}`,
      groupId,
      from: collapsable ? 1 : 0,
      to: 1,
      ease: easeOut,
      collapsable,
      onUpdate(ratio8, preInit) {
        if (preInit && phase !== "removed")
          return;
        path.path.clear(true);
        updateFn(ratio8, path);
        path.checkPathDirty();
      },
      onStop() {
        if (phase !== "added")
          return;
        path.path.clear(true);
        updateFn(1, path);
        path.checkPathDirty();
      },
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
    });
  };
  const tempPath = new Path();
  const resultsChange = (updateFn) => {
    tempPath.resetPathDirty();
    updateFn(0, tempPath);
    tempPath.resetPathDirty();
    updateFn(1, tempPath);
    tempPath.checkPathDirty();
    return tempPath.isPathDirty();
  };
  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
  for (const path of paths) {
    if (!animationManager.isSkipped()) {
      animate("removed", path, !resultsChange(removePhaseFn), removePhaseFn);
      animate("updated", path, !resultsChange(updatePhaseFn), updatePhaseFn);
    }
    animate("added", path, !resultsChange(addPhaseFn), addPhaseFn);
  }
}

// packages/ag-charts-community/src/chart/axis/logAxis.ts
import { Logger as Logger35 } from "ag-charts-core";
var LogAxis = class extends NumberAxis {
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    if (extent2[0] < 0 && extent2[1] > 0 || d[0] < 0 && d[1] > 0) {
      Logger35.warn(
        `The log axis domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`
      );
      return { domain: [], clipped };
    } else if (extent2[0] === 0 || extent2[1] === 0 || d[0] === 0 || d[1] === 0) {
      Logger35.warn(
        `The log axis domain contains a value of 0, the chart data cannot be rendered. See log axis documentation for more information.`
      );
      return { domain: [], clipped };
    }
    return { domain: extent2, clipped };
  }
  set base(value) {
    this.scale.base = value;
  }
  get base() {
    return this.scale.base;
  }
  constructor(moduleCtx) {
    super(moduleCtx, new LogScale());
  }
};
LogAxis.className = "LogAxis";
LogAxis.type = "log";

// packages/ag-charts-community/src/chart/data/processors.ts
import { clamp as clamp18, isArray as isArray12, isFiniteNumber as isFiniteNumber6, isNegative as isNegative2 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts
import { isFiniteNumber as isFiniteNumber5 } from "ag-charts-core";
function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function groupSum(id, matchGroupId) {
  return {
    id,
    type: "aggregate",
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function range2(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)
  };
  return result;
}
function groupCount(id) {
  return {
    id,
    type: "aggregate",
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function groupAverage(id, matchGroupId) {
  const def = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result = acc[0] + acc[1];
      if (result >= 0) {
        return [0, result / acc[2]];
      }
      return [result / acc[2], 0];
    }
  };
  return def;
}
function area(id, aggFn, matchGroupId) {
  const result = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue(onlyPositive) {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber5(datum)) {
        return datum;
      }
      value += onlyPositive ? Math.max(0, datum) : datum;
      return value;
    };
  };
}

// packages/ag-charts-community/src/chart/data/processors.ts
var MAX_ANIMATABLE_NODES = 1e3;
function processedDataIsAnimatable(processedData) {
  return processedData.input.count <= MAX_ANIMATABLE_NODES;
}
function basicContinuousCheckDatumValidation(value) {
  return value != null && isContinuous(value);
}
function basicDiscreteCheckDatumValidation(value) {
  return value != null;
}
function getValidationFn(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "unit-time":
    case "ordinal-time":
    case "color":
      return basicContinuousCheckDatumValidation;
    default:
      return basicDiscreteCheckDatumValidation;
  }
}
function getValueType(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "color":
      return "range";
    default:
      return "category";
  }
}
function keyProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "key",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function valueProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function rowCountProperty(propName, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: "range",
    missingValue: 1,
    processor: () => () => 1,
    ...opts
  };
  return result;
}
var noopProcessor = function(v) {
  return v;
};
function processorChain(...chain) {
  const filteredChain = chain.filter((fn) => fn != null);
  if (filteredChain.length === 0) {
    return () => noopProcessor;
  }
  if (filteredChain.length === 1) {
    return filteredChain[0];
  }
  return () => {
    const processorInstances = filteredChain.map((fn) => fn());
    return (value, index) => {
      return processorInstances.reduce((r, p) => p(r, index), value);
    };
  };
}
function rangedValueProperty(propName, opts = {}) {
  const { min = -Infinity, max = Infinity, processor, ...defOpts } = opts;
  return {
    type: "value",
    property: propName,
    valueType: "range",
    validation: basicContinuousCheckDatumValidation,
    processor: processorChain(processor, () => (datum) => isFiniteNumber6(datum) ? clamp18(min, datum, max) : datum),
    ...defOpts
  };
}
function accumulativeValueProperty(propName, scaleType, opts = {}) {
  const { onlyPositive, processor, ...defOpts } = opts;
  const result = {
    ...valueProperty(propName, scaleType, defOpts),
    processor: processorChain(processor, accumulatedValue(onlyPositive))
  };
  return result;
}
function groupAccumulativeValueProperty(propName, mode, sum, opts, scaleType) {
  return [
    valueProperty(propName, scaleType, opts),
    accumulateGroup(opts.groupId, mode, sum, opts.separateNegative),
    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []
  ];
}
function groupStackValueProperty(propName, scaleType, opts) {
  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];
}
var SMALLEST_KEY_INTERVAL = {
  type: "reducer",
  property: "smallestKeyInterval",
  initialValue: Infinity,
  reducer: () => {
    let prevX = NaN;
    return (smallestSoFar = Infinity, keys) => {
      const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
        return interval;
      }
      return smallestSoFar;
    };
  }
};
var LARGEST_KEY_INTERVAL = {
  type: "reducer",
  property: "largestKeyInterval",
  initialValue: -Infinity,
  reducer: () => {
    let prevX = NaN;
    return (largestSoFar = -Infinity, keys) => {
      const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {
        return interval;
      }
      return largestSoFar;
    };
  }
};
var SORT_DOMAIN_GROUPS = {
  type: "processor",
  property: "sortedGroupDomain",
  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {
    for (let i = 0; i < a.length; i++) {
      const result = a[i] - b[i];
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  })
};
function normaliseFnBuilder({ normaliseTo }) {
  const normalise2 = (val, extent2) => {
    if (extent2 === 0)
      return null;
    const result = (val ?? 0) * normaliseTo / extent2;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return () => () => (columns, valueIndexes, dataGroup) => {
    const extent2 = normaliseFindExtent(columns, valueIndexes, dataGroup);
    for (const valueIdx of valueIndexes) {
      const datumIndices = dataGroup.datumIndices[valueIdx];
      if (datumIndices == null)
        continue;
      for (const datumIndex of datumIndices) {
        const column = columns[valueIdx];
        const value = column[datumIndex];
        if (value == null) {
          column[datumIndex] = void 0;
          continue;
        }
        column[datumIndex] = // eslint-disable-next-line sonarjs/no-nested-functions
        typeof value === "number" ? normalise2(value, extent2) : value.map((v) => normalise2(v, extent2));
      }
    }
  };
}
function normaliseFindExtent(columns, valueIndexes, dataGroup) {
  const valuesExtent = [0, 0];
  for (const valueIdx of valueIndexes) {
    const column = columns[valueIdx];
    const datumIndices = dataGroup.datumIndices[valueIdx];
    if (datumIndices == null)
      continue;
    for (const datumIndex of datumIndices) {
      const value = column[datumIndex];
      if (value == null)
        continue;
      const valueExtent = typeof value === "number" ? value : Math.max(...value.map((v) => v ?? 0));
      const valIdx = valueExtent < 0 ? 0 : 1;
      if (valIdx === 0) {
        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);
      } else {
        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);
      }
    }
  }
  return Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
}
function normaliseGroupTo(matchGroupIds, normaliseTo) {
  return {
    type: "group-value-processor",
    matchGroupIds,
    adjust: memo({ normaliseTo }, normaliseFnBuilder)
  };
}
function normalisePropertyFnBuilder({
  normaliseTo,
  zeroDomain,
  rangeMin,
  rangeMax
}) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise2 = (val, start2, span) => {
    const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;
    if (span === 0) {
      return zeroDomain;
    } else if (result >= normaliseTo[1]) {
      return normaliseTo[1];
    } else if (result < normaliseTo[0]) {
      return normaliseTo[0];
    }
    return result;
  };
  return () => (pData, pIdx) => {
    let [start2, end2] = pData.domain.values[pIdx];
    if (rangeMin != null)
      start2 = rangeMin;
    if (rangeMax != null)
      end2 = rangeMax;
    const span = end2 - start2;
    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
    const column = pData.columns[pIdx];
    for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {
      column[datumIndex] = normalise2(column[datumIndex], start2, span);
    }
  };
}
function normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
  return {
    type: "property-value-processor",
    property,
    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)
  };
}
var ANIMATION_VALIDATION_UNIQUE_KEYS = 1;
var ANIMATION_VALIDATION_ORDERED_KEYS = 2;
function animationValidationProcessKey(count, def, keyValues, column) {
  let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
  if (def.valueType === "category") {
    if (keyValues.length < count)
      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
    return validation;
  }
  let lastValue = column[0]?.valueOf();
  for (let d = 1; validation !== 0 && d < column.length; d++) {
    const keyValue = column[d]?.valueOf();
    if (!Number.isFinite(keyValue) || lastValue > keyValue)
      validation &= ~ANIMATION_VALIDATION_ORDERED_KEYS;
    if (Number.isFinite(keyValue) && lastValue === keyValue)
      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
    lastValue = keyValue;
  }
  return validation;
}
function animationValidation(valueKeyIds) {
  return {
    type: "processor",
    property: "animationValidation",
    calculate(result) {
      if (!processedDataIsAnimatable(result))
        return;
      const { keys: keysDefs, values: valuesDef } = result.defs;
      const {
        input,
        domain: { keys: domainKeys, values: domainValues },
        keys,
        columns,
        invalidKeyCount
      } = result;
      let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
      if (input.count !== 0) {
        for (let i = 0; validation !== 0 && i < keysDefs.length; i++) {
          for (const scope of keysDefs[i].scopes) {
            const column = keys[i].get(scope);
            const missingKeys = invalidKeyCount?.get(scope) ?? 0;
            const count = column.length - missingKeys;
            validation &= animationValidationProcessKey(count, keysDefs[i], domainKeys[i], column);
          }
        }
        for (let i = 0; validation !== 0 && i < valuesDef.length; i++) {
          const value = valuesDef[i];
          if (!valueKeyIds?.includes(value.id))
            continue;
          validation &= animationValidationProcessKey(
            0,
            value,
            domainValues[i],
            columns[i]
          );
        }
      }
      return {
        uniqueKeys: (validation & ANIMATION_VALIDATION_UNIQUE_KEYS) !== 0,
        orderedKeys: (validation & ANIMATION_VALIDATION_ORDERED_KEYS) !== 0
      };
    }
  };
}
function buildGroupAccFn({ mode, separateNegative }) {
  return () => () => (columns, valueIndexes, dataGroup) => {
    const acc = [0, 0];
    for (const valueIdx of valueIndexes) {
      const datumIndices = dataGroup.datumIndices[valueIdx];
      if (datumIndices == null)
        continue;
      for (const datumIndex of datumIndices) {
        const column = columns[valueIdx];
        const currentVal = column[datumIndex];
        const accIndex = isNegative2(currentVal) && separateNegative ? 0 : 1;
        if (!isFiniteNumber6(currentVal))
          continue;
        if (mode === "normal")
          acc[accIndex] += currentVal;
        column[datumIndex] = acc[accIndex];
        if (mode === "trailing")
          acc[accIndex] += currentVal;
      }
    }
  };
}
function buildGroupWindowAccFn({ mode, sum }) {
  return () => {
    const lastValues = [];
    let firstRow = true;
    return () => {
      return (columns, valueIndexes, dataGroup) => {
        let acc = 0;
        for (const valueIdx of valueIndexes) {
          const column = columns[valueIdx];
          const datumIndices = dataGroup.datumIndices[valueIdx];
          if (datumIndices == null)
            continue;
          for (const datumIndex of datumIndices) {
            const currentVal = column[datumIndex];
            const lastValue = firstRow && sum === "current" ? 0 : lastValues[valueIdx];
            lastValues[valueIdx] = currentVal;
            const sumValue = sum === "current" ? currentVal : lastValue;
            if (!isFiniteNumber6(currentVal) || !isFiniteNumber6(lastValue)) {
              column[datumIndex] = acc;
              continue;
            }
            if (mode === "normal") {
              acc += sumValue;
            }
            column[datumIndex] = acc;
            if (mode === "trailing") {
              acc += sumValue;
            }
          }
        }
        firstRow = false;
      };
    };
  };
}
function accumulateGroup(matchGroupId, mode, sum, separateNegative = false) {
  let adjust;
  if (mode.startsWith("window")) {
    const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
    adjust = memo({ mode: modeParam, sum }, buildGroupWindowAccFn);
  } else {
    adjust = memo({ mode, separateNegative }, buildGroupAccFn);
  }
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust
  };
}
function groupStackAccFn() {
  return () => (columns, valueIndexes, dataGroup) => {
    const acc = new Float64Array(valueIndexes.length);
    let stackCount = 0;
    for (const valueIdx of valueIndexes) {
      const column = columns[valueIdx];
      const datumIndices = dataGroup.datumIndices[valueIdx];
      if (datumIndices == null)
        continue;
      for (const datumIndex of datumIndices) {
        const currentValue = column[datumIndex];
        acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;
        stackCount += 1;
        column[datumIndex] = acc.subarray(0, stackCount);
      }
    }
  };
}
function accumulateStack(matchGroupId) {
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust: groupStackAccFn
  };
}
function valueIdentifier(value) {
  return value.id ?? value.property;
}
function valueIndices(id, previousData, processedData) {
  const properties = /* @__PURE__ */ new Map();
  const previousValues = previousData.defs.values;
  for (let previousIndex = 0; previousIndex < previousValues.length; previousIndex += 1) {
    const previousValue = previousValues[previousIndex];
    if (previousValue.scopes?.includes(id) === false)
      continue;
    const valueId = valueIdentifier(previousValue);
    if (properties.has(valueId))
      return;
    properties.set(valueId, previousIndex);
  }
  const indices = [];
  const nextValues = processedData.defs.values;
  for (let nextIndex = 0; nextIndex < nextValues.length; nextIndex += 1) {
    const nextValue = nextValues[nextIndex];
    if (nextValue.scopes?.includes(id) === false)
      continue;
    const valueId = valueIdentifier(nextValue);
    const previousIndex = properties.get(valueId);
    if (previousIndex == null)
      return;
    properties.delete(valueId);
    indices.push({ previousIndex, nextIndex });
  }
  if (properties.size !== 0)
    return;
  return indices;
}
function columnsEqual(previousColumns, nextColumns, indices, previousDatumIndex, nextDatumIndex) {
  for (const { previousIndex, nextIndex } of indices) {
    const previousColumn = previousColumns[previousIndex];
    const nextColumn = nextColumns[nextIndex];
    const previousValue = previousColumn[previousDatumIndex];
    const nextValue = nextColumn[nextDatumIndex];
    if (previousValue !== nextValue) {
      return false;
    }
  }
  return true;
}
function diff(id, previousData, updateMovedData = true) {
  return {
    type: "processor",
    property: "diff",
    calculate(processedData, previousValue) {
      if (!processedDataIsAnimatable(processedData))
        return;
      const moved = /* @__PURE__ */ new Map();
      const added = /* @__PURE__ */ new Map();
      const updated = /* @__PURE__ */ new Map();
      const removed = /* @__PURE__ */ new Map();
      const previousKeys = previousData.keys;
      const keys = processedData.keys;
      const previousColumns = previousData.columns;
      const columns = processedData.columns;
      const indices = valueIndices(id, previousData, processedData);
      if (indices == null)
        return previousValue;
      const length = Math.max(previousData.input.count, processedData.input.count);
      for (let i = 0; i < length; i++) {
        const hasPreviousDatum = i < previousData.input.count;
        const hasDatum = i < processedData.input.count;
        const prevKeys = hasPreviousDatum ? datumKeys(previousKeys, id, i) : void 0;
        const prevId = prevKeys != null ? createDatumId(prevKeys) : "";
        const dKeys = hasDatum ? datumKeys(keys, id, i) : void 0;
        const datumId = dKeys != null ? createDatumId(dKeys) : "";
        if (hasDatum && hasPreviousDatum && prevId === datumId) {
          if (!columnsEqual(previousColumns, columns, indices, i, i)) {
            updated.set(datumId, i);
          }
          continue;
        }
        const removedIndex = removed.get(datumId);
        if (removedIndex != null) {
          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, removedIndex, i)) {
            updated.set(datumId, i);
            moved.set(datumId, i);
          }
          removed.delete(datumId);
        } else if (hasDatum) {
          added.set(datumId, i);
        }
        const addedIndex = added.get(prevId);
        if (addedIndex != null) {
          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, addedIndex, i)) {
            updated.set(prevId, i);
            moved.set(prevId, i);
          }
          added.delete(prevId);
        } else if (hasPreviousDatum) {
          updated.delete(prevId);
          removed.set(prevId, i);
        }
      }
      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;
      const value = {
        changed,
        added: new Set(added.keys()),
        updated: new Set(updated.keys()),
        removed: new Set(removed.keys()),
        moved: new Set(moved.keys())
      };
      return {
        ...previousValue,
        [id]: value
      };
    }
  };
}
function createDatumId(keys, ...extraKeys) {
  let result;
  if (isArray12(keys)) {
    result = keys.map((key) => transformIntegratedCategoryValue(key)).join("___");
  } else {
    result = transformIntegratedCategoryValue(keys);
  }
  const primitiveType = typeof result === "string" || typeof result === "number" || typeof result === "boolean" || result instanceof Date;
  if (primitiveType && extraKeys.length > 0) {
    result += `___${extraKeys.join("___")}`;
  }
  return result;
}

// packages/ag-charts-community/src/chart/labelUtil.ts
function getLabelStyles(series, nodeDatum, params, label, highlighted, highlightState) {
  if (label.itemStyler) {
    const styleParams = {
      border: label.border,
      color: label.color,
      cornerRadius: label.cornerRadius,
      datum: nodeDatum?.datum,
      enabled: label.enabled,
      fill: label.fill,
      fillOpacity: label.fillOpacity,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight,
      itemId: void 0,
      seriesId: series.id,
      padding: label.padding,
      highlighted,
      highlightState
    };
    return mergeDefaults(series.callWithContext(label.itemStyler, { ...params, ...styleParams }), styleParams);
  }
  return label;
}
function updateLabelNode(series, textNode, params, label, labelDatum, highlighted, highlightState) {
  if (label.enabled && labelDatum) {
    const style = getLabelStyles(series, labelDatum, params, label, highlighted, highlightState);
    textNode.visible = true;
    textNode.x = labelDatum.x;
    textNode.y = labelDatum.y;
    textNode.text = labelDatum.text;
    textNode.fill = style.color;
    textNode.setAlign(labelDatum);
    textNode.setFont(style);
    textNode.setBoxing(style);
  } else {
    textNode.visible = false;
  }
}
var placements = {
  "inside-start": { inside: true, direction: -1, textAlignment: 1 },
  "inside-end": { inside: true, direction: 1, textAlignment: -1 },
  "outside-start": { inside: false, direction: -1, textAlignment: -1 },
  "outside-end": { inside: false, direction: 1, textAlignment: 1 }
};
function adjustLabelPlacement({
  isUpward,
  isVertical,
  placement,
  spacing = 0,
  rect
}) {
  let x = rect.x + rect.width / 2;
  let y = rect.y + rect.height / 2;
  let textAlign = "center";
  let textBaseline = "middle";
  if (placement !== "inside-center") {
    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);
    const { direction, textAlignment } = placements[placement];
    const displacementRatio = (direction + 1) * 0.5;
    if (isVertical) {
      const y0 = isUpward ? rect.y + rect.height : rect.y;
      const height2 = rect.height * barDirection;
      y = y0 + height2 * displacementRatio + spacing * textAlignment * barDirection;
      textBaseline = textAlignment === barDirection ? "top" : "bottom";
    } else {
      const x0 = isUpward ? rect.x : rect.x + rect.width;
      const width2 = rect.width * barDirection;
      x = x0 + width2 * displacementRatio + spacing * textAlignment * barDirection;
      textAlign = textAlignment === barDirection ? "left" : "right";
    }
  }
  return { x, y, textAlign, textBaseline };
}

// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {
  for (const labelSelection of labelSelections) {
    labelSelection.cleanup();
  }
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 0 },
    { opacity: 1 },
    { phase: "trailing" }
  );
}
function seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 1 },
    { opacity: 0 },
    { phase: "remove" }
  );
}
function resetLabelFn(_node) {
  return { opacity: 1 };
}

// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this._dirty = true;
  }
  markDirty() {
    this._dirty = true;
  }
  markClean(_opts) {
    this._dirty = false;
  }
  isDirty() {
    return this._dirty;
  }
  onChangeDetection(_property) {
    this.markDirty();
  }
};

// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = "rgba(0, 0, 0, 0.5)";
    this.xOffset = 0;
    this.yOffset = 0;
    this.blur = 5;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "enabled", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "color", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "xOffset", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "yOffset", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "blur", 2);

// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var SeriesMarker = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.shape = "circle";
    this.size = 6;
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
  getStyle() {
    const { size, shape, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      size,
      shape,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
  getDiameter() {
    return this.size + this.strokeWidth;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "enabled", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], SeriesMarker.prototype, "shape", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "size", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: objectsEqual })
], SeriesMarker.prototype, "fill", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "fillOpacity", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "stroke", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "lineDash", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "lineDashOffset", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], SeriesMarker.prototype, "itemStyler", 2);

// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Property
], SeriesTooltipInteraction.prototype, "enabled", 2);
var SeriesTooltip = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.interaction = new SeriesTooltipInteraction();
    this.position = new TooltipPosition();
    this.range = void 0;
    this.class = void 0;
  }
  formatTooltip(callers, content, params) {
    const overrides = this.renderer == null ? void 0 : callWithContext(callers, this.renderer, params);
    if (typeof overrides === "string")
      return { type: "raw", rawHtmlString: overrides };
    if (overrides != null)
      return { type: "structured", ...content, ...overrides };
    return { type: "structured", ...content };
  }
};
__decorateClass([
  Property
], SeriesTooltip.prototype, "enabled", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "showArrow", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "renderer", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "interaction", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "position", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "range", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "class", 2);
function makeSeriesTooltip() {
  return new SeriesTooltip();
}

// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts
var InterpolationProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "linear";
    this.tension = 1;
    this.position = "end";
  }
};
__decorateClass([
  Property
], InterpolationProperties.prototype, "type", 2);
__decorateClass([
  Property
], InterpolationProperties.prototype, "tension", 2);
__decorateClass([
  Property
], InterpolationProperties.prototype, "position", 2);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.xName = void 0;
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.shadow = new DropShadow();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = makeSeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts
function spanRange(span) {
  switch (span.type) {
    case "linear":
    case "step":
      return [
        { x: span.x0, y: span.y0 },
        { x: span.x1, y: span.y1 }
      ];
    case "cubic":
      return [
        { x: span.cp0x, y: span.cp0y },
        { x: span.cp3x, y: span.cp3y }
      ];
  }
}
function spanRangeNormalized(span) {
  const range3 = spanRange(span);
  if (range3[0].x > range3[1].x) {
    range3.reverse();
  }
  return range3;
}
function collapseSpanToPoint(span, point) {
  const { x, y } = point;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: x,
        y0: y,
        x1: x,
        y1: y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: x,
        y0: y,
        x1: x,
        y1: y,
        stepX: x
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: x,
        cp0y: y,
        cp1x: x,
        cp1y: y,
        cp2x: x,
        cp2y: y,
        cp3x: x,
        cp3y: y
      };
  }
}
function rescaleSpan(span, nextStart, nextEnd) {
  const [prevStart, prevEnd] = spanRange(span);
  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;
  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: nextStart.x,
        cp0y: nextStart.y,
        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,
        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,
        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,
        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,
        cp3x: nextEnd.x,
        cp3y: nextEnd.y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y,
        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale
      };
  }
}
function clipSpanX(span, x0, x1) {
  const { moveTo } = span;
  const [start2, end2] = spanRangeNormalized(span);
  const { x: spanX0, y: spanY0 } = start2;
  const { x: spanX1, y: spanY1 } = end2;
  if (x1 < spanX0) {
    return rescaleSpan(span, start2, start2);
  } else if (x0 > spanX1) {
    return rescaleSpan(span, end2, end2);
  }
  switch (span.type) {
    case "linear": {
      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);
      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;
      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;
      return { type: "linear", moveTo, x0, y0, x1, y1 };
    }
    case "step":
      if (x1 <= span.stepX) {
        const y = span.y0;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };
      } else if (x0 >= span.stepX) {
        const y = span.y1;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };
      } else {
        const { y0, y1, stepX } = span;
        return { type: "step", moveTo, x0, y0, x1, y1, stepX };
      }
    case "cubic": {
      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);
      let [_unused, bezier] = splitBezier2D(
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        t0
      );
      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);
      [bezier, _unused] = splitBezier2D(
        bezier[0].x,
        bezier[0].y,
        bezier[1].x,
        bezier[1].y,
        bezier[2].x,
        bezier[2].y,
        bezier[3].x,
        bezier[3].y,
        t1
      );
      return {
        type: "cubic",
        moveTo,
        cp0x: bezier[0].x,
        cp0y: bezier[0].y,
        cp1x: bezier[1].x,
        cp1y: bezier[1].y,
        cp2x: bezier[2].x,
        cp2y: bezier[2].y,
        cp3x: bezier[3].x,
        cp3y: bezier[3].y
      };
    }
  }
}
function linearPoints(points) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      spans.push({ type: "linear", moveTo, x0, y0, x1, y1 });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var lineSteps = {
  start: 0,
  middle: 0.5,
  end: 1
};
function stepPoints(points, position) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  const p0 = typeof position === "number" ? position : lineSteps[position];
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      const stepX = x0 + (x1 - x0) * p0;
      spans.push({ type: "step", moveTo, x0, y0, x1, y1, stepX });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var flatnessRatio = 0.05;
function smoothPoints(iPoints, tension) {
  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);
  if (points.length <= 1)
    return [];
  const gradients = points.map((c, i) => {
    const p = i === 0 ? c : points[i - 1];
    const n = i === points.length - 1 ? c : points[i + 1];
    const isTerminalPoint = i === 0 || i === points.length - 1;
    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {
      return 0;
    }
    if (!isTerminalPoint) {
      const range3 = Math.abs(p.y - n.y);
      const prevRatio = Math.abs(c.y - p.y) / range3;
      const nextRatio = Math.abs(c.y - n.y) / range3;
      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {
        return 0;
      }
    }
    return (n.y - p.y) / (n.x - p.x);
  });
  if (gradients[1] === 0) {
    gradients[0] *= 2;
  }
  if (gradients[gradients.length - 2] === 0) {
    gradients[gradients.length - 1] *= 2;
  }
  const spans = [];
  for (let i = 1; i < points.length; i += 1) {
    const prev = points[i - 1];
    const prevM = gradients[i - 1];
    const cur = points[i];
    const curM = gradients[i];
    const dx = cur.x - prev.x;
    const dy = cur.y - prev.y;
    let dcp1x = dx * tension / 3;
    let dcp1y = dx * prevM * tension / 3;
    let dcp2x = dx * tension / 3;
    let dcp2y = dx * curM * tension / 3;
    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {
      dcp1x *= Math.abs(dy / dcp1y);
      dcp1y = Math.sign(dcp1y) * Math.abs(dy);
    }
    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {
      dcp2x *= Math.abs(dy / dcp2y);
      dcp2y = Math.sign(dcp2y) * Math.abs(dy);
    }
    spans.push({
      type: "cubic",
      moveTo: i === 1,
      cp0x: prev.x,
      cp0y: prev.y,
      cp1x: prev.x + dcp1x,
      cp1y: prev.y + dcp1y,
      cp2x: cur.x - dcp2x,
      cp2y: cur.y - dcp2y,
      cp3x: cur.x,
      cp3y: cur.y
    });
  }
  return spans;
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts
function lerp2(a, b, ratio8) {
  return (b - a) * ratio8 + a;
}
function linearSupertype(span, stepX) {
  const { x0, y0, x1, y1 } = span;
  const m = (y1 - y0) / (x1 - x0);
  const stepY = m * (stepX - x0) + y0;
  return {
    leftCp1x: x0,
    leftCp1y: y0,
    leftCp2x: stepX,
    leftCp2y: stepY,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: stepX,
    rightCp1y: stepY,
    rightCp2x: x1,
    rightCp2y: y1
  };
}
function bezierSupertype(span, stepX) {
  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;
  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);
  const [left, right] = splitBezier2D(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);
  const stepY = left[3].y;
  return {
    leftCp1x: left[1].x,
    leftCp1y: left[1].y,
    leftCp2x: left[2].x,
    leftCp2y: left[2].y,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: right[1].x,
    rightCp1y: right[1].y,
    rightCp2x: right[2].x,
    rightCp2y: right[2].y
  };
}
function stepSupertype(span) {
  const { x0, y0, x1, y1, stepX } = span;
  return {
    leftCp1x: (x0 + stepX) / 2,
    leftCp1y: y0,
    leftCp2x: (x0 + stepX) / 2,
    leftCp2y: y0,
    stepX,
    stepY0: y0,
    stepY1: y1,
    rightCp1x: (stepX + x1) / 2,
    rightCp1y: y1,
    rightCp2x: (stepX + x1) / 2,
    rightCp2y: y1
  };
}
function spanSupertype(span, stepX) {
  if (span.type === "linear") {
    return linearSupertype(span, stepX);
  } else if (span.type === "cubic") {
    return bezierSupertype(span, stepX);
  } else {
    return stepSupertype(span);
  }
}
function plotStart(path, moveTo, x0, y0, x1, y1, reversed) {
  switch (moveTo) {
    case 0 /* MoveTo */:
      if (reversed) {
        path.moveTo(x1, y1);
      } else {
        path.moveTo(x0, y0);
      }
      break;
    case 1 /* LineTo */:
      if (reversed) {
        path.lineTo(x1, y1);
      } else {
        path.lineTo(x0, y0);
      }
      break;
  }
}
function plotLinear(path, x0, y0, x1, y1, reversed) {
  if (reversed) {
    path.lineTo(x0, y0);
  } else {
    path.lineTo(x1, y1);
  }
}
function plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {
  if (reversed) {
    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);
  } else {
    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
  }
}
function plotStep(path, x0, y0, x1, y1, stepX, reversed) {
  if (reversed) {
    path.lineTo(stepX, y1);
    path.lineTo(stepX, y0);
    path.lineTo(x0, y0);
  } else {
    path.lineTo(stepX, y0);
    path.lineTo(stepX, y1);
    path.lineTo(x1, y1);
  }
}
function plotSpan(path, span, moveTo, reversed) {
  const [start2, end2] = spanRange(span);
  plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);
  switch (span.type) {
    case "linear":
      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);
      break;
    case "cubic":
      plotCubic(
        path,
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        reversed
      );
      break;
    case "step":
      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);
      break;
  }
}
function interpolatedSpanRange(a, b, ratio8) {
  const [aStart, aEnd] = spanRange(a);
  const [bStart, bEnd] = spanRange(b);
  const x0 = lerp2(aStart.x, bStart.x, ratio8);
  const y0 = lerp2(aStart.y, bStart.y, ratio8);
  const x1 = lerp2(aEnd.x, bEnd.x, ratio8);
  const y1 = lerp2(aEnd.y, bEnd.y, ratio8);
  return [
    { x: x0, y: y0 },
    { x: x1, y: y1 }
  ];
}
function plotInterpolatedSpans(path, a, b, ratio8, moveTo, reversed) {
  const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = interpolatedSpanRange(a, b, ratio8);
  plotStart(path, moveTo, x0, y0, x1, y1, reversed);
  if (a.type === "cubic" && b.type === "cubic") {
    const cp1x = lerp2(a.cp1x, b.cp1x, ratio8);
    const cp1y = lerp2(a.cp1y, b.cp1y, ratio8);
    const cp2x = lerp2(a.cp2x, b.cp2x, ratio8);
    const cp2y = lerp2(a.cp2y, b.cp2y, ratio8);
    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);
  } else if (a.type === "step" && b.type === "step") {
    const stepX = lerp2(a.stepX, b.stepX, ratio8);
    plotStep(path, x0, y0, x1, y1, stepX, reversed);
  } else if (a.type === "linear" && b.type === "linear") {
    plotLinear(path, x0, y0, x1, y1, reversed);
  } else {
    let defaultStepX;
    if (a.type === "step") {
      defaultStepX = a.stepX;
    } else if (b.type === "step") {
      defaultStepX = b.stepX;
    } else {
      defaultStepX = (x0 + x1) / 2;
    }
    const as = spanSupertype(a, defaultStepX);
    const bs = spanSupertype(b, defaultStepX);
    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio8);
    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio8);
    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio8);
    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio8);
    const stepX = lerp2(as.stepX, bs.stepX, ratio8);
    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio8);
    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio8);
    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio8);
    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio8);
    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio8);
    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio8);
    if (reversed) {
      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);
      path.lineTo(stepX, stepY0);
      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);
    } else {
      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);
      path.lineTo(stepX, stepY1);
      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);
    }
  }
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts
var MAX_CATEGORIES = 1e3;
function integratedCategoryMatch(a, b) {
  if (a == null || b == null)
    return false;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if ("id" in a && "id" in b) {
    return a.id === b.id;
  }
  return a.toString() === b.toString();
}
function toAxisValue(value) {
  return transformIntegratedCategoryValue(value).valueOf();
}
function scale(val, scaling) {
  if (!scaling)
    return NaN;
  if (val instanceof Date) {
    val = val.getTime();
  }
  if (scaling.type === "continuous" && typeof val === "number") {
    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
  }
  if (scaling.type === "log" && typeof val === "number") {
    return scaling.convert(val);
  }
  if (scaling.type !== "category")
    return NaN;
  const axisValue = toAxisValue(val);
  let matchingIndex = scaling.domain.findIndex((d) => toAxisValue(d) === axisValue);
  if (matchingIndex === -1) {
    matchingIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));
  }
  if (matchingIndex >= 0) {
    return scaling.inset + scaling.step * matchingIndex;
  }
  return NaN;
}
function getAxisIndices({ data }, values) {
  return data.map((datum, datumIndex) => ({
    xValue0Index: values.indexOf(toAxisValue(datum.xValue0)),
    xValue1Index: values.indexOf(toAxisValue(datum.xValue1)),
    datumIndex
  }));
}
function isValidScaling(data) {
  return Object.values(data.scales).every((s) => {
    if (s.type === "category") {
      return s.domain.length < MAX_CATEGORIES;
    }
    return true;
  });
}
function validateCategorySorting(newData, oldData) {
  const oldScale = oldData.scales.x;
  const newScale = newData.scales.x;
  if (oldScale?.type !== "category" || newScale?.type !== "category")
    return true;
  let x0 = -Infinity;
  for (const oldValue of oldScale.domain) {
    const x = scale(oldValue, newScale);
    if (!Number.isFinite(x))
      continue;
    if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function validateAxisEntriesOrder(axisValues, data) {
  let x0 = -Infinity;
  for (const axisValue of axisValues) {
    const x = scale(axisValue.value, data.scales.x);
    if (!Number.isFinite(x))
      continue;
    if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function spanAxisContext(newData, oldData) {
  const allAxisEntries = /* @__PURE__ */ new Map();
  for (const { xValue0, xValue1 } of newData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    allAxisEntries.set(xValue0Value, xValue0).set(xValue1Value, xValue1);
  }
  const newAxisEntries = Array.from(allAxisEntries, ([axisValue, value]) => ({ axisValue, value }));
  newAxisEntries.sort((a, b) => {
    return scale(a.value, newData.scales.x) - scale(b.value, newData.scales.x);
  });
  const exclusivelyOldAxisEntries = [];
  for (const { xValue0, xValue1 } of oldData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    if (!allAxisEntries.has(xValue0Value)) {
      allAxisEntries.set(xValue0Value, xValue0);
      exclusivelyOldAxisEntries.push({ axisValue: xValue0Value, value: xValue0 });
    }
    if (!allAxisEntries.has(xValue1Value)) {
      allAxisEntries.set(xValue1Value, xValue1);
      exclusivelyOldAxisEntries.push({ axisValue: xValue1Value, value: xValue1 });
    }
  }
  exclusivelyOldAxisEntries.sort((a, b) => {
    return scale(a.value, oldData.scales.x) - scale(b.value, oldData.scales.x);
  });
  const axisEntries = newAxisEntries;
  let insertionIndex = 0;
  for (const oldAxisEntry of exclusivelyOldAxisEntries) {
    for (let i = axisEntries.length - 1; i >= insertionIndex; i -= 1) {
      const oldValueX = scale(oldAxisEntry.value, oldData.scales.x);
      const newValueX = scale(axisEntries[i].value, oldData.scales.x);
      if (oldValueX > newValueX) {
        insertionIndex = i + 1;
        break;
      }
    }
    axisEntries.splice(insertionIndex, 0, oldAxisEntry);
    insertionIndex += 1;
  }
  if (!validateAxisEntriesOrder(axisEntries, oldData))
    return;
  const axisValues = axisEntries.map((axisEntry) => axisEntry.axisValue);
  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);
  const newDataAxisIndices = getAxisIndices(newData, axisValues);
  return { axisValues, oldDataAxisIndices, newDataAxisIndices };
}
function clipSpan(span, xValue0Index, xIndices) {
  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)
    return span;
  const range3 = spanRange(span);
  const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);
  const start2 = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;
  const end2 = start2 + step;
  return clipSpanX(span, start2, end2);
}
function axisZeroSpan(span, data) {
  const [r0, r1] = spanRange(span);
  const y0 = scale(0, data.scales.y);
  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });
}
function collapseSpanToMidpoint(span) {
  const [r0, r1] = spanRange(span);
  return collapseSpanToPoint(span, {
    x: (r0.x + r1.x) / 2,
    y: (r0.y + r1.y) / 2
  });
}
function collapseSpan(span, collapseMode, data, axisIndices, indices, range3) {
  let xValue;
  let yValue;
  if (indices.xValue0Index >= range3.xValue1Index) {
    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range3.xValue1Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue = datum?.xValue1;
    yValue = datum?.yValue1;
  } else if (indices.xValue0Index <= range3.xValue0Index) {
    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range3.xValue0Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue = datum?.xValue0;
    yValue = datum?.yValue0;
  }
  if (xValue == null || yValue == null) {
    switch (collapseMode) {
      case 0 /* Zero */:
        return axisZeroSpan(span, data);
      case 1 /* Split */:
        return collapseSpanToMidpoint(span);
    }
  }
  const x = scale(xValue, data.scales.x);
  const y = scale(yValue, data.scales.y);
  const point = { x, y };
  return rescaleSpan(span, point, point);
}
function zeroDataSpan(spanDatum, zeroData) {
  if (zeroData == null)
    return;
  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);
  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);
  return zeroData.find(
    (zeroSpanDatum) => toAxisValue(zeroSpanDatum.xValue0) === newSpanXValue0 && toAxisValue(zeroSpanDatum.xValue1) === newSpanXValue1
  )?.span;
}
function addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out) {
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const newSpan = newSpanDatum.span;
  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: zeroSpan, to: zeroSpan });
    out.moved.push({ from: zeroSpan, to: newSpan });
    out.added.push({ from: newSpan, to: newSpan });
  } else {
    const oldSpan = collapseSpan(newSpan, collapseMode, newData, newAxisIndices, newIndices, range3);
    out.added.push({ from: oldSpan, to: newSpan });
  }
}
function removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out) {
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const oldSpan = oldSpanDatum.span;
  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: oldSpan, to: oldSpan });
    out.moved.push({ from: oldSpan, to: zeroSpan });
    out.added.push({ from: zeroSpan, to: zeroSpan });
  } else {
    const newSpan = collapseSpan(oldSpan, collapseMode, oldData, oldAxisIndices, oldIndices, range3);
    out.removed.push({ from: oldSpan, to: newSpan });
  }
}
function alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {
  const startXValue0 = axisValues[postSpanIndices.xValue0Index];
  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);
  const endXValue1 = axisValues[postSpanIndices.xValue1Index];
  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);
  if (startDatum == null || endDatum == null)
    return;
  const [{ x: x0 }, { x: x1 }] = spanRange(span);
  const startX = scale(startDatum.xValue0, preData.scales.x);
  const startY = scale(startDatum.yValue0, preData.scales.y);
  const endX = scale(endDatum.xValue1, preData.scales.x);
  const endY = scale(endDatum.yValue1, preData.scales.y);
  let altSpan = postData.data[postSpanIndices.datumIndex].span;
  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });
  altSpan = clipSpanX(altSpan, x0, x1);
  return altSpan;
}
function appendSpanPhases(newData, oldData, collapseMode, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {
  const xValue1Index = xValue0Index + 1;
  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const oldZeroData = oldData.zeroData;
  const newZeroData = newData.zeroData;
  if (oldIndices == null && newIndices != null) {
    addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);
    return;
  } else if (oldIndices != null && newIndices == null) {
    removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);
    return;
  } else if (oldIndices == null || newIndices == null) {
    return;
  }
  let ordering;
  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {
    ordering = 0;
  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {
    ordering = -1;
  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {
    ordering = 1;
  } else {
    ordering = 0;
  }
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);
  if (ordering === 1) {
    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(
      clippedOldSpanOldScale,
      axisValues,
      oldData,
      newData,
      newIndices
    );
    if (clippedPostRemoveOldSpanOldScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });
      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });
      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);
    }
  } else if (ordering === -1) {
    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(
      clippedNewSpanNewScale,
      axisValues,
      newData,
      oldData,
      oldIndices
    );
    if (clippedPreAddedNewSpanNewScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });
      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);
    }
  } else {
    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });
    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
  }
}
function phaseAnimation(axisContext, newData, oldData, collapseMode) {
  const out = {
    removed: [],
    moved: [],
    added: []
  };
  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;
  const range3 = {
    xValue0Index: Math.max(
      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,
      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity
    ),
    xValue1Index: Math.min(
      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,
      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity
    )
  };
  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {
    appendSpanPhases(
      newData,
      oldData,
      collapseMode,
      axisValues,
      xValue0Index,
      newDataAxisIndices,
      oldDataAxisIndices,
      range3,
      out
    );
  }
  return out;
}
function resetSpan(data, spanDatum, collapseMode) {
  const { span } = spanDatum;
  switch (collapseMode) {
    case 0 /* Zero */:
      return zeroDataSpan(spanDatum, data.zeroData) ?? axisZeroSpan(span, data);
    case 1 /* Split */:
      return collapseSpanToMidpoint(span);
  }
}
function resetAnimation(newData, oldData, collapseMode) {
  const added = [];
  const removed = [];
  for (const oldSpanDatum of oldData.data) {
    const oldSpan = oldSpanDatum.span;
    const collapsedSpan = resetSpan(oldData, oldSpanDatum, collapseMode);
    removed.push({ from: oldSpan, to: collapsedSpan });
  }
  for (const newSpanDatum of newData.data) {
    const newSpan = newSpanDatum.span;
    const collapsedSpan = resetSpan(newData, newSpanDatum, collapseMode);
    added.push({ from: collapsedSpan, to: newSpan });
  }
  return {
    removed,
    moved: [],
    added
  };
}
function pairUpSpans(newData, oldData, collapseMode) {
  if (!isValidScaling(newData) || !isValidScaling(oldData))
    return;
  if (!validateCategorySorting(newData, oldData))
    return;
  const axisContext = spanAxisContext(newData, oldData);
  return axisContext == null ? resetAnimation(newData, oldData, collapseMode) : phaseAnimation(axisContext, newData, oldData, collapseMode);
}

// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts
import { arraysEqual as arraysEqual4 } from "ag-charts-core";
function isContinuousScaling(scaling) {
  return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
  return scaling.type === "category";
}
function areScalingEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a !== void 0 || b !== void 0;
  }
  if (isContinuousScaling(a) && isContinuousScaling(b)) {
    return a.type === b.type && arraysEqual4(a.domain, b.domain) && arraysEqual4(a.range, b.range);
  }
  if (isCategoryScaling(a) && isCategoryScaling(b)) {
    return a.inset === b.inset && a.step === b.step && arraysEqual4(a.domain, b.domain);
  }
  return false;
}
function isScaleValid(scale2) {
  if (scale2 == null)
    return false;
  if (scale2.type === "category")
    return scale2.domain.every((v) => v != null);
  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date) && scale2.range.every((v) => Number.isFinite(v));
}

// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function interpolatePoints(points, interpolation) {
  let spans;
  const pointsIter = points.map((point) => point.point);
  switch (interpolation.type) {
    case "linear":
      spans = linearPoints(pointsIter);
      break;
    case "smooth":
      spans = smoothPoints(pointsIter, interpolation.tension);
      break;
    case "step":
      spans = stepPoints(pointsIter, interpolation.position);
      break;
  }
  return spans.map((span, i) => ({
    span,
    xValue0: points[i].xDatum,
    yValue0: points[i].yDatum,
    xValue1: points[i + 1].xDatum,
    yValue1: points[i + 1].yDatum
  }));
}
function pointsEq(a, b, delta3 = 1e-3) {
  return Math.abs(a.x - b.x) < delta3 && Math.abs(a.y - b.y) < delta3;
}
function plotLinePathStroke({ path }, spans) {
  let lastPoint;
  for (const { span } of spans) {
    const [start2, end2] = spanRange(span);
    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;
    plotSpan(path, span, join, false);
    lastPoint = end2;
  }
}
function plotInterpolatedLinePathStroke(ratio8, path, spans) {
  let lastPoint;
  for (const span of spans) {
    const [start2, end2] = interpolatedSpanRange(span.from, span.to, ratio8);
    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;
    plotInterpolatedSpans(path.path, span.from, span.to, ratio8, join, false);
    lastPoint = end2;
  }
}
function prepareLinePathStrokeAnimationFns(status, spans, visibleToggleMode) {
  const removePhaseFn = (ratio8, path) => plotInterpolatedLinePathStroke(ratio8, path, spans.removed);
  const updatePhaseFn = (ratio8, path) => plotInterpolatedLinePathStroke(ratio8, path, spans.moved);
  const addPhaseFn = (ratio8, path) => plotInterpolatedLinePathStroke(ratio8, path, spans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
  const phase = visibleToggleMode === "none" ? "updated" : status;
  const result = {
    fromFn: (_path) => {
      let mixin;
      if (status === "removed") {
        mixin = { finish: { visible: false } };
      } else if (status === "added") {
        mixin = { start: { visible: true } };
      } else {
        mixin = {};
      }
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };
    },
    toFn: (_path) => {
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };
    }
  };
  if (visibleToggleMode === "fade") {
    return {
      fromFn: (path) => {
        const opacity = status === "added" ? 0 : path.opacity;
        return { opacity, ...result.fromFn(path) };
      },
      toFn: (path) => {
        const opacity = status === "removed" ? 0 : 1;
        return { opacity, ...result.toFn(path) };
      }
    };
  }
  return result;
}
function prepareLinePathAnimation(newData, oldData, diff2) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  if (newData.strokeData == null || oldData.strokeData == null) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const strokeSpans = pairUpSpans(
    { scales: newData.scales, data: newData.strokeData.spans },
    { scales: oldData.scales, data: oldData.strokeData.spans },
    1 /* Split */
  );
  if (strokeSpans == null)
    return;
  const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, "fade");
  const hasMotion = (diff2?.changed ?? true) || !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y) || status !== "updated";
  return { status, stroke: stroke2, hasMotion };
}

// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
function plotAreaPathFill({ path }, { spans, phantomSpans }) {
  let phantomSpanIndex = 0;
  let sp = { x: NaN, y: NaN };
  let pp = { x: NaN, y: NaN };
  for (let i = 0; i < spans.length; i += 1) {
    const { span } = spans[i];
    const { span: phantomSpan } = phantomSpans[i];
    const { 0: sp0, 1: sp1 } = spanRange(span);
    const { 0: pp0, 1: pp1 } = spanRange(phantomSpan);
    if (pointsEq(sp, sp0) && pointsEq(pp, pp0)) {
      plotSpan(path, span, 1 /* LineTo */, false);
    } else {
      for (let j = i - 1; j >= phantomSpanIndex; j -= 1) {
        plotSpan(path, phantomSpans[j].span, 1 /* LineTo */, true);
      }
      path.closePath();
      plotSpan(path, span, 0 /* MoveTo */, false);
      phantomSpanIndex = i;
    }
    sp = sp1;
    pp = pp1;
  }
  for (let j = spans.length - 1; j >= phantomSpanIndex; j -= 1) {
    plotSpan(path, phantomSpans[j].span, 1 /* LineTo */, true);
  }
  path.closePath();
}
function plotInterpolatedAreaSeriesFillSpans(ratio8, { path }, spans, fillPhantomSpans) {
  for (let i = 0; i < spans.length; i += 1) {
    const span = spans[i];
    const reversedPhantomSpan = fillPhantomSpans[i];
    plotInterpolatedSpans(path, span.from, span.to, ratio8, 0 /* MoveTo */, false);
    plotInterpolatedSpans(path, reversedPhantomSpan.from, reversedPhantomSpan.to, ratio8, 1 /* LineTo */, true);
    path.closePath();
  }
}
function prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {
  const removePhaseFn = (ratio8, path) => plotInterpolatedAreaSeriesFillSpans(ratio8, path, spans.removed, fillPhantomSpans.removed);
  const updatePhaseFn = (ratio8, path) => plotInterpolatedAreaSeriesFillSpans(ratio8, path, spans.moved, fillPhantomSpans.moved);
  const addPhaseFn = (ratio8, path) => plotInterpolatedAreaSeriesFillSpans(ratio8, path, spans.added, fillPhantomSpans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareAreaPathAnimation(newData, oldData) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const fillSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.spans },
    { scales: oldData.scales, data: oldData.fillData.spans },
    0 /* Zero */
  );
  if (fillSpans == null)
    return;
  const fillPhantomSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.phantomSpans },
    { scales: oldData.scales, data: oldData.fillData.phantomSpans },
    0 /* Zero */
  );
  if (fillPhantomSpans == null)
    return;
  const strokeSpans = pairUpSpans(
    {
      scales: newData.scales,
      data: newData.strokeData.spans,
      zeroData: newData.fillData.phantomSpans
    },
    {
      scales: oldData.scales,
      data: oldData.strokeData.spans,
      zeroData: oldData.fillData.phantomSpans
    },
    0 /* Zero */
  );
  if (strokeSpans == null)
    return;
  const fadeMode = "none";
  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);
  const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, fadeMode);
  return { status, fill, stroke: stroke2 };
}

// packages/ag-charts-community/src/chart/series/aggregation.ts
var AGGREGATION_INDEX_X_MIN = 0;
var AGGREGATION_INDEX_X_MAX = 1;
var AGGREGATION_INDEX_Y_MIN = 2;
var AGGREGATION_INDEX_Y_MAX = 3;
var AGGREGATION_SPAN = 4;
function aggregationRangeFittingPoints(data) {
  let power = Math.ceil(Math.log2(data.length)) - 1;
  power = Math.min(Math.max(power, 0), 24);
  return 2 ** power | 0;
}
function aggregationDomain(scale2, domain) {
  switch (scale2) {
    case "category":
      return [NaN, NaN];
    case "number":
    case "time":
    case "ordinal-time":
    case "unit-time": {
      let min = Infinity;
      let max = -Infinity;
      for (const d of domain) {
        const value = Number(d);
        min = Math.min(min, value);
        max = Math.max(max, value);
      }
      return [min, max];
    }
    case "color":
    case "log":
    case "mercator":
      return [0, 0];
  }
}
function aggregationXRatioForDatumIndex(datumIndex, domainCount) {
  return datumIndex / domainCount;
}
function aggregationXRatioForXValue(xValue, d0, d1) {
  return (xValue.valueOf() - d0) / (d1 - d0);
}
function aggregationIndexForXRatio(xRatio, maxRange) {
  return Math.min(Math.floor(xRatio * maxRange), maxRange - 1) * AGGREGATION_SPAN | 0;
}
function createAggregationIndices(xValues, yMaxValues, yMinValues, d0, d1, maxRange) {
  const indexData = new Int32Array(maxRange * AGGREGATION_SPAN).fill(-1);
  const valueData = new Float64Array(maxRange * AGGREGATION_SPAN).fill(NaN);
  const continuous = Number.isFinite(d0) && Number.isFinite(d1);
  const domainCount = xValues.length;
  for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
    const xValue = xValues[datumIndex];
    if (xValue == null)
      continue;
    const xRatio = continuous ? aggregationXRatioForXValue(xValue, d0, d1) : aggregationXRatioForDatumIndex(datumIndex, domainCount);
    const aggIndex = aggregationIndexForXRatio(xRatio, maxRange);
    const yMaxValue = yMaxValues[datumIndex];
    const yMinValue = yMinValues[datumIndex];
    const yMax = yMaxValue != null ? yMaxValue.valueOf() : NaN;
    const yMin = yMinValue != null ? yMinValue.valueOf() : NaN;
    const unset = indexData[aggIndex + AGGREGATION_INDEX_X_MIN] === -1;
    if (unset || xRatio < valueData[aggIndex + AGGREGATION_INDEX_X_MIN]) {
      indexData[aggIndex + AGGREGATION_INDEX_X_MIN] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_X_MIN] = xRatio;
    }
    if (unset || xRatio > valueData[aggIndex + AGGREGATION_INDEX_X_MAX]) {
      indexData[aggIndex + AGGREGATION_INDEX_X_MAX] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_X_MAX] = xRatio;
    }
    if (!Number.isNaN(yMin) && (unset || yMin < valueData[aggIndex + AGGREGATION_INDEX_Y_MIN])) {
      indexData[aggIndex + AGGREGATION_INDEX_Y_MIN] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_Y_MIN] = yMin;
    }
    if (!Number.isNaN(yMax) && (unset || yMax > valueData[aggIndex + AGGREGATION_INDEX_Y_MAX])) {
      indexData[aggIndex + AGGREGATION_INDEX_Y_MAX] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_Y_MAX] = yMax;
    }
  }
  return { indexData, valueData };
}
function compactAggregationIndices(indexData, valueData, maxRange, { inPlace = false } = {}) {
  const nextMaxRange = maxRange / 2 | 0;
  const nextIndexData = !inPlace ? new Int32Array(nextMaxRange * AGGREGATION_SPAN) : indexData;
  const nextValueData = !inPlace ? new Float64Array(nextMaxRange * AGGREGATION_SPAN) : valueData;
  for (let i = 0; i < nextMaxRange; i += 1) {
    const aggIndex = i * AGGREGATION_SPAN | 0;
    const index0 = aggIndex * 2 | 0;
    const index1 = index0 + AGGREGATION_SPAN | 0;
    const index1Unset = indexData[index1 + AGGREGATION_INDEX_X_MIN] === -1;
    const xMinAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_X_MIN] < valueData[index1 + AGGREGATION_INDEX_X_MIN] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_X_MIN] = indexData[xMinAggIndex + AGGREGATION_INDEX_X_MIN];
    nextValueData[aggIndex + AGGREGATION_INDEX_X_MIN] = valueData[xMinAggIndex + AGGREGATION_INDEX_X_MIN];
    const xMaxAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_X_MAX] > valueData[index1 + AGGREGATION_INDEX_X_MAX] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_X_MAX] = indexData[xMaxAggIndex + AGGREGATION_INDEX_X_MAX];
    nextValueData[aggIndex + AGGREGATION_INDEX_X_MAX] = valueData[xMaxAggIndex + AGGREGATION_INDEX_X_MAX];
    const yMinAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_Y_MIN] < valueData[index1 + AGGREGATION_INDEX_Y_MIN] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_Y_MIN] = indexData[yMinAggIndex + AGGREGATION_INDEX_Y_MIN];
    nextValueData[aggIndex + AGGREGATION_INDEX_Y_MIN] = valueData[yMinAggIndex + AGGREGATION_INDEX_Y_MIN];
    const yMaxAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_Y_MAX] > valueData[index1 + AGGREGATION_INDEX_Y_MAX] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_Y_MAX] = indexData[yMaxAggIndex + AGGREGATION_INDEX_Y_MAX];
    nextValueData[aggIndex + AGGREGATION_INDEX_Y_MAX] = valueData[yMaxAggIndex + AGGREGATION_INDEX_Y_MAX];
  }
  return { maxRange: nextMaxRange, indexData: nextIndexData, valueData: nextValueData };
}

// packages/ag-charts-community/src/chart/series/cartesian/lineAggregation.ts
var AGGREGATION_THRESHOLD = 1e3;
var MAX_POINTS = 10;
function aggregationContainsIndex(xValues, d0, d1, indexData, maxRange, datumIndex) {
  const xValue = xValues[datumIndex];
  if (xValue == null)
    return false;
  const xRatio = Number.isFinite(d0) ? aggregationXRatioForXValue(xValue, d0, d1) : aggregationXRatioForDatumIndex(datumIndex, xValues.length);
  const aggIndex = aggregationIndexForXRatio(xRatio, maxRange);
  return datumIndex === indexData[aggIndex + AGGREGATION_INDEX_X_MIN] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_X_MAX] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MIN] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MAX];
}
function aggregateLineData(scale2, xValues, yValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD)
    return;
  const [d0, d1] = aggregationDomain(scale2, domain);
  let maxRange = aggregationRangeFittingPoints(xValues);
  const { indexData, valueData } = createAggregationIndices(xValues, yValues, yValues, d0, d1, maxRange);
  let indices = [];
  for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
    if (aggregationContainsIndex(xValues, d0, d1, indexData, maxRange, datumIndex)) {
      indices.push(datumIndex);
    }
  }
  const filters = [{ maxRange, indices }];
  while (indices.length > MAX_POINTS && maxRange > 64) {
    ({ maxRange } = compactAggregationIndices(indexData, valueData, maxRange, { inPlace: true }));
    indices = indices.filter(aggregationContainsIndex.bind(null, xValues, d0, d1, indexData, maxRange));
    filters.push({ maxRange, indices });
  }
  filters.reverse();
  return filters;
}

// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts
import { clamp as clamp19 } from "ag-charts-core";
function markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {
  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing" };
  staticFromToMotion(id, "markers", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);
  markerSelections.forEach((s) => s.cleanup());
}
function markerScaleInAnimation({ id }, animationManager, ...markerSelections) {
  staticFromToMotion(
    id,
    "markers",
    animationManager,
    markerSelections,
    { scalingX: 0, scalingY: 0 },
    { scalingX: 1, scalingY: 1 },
    { phase: "initial" }
  );
  markerSelections.forEach((s) => s.cleanup());
}
function markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {
  const seriesWidth = nodeDataDependencies.seriesRectWidth;
  const fromFn = (_, datum) => {
    const x = datum.midPoint?.x ?? seriesWidth;
    let delay = clamp19(0, inverseEaseOut(x / seriesWidth), 1);
    if (isNaN(delay)) {
      delay = 0;
    }
    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: "initial" };
  };
  const toFn = () => {
    return { scalingX: 1, scalingY: 1 };
  };
  fromToMotion(id, "markers", animationManager, markerSelections, { fromFn, toFn });
}
function resetMarkerFn(_node) {
  return { opacity: 1, scalingX: 1, scalingY: 1 };
}
function resetMarkerPositionFn(_node, datum) {
  return {
    x: datum.point?.x ?? NaN,
    y: datum.point?.y ?? NaN,
    scalingCenterX: datum.point?.x ?? NaN,
    scalingCenterY: datum.point?.y ?? NaN
  };
}
function computeMarkerFocusBounds(series, { datumIndex }) {
  const nodeData = series.getNodeData();
  if (nodeData === void 0)
    return void 0;
  const datum = nodeData[datumIndex];
  const { point } = datum ?? {};
  if (datum == null || point == null)
    return void 0;
  const style = series.getFormattedMarkerStyle(datum);
  const anchor = Marker.anchor(style.shape);
  const size = point.focusSize ?? style.size;
  const paddedSize = 4 + size;
  const paddedRadius = paddedSize / 2;
  const anchorX = (anchor.x - 0.5) * size;
  const anchorY = (anchor.y - 0.5) * size;
  const x = datum.point.x - paddedRadius - anchorX;
  const y = datum.point.y - paddedRadius - anchorY;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, paddedSize, paddedSize));
}

// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {
  const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;
  staticFromToMotion(
    id,
    "path_properties",
    animationManager,
    paths,
    { clipX: 0 },
    { clipX: width2 },
    {
      phase: "initial",
      start: { clip: true, clipY: height2, visible },
      finish: { clip: false, visible }
    }
  );
}
function pathFadeInAnimation({ id }, subId, animationManager, phase = "add", ...selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });
}
function buildResetPathFn(opts) {
  return (_node) => ({
    visible: opts.getVisible(),
    opacity: opts.getOpacity(),
    clipScalingX: 1,
    clip: false
  });
}
function updateClipPath({ nodeDataDependencies }, path) {
  const toFinite = (value) => isFinite(value) ? value : 0;
  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;
var CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;
var memoizedAggregateLineData = simpleMemorize2(aggregateLineData);
var AreaSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pathsPerSeries: ["fill", "stroke"],
      pathsZIndexSubOrderOffset: [0, 1e3],
      datumSelectionGarbageCollection: false,
      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        datum: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new AreaSeriesProperties();
    this.connectsToYAxis = true;
    this.dataAggregationFilters = void 0;
    this.backgroundGroup = new Group({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this._isStacked = void 0;
  }
  get pickModeAxis() {
    return "main";
  }
  renderToOffscreenCanvas() {
    return super.renderToOffscreenCanvas() || this.contextNodeData != null && (this.contextNodeData.fillData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD || this.contextNodeData.strokeData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD);
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  attachPaths([fill, stroke2]) {
    this.backgroundGroup.appendChild(fill);
    this.contentGroup.appendChild(stroke2);
    stroke2.zIndex = -1;
  }
  detachPaths([fill, stroke2]) {
    this.backgroundGroup.removeChild(fill);
    this.contentGroup.removeChild(stroke2);
  }
  isStacked() {
    const stackCount = this.seriesGrouping?.stackCount ?? 1;
    return stackCount > 1;
  }
  setSeriesIndex(index) {
    const isStacked = this.isStacked();
    const isStackedChanged = isStacked === this._isStacked;
    this._isStacked = isStackedChanged;
    return super.setSeriesIndex(index, isStackedChanged);
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    if (this.isStacked()) {
      this.backgroundGroup.zIndex = [0 /* BACKGROUND */, zIndex];
      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */];
    } else {
      this.backgroundGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */, 0];
      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */, 1];
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stacked = stackCount > 1 || normalizedTo != null;
    const idMap = {
      value: `area-stack-${groupIndex}-yValue`,
      values: `area-stack-${groupIndex}-yValues`,
      stack: `area-stack-${groupIndex}-yValue-stack`,
      marker: `area-stack-${groupIndex}-yValues-marker`
    };
    const common = { invalidValue: null };
    if ((isDefined(normalizedTo) || connectMissingData) && stackCount > 1) {
      common.invalidValue = 0;
    }
    if (!visible) {
      common.forceValue = 0;
    }
    const props = [
      keyProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),
      ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" })] : [],
      ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),
      valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value })
    ];
    if (stacked) {
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: idMap.values },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: idMap.marker },
          yScaleType
        )
      );
    }
    if (isDefined(normalizedTo)) {
      props.push(normaliseGroupTo(Object.values(idMap), normalizedTo));
    }
    if (animationEnabled) {
      props.push(animationValidation());
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: stacked,
      groupByData: !stacked
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize) {
    const { marker } = this.properties;
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const { marker } = this.properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [y - r, y + r];
  }
  yCumulativeKey(processData) {
    return processData.type === "grouped" ? "yValueCumulative" : "yValue";
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!processedData || !dataModel)
      return [];
    const yAxis = axes["y" /* Y */];
    if (direction === "x" /* X */) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent(extent(keys));
    }
    const yExtent = this.domainForClippedRange(
      "y" /* Y */,
      [this.yCumulativeKey(processedData)],
      "xValue"
    );
    if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]] : [];
      return fixNumericExtent(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    const [y0, y1] = this.domainForVisibleRange(
      "y" /* Y */,
      [this.yCumulativeKey(this.processedData)],
      "xValue",
      visibleRange
    );
    return [Math.min(y0, 0), Math.max(y1, 0)];
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    return this.countVisibleItems(
      "xValue",
      [this.yCumulativeKey(this.processedData)],
      xVisibleRange,
      yVisibleRange,
      minVisibleItems
    );
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type === "grouped")
      return;
    if (processedDataIsAnimatable(processedData))
      return;
    const xAxis = this.axes["x" /* X */];
    if (xAxis == null)
      return;
    const { scale: scale2 } = xAxis;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
    return memoizedAggregateLineData(scale2.type, xValues, yValues, domain);
  }
  createNodeData() {
    const { axes, data, processedData, dataModel, dataAggregationFilters } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !data || !dataModel || !processedData)
      return;
    const {
      yKey,
      xKey,
      xName,
      yName,
      yFilterKey,
      marker,
      label,
      fill: seriesFill,
      stroke: seriesStroke,
      connectMissingData,
      interpolation
    } = this.properties;
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const stacked = processedData.type === "grouped";
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, `yValueCumulative`, processedData) : yRawValues;
    const yFilterValues = yFilterKey != null ? dataModel.resolveColumnById(this, "yFilterRaw", processedData) : void 0;
    const yStackValues = processedData.type === "grouped" ? dataModel.resolveColumnById(this, "yValueStack", processedData) : void 0;
    const labelData = [];
    const markerData = [];
    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    let crossFiltering = false;
    const { dataSources } = processedData;
    const rawData = dataSources.get(this.id) ?? [];
    const [r0, r1] = xScale.range;
    const range3 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);
    let startIndex = 0;
    let endIndex = 0;
    const indices = dataAggregationFilter?.indices;
    [startIndex, endIndex] = this.visibleRangeIndices("xValue", xAxis.range, indices);
    startIndex = Math.max(startIndex - 1, 0);
    endIndex = Math.min(endIndex + 1, indices?.length ?? xValues.length);
    if (processedData.input.count < 1e3) {
      startIndex = 0;
      endIndex = processedData.input.count;
    }
    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {
      let currY;
      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
        currY = yEnd;
      }
      return {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(currY),
        size: marker.size
      };
    };
    const handleDatum = (datumIndex) => {
      const xDatum = xValues[datumIndex];
      if (xDatum == null)
        return;
      const seriesDatum = rawData[datumIndex];
      const yDatum = yRawValues[datumIndex];
      const yValueCumulative = yCumulativeValues[datumIndex];
      const validPoint = Number.isFinite(yDatum);
      const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
      const selected = yFilterValues != null ? yFilterValues[datumIndex] === yDatum : void 0;
      if (selected === false) {
        crossFiltering = true;
      }
      if (validPoint && marker) {
        markerData.push({
          series: this,
          itemId: yKey,
          datum: seriesDatum,
          datumIndex,
          midPoint: { x: point.x, y: point.y },
          cumulativeValue: yValueCumulative,
          yValue: yDatum,
          xValue: xDatum,
          yKey,
          xKey,
          point,
          fill: marker.fill ?? seriesFill,
          stroke: marker.stroke ?? seriesStroke,
          strokeWidth: marker.strokeWidth ?? this.properties.strokeWidth,
          selected
        });
      }
      if (label.enabled && validPoint) {
        const labelText = this.getLabelText(
          yDatum,
          seriesDatum,
          yKey,
          "y",
          yDomain,
          label,
          { value: yDatum, datum: seriesDatum, xKey, yKey, xName, yName }
        );
        labelData.push({
          series: this,
          itemId: yKey,
          datum: seriesDatum,
          datumIndex,
          x: point.x,
          y: point.y,
          labelText
        });
      }
    };
    if (processedData.type === "grouped") {
      for (const { datumIndex } of dataModel.forEachGroupDatum(this, processedData)) {
        handleDatum(datumIndex);
      }
    } else {
      for (let i = startIndex; i < endIndex; i += 1) {
        const datumIndex = indices?.[i] ?? i;
        if (xValues[datumIndex] == null)
          continue;
        handleDatum(datumIndex);
      }
    }
    const spansForPoints = (points) => {
      return points.flatMap((p) => {
        return Array.isArray(p) ? interpolatePoints(p, interpolation) : new Array(p.skip).fill(null);
      });
    };
    const createPoint = (xDatum, yDatum) => ({
      point: {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(yDatum)
      },
      xDatum,
      yDatum
    });
    const getSeriesSpans = (index) => {
      const points = [];
      const handleSeriesPoint = (pIdx, datumIndex, nIdx) => {
        const xDatum = xValues[datumIndex];
        const yDatum = yStackValues != null ? yStackValues?.[datumIndex][index] : yRawValues[datumIndex];
        if (connectMissingData && !Number.isFinite(yRawValues[datumIndex]))
          return;
        const yDatumIsFinite = Number.isFinite(yDatum);
        let yValueEndBackwards = 0;
        let yBackwardsFinite = true;
        let yValueEndForwards = 0;
        let yForwardsFinite = true;
        if (yStackValues == null) {
          yBackwardsFinite = pIdx == null || Number.isFinite(yRawValues[pIdx]);
          yForwardsFinite = nIdx == null || Number.isFinite(yRawValues[nIdx]);
          yValueEndBackwards = pIdx != null && Number.isFinite(yRawValues[pIdx]) ? yDatum : 0;
          yValueEndForwards = nIdx != null && Number.isFinite(yRawValues[nIdx]) ? yDatum : 0;
        } else {
          const yValueStack = yStackValues[datumIndex];
          const lastYValueStack = pIdx != null ? yStackValues[pIdx] : void 0;
          const nextYValueStack = nIdx != null ? yStackValues[nIdx] : void 0;
          for (let j = 0; j <= index; j += 1) {
            const value = yValueStack[j];
            if (Number.isFinite(value)) {
              const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);
              const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);
              if (lastWasFinite) {
                yValueEndBackwards += value;
              } else {
                yBackwardsFinite = false;
              }
              if (nextWasFinite) {
                yValueEndForwards += value;
              } else {
                yForwardsFinite = false;
              }
            }
          }
        }
        const currentPoints = points[points.length - 1];
        if (!connectMissingData && (!yBackwardsFinite || !yForwardsFinite || !yDatumIsFinite || yValueEndBackwards !== yValueEndForwards)) {
          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {
            points[points.length - 1] = { skip: 1 };
          } else {
            const pointBackwards = createPoint(xDatum, yValueEndBackwards);
            const pointForwards = createPoint(xDatum, yValueEndForwards);
            if (Array.isArray(currentPoints)) {
              currentPoints.push(pointBackwards);
            } else if (currentPoints != null) {
              currentPoints.skip += 1;
            }
            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });
          }
        } else {
          const yValue = connectMissingData ? yDatum : Math.max(yValueEndBackwards, yValueEndForwards);
          const point = createPoint(xDatum, yValue);
          if (Array.isArray(currentPoints)) {
            currentPoints.push(point);
          } else if (currentPoints != null) {
            currentPoints.skip += 1;
            points.push([point]);
          } else {
            points.push([point]);
          }
        }
      };
      if (processedData.type === "grouped") {
        for (const {
          datumIndexes: [pIdx, datumIndex, nIdx]
        } of dataModel.forEachGroupDatumTuple(this, processedData)) {
          handleSeriesPoint(pIdx, datumIndex, nIdx);
        }
      } else {
        let pIdx;
        let datumIndex;
        for (let i = startIndex; i < endIndex; i += 1) {
          const nIdx = indices?.[i] ?? i;
          if (xValues[nIdx] == null)
            continue;
          if (datumIndex != null) {
            handleSeriesPoint(pIdx, datumIndex, nIdx);
          }
          pIdx = datumIndex;
          datumIndex = nIdx;
        }
        if (datumIndex != null) {
          handleSeriesPoint(pIdx, datumIndex, void 0);
        }
      }
      return spansForPoints(points);
    };
    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;
    const getAxisSpans = () => {
      const getPoint = (datumIndex) => {
        const xDatum = xValues[datumIndex];
        const yDatum = yStackValues?.[datumIndex][stackIndex] ?? yRawValues[datumIndex];
        if (connectMissingData && !Number.isFinite(yDatum))
          return;
        return createPoint(xDatum, 0);
      };
      let yValueZeroPoints;
      if (processedData.type === "grouped") {
        yValueZeroPoints = Array.from(dataModel.forEachGroupDatum(this, processedData), ({ datumIndex }) => {
          return getPoint(datumIndex);
        });
      } else {
        yValueZeroPoints = [];
        for (let i = startIndex; i < endIndex; i += 1) {
          const datumIndex = indices?.[i] ?? i;
          if (xValues[datumIndex] == null)
            continue;
          yValueZeroPoints.push(getPoint(datumIndex));
        }
      }
      yValueZeroPoints = yValueZeroPoints.filter((x) => x != null);
      return interpolatePoints(yValueZeroPoints, interpolation);
    };
    const currentSeriesSpans = getSeriesSpans(stackIndex);
    const phantomSpans = currentSeriesSpans.map(() => null);
    for (let j = stackIndex - 1; j >= -1; j -= 1) {
      let spans;
      for (let i = 0; i < phantomSpans.length; i += 1) {
        if (phantomSpans[i] != null)
          continue;
        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());
        phantomSpans[i] = spans[i];
      }
    }
    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);
    const strokeSpans = currentSeriesSpans.filter((span) => span != null);
    const context = {
      itemId: yKey,
      fillData: { itemId: yKey, spans: fillSpans, phantomSpans },
      strokeData: { itemId: yKey, spans: strokeSpans },
      labelData,
      nodeData: markerData,
      scales: this.calculateScaling(),
      visible: this.visible,
      stackVisible: visibleSameStackCount > 0,
      crossFiltering
    };
    return context;
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const { visible, animationEnabled } = opts;
    const [fill, stroke2] = opts.paths;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    const {
      strokeWidth,
      stroke: strokeColor,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fill: fillColor,
      fillOpacity,
      opacity
    } = mergeDefaults(this.getHighlightStyle(), this.properties);
    stroke2.setProperties({
      fill: void 0,
      lineCap: "round",
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      stroke: strokeColor,
      strokeWidth,
      strokeOpacity: strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),
      lineDash,
      lineDashOffset,
      opacity,
      visible: visible || animationEnabled
    });
    const seriesFill = getShapeFill(
      fillColor,
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    applyShapeStyle(
      fill,
      {
        fill: seriesFill,
        stroke: void 0,
        fillOpacity: fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1)
      },
      this.getShapeFillBBox()
    );
    fill.setProperties({
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      fillShadow: this.properties.shadow,
      opacity,
      visible: visible || animationEnabled
    });
    updateClipPath(this, stroke2);
    updateClipPath(this, fill);
  }
  updatePaths(opts) {
    this.updateAreaPaths(opts.paths, opts.contextData);
  }
  updateAreaPaths(paths, contextData) {
    for (const path of paths) {
      path.visible = contextData.visible;
    }
    if (contextData.visible) {
      this.updateFillPath(paths, contextData);
      this.updateStrokePath(paths, contextData);
    } else {
      for (const path of paths) {
        path.path.clear();
        path.markDirty("AreaSeries");
      }
    }
  }
  updateFillPath(paths, contextData) {
    const [fill] = paths;
    fill.path.clear();
    plotAreaPathFill(fill, contextData.fillData);
    fill.markDirty("AreaSeries");
  }
  updateStrokePath(paths, contextData) {
    const { spans } = contextData.strokeData;
    const [, stroke2] = paths;
    stroke2.path.clear();
    plotLinePathStroke(stroke2, spans);
    stroke2.markDirty("AreaSeries");
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    return datumSelection.update(markersEnabled ? nodeData : []);
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yKey, marker, stroke: stroke2, strokeWidth, strokeOpacity } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((node, datum) => {
      const { xValue, yValue } = datum;
      const params = datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain);
      const style = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
        stroke: stroke2,
        strokeWidth,
        strokeOpacity
      });
      this.applyMarkerStyle(style, node, datum.point, fillBBox, { selected: datum.selected });
    });
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    opts.labelSelection.each((text, datum) => {
      const { x, y, labelText } = datum;
      const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
      const style = getLabelStyles(
        this,
        datum,
        this.properties,
        this.properties.label,
        highlighted,
        highlightState
      );
      const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = style;
      if (labelText && labelEnabled && this.visible) {
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.textAlign = "center";
        text.textBaseline = "bottom";
        text.text = labelText;
        text.x = x;
        text.y = y - 10;
        text.fill = color7;
        text.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
        text.visible = true;
        text.setBoxing(style);
      } else {
        text.visible = false;
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, tooltip, marker, legendItemName } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];
    const { xDomain, yDomain } = this.cachedDatumCallback("domain", () => ({
      xDomain: this.getSeriesDomain("x" /* X */),
      yDomain: this.getSeriesDomain("y" /* Y */)
    }));
    if (xValue == null)
      return;
    const activeStyle = this.getMarkerStyle(
      marker,
      { datum, datumIndex },
      datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain),
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke2,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      marker,
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    } = this.properties;
    const useAreaFill = !marker.enabled || marker.fill === void 0;
    const legendMarkerFill = useAreaFill ? getShapeFill(fill, fillGradientDefaults, fillPatternDefaults, fillImageDefaults) : getShapeFill(
      marker.fill,
      marker.fillGradientDefaults,
      marker.fillPatternDefaults,
      marker.fillImageDefaults
    );
    const markerStyle = this.getMarkerStyle(
      marker,
      {},
      void 0,
      false,
      {
        size: marker.size,
        fill: legendMarkerFill,
        fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity
      },
      void 0,
      false
    );
    return {
      marker: {
        ...markerStyle,
        enabled: marker.enabled || strokeWidth <= 0
      },
      line: {
        stroke: stroke2,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, legendItemName, showInLegend } = this.properties;
    return [
      {
        legendType,
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: legendItemName ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady(animationData) {
    const { datumSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([datumSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, datumSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const { datumSelection, labelSelection, contextData, paths, previousContextData } = animationData;
    const [fill, stroke2] = paths;
    if (contextData.visible === false && previousContextData?.visible === false)
      return;
    if (fill == null && stroke2 == null)
      return;
    this.resetDatumAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateAreaPaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", datumSelection);
      pathFadeInAnimation(this, "fill_path_properties", animationManager, "add", fill);
      pathFadeInAnimation(this, "stroke_path_properties", animationManager, "add", stroke2);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareAreaPathAnimation(contextData, previousContextData);
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    markerFadeInAnimation(this, animationManager, void 0, datumSelection);
    fromToMotion(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
    pathMotion(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
    fromToMotion(this.id, "stroke_path_properties", animationManager, [stroke2], fns.stroke.pathProperties);
    pathMotion(this.id, "stroke_path_update", animationManager, [stroke2], fns.stroke.path);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    this.ctx.animationManager.animate({
      id: this.id,
      groupId: "reset_after_animation",
      phase: "trailing",
      from: {},
      to: {},
      onComplete: () => this.updateAreaPaths(paths, contextData)
    });
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Marker();
  }
  getFormattedMarkerStyle(datum) {
    const { xValue, yValue, xKey, yKey } = datum;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    return this.getMarkerStyle(
      this.properties.marker,
      datum,
      datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain),
      true
    );
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
AreaSeries.className = "AreaSeries";
AreaSeries.type = "area";

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "area",
  moduleFactory: (ctx) => new AreaSeries(ctx),
  stackable: true,
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      nodeClickRange: "nearest",
      fill: { $palette: "fill" },
      fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      stroke: { $palette: "stroke" },
      fillOpacity: 0.8,
      strokeOpacity: 1,
      strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
      lineDash: [0],
      lineDashOffset: 0,
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      interpolation: {
        type: "linear"
      },
      marker: {
        enabled: false,
        shape: "circle",
        size: 7,
        strokeWidth: { $isUserOption: ["./stroke", 1, 0] },
        fill: { $palette: "fill" },
        stroke: { $palette: "stroke" },
        // @ts-expect-error undocumented option
        fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
        fillPatternDefaults: FILL_PATTERN_DEFAULTS
      },
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewAreaSeriesModule = {
  type: "series",
  name: "area",
  chartType: "cartesian",
  options: areaSeriesOptionsDef,
  create: (ctx) => new AreaSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
import { isFiniteNumber as isFiniteNumber9 } from "ag-charts-core";

// packages/ag-charts-community/src/scene/shape/barShape.ts
var BarShape = class extends Rect {
  constructor() {
    super(...arguments);
    this.direction = "x";
    this.featherRatio = 0;
  }
  get feathered() {
    return Math.abs(this.featherRatio) > 1e-6;
  }
  isPointInPath(x, y) {
    if (!this.feathered) {
      return super.isPointInPath(x, y);
    }
    const bbox = this.getBBox();
    return bbox.containsPoint(x, y);
  }
  updatePath() {
    if (!this.feathered) {
      super.updatePath();
      return;
    }
    const { path, x, y, width: width2, height: height2, direction, featherRatio } = this;
    path.clear();
    if (direction === "x") {
      const featherInsetX = Math.abs(featherRatio) * width2;
      if (featherRatio > 0) {
        path.moveTo(x, y);
        path.lineTo(x + width2 - featherInsetX, y);
        path.lineTo(x + width2, y + height2 / 2);
        path.lineTo(x + width2 - featherInsetX, y + height2);
        path.lineTo(x, y + height2);
        path.closePath();
      } else {
        path.moveTo(x + featherInsetX, y);
        path.lineTo(x + width2, y);
        path.lineTo(x + width2, y + height2);
        path.lineTo(x + featherInsetX, y + height2);
        path.lineTo(x, y + height2 / 2);
        path.closePath();
      }
    } else {
      const featherInsetY = Math.abs(featherRatio) * height2;
      if (featherRatio > 0) {
        path.moveTo(x, y + featherInsetY);
        path.lineTo(x + width2 / 2, y);
        path.lineTo(x + width2, y + featherInsetY);
        path.lineTo(x + width2, y + height2);
        path.lineTo(x, y + height2);
        path.closePath();
      } else {
        path.moveTo(x, y);
        path.lineTo(x + width2, y);
        path.lineTo(x + width2, y + height2 - featherInsetY);
        path.lineTo(x + width2 / 2, y + height2);
        path.lineTo(x, y + height2 - featherInsetY);
        path.closePath();
      }
    }
  }
};
__decorateClass([
  SceneChangeDetection()
], BarShape.prototype, "direction", 2);
__decorateClass([
  SceneChangeDetection()
], BarShape.prototype, "featherRatio", 2);

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
import { isFiniteNumber as isFiniteNumber8 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
import { isFiniteNumber as isFiniteNumber7 } from "ag-charts-core";
var _CategoryAxis = class _CategoryAxis extends CartesianAxis {
  constructor(moduleCtx, scale2 = new CategoryScale(), includeInvisibleDomains = true) {
    super(moduleCtx, scale2);
    this.groupPaddingInner = 0.1;
    this.includeInvisibleDomains = includeInvisibleDomains;
    this.nice = false;
  }
  static is(value) {
    return value instanceof _CategoryAxis;
  }
  isCategoryLike() {
    return true;
  }
  hasDefinedDomain() {
    return false;
  }
  normaliseDataDomain(domain) {
    return { domain, clipped: false };
  }
  updateScale() {
    super.updateScale();
    let { paddingInner, paddingOuter } = this;
    if (!isFiniteNumber7(paddingInner) || !isFiniteNumber7(paddingOuter)) {
      const padding2 = this.reduceBandScalePadding();
      paddingInner ?? (paddingInner = padding2.inner);
      paddingOuter ?? (paddingOuter = padding2.outer);
    }
    this.scale.paddingInner = paddingInner ?? 0;
    this.scale.paddingOuter = paddingOuter ?? 0;
  }
  calculateGridLines(ticks, p1, p2) {
    const gridLines = super.calculateGridLines(ticks, p1, p2);
    if (this.interval.placement === "between" && ticks.length > 0) {
      gridLines.push(
        super.calculateGridLine(
          {
            index: ticks.at(-1).index + 1,
            tickId: `after:${ticks.at(-1).tickId}`,
            translation: this.range[1]
          },
          ticks.length,
          p1,
          p2,
          ticks
        )
      );
    }
    return gridLines;
  }
  calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks) {
    const { gridLine, horizontal, interval, scale: scale2 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks);
    }
    const halfStep = translation < scale2.step ? Math.floor(scale2.step / 2) : scale2.step / 2;
    const offset = translation - halfStep;
    const [x1, y1, x2, y2] = horizontal ? [offset, Math.max(p1, p2), offset, Math.min(p1, p2)] : [Math.min(p1, p2), offset, Math.max(p1, p2), offset];
    const { style } = gridLine;
    const { stroke: stroke2, strokeWidth = 0, lineDash } = style[tickIndex % style.length] ?? {};
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
  }
  calculateGridFills(ticks, p1, p2) {
    const { horizontal, range: range3, scale: scale2 } = this;
    if (this.interval.placement !== "between") {
      return super.calculateGridFills(ticks, p1, p2);
    }
    const gridFills = [];
    if (ticks.length == 0)
      return gridFills;
    const firstTick = ticks[0];
    const firstFillOffCanvas = firstTick.translation > range3[0] + scale2.step / 2;
    const lastTick = ticks[ticks.length - 1];
    const lastFillOffCanvas = horizontal && lastTick.translation < range3[1] - scale2.step / 2;
    if (firstFillOffCanvas) {
      const tick = { tickId: `before:${firstTick.tickId}`, translation: firstTick.translation - scale2.step };
      gridFills.push(this.calculateGridFill(tick, -1, firstTick.index - 1, p1, p2, ticks));
    }
    gridFills.push(...ticks.map((tick, index) => this.calculateGridFill(tick, index, tick.index, p1, p2, ticks)));
    if (lastFillOffCanvas) {
      const tick = { tickId: `after:${lastTick.tickId}`, translation: lastTick.translation + scale2.step };
      gridFills.push(this.calculateGridFill(tick, ticks.length, lastTick.index + 1, p1, p2, ticks));
    }
    return gridFills;
  }
  calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks) {
    const { gridLine, horizontal, interval, scale: scale2 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks);
    }
    const startOffset = translation - scale2.step / 2;
    const endOffset = translation + scale2.step / 2;
    const [x1, y1, x2, y2] = horizontal ? [startOffset, Math.max(p1, p2), endOffset, Math.min(p1, p2)] : [Math.min(p1, p2), startOffset, Math.max(p1, p2), endOffset];
    const { fill, fillOpacity } = gridLine.style[gridFillIndex % gridLine.style.length] ?? {};
    return { tickId, x1, y1, x2, y2, fill, fillOpacity };
  }
  calculateTickLines(ticks, direction) {
    const tickLines = super.calculateTickLines(ticks, direction);
    if (this.interval.placement === "between" && ticks.length > 0) {
      tickLines.push(
        super.calculateTickLine(
          { primary: false, tickId: `after:${ticks.at(-1)?.tickId}`, translation: this.range[1] },
          ticks.length,
          direction,
          ticks
        )
      );
    }
    return tickLines;
  }
  calculateTickLine({ primary, tickId, translation }, index, direction, ticks) {
    const { horizontal, interval, primaryTick, scale: scale2, tick } = this;
    if (interval.placement !== "between") {
      return super.calculateTickLine({ primary, tickId, translation }, index, direction, ticks);
    }
    const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
    const h = -direction * this.getTickSize(datumTick);
    const halfStep = translation < scale2.step ? Math.floor(scale2.step / 2) : scale2.step / 2;
    const offset = translation - halfStep;
    const [x1, y1, x2, y2] = horizontal ? [offset, 0, offset, h] : [0, offset, h, offset];
    const { stroke: stroke2, width: strokeWidth } = datumTick;
    const lineDash = void 0;
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
  }
  reduceBandScalePadding() {
    return this.boundSeries.reduce(
      (result, series) => {
        const padding2 = series.getBandScalePadding?.();
        if (padding2) {
          if (result.inner > padding2.inner) {
            result.inner = padding2.inner;
          }
          if (result.outer < padding2.outer) {
            result.outer = padding2.outer;
          }
        }
        return result;
      },
      { inner: Infinity, outer: -Infinity }
    );
  }
  tickFormatParams(_domain, _ticks, _fractionDigits, _timeInterval) {
    return { type: "category" };
  }
  datumFormatParams(value, params, _fractionDigits, _timeInterval, _style) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    if (Array.isArray(value) && value.some((v) => typeof v !== "string")) {
      value = value.map(String);
    } else if (!Array.isArray(value) && typeof value !== "string" && typeof value !== "number" && !(value instanceof Date)) {
      value = String(value);
    }
    return { type: "category", value, datum, seriesId, legendItemName, key, source, property, domain, boundSeries };
  }
};
_CategoryAxis.className = "CategoryAxis";
_CategoryAxis.type = "category";
__decorateClass([
  Property
], _CategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  Property
], _CategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
  Property
], _CategoryAxis.prototype, "paddingOuter", 2);
var CategoryAxis = _CategoryAxis;

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
import { getMaxInnerRectSize, inRange, isArray as isArray13, isObject as isObject8, sortBasedOnArray, toArray as toArray3 } from "ag-charts-core";

// packages/ag-charts-community/src/scale/groupedCategoryScale.ts
var GroupedCategoryScale = class _GroupedCategoryScale extends CategoryScale {
  static is(value) {
    return value instanceof _GroupedCategoryScale;
  }
  normalizeDomains(...domains) {
    const { domain } = super.normalizeDomains(...domains);
    return { domain, animatable: false };
  }
  findIndex(value) {
    return super.findIndex(value) ?? this.getMatchIndex(value);
  }
  getMatchIndex(value) {
    const key = JSON.stringify(value);
    const match = this._domain.find((d) => JSON.stringify(d) === key);
    if (match != null) {
      return super.findIndex(match);
    }
  }
};

// packages/ag-charts-community/src/chart/axis/tree.ts
var Dimensions = class {
  constructor() {
    this.top = Infinity;
    this.right = -Infinity;
    this.bottom = -Infinity;
    this.left = Infinity;
  }
  update(x, y) {
    if (x > this.right) {
      this.right = x;
    }
    if (x < this.left) {
      this.left = x;
    }
    if (y > this.bottom) {
      this.bottom = y;
    }
    if (y < this.top) {
      this.top = y;
    }
  }
};
var TreeNode = class _TreeNode {
  constructor(label = "", parent, refId) {
    this.label = label;
    this.parent = parent;
    this.refId = refId;
    this.position = 0;
    this.subtreeLeft = NaN;
    this.subtreeRight = NaN;
    this.children = [];
    this.leafCount = 0;
    this.prelim = 0;
    this.mod = 0;
    this.ancestor = this;
    this.change = 0;
    this.shift = 0;
    this.index = 0;
    // screen is meant to be recomputed from (layout) when the tree is resized (without performing another layout)
    this.screen = 0;
    this.depth = parent ? parent.depth + 1 : 0;
  }
  insertTick(tick, index) {
    let root = this;
    for (let i = 0; i < tick.length; i++) {
      const pathPart = tick[i];
      const isNotLeaf = i !== tick.length - 1;
      const { children } = root;
      const existingNode = children.find((child) => child.label === pathPart);
      if (existingNode && isNotLeaf) {
        root = existingNode;
      } else {
        const node = new _TreeNode(pathPart, root, index);
        node.index = children.length;
        children.push(node);
        if (isNotLeaf) {
          root = node;
        }
      }
    }
  }
  getLeftSibling() {
    return this.index > 0 ? this.parent?.children[this.index - 1] : void 0;
  }
  getLeftmostSibling() {
    return this.index > 0 ? this.parent?.children[0] : void 0;
  }
  // traverse the left contour of a subtree, return the successor of v on this contour
  nextLeft() {
    return this.children[0];
  }
  // traverse the right contour of a subtree, return the successor of v on this contour
  nextRight() {
    return this.children.at(-1);
  }
  getSiblings() {
    return this.parent?.children.filter((_, i) => i !== this.index) ?? [];
  }
};
function ticksToTree(ticks) {
  const maxDepth = ticks.reduce((depth, tick) => depth < tick.length ? tick.length : depth, 0);
  const root = new TreeNode();
  for (let i = 0; i < ticks.length; i++) {
    const tick = ticks[i];
    while (tick.length < maxDepth) {
      tick.push("");
    }
    root.insertTick(tick, i);
  }
  return root;
}
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.index - wm.index;
  const ratio8 = shift / subtrees;
  wp.change -= ratio8;
  wp.shift += shift;
  wm.change += ratio8;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts({ children }) {
  let shift = 0;
  let change = 0;
  for (let i = children.length - 1; i >= 0; i--) {
    const w = children[i];
    w.prelim += shift;
    w.mod += shift;
    change += w.change;
    shift += w.shift + change;
  }
}
function apportion(v, defaultAncestor) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + 1;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
function firstWalk(node) {
  const { children } = node;
  if (children.length) {
    let [defaultAncestor] = children;
    for (const child of children) {
      firstWalk(child);
      defaultAncestor = apportion(child, defaultAncestor);
    }
    executeShifts(node);
    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + 1;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + 1 : 0;
  }
}
function secondWalk(v, m, layout) {
  v.position = v.prelim + m;
  layout.insertNode(v);
  for (const w of v.children) {
    secondWalk(w, m + v.mod, layout);
  }
}
function thirdWalk(v) {
  const { children } = v;
  let leafCount = 0;
  for (const w of children) {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  }
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[children.length - 1].subtreeRight;
    v.position = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.position;
    v.subtreeRight = v.position;
  }
}
function treeLayout(ticks) {
  const layout = new TreeLayout();
  const root = ticksToTree(ticks);
  firstWalk(root);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
var TreeLayout = class {
  constructor() {
    this.dimensions = new Dimensions();
    this.nodes = [];
    this.depth = 0;
  }
  insertNode(node) {
    if (this.depth < node.depth) {
      this.depth = node.depth;
    }
    this.dimensions.update(node.position, node.depth);
    this.nodes.push(node);
  }
  scaling(extent2, flip) {
    let scaling = 1;
    if (extent2 > 0) {
      const { left, right } = this.dimensions;
      if (right !== left) {
        scaling = extent2 / (right - left);
      }
    }
    if (flip) {
      scaling *= -1;
    }
    return scaling;
  }
};

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var DepthLabelProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.border = new LabelBorder();
  }
};
__decorateClass([
  Property
], DepthLabelProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "avoidCollisions", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "border", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "color", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "spacing", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "wrapping", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "truncate", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fill", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontStyle", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontWeight", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontSize", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontFamily", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "padding", 2);
var DepthTickProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
};
__decorateClass([
  Property
], DepthTickProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], DepthTickProperties.prototype, "width", 2);
__decorateClass([
  Property
], DepthTickProperties.prototype, "stroke", 2);
var DepthProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.label = new DepthLabelProperties();
    this.tick = new DepthTickProperties();
  }
};
__decorateClass([
  Property
], DepthProperties.prototype, "label", 2);
__decorateClass([
  Property
], DepthProperties.prototype, "tick", 2);
var GroupedCategoryAxis = class extends CategoryAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new GroupedCategoryScale());
    // Label scale (labels are positioned between ticks, tick count = label count + 1).
    // We don't call is `labelScale` for consistency with other axes.
    this.tickScale = new GroupedCategoryScale();
    this.depthOptions = new PropertiesArray(DepthProperties);
    this.includeInvisibleDomains = true;
    this.tickScale.paddingInner = 1;
    this.tickScale.paddingOuter = 0;
  }
  resizeTickTree() {
    if (!this.tickTreeLayout)
      return;
    const { nodes } = this.tickTreeLayout;
    const { range: range3, step, inset, bandwidth } = this.scale;
    const width2 = Math.abs(range3[1] - range3[0]) - step;
    const scaling = this.tickTreeLayout.scaling(width2, range3[0] > range3[1]);
    const shift = inset + bandwidth / 2;
    let offset = 0;
    for (const node of nodes) {
      const screen = node.position * scaling;
      if (offset > screen) {
        offset = screen;
      }
      node.screen = screen + shift;
    }
    for (const node of nodes) {
      node.screen -= offset;
    }
  }
  getDepthOptionsMap(maxDepth) {
    const optionsMap = [];
    const { depthOptions, label } = this;
    const defaultNonLeafRotation = this.horizontal ? 0 : -90;
    for (let i = 0; i < maxDepth; i++) {
      optionsMap.push(
        depthOptions[i]?.label.enabled ?? label.enabled ? {
          enabled: true,
          spacing: depthOptions[i]?.label.spacing ?? label.spacing,
          wrapping: depthOptions[i]?.label.wrapping ?? label.wrapping,
          truncate: depthOptions[i]?.label.truncate ?? label.truncate,
          rotation: depthOptions[i]?.label.rotation ?? (i ? defaultNonLeafRotation : label.rotation),
          // Default top-level label roration only applies to label leaves
          avoidCollisions: depthOptions[i]?.label.avoidCollisions ?? label.avoidCollisions
        } : { enabled: false, spacing: 0, rotation: 0, avoidCollisions: false }
      );
    }
    return optionsMap;
  }
  updateCategoryLabels() {
    if (!this.computedLayout)
      return;
    this.tickLabelGroupSelection.update(this.computedLayout.tickLabelLayout).each((node, datum) => {
      node.fill = datum.color;
      node.text = datum.text;
      node.textBaseline = datum.textBaseline;
      node.textAlign = datum.textAlign ?? "center";
      node.setFont(datum);
      node.setBoxing(datum);
    });
  }
  updateAxisLine() {
    if (!this.computedLayout)
      return;
    this.lineNode.visible = this.line.enabled;
    this.lineNode.stroke = this.line.stroke;
    this.lineNode.strokeWidth = this.line.width;
  }
  computeLayout() {
    this.updateDirection();
    this.updateScale();
    const { step } = this.scale;
    const { title, label, range: range3, depthOptions, horizontal, line } = this;
    this.lineNode.datum = horizontal ? { x1: range3[0], x2: range3[1], y1: 0, y2: 0 } : { x1: 0, x2: 0, y1: range3[0], y2: range3[1] };
    this.lineNode.setProperties({ stroke: line.stroke, strokeWidth: line.enabled ? line.width : 0 });
    this.resizeTickTree();
    if (!this.tickTreeLayout?.depth) {
      return { bbox: BBox.zero, spacing: 0, separatorLayout: [], tickLabelLayout: [] };
    }
    const { depth: maxDepth, nodes: treeLabels } = this.tickTreeLayout;
    const sideFlag = horizontal ? -label.getSideFlag() : label.getSideFlag();
    const tickLabelLayout = [];
    const labelBBoxes = /* @__PURE__ */ new Map();
    const tempText = new TransformableText();
    const optionsMap = this.getDepthOptionsMap(maxDepth);
    const labelSpacing = sideFlag * optionsMap[0].spacing;
    const tickFormatter = this.tickFormatter(this.scale.domain, this.scale.domain, false);
    const setLabelProps = (datum, index) => {
      const depth = maxDepth - datum.depth;
      if (!optionsMap[depth]?.enabled || !inRange(datum.screen, range3)) {
        return false;
      }
      let text = tickFormatter(datum.label, index - 1);
      const labelStyles = this.getLabelStyles({ value: text, depth }, depthOptions[depth]?.label);
      if (label.avoidCollisions) {
        const rotation = optionsMap[depth].rotation;
        let maxWidth = (datum.leafCount || 1) * step;
        let maxHeight = this.thickness;
        if (rotation != null) {
          const innerRect = getMaxInnerRectSize(rotation, maxWidth, maxHeight);
          maxWidth = innerRect.width;
          maxHeight = innerRect.height;
        }
        text = TextWrapper.wrapText(text, {
          font: labelStyles,
          textWrap: optionsMap[depth].wrapping,
          overflow: optionsMap[depth].truncate ? "ellipsis" : "hide",
          maxWidth,
          maxHeight
        }) || text;
      }
      tempText.x = horizontal ? datum.screen : labelSpacing;
      tempText.y = horizontal ? labelSpacing : datum.screen;
      tempText.rotation = 0;
      tempText.lineHeight = TextUtils.getLineHeight(labelStyles.fontSize);
      tempText.fill = labelStyles.color;
      tempText.text = text;
      tempText.textAlign = "center";
      tempText.textBaseline = label.parallel ? "top" : "bottom";
      tempText.setFont(labelStyles);
      tempText.setBoxing(labelStyles);
      return true;
    };
    const depthLabelMaxSize = {};
    treeLabels.forEach((datum, index) => {
      const depth = maxDepth - datum.depth;
      depthLabelMaxSize[depth] ?? (depthLabelMaxSize[depth] = 0);
      const isVisible = setLabelProps(datum, index);
      if (!isVisible || !tempText.getBBox())
        return;
      labelBBoxes.set(index, tempText.getBBox());
      tempText.rotation = normalizeAngle360FromDegrees(optionsMap[depth]?.rotation);
      const { width: width2, height: height2 } = tempText.getBBox();
      const labelSize = horizontal ? height2 : width2;
      if (depthLabelMaxSize[depth] < labelSize) {
        depthLabelMaxSize[depth] = labelSize;
      }
    });
    const idGenerator = createIdsGenerator();
    const separatorData = /* @__PURE__ */ new Map();
    const nestedPadding = (d) => {
      if (d === 0)
        return 0;
      let v = depthLabelMaxSize[0];
      for (let i = 1; i <= d; i++) {
        v += optionsMap[i].spacing;
        if (i !== d) {
          v += depthLabelMaxSize[i];
        }
      }
      return v;
    };
    treeLabels.forEach((datum, index) => {
      if (index === 0)
        return;
      const visible = setLabelProps(datum, index);
      const isLeaf = !datum.children.length;
      const depth = maxDepth - datum.depth;
      if (datum.parent) {
        const separatorX = isLeaf ? datum.position : datum.position - (datum.leafCount - 1) / 2;
        if (!separatorData.has(separatorX)) {
          const tickOptions = this.depthOptions[depth]?.tick;
          let v = depthLabelMaxSize[0];
          for (let i = 0; i <= depth; i++) {
            v += optionsMap[i].spacing;
            if (i !== 0) {
              v += depthLabelMaxSize[i];
            }
          }
          separatorData.set(separatorX, {
            tickSize: v,
            tickStroke: tickOptions?.stroke,
            tickWidth: tickOptions?.enabled !== false ? tickOptions?.width : 0
          });
        }
      }
      if (!visible)
        return;
      const labelRotation = normalizeAngle360FromDegrees(optionsMap[depth].rotation);
      const { width: w, height: h } = labelBBoxes.get(index);
      const depthPadding = nestedPadding(depth);
      tempText.textAlign = "center";
      tempText.textBaseline = "middle";
      tempText.rotation = labelRotation;
      if (horizontal) {
        tempText.y += (depthPadding + angularPadding(w / 2, h / 2, labelRotation)) * sideFlag;
        tempText.rotationCenterX = datum.screen;
        tempText.rotationCenterY = tempText.y;
      } else {
        tempText.x += depthPadding * sideFlag + angularPadding(
          (optionsMap[depth].spacing * sideFlag + w) / 2,
          label.mirrored ? w : 0,
          labelRotation
        ) - w / 2;
        tempText.rotationCenterX = tempText.x;
        tempText.rotationCenterY = datum.screen;
      }
      if (optionsMap[depth].avoidCollisions) {
        const { width: width2, height: height2 } = tempText.getBBox();
        const labelSize = horizontal ? width2 : height2;
        const availableRange = isLeaf ? step : datum.leafCount * step;
        if (labelSize > availableRange) {
          labelBBoxes.delete(index);
          return;
        }
      }
      const text = tempText.getPlainText();
      const boxing = tempText.getBoxingProperties();
      tickLabelLayout.push({
        text,
        visible: true,
        tickId: idGenerator(text),
        range: this.scale.range,
        border: boxing.border,
        color: tempText.fill,
        cornerRadius: boxing.cornerRadius,
        fill: boxing.fill,
        fontFamily: tempText.fontFamily,
        fontSize: tempText.fontSize,
        fontStyle: tempText.fontStyle,
        fontWeight: tempText.fontWeight,
        padding: boxing.padding,
        rotation: tempText.rotation,
        rotationCenterX: tempText.rotationCenterX,
        rotationCenterY: tempText.rotationCenterY,
        textAlign: tempText.textAlign,
        textBaseline: tempText.textBaseline,
        x: tempText.x,
        y: tempText.y
      });
      labelBBoxes.set(index, Transformable.toCanvas(tempText));
    });
    const separatorLayout = [...separatorData.values()];
    separatorLayout.push(separatorLayout[0]);
    const bboxes = [
      this.lineNodeBBox(),
      BBox.merge(labelBBoxes.values()),
      new BBox(0, 0, separatorLayout[0].tickSize * sideFlag, 0)
    ];
    let spacing = 0;
    if (title.enabled) {
      const withoutTitle = BBox.merge(bboxes);
      spacing = horizontal ? withoutTitle.height : withoutTitle.width;
      bboxes.push(this.titleBBox(this.scale.domain, spacing));
    }
    const mergedBBox = BBox.merge(bboxes);
    this.layoutCrossLines();
    return { bbox: mergedBBox, spacing, separatorLayout, tickLabelLayout };
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */
  update() {
    if (!this.computedLayout)
      return;
    this.moduleCtx.animationManager.skipCurrentBatch();
    const { tickScale, tick, gridLine, gridLength } = this;
    const { separatorLayout, spacing } = this.computedLayout;
    const { position, horizontal, gridPadding } = this;
    const direction = position === "bottom" || position === "right" ? -1 : 1;
    const p1 = gridPadding;
    const p2 = direction * gridLength - gridPadding;
    const ticks = tickScale.ticks({
      nice: false,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    }).ticks.map((t, index) => ({
      index,
      tickId: createDatumId(t, index),
      translation: Math.round(tickScale.convert(t))
    }));
    this.gridLineGroupSelection.update(
      gridLine.enabled && gridLength ? this.calculateGridLines(ticks, p1, p2) : []
    );
    this.gridFillGroupSelection.update(
      gridLine.enabled && gridLength ? this.calculateGridFills(ticks, p1, p2) : []
    );
    this.tickLineGroupSelection.update(
      tick.enabled ? ticks.map(({ tickId, translation: offset }, index) => {
        const {
          tickSize = this.getTickSize(),
          tickStroke: stroke2 = tick.stroke,
          tickWidth: strokeWidth = tick.width
        } = separatorLayout[index] ?? {};
        const h = -direction * tickSize;
        const [x1, x2, y1, y2] = horizontal ? [offset, offset, 0, h] : [0, h, offset, offset];
        const lineDash = void 0;
        return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
      }) : []
    );
    this.updatePosition();
    this.updateCategoryLabels();
    this.updateAxisLine();
    this.updateGridLines();
    this.updateGridFills();
    this.updateTickLines();
    this.updateTitle(this.scale.domain, spacing);
    this.updateCrossLines();
    this.resetSelectionNodes();
  }
  calculateLayout() {
    const { separatorLayout, tickLabelLayout, spacing, bbox } = this.computeLayout();
    this.computedLayout = { separatorLayout, tickLabelLayout, spacing };
    return { bbox, niceDomain: this.scale.domain };
  }
  /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */
  onGridVisibilityChange() {
    super.onGridVisibilityChange();
    this.tickLabelGroupSelection.clear();
  }
  updateScale() {
    super.updateScale();
    this.tickScale.range = this.scale.range;
    this.scale.paddingOuter = this.scale.paddingInner / 2;
  }
  processData() {
    const { direction } = this;
    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => series.getDomain(direction));
    this.dataDomain = { domain: extent(flatDomains) ?? this.filterDuplicateArrays(flatDomains), clipped: false };
    if (this.isReversed()) {
      this.dataDomain.domain.reverse();
    }
    const domain = this.dataDomain.domain.map(
      (datum) => (
        // Handle integrated charts data when provided as an object
        toArray3(isObject8(datum) && "value" in datum ? datum.value : datum)
      )
    );
    this.tickTreeLayout = treeLayout(domain);
    const orderedDomain = [];
    for (const node of this.tickTreeLayout.nodes) {
      if (node.leafCount || node.refId == null)
        continue;
      orderedDomain.push(this.dataDomain.domain[node.refId]);
    }
    this.scale.domain = sortBasedOnArray(this.dataDomain.domain, orderedDomain);
    this.tickScale.domain = domain.concat([[""]]);
  }
  filterDuplicateArrays(array4) {
    const seen = /* @__PURE__ */ new Set();
    return array4.filter((item) => {
      const key = isArray13(item) ? JSON.stringify(item) : item;
      if (seen.has(key))
        return false;
      seen.add(key);
      return true;
    });
  }
};
GroupedCategoryAxis.className = "GroupedCategoryAxis";
GroupedCategoryAxis.type = "grouped-category";
__decorateClass([
  Property
], GroupedCategoryAxis.prototype, "depthOptions", 2);

// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts
import { Logger as Logger36 } from "ag-charts-core";
function addHitTestersToQuadtree(quadtree, hitTesters) {
  for (const node of hitTesters) {
    const datum = node.datum;
    if (datum === void 0) {
      Logger36.error("undefined datum");
    } else {
      quadtree.addValue(node, datum);
    }
  }
}
function findQuadtreeMatch(series, point) {
  const { x, y } = point;
  const { nearest, distanceSquared } = series.getQuadTree().find(x, y);
  if (nearest !== void 0) {
    return { datum: nearest.value, distance: Math.sqrt(distanceSquared) };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
  }
};
__decorateClass([
  Property
], AbstractBarSeriesProperties.prototype, "direction", 2);
var AbstractBarSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments);
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new CategoryScale();
    this.smallestDataInterval = void 0;
    this.largestDataInterval = void 0;
  }
  padBandExtent(keys, alignStart) {
    const ratio8 = typeof alignStart === "boolean" ? 1 : 0.5;
    const scalePadding = isFiniteNumber8(this.smallestDataInterval) ? this.smallestDataInterval * ratio8 : 0;
    const keysExtent = extent(keys) ?? [NaN, NaN];
    if (typeof alignStart === "boolean") {
      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;
    } else {
      keysExtent[0] -= scalePadding;
      keysExtent[1] += scalePadding;
    }
    return fixNumericExtent(keysExtent);
  }
  getBandScalePadding() {
    return { inner: 0.3, outer: 0.15 };
  }
  shouldFlipXY() {
    return !this.isVertical();
  }
  isVertical() {
    return this.properties.direction === "vertical";
  }
  getBarDirection() {
    return this.shouldFlipXY() ? "x" /* X */ : "y" /* Y */;
  }
  getCategoryDirection() {
    return this.shouldFlipXY() ? "y" /* Y */ : "x" /* X */;
  }
  getValueAxis() {
    const direction = this.getBarDirection();
    return this.axes[direction];
  }
  getCategoryAxis() {
    const direction = this.getCategoryDirection();
    return this.axes[direction];
  }
  getBandwidth(xAxis, minWidth) {
    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval, minWidth) : xAxis.scale.bandwidth;
  }
  xCoordinateRange(xValue) {
    const xAxis = this.axes[this.getCategoryDirection()];
    const xScale = xAxis.scale;
    const bandWidth = this.getBandwidth(xAxis, 0) ?? 0;
    const barOffset = ContinuousScale.is(xScale) ? bandWidth * -0.5 : 0;
    const x = xScale.convert(xValue) + barOffset;
    return [x, x + bandWidth];
  }
  yCoordinateRange(yValues) {
    const yAxis = this.axes[this.getBarDirection()];
    const yScale = yAxis.scale;
    const ys = yValues.map((yValue) => yScale.convert(yValue));
    if (ys.length === 1) {
      const y0 = yScale.convert(0);
      return [Math.min(ys[0], y0), Math.max(ys[0], y0)];
    }
    return [Math.min(...ys), Math.max(...ys)];
  }
  updateGroupScale(xAxis) {
    const domain = [];
    const { groupScale } = this;
    const xBandWidth = this.getBandwidth(xAxis);
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
      domain.push(String(groupIdx));
    }
    groupScale.domain = domain;
    groupScale.range = [0, xBandWidth ?? 0];
    if (xAxis instanceof GroupedCategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
    } else if (xAxis instanceof CategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
      groupScale.round = groupScale.padding !== 0;
    } else {
      groupScale.padding = 0;
    }
    const barWidth = groupScale.bandwidth >= 1 ? (
      // Pixel-rounded value for low-volume bar charts.
      groupScale.bandwidth
    ) : (
      // Handle high-volume bar charts gracefully.
      groupScale.rawBandwidth
    );
    return { barWidth, groupIndex };
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === "x" /* X */) {
      if (direction === "x" /* X */) {
        return "y" /* Y */;
      }
      return "x" /* X */;
    }
    return direction;
  }
  initQuadTree(quadtree) {
    addHitTestersToQuadtree(quadtree, this.datumNodesIter());
  }
  pickNodesExactShape(point) {
    const item = findQuadtreeMatch(this, point);
    return item != null && item.distance <= 0 ? [item.datum] : [];
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/barAggregation.ts
var BAR_X_MIN = AGGREGATION_INDEX_X_MIN;
var BAR_X_MAX = AGGREGATION_INDEX_X_MAX;
var BAR_Y_MIN = AGGREGATION_INDEX_Y_MIN;
var BAR_Y_MAX = AGGREGATION_INDEX_Y_MAX;
var BAR_SPAN = AGGREGATION_SPAN;
var AGGREGATION_THRESHOLD2 = 1e3;
function getIndices(maxRange, indexData) {
  return Array.from({ length: maxRange }, (_, index) => {
    const aggIndex = index * AGGREGATION_SPAN;
    const xMinIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MIN];
    const xMaxIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MAX];
    return (xMinIndex + xMaxIndex) / 2 | 0;
  });
}
function aggregateBarData(scale2, xValues, yValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD2)
    return;
  const [d0, d1] = aggregationDomain(scale2, domain);
  let maxRange = aggregationRangeFittingPoints(xValues);
  let { indexData, valueData } = createAggregationIndices(xValues, yValues, yValues, d0, d1, maxRange);
  let indices = getIndices(maxRange, indexData);
  const filters = [{ maxRange, indexData, indices }];
  while (maxRange > 64) {
    ({ indexData, valueData, maxRange } = compactAggregationIndices(indexData, valueData, maxRange));
    indices = getIndices(maxRange, indexData);
    filters.push({ maxRange, indexData, indices });
  }
  filters.reverse();
  return filters;
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "inside-center";
    this.spacing = 0;
  }
};
__decorateClass([
  Property
], BarSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Property
], BarSeriesLabel.prototype, "spacing", 2);
var BarSeriesProperties = class extends AbstractBarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.crisp = void 0;
    this.shadow = new DropShadow();
    this.label = new BarSeriesLabel();
    this.tooltip = makeSeriesTooltip();
    this.sparklineMode = false;
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass([
  Property
], BarSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "crisp", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "sparklineMode", 2);

// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts
import { isNegative as isNegative3 } from "ag-charts-core";
function checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {
  if (visibleRange != null) {
    const [visibleMin, visibleMax] = visibleRange;
    const isZoomed = visibleMin !== 0 || visibleMax !== 1;
    if (isZoomed)
      return false;
  }
  if (ContinuousScale.is(scale2)) {
    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);
    if (spacing > 0 && spacing < 1)
      return false;
  }
  if (BandScale.is(scale2)) {
    const { bandwidth, step } = scale2;
    if (bandwidth > 0 && bandwidth < 1)
      return false;
    const spacing = step - bandwidth;
    if (spacing > 0 && spacing < 1)
      return false;
  }
  return true;
}
var isDatumNegative = (datum) => {
  return isNegative3(datum.yValue ?? 0);
};
function collapsedStartingBarPosition(isVertical, axes, mode) {
  const { startingX, startingY } = getStartingValues(isVertical, axes);
  const calculate = (datum, prevDatum) => {
    let x = isVertical ? datum.x : startingX;
    let y = isVertical ? startingY : datum.y;
    let width2 = isVertical ? datum.width : 0;
    let height2 = isVertical ? 0 : datum.height;
    const { opacity = 1 } = datum;
    if (prevDatum && (isNaN(x) || isNaN(y))) {
      ({ x, y } = prevDatum);
      width2 = isVertical ? prevDatum.width : 0;
      height2 = isVertical ? 0 : prevDatum.height;
      if (isVertical && !isDatumNegative(prevDatum)) {
        y += prevDatum.height;
      } else if (!isVertical && isDatumNegative(prevDatum)) {
        x += prevDatum.width;
      }
    }
    let clipBBox;
    if (datum.clipBBox == null) {
      clipBBox = void 0;
    } else if (isDatumNegative(datum)) {
      clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);
    } else {
      clipBBox = new BBox(x, y, width2, height2);
    }
    return { x, y, width: width2, height: height2, clipBBox, opacity };
  };
  return { isVertical, calculate, mode };
}
function prepareBarAnimationFunctions(initPos) {
  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);
  const fromFn = (rect, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(rect.previousDatum)) {
      status = "added";
    }
    let source;
    if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
      source = {
        ...resetBarSelectionsFn(rect, datum),
        opacity: 0
      };
    } else if (status === "unknown" || status === "added") {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        clipBBox: rect.clipBBox,
        opacity: rect.opacity ?? 1
      };
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { ...source, phase };
  };
  const toFn = (rect, datum, status) => {
    if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
      return { ...resetBarSelectionsFn(rect, datum), opacity: 0 };
    } else if (status === "removed" || isRemoved(datum)) {
      return initPos.calculate(datum, rect.previousDatum);
    } else {
      return {
        x: datum.x,
        y: datum.y,
        width: datum.width,
        height: datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity ?? 1
      };
    }
  };
  const applyFn = (rect, datum, status) => {
    rect.setProperties(datum);
    rect.crisp = status === "end" && (rect.datum?.crisp ?? false);
  };
  return { toFn, fromFn, applyFn };
}
function getStartingValues(isVertical, axes) {
  const axis = axes[isVertical ? "y" /* Y */ : "x" /* X */];
  let startingX = Infinity;
  let startingY = 0;
  if (!axis) {
    return { startingX, startingY };
  }
  if (isVertical) {
    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
  } else {
    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
  }
  return { startingX, startingY };
}
function resetBarSelectionsFn(rect, { x, y, width: width2, height: height2, clipBBox, opacity = 1 }) {
  return { x, y, width: width2, height: height2, clipBBox, opacity, crisp: rect.datum?.crisp ?? false };
}
function computeBarFocusBounds(series, datum) {
  if (datum === void 0)
    return void 0;
  const { x, y, width: width2, height: height2 } = datum;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, width2, height2));
}

// packages/ag-charts-community/src/chart/series/cartesian/diffUtil.ts
function calculateDataDiff(seriesId, datumSelection, getDatumId, contextNodeData, previousContextNodeData, processedData) {
  let dataDiff = processedData?.reduced?.diff?.[seriesId];
  if (dataDiff?.changed) {
    return dataDiff;
  }
  const scalingChanged = hasScalingChanged(contextNodeData, previousContextNodeData);
  if (dataDiff == null && processedData?.reduced?.diff != null) {
    dataDiff = {
      changed: true,
      added: /* @__PURE__ */ new Set(),
      updated: /* @__PURE__ */ new Set(),
      removed: /* @__PURE__ */ new Set(),
      moved: /* @__PURE__ */ new Set()
    };
    if (scalingChanged) {
      dataDiff.updated = new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum)));
    } else {
      dataDiff.added = new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum)));
    }
  } else if (scalingChanged) {
    dataDiff = {
      changed: true,
      added: /* @__PURE__ */ new Set(),
      updated: new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum))),
      removed: /* @__PURE__ */ new Set(),
      moved: /* @__PURE__ */ new Set()
    };
  }
  return dataDiff;
}
function isGroupScaleContext(ctx) {
  return typeof ctx === "object" && ctx !== null && "groupScale" in ctx;
}
function hasScalingChanged(contextNodeData, previousContextNodeData) {
  if (!previousContextNodeData)
    return false;
  const scales = contextNodeData.scales;
  const prevScales = previousContextNodeData.scales;
  if (!areScalingEqual(scales.x, prevScales.x))
    return true;
  if (!areScalingEqual(scales.y, prevScales.y))
    return true;
  if (!isGroupScaleContext(contextNodeData) || !isGroupScaleContext(previousContextNodeData))
    return false;
  const groupScale = contextNodeData.groupScale;
  const prevGroupScale = previousContextNodeData.groupScale;
  return !areScalingEqual(groupScale, prevGroupScale);
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var memoizedAggregateBarData = simpleMemorize2(aggregateBarData);
var BarSeries = class extends AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pickModes: [
        2 /* AXIS_ALIGNED */,
        // Only used in sparklineMode
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new BarSeriesProperties();
    this.connectsToYAxis = true;
    this.dataAggregationFilters = void 0;
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : void 0;
  }
  crossFilteringEnabled() {
    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);
  }
  async processData(dataController) {
    if (!this.data)
      return;
    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;
    const { seriesGrouping: { groupIndex = this.id } = {}, data } = this;
    const stackCount = this.seriesGrouping?.stackCount ?? 0;
    const stacked = stackCount > 1 || normalizedTo != null;
    const grouped = stacked;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stackGroupName = `bar-stack-${groupIndex}-yValues`;
    const stackGroupTrailingName = `${stackGroupName}-trailing`;
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const props = [
      keyProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps })
    ];
    if (this.crossFilteringEnabled()) {
      props.push(
        valueProperty(yFilterKey, yScaleType, {
          id: `yFilterValue`,
          invalidValue: null,
          ...visibleProps
        })
      );
    }
    if (stacked) {
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          {
            id: `yValue-end`,
            rangeId: `yValue-range`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "trailing",
          "current",
          {
            id: `yValue-start`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupTrailingName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        )
      );
    }
    if (isContinuousX) {
      props.push(SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL);
    }
    if (isFiniteNumber9(normalizedTo)) {
      props.push(normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo)));
    }
    if (animationEnabled && this.processedData) {
      props.push(diff(this.id, this.processedData));
    }
    if (animationEnabled || !grouped) {
      props.push(animationValidation());
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: grouped,
      groupByData: !grouped
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (dataModel == null || processedData == null)
      return [];
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    }
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    let yExtent = this.domainForClippedRange(direction, [yKey], "xValue");
    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, "value", processedData) : void 0;
    if (yFilterExtent != null) {
      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];
    }
    if (this.getValueAxis() instanceof LogAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])] : [];
      return fixNumericExtent(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    const [y0, y1] = this.domainForVisibleRange("y" /* Y */, [yKey], "xValue", visibleRange);
    return [Math.min(y0, 0), Math.max(y1, 0)];
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    return this.countVisibleItems("xValue", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable(processedData))
      return;
    const xAxis = this.axes["x" /* X */];
    if (xAxis == null)
      return;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue-raw`, processedData);
    const { index } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const domain = processedData.domain.keys[index];
    return memoizedAggregateBarData(xAxis.scale.type, xValues, yValues, domain);
  }
  createNodeData() {
    const { dataModel, processedData, groupScale, dataAggregationFilters } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const rawData = processedData.dataSources?.get(this.id);
    if (rawData == null)
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const { xKey, yKey, xName, yName, legendItemName, label } = this.properties;
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const yReversed = yAxis.isReversed();
    const { barWidth, groupIndex: groupScaleIndex } = this.updateGroupScale(xAxis);
    const groupOffset = groupScale.convert(String(groupScaleIndex));
    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yValue-raw`, processedData);
    const yFilterValues = this.crossFilteringEnabled() ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xPosition = (index) => xScale.convert(xValues[index]) + groupOffset + barOffset;
    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);
    const bboxBottom = yScale.convert(0);
    const nodeDatum = ({
      datum,
      datumIndex,
      xValue,
      yValue,
      cumulativeValue,
      phantom,
      currY,
      prevY,
      x,
      width: width2,
      isPositive,
      yRange,
      labelText,
      opacity,
      featherRatio,
      crossScale = 1
    }) => {
      const isUpward = isPositive !== yReversed;
      const y = yScale.convert(currY);
      const bottomY = yScale.convert(prevY);
      const bboxHeight = yScale.convert(yRange);
      const barAlongX = this.getBarDirection() === "x" /* X */;
      const xOffset = width2 * 0.5 * (1 - crossScale);
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : x + xOffset,
        y: barAlongX ? x + xOffset : Math.min(y, bottomY),
        width: barAlongX ? Math.abs(bottomY - y) : width2 * crossScale,
        height: barAlongX ? width2 * crossScale : Math.abs(bottomY - y)
      };
      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);
      const barRect = {
        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : x + xOffset,
        y: barAlongX ? x + xOffset : Math.min(bboxBottom, bboxHeight),
        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : width2 * crossScale,
        height: barAlongX ? width2 * crossScale : Math.abs(bboxBottom - bboxHeight)
      };
      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
      const spacing = label.spacing + (typeof label.padding === "number" ? label.padding : 0);
      return {
        series: this,
        itemId: phantom ? createDatumId(yKey, phantom) : yKey,
        datum,
        datumIndex,
        cumulativeValue,
        phantom,
        xValue,
        yValue,
        yKey,
        xKey,
        capDefaults: {
          lengthRatioMultiplier,
          lengthMax: lengthRatioMultiplier
        },
        x: barRect.x,
        y: barRect.y,
        width: barRect.width,
        height: barRect.height,
        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
        opacity,
        featherRatio,
        topLeftCornerRadius: barAlongX !== isUpward,
        topRightCornerRadius: isUpward,
        bottomRightCornerRadius: barAlongX === isUpward,
        bottomLeftCornerRadius: !isUpward,
        clipBBox,
        crisp,
        label: labelText != null ? {
          text: labelText,
          ...adjustLabelPlacement({
            isUpward,
            isVertical: !barAlongX,
            placement: label.placement,
            spacing,
            rect
          })
        } : void 0,
        missing: yValue == null,
        focusable: !phantom
      };
    };
    const phantomNodes = [];
    const nodes = [];
    const labels = [];
    const handleDatum = (datumIndex, x, width2, yStart, yEnd, yRange, featherRatio = 0, opacity = 1) => {
      const xValue = xValues[datumIndex];
      if (xValue == null)
        return;
      const datum = rawData[datumIndex];
      const yRawValue = yRawValues[datumIndex];
      const yFilterValue = yFilterValues != null ? Number(yFilterValues[datumIndex]) : void 0;
      const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
      if (!Number.isFinite(yEnd))
        return;
      if (yFilterValue != null && !Number.isFinite(yFilterValue))
        return;
      const labelText = label.enabled && yRawValue != null ? this.getLabelText(
        yFilterValue ?? yRawValue,
        datum,
        yKey,
        "y",
        yDomain,
        label,
        { datum, value: yFilterValue ?? yRawValue, xKey, yKey, xName, yName, legendItemName }
      ) : void 0;
      const inset = yFilterValue != null && yFilterValue > yRawValue;
      const nodeData = nodeDatum({
        datum,
        datumIndex,
        xValue,
        yValue: yFilterValue ?? yRawValue,
        cumulativeValue: yFilterValue ?? yEnd,
        phantom: false,
        currY: yFilterValue != null ? yStart + yFilterValue : yEnd,
        prevY: yStart,
        x,
        width: width2,
        isPositive,
        yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),
        labelText,
        opacity,
        featherRatio,
        crossScale: inset ? 0.6 : void 0
      });
      nodes.push(nodeData);
      labels.push(nodeData);
      if (yFilterValue != null) {
        const phantomNodeData = nodeDatum({
          datum: rawData[datumIndex],
          datumIndex,
          xValue,
          yValue: yFilterValue,
          cumulativeValue: yFilterValue,
          phantom: true,
          currY: yEnd,
          prevY: yStart,
          x,
          width: width2,
          isPositive,
          yRange,
          labelText: void 0,
          opacity,
          featherRatio,
          crossScale: void 0
        });
        phantomNodes.push(phantomNodeData);
      }
    };
    const [r0, r1] = xScale.range;
    const range3 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);
    if (processedData.type === "grouped") {
      const width2 = barWidth;
      const stacked = dataModel.hasColumnById(this, `yValue-start`);
      const yStartValues = stacked ? dataModel.resolveColumnById(this, `yValue-start`, processedData) : void 0;
      const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValue-end`, processedData) : void 0;
      const yRangeIndex = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValue-range`) : -1;
      for (const {
        datumIndex,
        group: { aggregation }
      } of dataModel.forEachGroupDatum(this, processedData)) {
        const x = xPosition(datumIndex);
        const yRawValue = yRawValues[datumIndex];
        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
        const yStart = stacked ? Number(yStartValues?.[datumIndex]) : 0;
        const yEnd = stacked ? Number(yEndValues?.[datumIndex]) : yRawValue;
        let yRange = yEnd;
        if (stacked) {
          yRange = aggregation[yRangeIndex][isPositive ? 1 : 0];
        }
        handleDatum(datumIndex, x, width2, yStart, yEnd, yRange);
      }
    } else if (dataAggregationFilter == null) {
      const invalidData = processedData.invalidData?.get(this.id);
      const width2 = barWidth;
      let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range);
      if (processedData.input.count < 1e3) {
        start2 = 0;
        end2 = processedData.input.count;
      }
      for (let datumIndex = start2; datumIndex < end2; datumIndex += 1) {
        if (invalidData?.[datumIndex] === true)
          continue;
        const x = xPosition(datumIndex);
        const yEnd = Number(yRawValues[datumIndex]);
        handleDatum(datumIndex, x, width2, 0, yEnd, yEnd);
      }
    } else {
      const { indexData, indices } = dataAggregationFilter;
      const [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, indices);
      const sign = yReversed ? -1 : 1;
      for (let i = start2; i < end2; i += 1) {
        const aggIndex = i * BAR_SPAN;
        const xMinIndex = indexData[aggIndex + BAR_X_MIN];
        const xMaxIndex = indexData[aggIndex + BAR_X_MAX];
        const yMinIndex = indexData[aggIndex + BAR_Y_MIN];
        const yMaxIndex = indexData[aggIndex + BAR_Y_MAX];
        if (xMinIndex === -1)
          continue;
        const x = xPosition((xMinIndex + xMaxIndex) / 2 | 0);
        const width2 = Math.abs(xPosition(xMaxIndex) - xPosition(xMinIndex)) + barWidth;
        const bandCount = Math.abs(xMaxIndex - xMinIndex);
        const opacity = BandScale.is(xScale) ? xScale.bandwidth * Math.max(bandCount - 1, 1) / (xScale.step * bandCount) : 1;
        const yEndMax = xValues[yMaxIndex] != null ? Number(yRawValues[yMaxIndex]) : NaN;
        const yEndMin = xValues[yMinIndex] != null ? Number(yRawValues[yMinIndex]) : NaN;
        if (yEndMax > 0) {
          const featherRatio = yEndMin >= 0 ? sign * (1 - yEndMin / yEndMax) : sign;
          handleDatum(yMaxIndex, x, width2, 0, yEndMax, yEndMax, featherRatio, opacity);
        }
        if (yEndMin < 0) {
          const featherRatio = yEndMax <= 0 ? -sign * (1 - yEndMax / yEndMin) : -sign;
          handleDatum(yMinIndex, x, width2, 0, yEndMin, yEndMin, featherRatio, opacity);
        }
      }
    }
    return {
      itemId: yKey,
      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,
      labelData: labels,
      scales: this.calculateScaling(),
      visible: this.visible || animationEnabled,
      groupScale: this.getScaling(this.groupScale)
    };
  }
  nodeFactory() {
    return new BarShape();
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItem = nodeData.find(
      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom
    );
    return highlightItem != null ? [highlightItem] : void 0;
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => this.getDatumId(datum));
  }
  getItemStyle(nodeDatum, isHighlight) {
    const { id: seriesId, properties } = this;
    const { xKey, yKey, itemStyler, fillGradientDefaults, fillPatternDefaults, fillImageDefaults } = properties;
    const { xValue, yValue, datum, datumIndex } = nodeDatum;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    let style = getShapeStyle(
      mergeDefaults(highlightStyle, properties.getStyle()),
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    );
    if (itemStyler && nodeDatum != null) {
      const { xDomain, yDomain } = this.cachedDatumCallback("domain", () => ({
        xDomain: this.getSeriesDomain("x" /* X */),
        yDomain: this.getSeriesDomain("y" /* Y */)
      }));
      const overrides = this.cachedDatumCallback(
        createDatumId(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            ...datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain),
            datum,
            xValue,
            yValue,
            highlighted: isHighlight,
            highlightState,
            ...style
          });
        }
      );
      if (overrides) {
        style = getShapeStyle(
          mergeDefaults(overrides, style),
          fillGradientDefaults,
          fillPatternDefaults,
          fillImageDefaults
        );
      }
    }
    return style;
  }
  updateDatumNodes(opts) {
    const { shadow } = this.properties;
    const categoryAlongX = this.getCategoryDirection() === "x" /* X */;
    const fillBBox = this.getShapeFillBBox();
    const direction = this.getBarDirection();
    opts.datumSelection.each((rect, datum) => {
      const style = this.getItemStyle(datum, opts.isHighlight);
      applyShapeStyle(rect, style, fillBBox);
      const cornerRadius = style.cornerRadius ?? 0;
      rect.topLeftCornerRadius = datum.topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = datum.topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = datum.bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = datum.bottomLeftCornerRadius ? cornerRadius : 0;
      rect.visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;
      rect.direction = direction;
      rect.featherRatio = datum.featherRatio;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
    });
  }
  updateLabelSelection(opts) {
    const data = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(data, (text) => {
      text.pointerEvents = 1 /* None */;
    });
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const params = {
      xKey: this.properties.xKey,
      xName: this.properties.xName ?? this.properties.xKey,
      yKey: this.properties.yKey,
      yName: this.properties.yName ?? this.properties.yKey,
      legendItemName: this.properties.legendItemName ?? this.properties.xName ?? this.properties.xKey
    };
    opts.labelSelection.each((textNode, datum) => {
      textNode.fillOpacity = this.getHighlightStyle(isHighlight, datum?.datumIndex).opacity ?? 1;
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
      updateLabelNode(this, textNode, params, this.properties.label, datum.label, isHighlight, highlightState);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { xKey, xName, yKey, yName, legendItemName, stackGroup, tooltip } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    const nodeDatum = this.contextNodeData?.nodeData?.[datumIndex];
    if (!dataModel || !processedData || !xAxis || !yAxis || !nodeDatum) {
      return;
    }
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue-raw`, processedData)[datumIndex];
    if (xValue == null)
      return;
    const format = this.getItemStyle(nodeDatum, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        legendItemName,
        stackGroup,
        ...format,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke2,
      strokeWidth,
      fillOpacity,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    } = this.properties;
    return {
      marker: getShapeStyle(
        {
          fill: fill ?? "rgba(0, 0, 0, 0)",
          stroke: stroke2 ?? "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults,
        fillPatternDefaults,
        fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    const { showInLegend } = this.properties;
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, legendItemName } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: { text: legendItemName ?? yName ?? itemId },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection, labelSelection, annotationSelections, contextData, previousContextData } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const dataDiff = calculateDataDiff(
      this.id,
      datumSelection,
      this.getDatumId.bind(this),
      data.contextData,
      previousContextData,
      this.processedData
    );
    const mode = previousContextData == null ? "fade" : "normal";
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
    fromToMotion(
      this.id,
      "nodes",
      this.ctx.animationManager,
      [datumSelection],
      fns,
      (_, datum) => this.getDatumId(datum),
      dataDiff
    );
    if (dataDiff?.changed || !areScalingEqual(contextData.groupScale, previousContextData?.groupScale)) {
      seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
      seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
  }
  getDatumId(datum) {
    return createDatumId(datum.xValue, datum.phantom);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;
    return computeBarFocusBounds(this, datumBox);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
BarSeries.className = "BarSeries";
BarSeries.type = "bar";

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var BarSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bar",
  moduleFactory: (ctx) => new BarSeries(ctx),
  stackable: true,
  groupable: true,
  defaultAxes: DIRECTION_SWAP_AXES,
  themeTemplate: {
    series: {
      direction: "vertical",
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 1,
      strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        padding: { $isUserOption: ["./spacing", 0, 8] },
        // compatibility with old `padding` property (now named `spacing`).
        enabled: false,
        fontWeight: { $ref: "fontWeight" },
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        color: {
          $if: [
            {
              $or: [
                { $eq: [{ $path: "./placement" }, "outside-start"] },
                { $eq: [{ $path: "./placement" }, "outside-end"] }
              ]
            },
            { $ref: "textColor" },
            { $ref: "chartBackgroundColor" }
          ]
        },
        placement: "inside-center"
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      errorBar: {
        cap: {
          lengthRatio: 0.3
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewBarSeriesModule = {
  type: "series",
  name: "bar",
  chartType: "cartesian",
  options: barSeriesOptionsDef,
  create: (ctx) => new BarSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/bubbleAggregation.ts
import { clamp as clamp20 } from "ag-charts-core";
var SIZE_QUANTIZATION = 3;
var FILTER_DATUM_THRESHOLD = 5;
function getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
  let currentIndex = 0;
  let currentDistanceSquared = Infinity;
  const midX = (x0 + x1) / 2;
  const midY = (y0 + y1) / 2;
  for (const datumIndex of indices) {
    const xValue = xValues[datumIndex];
    const yValue = yValues[datumIndex];
    if (xValue == null || yValue == null)
      continue;
    const xRatio = aggregationXRatioForXValue(xValue, xd0, xd1);
    const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
    const distanceSquared = (xRatio - midX) ** 2 + (yRatio - midY) ** 2;
    if (distanceSquared < currentDistanceSquared) {
      currentDistanceSquared = distanceSquared;
      currentIndex = datumIndex;
    }
  }
  return currentIndex;
}
function countVisibleItems(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
  let count = 0;
  for (const datumIndex of indices) {
    const xValue = xValues[datumIndex];
    const yValue = yValues[datumIndex];
    if (xValue == null || yValue == null)
      continue;
    const xRatio = aggregationXRatioForXValue(xValue, xd0, xd1);
    const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
    if (xRatio >= x0 && xRatio <= x1 && yRatio >= y0 && yRatio <= y1) {
      count += 1;
    }
  }
  return count;
}
function aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
  if (indices.length < FILTER_DATUM_THRESHOLD) {
    return;
  } else if (x0 === x1 && y0 === y1) {
    const primaryDatumIndex2 = getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1);
    return { scale: 0, x0, y0, x1, y1, indices, primaryDatumIndex: primaryDatumIndex2, children: null };
  }
  const childBuckets = [
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] },
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] },
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] },
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] }
  ];
  const midX = (x0 + x1) / 2;
  const midY = (y0 + y1) / 2;
  for (const datumIndex of indices) {
    const xValue = xValues[datumIndex];
    const yValue = yValues[datumIndex];
    if (xValue == null || yValue == null)
      continue;
    const xRatio = aggregationXRatioForXValue(xValue, xd0, xd1);
    const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
    const childIndex = (xRatio > midX ? 1 : 0) + (yRatio > midY ? 2 : 0);
    const childBucket = childBuckets[childIndex];
    childBucket.indices.push(datumIndex);
    childBucket.x0 = Math.min(childBucket.x0, xRatio);
    childBucket.y0 = Math.min(childBucket.y0, yRatio);
    childBucket.x1 = Math.max(childBucket.x1, xRatio);
    childBucket.y1 = Math.max(childBucket.y1, yRatio);
  }
  let children = [];
  for (const childBucket of childBuckets) {
    const { indices: childIndices, x0: cx0, x1: cx1, y0: cy0, y1: cy1 } = childBucket;
    const child = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, childIndices, cx0, cy0, cx1, cy1);
    if (child != null)
      children.push(child);
  }
  if (children.length === 1) {
    return children[0];
  } else if (children.length === 0) {
    children = null;
  }
  const scale2 = Math.hypot(x1 - x0, y1 - y0);
  const primaryDatumIndex = getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1);
  return { scale: scale2, x0, y0, x1, y1, indices, primaryDatumIndex, children };
}
function aggregateBubbleData(xScale, yScale, xValues, yValues, sizeValues, xDomain, yDomain, sizeDomain) {
  const [xd0, xd1] = aggregationDomain(xScale, xDomain);
  const [yd0, yd1] = aggregationDomain(yScale, yDomain);
  const [sd0, sd1] = sizeDomain;
  const filters = [];
  if (sizeValues != null && sd1 > sd0) {
    const sizeIndices = Array.from({ length: SIZE_QUANTIZATION }, () => []);
    for (let datumIndex = 0; datumIndex < sizeValues.length; datumIndex += 1) {
      const sizeValue = sizeValues[datumIndex];
      const sizeRatio = (sizeValue - sd0) / (sd1 - sd0);
      const sizeIndex = sizeRatio * SIZE_QUANTIZATION | 0;
      if (sizeIndex >= 0 && sizeIndex < SIZE_QUANTIZATION) {
        sizeIndices[sizeIndex].push(datumIndex);
      }
    }
    for (let i = 0; i < sizeIndices.length; i += 1) {
      const indices = sizeIndices[i];
      const node = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, 0, 0, 1, 1);
      if (node != null) {
        const sizeRatio = i / SIZE_QUANTIZATION;
        filters.push({ sizeRatio, node });
      }
    }
  } else {
    const indices = xValues.map((_, i) => i);
    const node = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, 0, 0, 1, 1);
    if (node != null) {
      filters.push({ sizeRatio: 0, node });
    }
  }
  return filters.length > 0 ? { xValues, yValues, xd0, xd1, yd0, yd1, filters } : void 0;
}
function computeBubbleAggregationCountIndices(dilation, dataAggregation, options, counter, groupedAggregation, singleDatumIndices) {
  const {
    xRange,
    yRange,
    xVisibleRange: [xvr0, xvr1],
    yVisibleRange: [yvr0, yvr1],
    minSize,
    maxSize
  } = options;
  const { xValues, yValues, xd0, xd1, yd0, yd1 } = dataAggregation;
  const baseScalingFactor = 1 / Math.min(xRange / (xvr1 - xvr0), yRange / (yvr1 - yvr0));
  for (const { sizeRatio, node } of dataAggregation.filters) {
    const radius = 0.5 * (minSize + sizeRatio * (maxSize - minSize));
    const baseMinScale = radius * baseScalingFactor;
    const minScale = dilation * baseMinScale;
    const x0 = xvr0 - radius / xRange;
    const x1 = xvr1 + radius / xRange;
    const y0 = yvr0 - radius / yRange;
    const y1 = yvr1 + radius / yRange;
    const queue = [node];
    while (queue.length > 0) {
      const item = queue.pop();
      if (item.x1 < x0 || item.x0 > x1 || item.y1 < y0 || item.y0 > y1) {
        continue;
      }
      if (item.scale <= minScale) {
        if (counter != null) {
          counter.count += 1;
        }
        groupedAggregation?.push({
          datumIndex: item.primaryDatumIndex,
          count: item.indices.length,
          dilation: clamp20(1, item.scale / baseMinScale, dilation)
        });
      } else if (item.children == null) {
        const { indices } = item;
        if (counter != null) {
          const fullyVisible = item.x0 >= xvr0 && item.x1 <= xvr1 && item.y0 >= yvr0 && item.y1 <= yvr1;
          const itemCount = fullyVisible ? indices.length : countVisibleItems(xValues, yValues, xd0, yd0, xd1, yd1, indices, xvr0, yvr0, xvr1, yvr1);
          counter.count += itemCount;
        }
        singleDatumIndices?.push(...indices);
      } else {
        queue.push(...item.children);
      }
    }
  }
}
function computeBubbleAggregationCount(dilation, dataAggregation, options) {
  const counter = { count: 0 };
  computeBubbleAggregationCountIndices(dilation, dataAggregation, options, counter, void 0, void 0);
  return counter.count;
}
var MAX_AGGREGATION_DILATION = 100;
var DILATION_ITERATIONS = 12;
function computeBubbleAggregationDilation(dataAggregation, aggregationOptions, maxRenderedItems) {
  let minDilation = 1;
  let maxDilation = 2;
  while (computeBubbleAggregationCount(maxDilation, dataAggregation, aggregationOptions) > maxRenderedItems && maxDilation < MAX_AGGREGATION_DILATION) {
    minDilation *= 2;
    maxDilation *= 2;
  }
  for (let i = 0; i < DILATION_ITERATIONS; i += 1) {
    const dilation = (maxDilation + minDilation) / 2;
    const count = computeBubbleAggregationCount(dilation, dataAggregation, aggregationOptions);
    if (count > maxRenderedItems) {
      minDilation = dilation;
    } else {
      maxDilation = dilation;
    }
  }
  return minDilation;
}
function computeBubbleAggregationData(dilation, dataAggregation, options) {
  const groupedAggregation = [];
  const singleDatumIndices = [];
  computeBubbleAggregationCountIndices(
    dilation,
    dataAggregation,
    options,
    void 0,
    groupedAggregation,
    singleDatumIndices
  );
  return { groupedAggregation, singleDatumIndices };
}

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker = class extends SeriesMarker {
  constructor() {
    super(...arguments);
    this.maxSize = 30;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], BubbleSeriesMarker.prototype, "maxSize", 2);
__decorateClass([
  Property,
  SceneArrayChangeDetection()
], BubbleSeriesMarker.prototype, "domain", 2);
var BubbleSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "top";
  }
};
__decorateClass([
  Property
], BubbleSeriesLabel.prototype, "placement", 2);
var BubbleSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.label = new BubbleSeriesLabel();
    this.tooltip = makeSeriesTooltip();
    this.maxRenderedItems = Infinity;
    // No validation. Not a part of the options contract.
    this.marker = new BubbleSeriesMarker();
  }
};
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "title", 2);
__decorateClass([
  ProxyProperty("marker.shape")
], BubbleSeriesProperties.prototype, "shape", 2);
__decorateClass([
  ProxyProperty("marker.size")
], BubbleSeriesProperties.prototype, "size", 2);
__decorateClass([
  ProxyProperty("marker.maxSize")
], BubbleSeriesProperties.prototype, "maxSize", 2);
__decorateClass([
  ProxyProperty("marker.domain")
], BubbleSeriesProperties.prototype, "domain", 2);
__decorateClass([
  ProxyProperty("marker.fillGradientDefaults")
], BubbleSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillPatternDefaults")
], BubbleSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillImageDefaults")
], BubbleSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fill")
], BubbleSeriesProperties.prototype, "fill", 2);
__decorateClass([
  ProxyProperty("marker.fillOpacity")
], BubbleSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  ProxyProperty("marker.stroke")
], BubbleSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  ProxyProperty("marker.strokeWidth")
], BubbleSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  ProxyProperty("marker.strokeOpacity")
], BubbleSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  ProxyProperty("marker.lineDash")
], BubbleSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  ProxyProperty("marker.lineDashOffset")
], BubbleSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  ProxyProperty("marker.itemStyler")
], BubbleSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "maxRenderedItems", 2);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleScatterSeriesNodeEvent = class extends CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.sizeKey = series.properties.sizeKey;
  }
};
var BubbleSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: {
        ...DEFAULT_CARTESIAN_DIRECTION_KEYS,
        label: ["labelKey"],
        size: ["sizeKey"]
      },
      propertyNames: {
        ...DEFAULT_CARTESIAN_DIRECTION_NAMES,
        label: ["labelName"],
        size: ["sizeName"]
      },
      categoryKey: void 0,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        label: resetLabelFn,
        datum: resetMarkerFn
      },
      usesPlacedLabels: true,
      clipFocusBox: false
    });
    this.NodeEvent = BubbleScatterSeriesNodeEvent;
    this.properties = new BubbleSeriesProperties();
    this.dataAggregation = void 0;
    this.sizeScale = new LinearScale();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (this.data == null || !this.visible)
      return;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const sizeScaleType = this.sizeScale.type;
    const { xKey, yKey, sizeKey, xFilterKey, yFilterKey, sizeFilterKey, labelKey, marker } = this.properties;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty(yKey, yScaleType, { id: `yValue` }),
        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],
        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],
        ...sizeKey ? [valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` })] : [],
        ...labelKey ? [valueProperty(labelKey, "category", { id: `labelValue` })] : []
      ]
    });
    this.dataAggregation = this.aggregateData(dataModel, processedData);
    const sizeKeyIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
    const mutableMarkerDomain = marker.domain ? [marker.domain[0], marker.domain[1]] : void 0;
    this.sizeScale.domain = mutableMarkerDomain ?? (sizeKeyIdx == null ? void 0 : processedData.domain.values[sizeKeyIdx]) ?? [];
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize, index) {
    const { properties, sizeScale } = this;
    const { size, sizeKey } = properties;
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;
    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
    const r = 0.5 * sizeValue * pixelSize;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize, index) {
    const { properties, sizeScale } = this;
    const { size, sizeKey } = properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;
    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
    const r = 0.5 * sizeValue * pixelSize;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const dataValues = {
      ["x" /* X */]: "xValue",
      ["y" /* Y */]: "yValue"
    };
    const id = dataValues[direction];
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if (dataDef?.def.type === "value" && dataDef?.def.valueType === "category") {
      return domain;
    }
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossId = dataValues[crossDirection];
    const ext = this.domainForClippedRange(direction, [id], crossId);
    return fixNumericExtent(extent(ext));
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange("y" /* Y */, ["yValue"], "xValue", visibleRange);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const { dataAggregation, axes } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (dataAggregation == null || xAxis == null || yAxis == null) {
      return this.countVisibleItems("xValue", ["yValue"], xVisibleRange, yVisibleRange, minVisibleItems);
    }
    const aggregationOptions = this.aggregationOptions(xAxis, yAxis, xVisibleRange, yVisibleRange ?? [0, 1]);
    return computeBubbleAggregationCount(0, dataAggregation, aggregationOptions);
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type === "grouped")
      return;
    if (processedData.input.count <= this.properties.maxRenderedItems)
      return;
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (xAxis == null || yAxis == null)
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    if (!ContinuousScale.is(xScale) || !ContinuousScale.is(yScale))
      return;
    const { sizeScale, properties } = this;
    const { sizeKey } = properties;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const sizeValues = sizeKey ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const xDomain = dataModel.getDomain(this, `xValue`, "value", processedData);
    const yDomain = dataModel.getDomain(this, `yValue`, "value", processedData);
    const sizeDomain = sizeKey ? sizeScale.domain : [0, 0];
    return aggregateBubbleData(
      xScale.type,
      yScale.type,
      xValues,
      yValues,
      sizeValues,
      xDomain,
      yDomain,
      sizeDomain
    );
  }
  aggregationOptions(xAxis, yAxis, xVisibleRange = xAxis.visibleRange, yVisibleRange = yAxis.visibleRange) {
    const { sizeKey, marker } = this.properties;
    const xRange = Math.abs(xAxis.range[1] - xAxis.range[0]);
    const yRange = Math.abs(yAxis.range[1] - yAxis.range[0]);
    const minSize = marker.size;
    const maxSize = sizeKey ? marker.maxSize : minSize;
    return { xRange, yRange, minSize, maxSize, xVisibleRange, yVisibleRange };
  }
  createNodeData() {
    const { axes, dataModel, processedData, sizeScale, visible } = this;
    const {
      xKey,
      yKey,
      sizeKey,
      xFilterKey,
      yFilterKey,
      sizeFilterKey,
      labelKey,
      xName,
      yName,
      sizeName,
      labelName,
      label,
      marker,
      maxRenderedItems
    } = this.properties;
    const { enabled: labelEnabled, placement } = label;
    const anchor = Marker.anchor(marker.shape);
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!(dataModel && processedData && visible && xAxis && yAxis)) {
      return;
    }
    const xDataValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yDataValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const sizeDataValues = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, `xFilterValue`, processedData) : void 0;
    const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const sizeFilterDataValues = sizeFilterKey != null ? dataModel.resolveColumnById(this, `sizeFilterValue`, processedData) : void 0;
    let labelTextDomain;
    if (labelKey) {
      labelTextDomain = [];
    } else if (sizeKey) {
      labelTextDomain = dataModel.getDomain(this, `sizeValue`, "value", processedData);
    } else {
      labelTextDomain = [];
    }
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    sizeScale.range = [marker.size, marker.maxSize];
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: label });
    const rawData = processedData.dataSources.get(this.id);
    if (rawData == null)
      return;
    const padding2 = expandLabelPadding(label);
    const handleDatum = (datumIndex, count, dilation) => {
      const datum = rawData[datumIndex];
      const xDatum = xDataValues[datumIndex];
      const yDatum = yDataValues[datumIndex];
      const sizeValue = sizeDataValues?.[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      let selected;
      if (xFilterDataValues != null && yFilterDataValues != null) {
        selected = xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum;
        if (sizeFilterDataValues != null) {
          selected && (selected = sizeFilterDataValues[datumIndex] === sizeValue);
        }
      }
      let nodeLabel;
      if (labelEnabled) {
        let labelTextValue;
        let labelTextKey;
        let labelTextProperty;
        if (labelKey && labelDataValues) {
          labelTextValue = labelDataValues[datumIndex];
          labelTextKey = labelKey;
          labelTextProperty = "label";
        } else if (sizeKey) {
          labelTextValue = sizeValue;
          labelTextKey = sizeKey;
          labelTextProperty = "size";
        } else {
          labelTextValue = yDatum;
          labelTextKey = yKey;
          labelTextProperty = "y";
        }
        const labelText = this.getLabelText(
          labelTextValue,
          datum,
          labelTextKey,
          labelTextProperty,
          labelTextDomain,
          label,
          { value: labelTextValue, datum, xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName }
        );
        const size = textMeasurer.measureText(String(labelText));
        size.width += padding2.left + padding2.right;
        size.height += padding2.bottom + padding2.top;
        nodeLabel = { text: labelText, ...size };
      } else {
        nodeLabel = { text: "", width: 0, height: 0 };
      }
      const markerSize = sizeValue != null ? sizeScale.convert(sizeValue) : marker.size;
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        datum,
        datumIndex,
        xValue: xDatum,
        yValue: yDatum,
        sizeValue,
        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },
        point: { x, y, size: Math.sqrt(dilation) * markerSize },
        midPoint: { x, y },
        label: nodeLabel,
        anchor,
        placement,
        count,
        dilation,
        selected
      });
    };
    const { dataAggregation } = this;
    if (dataAggregation == null) {
      for (let datumIndex = 0; datumIndex < rawData.length; datumIndex++) {
        handleDatum(datumIndex, 1, 1);
      }
    } else {
      const aggregationOptions = this.aggregationOptions(xAxis, yAxis);
      const aggregationDilation = computeBubbleAggregationDilation(
        dataAggregation,
        aggregationOptions,
        maxRenderedItems
      );
      const { groupedAggregation, singleDatumIndices } = computeBubbleAggregationData(
        aggregationDilation,
        dataAggregation,
        aggregationOptions
      );
      for (const { datumIndex, count, dilation } of groupedAggregation) {
        handleDatum(datumIndex, count, dilation);
      }
      for (const datumIndex of singleDatumIndices) {
        handleDatum(datumIndex, 1, 1);
      }
    }
    return {
      itemId: yKey,
      nodeData,
      labelData: labelEnabled ? nodeData : [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    if (!this.isLabelEnabled())
      return [];
    return this.contextNodeData?.labelData ?? [];
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const { sizeKey } = this.properties;
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    const data = this.properties.marker.enabled ? nodeData : [];
    let getId;
    if (sizeKey) {
      getId = (datum) => createDatumId([datum.xValue, datum.yValue, datum.sizeValue, datum.label.text]);
    }
    return datumSelection.update(data, void 0, getId);
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    this.sizeScale.range = [marker.size, marker.maxSize];
    const fillBBox = this.getShapeFillBBox();
    const aggregated = this.dataAggregation != null;
    const params = { xKey, yKey, sizeKey, labelKey };
    datumSelection.each((node, datum, index) => {
      const { count, dilation } = datum;
      const style = this.getMarkerStyle(marker, datum, params, isHighlight);
      style.fillOpacity = (1 - (1 - (style.fillOpacity ?? 1)) ** count) / Math.sqrt(dilation);
      this.applyMarkerStyle(style, node, datum.point, fillBBox, { selected: datum.selected });
      node.zIndex = aggregated ? [-count, index] : 0;
    });
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
  }
  updatePlacedLabelData(labelData) {
    this.labelSelection.update(
      labelData.map((v) => ({
        ...v.datum,
        point: {
          x: v.x,
          y: v.y,
          size: v.datum.point.size
        }
      })),
      (text) => {
        text.pointerEvents = 1 /* None */;
      }
    );
    this.updateLabelNodes({ labelSelection: this.labelSelection });
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    opts.labelSelection.each((text, datum) => {
      const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
      const style = getLabelStyles(
        this,
        datum,
        this.properties,
        this.properties.label,
        highlighted,
        highlightState
      );
      text.text = datum.label.text;
      text.fill = style.color;
      text.x = datum.point?.x ?? 0;
      text.y = datum.point?.y ?? 0;
      text.fontStyle = style.fontStyle;
      text.fontWeight = style.fontWeight;
      text.fontSize = style.fontSize;
      text.fontFamily = style.fontFamily;
      text.textAlign = "left";
      text.textBaseline = "top";
      text.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
      text.setBoxing(style);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties, ctx } = this;
    const { formatManager } = ctx;
    const {
      xKey,
      xName,
      yKey,
      yName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      title,
      tooltip,
      marker,
      legendItemName
    } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    const nodeDatum = this.contextNodeData?.nodeData[datumIndex];
    if (xValue == null || nodeDatum == null)
      return;
    const data = [];
    if (this.isLabelEnabled() && labelKey != null) {
      const value = dataModel.resolveColumnById(this, `labelValue`, processedData)[datumIndex];
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value,
        datum,
        seriesId,
        legendItemName,
        key: labelKey,
        source: "tooltip",
        property: "label",
        domain: [],
        boundSeries: this.getFormatterContext("label")
      });
      data.push({ label: labelName, fallbackLabel: labelKey, value: content ?? formatValue(value) });
    }
    data.push(
      {
        label: xName,
        fallbackLabel: xKey,
        value: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName)
      },
      {
        label: yName,
        fallbackLabel: yKey,
        value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
      }
    );
    if (sizeKey != null) {
      const value = dataModel.resolveColumnById(this, `sizeValue`, processedData)[datumIndex];
      const domain = dataModel.getDomain(this, `sizeValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value,
        datum,
        seriesId,
        legendItemName,
        key: sizeKey,
        source: "tooltip",
        property: "size",
        boundSeries: this.getFormatterContext("size"),
        domain,
        fractionDigits: void 0
      });
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: content ?? formatValue(value) });
    }
    const activeStyle = this.getMarkerStyle(
      marker,
      { datum, datumIndex },
      { xKey, yKey, sizeKey, labelKey, highlighted: true },
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yKey,
        xKey,
        xName,
        yKey,
        yName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const marker = this.getMarkerStyle(this.properties.marker, {}, void 0, false, void 0, void 0, false);
    return {
      marker
    };
  }
  getLegendData() {
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, title } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol()
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    markerScaleInAnimation(this, this.ctx.animationManager, datumSelection);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Marker();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    return this.getMarkerStyle(marker, datum, { xKey, yKey, sizeKey, labelKey }, false);
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
  hasItemStylers() {
    const { itemStyler, marker, label } = this.properties;
    return !!(itemStyler ?? marker.itemStyler ?? label.itemStyler);
  }
};
BubbleSeries.className = "BubbleSeries";
BubbleSeries.type = "bubble";

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesOptionsDef.ts
import {
  arrayOf as arrayOf3,
  boolean as boolean8,
  constant as constant5,
  multiSeriesHighlightOptionsDef as multiSeriesHighlightOptionsDef4,
  number as number7,
  positiveNumber as positiveNumber5,
  required as required6,
  shapeHighlightOptionsDef as shapeHighlightOptionsDef4,
  string as string8,
  union as union6
} from "ag-charts-core";
var bubbleSeriesThemeableOptionsDef = {
  title: string8,
  domain: arrayOf3(number7),
  maxSize: positiveNumber5,
  showInMiniChart: boolean8,
  label: {
    placement: union6("top", "right", "bottom", "left"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  maxRenderedItems: number7,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"]),
  highlight: multiSeriesHighlightOptionsDef4(shapeHighlightOptionsDef4, shapeHighlightOptionsDef4)
};
var bubbleSeriesOptionsDef = {
  ...bubbleSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required6(constant5("bubble")),
  xKey: required6(string8),
  yKey: required6(string8),
  sizeKey: required6(string8),
  labelKey: string8,
  xName: string8,
  yName: string8,
  sizeName: string8,
  labelName: string8,
  highlight: multiSeriesHighlightOptionsDef4(shapeHighlightOptionsDef4, shapeHighlightOptionsDef4)
};

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bubble",
  moduleFactory: (ctx) => new BubbleSeries(ctx),
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      maxSize: 30,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      maxRenderedItems: 1e4,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewBubbleSeriesModule = {
  type: "series",
  name: "bubble",
  chartType: "cartesian",
  options: bubbleSeriesOptionsDef,
  create: (ctx) => new BubbleSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
import { isDate as isDate3, isNumber } from "ag-charts-core";

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.areaPlot = false;
    this.aggregation = "sum";
    this.shadow = new DropShadow();
    this.label = new Label();
    this.tooltip = makeSeriesTooltip();
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "areaPlot", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "bins", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "aggregation", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "binCount", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount = 10;
var HistogramSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: void 0,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      datumSelectionGarbageCollection: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new HistogramSeriesProperties();
    this.calculatedBins = [];
  }
  // During processData phase, used to unify different ways of the user specifying
  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
  deriveBins(xDomain) {
    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount).ticks;
    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
    const [firstBinEnd] = binStarts;
    const expandStartToBin = (n) => [n, n + binSize];
    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
  }
  calculateNiceBins(domain, binCount) {
    const startGuess = Math.floor(domain[0]);
    const stop = domain[1];
    const segments = binCount || 1;
    const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);
    return this.getBins(start2, stop, binSize, segments);
  }
  getBins(start2, stop, step, count) {
    const bins = [];
    const precision = this.calculatePrecision(step);
    for (let i = 0; i < count; i++) {
      const a = Math.round((start2 + i * step) * precision) / precision;
      let b = Math.round((start2 + (i + 1) * step) * precision) / precision;
      if (i === count - 1) {
        b = Math.max(b, stop);
      }
      bins[i] = [a, b];
    }
    return bins;
  }
  calculatePrecision(step) {
    let precision = 10;
    if (isFinite(step) && step > 0) {
      while (step < 1) {
        precision *= 10;
        step *= 10;
      }
    }
    return precision;
  }
  calculateNiceStart(a, b, segments) {
    const binSize = Math.abs(b - a) / segments;
    const order = Math.floor(Math.log10(binSize));
    const magnitude = Math.pow(10, order);
    const start2 = Math.floor(a / magnitude) * magnitude;
    return {
      start: start2,
      binSize
    };
  }
  async processData(dataController) {
    if (!this.visible) {
      this.processedData = void 0;
      this.animationState.transition("updateData");
    }
    const { xKey, yKey, areaPlot, aggregation } = this.properties;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });
    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];
    if (yKey) {
      let aggProp = groupCount("groupAgg");
      if (aggregation === "count") {
      } else if (aggregation === "sum") {
        aggProp = groupSum("groupAgg");
      } else if (aggregation === "mean") {
        aggProp = groupAverage("groupAgg");
      }
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);
    } else {
      props.push(rowCountProperty("count"));
      let aggProp = groupCount("groupAgg");
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(aggProp);
    }
    const groupByFn = (dataSet) => {
      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
      if (xExtent.length === 0) {
        dataSet.domain.groups = [];
        return () => [];
      }
      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);
      const binCount = bins.length;
      this.calculatedBins = [...bins];
      return (keys) => {
        let xValue = keys[0];
        if (isDate3(xValue)) {
          xValue = xValue.getTime();
        }
        if (!isNumber(xValue))
          return [];
        for (let i = 0; i < binCount; i++) {
          const nextBin = bins[i];
          if (xValue >= nextBin[0] && xValue < nextBin[1]) {
            return nextBin;
          }
          if (i === binCount - 1 && xValue <= nextBin[1]) {
            return nextBin;
          }
        }
        return [];
      };
    };
    if (!this.ctx.animationManager.isSkipped() && this.processedData) {
      props.push(diff(this.id, this.processedData, false));
    }
    await this.requestDataModel(dataController, this.data, {
      props,
      groupByFn
    });
    this.animationState.transition("updateData");
  }
  xCoordinateRange() {
    return [NaN, NaN];
  }
  yCoordinateRange() {
    return [NaN, NaN];
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.calculatedBins.length)
      return [];
    const yDomain = dataModel.getDomain(this, `groupAgg`, "aggregate", processedData);
    const xDomainMin = this.calculatedBins?.[0][0];
    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];
    if (direction === "x" /* X */) {
      return fixNumericExtent([xDomainMin, xDomainMax]);
    }
    return fixNumericExtent(yDomain);
  }
  getSeriesRange(_direction, [r0, r1]) {
    const { dataModel, processedData } = this;
    if (!dataModel || processedData?.type !== "grouped")
      return [NaN, NaN];
    const xScale = this.axes["x" /* X */].scale;
    const yMin = 0;
    let yMax = -Infinity;
    processedData.groups.forEach(({ keys, aggregation }) => {
      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
      const [xDomainMin, xDomainMax] = keys;
      const [x0, x1] = findMinMax([xScale.convert(xDomainMin), xScale.convert(xDomainMax)]);
      if (x1 >= r0 && x0 <= r1) {
        const total = negativeAgg + positiveAgg;
        yMax = Math.max(yMax, total);
      }
    });
    if (yMin > yMax)
      return [NaN, NaN];
    return [yMin, yMax];
  }
  frequency(group) {
    return group.datumIndices.reduce((acc, datumIndices) => acc + datumIndices.length, 0);
  }
  createNodeData() {
    const { axes, processedData, dataModel } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !dataModel) {
      return;
    }
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const { xKey, yKey, xName, yName, label } = this.properties;
    const nodeData = [];
    const context = {
      itemId: this.properties.yKey ?? this.id,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      animationValid: true,
      visible: this.visible
    };
    if (!this.visible || processedData == null || processedData.type !== "grouped") {
      return context;
    }
    processedData.groups.forEach((group, groupIndex) => {
      const { keys, aggregation } = group;
      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
      const frequency = this.frequency(group);
      const domain = keys;
      const [xDomainMin, xDomainMax] = domain;
      const datum = [...dataModel.forEachDatum(this, processedData, group)];
      const xMinPx = xScale.convert(xDomainMin);
      const xMaxPx = xScale.convert(xDomainMax);
      const total = negativeAgg + positiveAgg;
      const yZeroPx = yScale.convert(0);
      const yMaxPx = yScale.convert(total);
      const w = Math.abs(xMaxPx - xMinPx);
      const h = Math.abs(yMaxPx - yZeroPx);
      const x = Math.min(xMinPx, xMaxPx);
      const y = Math.min(yZeroPx, yMaxPx);
      let selectionDatumLabel = void 0;
      if (label.enabled && total !== 0) {
        selectionDatumLabel = {
          x: x + w / 2,
          y: y + h / 2,
          text: this.getLabelText(
            total,
            datum,
            yKey,
            "y",
            [],
            label,
            { value: total, datum, xKey, yKey, xName, yName }
          )
        };
      }
      const nodeMidPoint = {
        x: x + w / 2,
        y: y + h / 2
      };
      const yAxisReversed = yAxis.isReversed();
      nodeData.push({
        series: this,
        datumIndex: groupIndex,
        datum,
        // required by SeriesNodeDatum, but might not make sense here
        // since each selection is an aggregation of multiple data.
        aggregatedValue: total,
        frequency,
        domain,
        yKey,
        xKey,
        x,
        y,
        xValue: xMinPx,
        yValue: yMaxPx,
        width: w,
        height: h,
        midPoint: nodeMidPoint,
        topLeftCornerRadius: !yAxisReversed,
        topRightCornerRadius: !yAxisReversed,
        bottomRightCornerRadius: yAxisReversed,
        bottomLeftCornerRadius: yAxisReversed,
        label: selectionDatumLabel,
        crisp: true
      });
    });
    nodeData.sort((a, b) => a.x - b.x);
    return context;
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    return datumSelection.update(nodeData, void 0, (datum) => datum.domain.join("_"));
  }
  getItemStyle(isHighlight, datum) {
    const { properties } = this;
    const highlightStyle = this.getHighlightStyle(isHighlight, datum?.datumIndex);
    return getShapeStyle(
      mergeDefaults(highlightStyle, properties.getStyle()),
      properties.fillGradientDefaults,
      properties.fillPatternDefaults,
      properties.fillImageDefaults
    );
  }
  updateDatumNodes(opts) {
    const { isHighlight } = opts;
    const { shadow } = this.properties;
    const fillBBox = this.getShapeFillBBox();
    opts.datumSelection.each((rect, datum) => {
      const style = this.getItemStyle(isHighlight, datum);
      const { cornerRadius = 0 } = style;
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius } = datum;
      applyShapeStyle(rect, style, fillBBox);
      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
      rect.visible = datum.height > 0;
    });
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData, (text) => {
      text.pointerEvents = 1 /* None */;
      text.textAlign = "center";
      text.textBaseline = "middle";
    });
  }
  updateLabelNodes(opts) {
    const labelEnabled = this.isLabelEnabled();
    opts.labelSelection.each((text, datum) => {
      const style = getLabelStyles(this, datum, this.properties, this.properties.label);
      const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = style;
      if (enabled && labelEnabled && datum?.label) {
        text.text = datum.label.text;
        text.x = datum.label.x;
        text.y = datum.label.y;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontFamily = fontFamily;
        text.fontSize = fontSize;
        text.fill = color7;
        text.visible = true;
        text.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
        text.setBoxing(style);
      } else {
        text.visible = false;
      }
    });
  }
  initQuadTree(quadtree) {
    const { value: childNode } = this.contentGroup.children().next();
    if (childNode instanceof Group) {
      addHitTestersToQuadtree(quadtree, childNode.children());
    }
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      axes,
      properties,
      ctx: { localeManager }
    } = this;
    const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || processedData?.type !== "grouped" || !xAxis || !yAxis) {
      return;
    }
    const group = processedData.groups[datumIndex];
    const { aggregation, keys } = group;
    const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
    const frequency = this.frequency(group);
    const domain = keys;
    const [rangeMin, rangeMax] = domain;
    const aggregatedValue = negativeAgg + positiveAgg;
    const datum = {
      data: [...dataModel.forEachDatum(this, processedData, group)],
      aggregatedValue,
      frequency,
      domain
    };
    const data = [
      {
        label: xName,
        fallbackLabel: xKey,
        value: `${this.getAxisValueText(xAxis, "tooltip", rangeMin, datum, xKey, legendItemName)} - ${this.getAxisValueText(xAxis, "tooltip", rangeMax, datum, xKey, legendItemName)}`
      },
      {
        label: localeManager.t("seriesHistogramTooltipFrequency"),
        value: this.getAxisValueText(yAxis, "tooltip", frequency, datum, yKey, legendItemName)
      }
    ];
    if (yKey != null) {
      let label;
      switch (properties.aggregation) {
        case "sum":
          label = localeManager.t("seriesHistogramTooltipSum", { yName: yName ?? yKey });
          break;
        case "mean":
          label = localeManager.t("seriesHistogramTooltipMean", { yName: yName ?? yKey });
          break;
        case "count":
          label = localeManager.t("seriesHistogramTooltipCount", { yName: yName ?? yKey });
          break;
      }
      data.push({
        label,
        value: this.getAxisValueText(yAxis, "tooltip", aggregatedValue, datum, yKey, legendItemName)
      });
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        // HistogramSeries is an outlier since it's callbacks don't use TDatum.
        xName,
        yKey,
        // HistogramSeries is an outlier since it's callbacks don't use TDatum.
        yName,
        xRange: [rangeMin, rangeMax],
        frequency,
        ...this.getItemStyle(false)
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    } = this.properties;
    return {
      marker: getShapeStyle(
        {
          fill: fill ?? "rgba(0, 0, 0, 0)",
          stroke: stroke2 ?? "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults,
        fillPatternDefaults,
        fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { xKey: itemId, yName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: yName ?? itemId ?? "Frequency"
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetDatumAnimation(data);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds(this, this.contextNodeData?.nodeData[datumIndex]);
  }
  hasItemStylers() {
    return this.properties.label.itemStyler != null;
  }
};
HistogramSeries.className = "HistogramSeries";
HistogramSeries.type = "histogram";

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesOptionsDef.ts
import {
  arrayOf as arrayOf4,
  boolean as boolean9,
  constant as constant6,
  fillOptionsDef as fillOptionsDef5,
  lineDashOptionsDef as lineDashOptionsDef7,
  multiSeriesHighlightOptionsDef as multiSeriesHighlightOptionsDef5,
  number as number8,
  positiveNumber as positiveNumber6,
  required as required7,
  shapeHighlightOptionsDef as shapeHighlightOptionsDef5,
  string as string9,
  strokeOptionsDef as strokeOptionsDef7,
  union as union7
} from "ag-charts-core";
var histogramSeriesThemeableOptionsDef = {
  showInMiniChart: boolean9,
  cornerRadius: positiveNumber6,
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef5,
  ...strokeOptionsDef7,
  ...lineDashOptionsDef7,
  highlight: multiSeriesHighlightOptionsDef5(shapeHighlightOptionsDef5, shapeHighlightOptionsDef5)
};
var histogramSeriesOptionsDef = {
  ...commonSeriesOptionsDefs,
  ...histogramSeriesThemeableOptionsDef,
  type: required7(constant6("histogram")),
  xKey: required7(string9),
  yKey: string9,
  xName: string9,
  yName: string9,
  areaPlot: boolean9,
  aggregation: union7("count", "sum", "mean"),
  bins: arrayOf4(arrayOf4(number8)),
  binCount: positiveNumber6
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "histogram",
  moduleFactory: (ctx) => new HistogramSeries(ctx),
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      strokeWidth: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "chartBackgroundColor" }
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewHistogramSeriesModule = {
  type: "series",
  name: "histogram",
  chartType: "cartesian",
  enterprise: true,
  options: histogramSeriesOptionsDef,
  create: (ctx) => new HistogramSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
import { isDefined as isDefined2 } from "ag-charts-core";

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = makeSeriesTooltip();
    this.connectMissingData = false;
    this.sparklineMode = false;
  }
};
__decorateClass([
  Property
], LineSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "connectMissingData", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "sparklineMode", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;
var memoizedAggregateLineData2 = simpleMemorize2(aggregateLineData);
var LineSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        datum: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new LineSeriesProperties();
    this.dataAggregationFilters = void 0;
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : "main-category";
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 0 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stacked = stackCount > 1 || normalizedTo != null;
    const common = { invalidValue: null };
    if (connectMissingData && stacked) {
      common.invalidValue = 0;
    }
    if (stacked && !visible) {
      common.forceValue = 0;
    }
    const props = [];
    if (!isContinuousX || stacked) {
      props.push(keyProperty(xKey, xScaleType, { id: "xKey" }));
    }
    props.push(
      valueProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, {
        id: `yValueRaw`,
        ...common,
        invalidValue: void 0
      })
    );
    if (yFilterKey != null) {
      props.push(valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" }));
    }
    if (stacked) {
      const ids = [
        `line-stack-${groupIndex}-yValues`,
        `line-stack-${groupIndex}-yValues-trailing`,
        `line-stack-${groupIndex}-yValues-marker`
      ];
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: ids[0] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "window-trailing",
          "current",
          { id: `yValueStart`, ...common, groupId: ids[1] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: ids[2] },
          yScaleType
        )
      );
      if (isDefined2(normalizedTo)) {
        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo));
      }
    }
    if (animationEnabled) {
      props.push(animationValidation(isContinuousX ? ["xValue"] : void 0));
      if (this.processedData) {
        props.push(diff(this.id, this.processedData));
      }
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: stacked,
      groupByData: !stacked
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize) {
    const { marker } = this.properties;
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const { marker } = this.properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === "x" /* X */) {
      const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
      if (xDef?.def.type === "value" && xDef.def.valueType === "category") {
        return domain;
      }
      return fixNumericExtent(extent(domain));
    }
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    const yExtent = this.domainForClippedRange("y" /* Y */, [yKey], "xValue");
    return fixNumericExtent(yExtent);
  }
  getSeriesRange(_direction, visibleRange) {
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    return this.domainForVisibleRange("y" /* Y */, [yKey], "xValue", visibleRange);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    return this.countVisibleItems("xValue", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable(processedData))
      return;
    const xAxis = this.axes["x" /* X */];
    if (xAxis == null)
      return;
    const { scale: scale2 } = xAxis;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
    return memoizedAggregateLineData2(scale2.type, xValues, yValues, domain);
  }
  createNodeData() {
    const { dataModel, processedData, axes, dataAggregationFilters } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const {
      xKey,
      yKey,
      yFilterKey,
      xName,
      yName,
      marker,
      label,
      connectMissingData,
      interpolation,
      legendItemName
    } = this.properties;
    const stacked = this.dataModel?.hasColumnById(this, `yValueEnd`);
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const size = marker.enabled ? marker.size : 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValueEnd`, processedData) : void 0;
    const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, `yValueCumulative`, processedData) : yValues;
    const selectionValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterRaw`, processedData) : void 0;
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const capDefaults = {
      lengthRatioMultiplier: this.properties.marker.getDiameter(),
      lengthMax: Infinity
    };
    const nodeData = [];
    const spanPoints = [];
    const handleDatum = (datumIndex) => {
      const datum = rawData[datumIndex];
      const xDatum = xValues[datumIndex];
      const yDatum = yValues[datumIndex];
      const yEndDatum = yEndValues?.[datumIndex];
      const selected = selectionValues?.[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yCumulativeValues[datumIndex]) + yOffset;
      if (!Number.isFinite(x))
        return;
      if (yDatum != null) {
        const labelText = label.enabled ? this.getLabelText(yDatum, datum, yKey, "y", yDomain, label, {
          value: yDatum,
          datum,
          xKey,
          yKey,
          xName,
          yName,
          legendItemName
        }) : void 0;
        nodeData.push({
          series: this,
          datum,
          datumIndex,
          yKey,
          xKey,
          point: { x, y, size },
          midPoint: { x, y },
          cumulativeValue: yEndDatum,
          yValue: yDatum,
          xValue: xDatum,
          capDefaults,
          labelText,
          selected
        });
      }
      const currentSpanPoints = spanPoints[spanPoints.length - 1];
      if (yDatum != null) {
        const spanPoint = {
          point: { x, y },
          xDatum,
          yDatum
        };
        if (Array.isArray(currentSpanPoints)) {
          currentSpanPoints.push(spanPoint);
        } else if (currentSpanPoints != null) {
          currentSpanPoints.skip += 1;
          spanPoints.push([spanPoint]);
        } else {
          spanPoints.push([spanPoint]);
        }
      } else if (!connectMissingData) {
        if (Array.isArray(currentSpanPoints) || currentSpanPoints == null) {
          spanPoints.push({ skip: 0 });
        } else {
          currentSpanPoints.skip += 1;
        }
      }
    };
    const [r0, r1] = xScale.range;
    const range3 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);
    const indices = dataAggregationFilter?.indices;
    let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, indices);
    start2 = Math.max(start2 - 1, 0);
    end2 = Math.min(end2 + 1, indices?.length ?? xValues.length);
    if (processedData.input.count < 1e3) {
      start2 = 0;
      end2 = processedData.input.count;
    }
    for (let i = start2; i < end2; i += 1) {
      handleDatum(indices?.[i] ?? i);
    }
    const strokeSpans = spanPoints.flatMap((p) => {
      return Array.isArray(p) ? interpolatePoints(p, interpolation) : [];
    });
    const strokeData = { itemId: yKey, spans: strokeSpans };
    const crossFiltering = selectionValues?.some((selectionValue, index) => selectionValue === yValues[index]) ?? false;
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      strokeData,
      scales: this.calculateScaling(),
      visible: this.visible,
      crossFiltering
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const {
      paths: [lineNode],
      visible,
      animationEnabled
    } = opts;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    const { strokeWidth, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset, opacity } = mergeDefaults(
      this.getHighlightStyle(),
      this.properties
    );
    lineNode.setProperties({
      fill: void 0,
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      opacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity: strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),
      lineDash,
      lineDashOffset
    });
    if (!animationEnabled) {
      lineNode.visible = visible;
    }
    updateClipPath(this, lineNode);
  }
  updateDatumSelection(opts) {
    let { nodeData } = opts;
    const { datumSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    nodeData = markersEnabled ? nodeData : [];
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    return datumSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yKey, marker, stroke: stroke2, strokeWidth, strokeOpacity } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const applyTranslation = this.ctx.animationManager.isSkipped();
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((node, datum) => {
      const { xValue, yValue } = datum;
      const params = datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain);
      const style = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
        stroke: stroke2,
        strokeWidth,
        strokeOpacity
      });
      this.applyMarkerStyle(style, node, datum.point, fillBBox, {
        applyTranslation,
        selected: datum.selected
      });
    });
    if (!isHighlight) {
      marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    opts.labelSelection.each((text, datum) => {
      const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
      const style = getLabelStyles(
        this,
        datum,
        this.properties,
        this.properties.label,
        highlighted,
        highlightState
      );
      const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = style;
      if (enabled && datum?.labelText) {
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.textAlign = "center";
        text.textBaseline = "bottom";
        text.text = datum.labelText;
        text.x = datum.point.x;
        text.y = datum.point.y - 10;
        text.fill = color7;
        text.visible = true;
        text.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
        text.setBoxing(style);
      } else {
        text.visible = false;
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];
    if (xValue == null)
      return;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const params = datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain);
    const format = this.getMarkerStyle(
      this.properties.marker,
      { datumIndex, datum },
      params,
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        ...format,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const color0 = "rgba(0, 0, 0, 0)";
    const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, marker } = this.properties;
    const markerStyle = this.getMarkerStyle(
      marker,
      {},
      void 0,
      false,
      {
        size: marker.size,
        fill: marker.fill ?? color0,
        stroke: marker.stroke ?? stroke2 ?? color0
      },
      void 0,
      false
    );
    return {
      marker: {
        ...markerStyle,
        enabled: marker.enabled
      },
      line: {
        stroke: stroke2 ?? color0,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, title, legendItemName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        legendItemName,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: legendItemName ?? title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  updatePaths(opts) {
    this.updateLinePaths(opts.paths, opts.contextData);
  }
  updateLinePaths(paths, contextData) {
    const spans = contextData.strokeData.spans;
    const [lineNode] = paths;
    lineNode.path.clear();
    plotLinePathStroke(lineNode, spans);
    lineNode.markDirty("LineSeries");
  }
  animateEmptyUpdateReady(animationData) {
    const { datumSelection, labelSelection, annotationSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateLinePaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([datumSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, datumSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateLinePaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const {
      datumSelection,
      labelSelection: labelSelections,
      annotationSelections,
      contextData,
      paths,
      previousContextData
    } = animationData;
    const [path] = paths;
    if (contextData.visible === false && previousContextData?.visible === false)
      return;
    this.resetDatumAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateLinePaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", datumSelection);
      pathFadeInAnimation(this, "path_properties", animationManager, "add", path);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareLinePathAnimation(
      contextData,
      previousContextData,
      this.processedData?.reduced?.diff?.[this.id]
    );
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    fromToMotion(this.id, "path_properties", animationManager, [path], fns.stroke.pathProperties);
    if (fns.status === "added") {
      this.updateLinePaths(paths, contextData);
    } else if (fns.status === "removed") {
      this.updateLinePaths(paths, previousContextData);
    } else {
      pathMotion(this.id, "path_update", animationManager, [path], fns.stroke.path);
    }
    if (fns.hasMotion) {
      markerFadeInAnimation(this, animationManager, void 0, datumSelection);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0.1 };
  }
  nodeFactory() {
    return new Marker();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey } = this.properties;
    const { xValue, yValue } = datum;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    return this.getMarkerStyle(
      this.properties.marker,
      datum,
      datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain),
      true
    );
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
LineSeries.className = "LineSeries";
LineSeries.type = "line";

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "line",
  moduleFactory: (ctx) => new LineSeries(ctx),
  stackable: true,
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      stroke: SAFE_STROKE_FILL_OPERATION,
      strokeWidth: 2,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      interpolation: {
        type: "linear"
      },
      marker: {
        shape: "circle",
        size: 7,
        strokeWidth: { $isUserOption: ["./stroke", 1, 0] },
        fill: { $palette: "fill" },
        stroke: { $palette: "stroke" },
        // @ts-expect-error undocumented option
        fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
        fillPatternDefaults: FILL_PATTERN_DEFAULTS,
        fillImageDefaults: FILL_IMAGE_DEFAULTS
      },
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewLineSeriesModule = {
  type: "series",
  name: "line",
  chartType: "cartesian",
  options: lineSeriesOptionsDef,
  create: (ctx) => new LineSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var ScatterSeries = class extends BubbleSeries {
};
ScatterSeries.className = "ScatterSeries";
ScatterSeries.type = "scatter";

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesOptionsDef.ts
import {
  boolean as boolean10,
  constant as constant7,
  multiSeriesHighlightOptionsDef as multiSeriesHighlightOptionsDef6,
  number as number9,
  required as required8,
  shapeHighlightOptionsDef as shapeHighlightOptionsDef6,
  string as string10,
  union as union8
} from "ag-charts-core";
var scatterSeriesThemeableOptionsDef = {
  title: string10,
  showInMiniChart: boolean10,
  label: {
    placement: union8("top", "right", "bottom", "left"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  errorBar: errorBarThemeableOptionsDefs,
  maxRenderedItems: number9,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"]),
  highlight: multiSeriesHighlightOptionsDef6(shapeHighlightOptionsDef6, shapeHighlightOptionsDef6)
};
var scatterSeriesOptionsDef = {
  ...scatterSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required8(constant7("scatter")),
  xKey: required8(string10),
  yKey: required8(string10),
  labelKey: string10,
  xName: string10,
  yName: string10,
  labelName: string10,
  errorBar: errorBarOptionsDefs,
  highlight: multiSeriesHighlightOptionsDef6(shapeHighlightOptionsDef6, shapeHighlightOptionsDef6)
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "scatter",
  moduleFactory: (ctx) => new ScatterSeries(ctx),
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      maxRenderedItems: 1e4,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewScatterSeriesModule = {
  type: "series",
  name: "scatter",
  chartType: "cartesian",
  options: scatterSeriesOptionsDef,
  create: (ctx) => new ScatterSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
import { Logger as Logger37, modulus } from "ag-charts-core";

// packages/ag-charts-community/src/scene/sectorBox.ts
var SectorBox = class _SectorBox {
  constructor(startAngle, endAngle, innerRadius, outerRadius) {
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.innerRadius = innerRadius;
    this.outerRadius = outerRadius;
  }
  clone() {
    const { startAngle, endAngle, innerRadius, outerRadius } = this;
    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);
  }
  equals(other) {
    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;
  }
  [interpolate](other, d) {
    return new _SectorBox(
      this.startAngle * (1 - d) + other.startAngle * d,
      this.endAngle * (1 - d) + other.endAngle * d,
      this.innerRadius * (1 - d) + other.innerRadius * d,
      this.outerRadius * (1 - d) + other.outerRadius * d
    );
  }
};

// packages/ag-charts-community/src/scene/util/sector.ts
function sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {
  let x0 = Infinity;
  let y0 = Infinity;
  let x1 = -Infinity;
  let y1 = -Infinity;
  const addPoint = (x, y) => {
    x0 = Math.min(x, x0);
    y0 = Math.min(y, y0);
    x1 = Math.max(x, x1);
    y1 = Math.max(y, y1);
  };
  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));
  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));
  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));
  if (isBetweenAngles(0, startAngle, endAngle)) {
    addPoint(outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {
    addPoint(0, outerRadius);
  }
  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {
    addPoint(-outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {
    addPoint(0, -outerRadius);
  }
  return new BBox(x0, y0, x1 - x0, y1 - y0);
}
function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const { innerRadius, outerRadius } = sector;
  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  const startAngle = normalizeAngle180(sector.startAngle);
  const endAngle = normalizeAngle180(sector.endAngle);
  const angle = Math.atan2(y, x);
  return startAngle < endAngle ? angle <= endAngle && angle >= startAngle : angle <= endAngle && angle >= -Math.PI || angle >= startAngle && angle <= Math.PI;
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  if (isNaN(cx) || isNaN(cy)) {
    return 0;
  }
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return 0;
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  let intersections = 0;
  [i1x, i2x].forEach((x) => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x + y0;
    const adjacent = x - cx;
    const opposite = y - cy;
    const angle = Math.atan2(opposite, adjacent);
    if (isBetweenAngles(angle, startAngle, endAngle)) {
      intersections++;
    }
  });
  return intersections;
}
function lineCollidesSector(line, sector) {
  const { startAngle, endAngle, innerRadius, outerRadius } = sector;
  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };
  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };
  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };
  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };
  return segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerStart.x,
    outerStart.y,
    innerStart.x,
    innerStart.y
  ) || segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerEnd.x,
    outerEnd.y,
    innerEnd.x,
    innerEnd.y
  ) || arcIntersections(
    0,
    0,
    outerRadius,
    startAngle,
    endAngle,
    true,
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y
  );
}
function boxCollidesSector(box, sector) {
  const topLeft = { x: box.x, y: box.y };
  const topRight = { x: box.x + box.width, y: box.y };
  const bottomLeft = { x: box.x, y: box.y + box.height };
  const bottomRight = { x: box.x + box.width, y: box.y + box.height };
  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);
}
function radiiScalingFactor(r, sweep, a, b) {
  if (a === 0 && b === 0)
    return 0;
  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;
  if (fs1 < 0)
    return 1;
  let start2 = 0;
  let end2 = 1;
  for (let i = 0; i < 8; i += 1) {
    const s = (start2 + end2) / 2;
    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;
    if (fs < 0) {
      start2 = s;
    } else {
      end2 = s;
    }
  }
  return start2;
}
var delta2 = 1e-6;
function clockwiseAngle(angle, relativeToStartAngle) {
  if (angleBetween(angle, relativeToStartAngle) < delta2) {
    return relativeToStartAngle;
  } else {
    return normalizeAngle360(angle - relativeToStartAngle) + relativeToStartAngle;
  }
}
function clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {
  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;
  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);
  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);
  endAngle = startAngle + sweepAngle;
  return { startAngle, endAngle };
}
function arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {
  const sinA = Math.sin(clipAngle);
  const cosA = Math.cos(clipAngle);
  const c = cx ** 2 + cy ** 2 - r ** 2;
  let p0x;
  let p0y;
  let p1x;
  let p1y;
  if (cosA > 0.5) {
    const tanA = sinA / cosA;
    const a = 1 + tanA ** 2;
    const b = -2 * (cx + cy * tanA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const x0 = (-b + Math.sqrt(d)) / (2 * a);
    const x1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = x0;
    p0y = x0 * tanA;
    p1x = x1;
    p1y = x1 * tanA;
  } else {
    const cotA = cosA / sinA;
    const a = 1 + cotA ** 2;
    const b = -2 * (cy + cx * cotA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const y0 = (-b + Math.sqrt(d)) / (2 * a);
    const y1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = y0 * cotA;
    p0y = y0;
    p1x = y1 * cotA;
    p1y = y1;
  }
  const normalisedX = cosA;
  const normalisedY = sinA;
  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;
  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;
  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;
  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}
function arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {
  const d = Math.hypot(cx, cy);
  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);
  const d2 = d - d1;
  const theta = Math.atan2(cy, cx);
  const deltaTheta = Math.acos(-d2 / r);
  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);
  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}

// packages/ag-charts-community/src/scene/shape/sector.ts
var Arc = class {
  constructor(cx, cy, r, a0, a1) {
    this.cx = cx;
    this.cy = cy;
    this.r = r;
    this.a0 = a0;
    this.a1 = a1;
    if (this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  isValid() {
    return Number.isFinite(this.a0) && Number.isFinite(this.a1);
  }
  pointAt(a) {
    return {
      x: this.cx + this.r * Math.cos(a),
      y: this.cy + this.r * Math.sin(a)
    };
  }
  clipStart(a) {
    if (a == null || !this.isValid() || a < this.a0)
      return;
    this.a0 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  clipEnd(a) {
    if (a == null || !this.isValid() || a > this.a1)
      return;
    this.a1 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
};
var Sector = class extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.innerRadius = 10;
    this.outerRadius = 20;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clipSector = void 0;
    this.concentricEdgeInset = 0;
    this.radialEdgeInset = 0;
    this.startOuterCornerRadius = 0;
    this.endOuterCornerRadius = 0;
    this.startInnerCornerRadius = 0;
    this.endInnerCornerRadius = 0;
  }
  set inset(value) {
    this.concentricEdgeInset = value;
    this.radialEdgeInset = value;
  }
  set cornerRadius(value) {
    this.startOuterCornerRadius = value;
    this.endOuterCornerRadius = value;
    this.startInnerCornerRadius = value;
    this.endInnerCornerRadius = value;
  }
  computeBBox() {
    return sectorBox(this).translate(this.centerX, this.centerY);
  }
  normalizedRadii() {
    const { concentricEdgeInset } = this;
    let { innerRadius, outerRadius } = this;
    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;
    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);
    return { innerRadius, outerRadius };
  }
  normalizedClipSector() {
    const { clipSector } = this;
    if (clipSector == null)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);
    return new SectorBox(
      Math.max(startAngle, clipAngles.startAngle),
      Math.min(endAngle, clipAngles.endAngle),
      Math.max(innerRadius, clipSector.innerRadius),
      Math.min(outerRadius, clipSector.outerRadius)
    );
  }
  getAngleOffset(radius) {
    return radius > 0 ? this.radialEdgeInset / radius : 0;
  }
  arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {
    if (r <= 0)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    if (inner && innerRadius <= 0)
      return;
    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);
    const angle = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;
    const radius = inner ? innerRadius + r : outerRadius - r;
    const cx = radius * Math.cos(angle);
    const cy = radius * Math.sin(angle);
    if (clipSector != null) {
      const delta3 = 1e-6;
      if (!start2 && !(angle >= startAngle - delta3 && angle <= clipSector.endAngle - delta3))
        return;
      if (start2 && !(angle >= clipSector.startAngle + delta3 && angle <= endAngle - delta3))
        return;
      if (inner && radius < clipSector.innerRadius - delta3)
        return;
      if (!inner && radius > clipSector.outerRadius + delta3)
        return;
    }
    const arc = new Arc(cx, cy, r, a0, a1);
    if (clipSector != null) {
      if (inner) {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
      } else {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
      }
      let circleClipStart;
      let circleClipEnd;
      if (start2) {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
      } else {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
      }
      arc.clipStart(circleClipStart);
      arc.clipEnd(circleClipEnd);
      if (circleClipStart != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start2) {
          innerArc?.clipStart(theta2);
        } else {
          outerArc.clipEnd(theta2);
        }
      }
      if (circleClipEnd != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start2) {
          outerArc.clipStart(theta2);
        } else {
          innerArc?.clipEnd(theta2);
        }
      }
    }
    if (clipSector != null) {
      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);
      if (!isPointInSector(x2, y2, clipSector))
        return;
    }
    const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);
    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);
    const radialArc = inner ? innerArc : outerArc;
    if (start2) {
      radialArc?.clipStart(theta);
    } else {
      radialArc?.clipEnd(theta);
    }
    return arc;
  }
  updatePath() {
    const delta3 = 1e-6;
    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;
    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    const sweepAngle = endAngle - startAngle;
    const fullPie = sweepAngle >= 2 * Math.PI - delta3;
    path.clear();
    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {
      return;
    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {
      return;
    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {
      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > concentricEdgeInset) {
        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      }
      path.closePath();
      return;
    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
      path.closePath();
      return;
    }
    const innerAngleOffset = this.getAngleOffset(innerRadius);
    const outerAngleOffset = this.getAngleOffset(outerRadius);
    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;
    if (outerAngleExceeded)
      return;
    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;
    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;
    const radialLength = outerRadius - innerRadius;
    const maxRadialLength = Math.max(
      startOuterCornerRadius,
      startInnerCornerRadius,
      endOuterCornerRadius,
      endInnerCornerRadius
    );
    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;
    startOuterCornerRadius *= initialScalingFactor;
    endOuterCornerRadius *= initialScalingFactor;
    startInnerCornerRadius *= initialScalingFactor;
    endInnerCornerRadius *= initialScalingFactor;
    const outerScalingFactor = radiiScalingFactor(
      outerRadius,
      sweepAngle - 2 * outerAngleOffset,
      -startOuterCornerRadius,
      -endOuterCornerRadius
    );
    startOuterCornerRadius *= outerScalingFactor;
    endOuterCornerRadius *= outerScalingFactor;
    if (!innerAngleExceeded && hasInnerSweep) {
      const innerScalingFactor = radiiScalingFactor(
        innerRadius,
        sweepAngle - 2 * innerAngleOffset,
        startInnerCornerRadius,
        endInnerCornerRadius
      );
      startInnerCornerRadius *= innerScalingFactor;
      endInnerCornerRadius *= innerScalingFactor;
    } else {
      startInnerCornerRadius = 0;
      endInnerCornerRadius = 0;
    }
    const maxCombinedRadialLength = Math.max(
      startOuterCornerRadius + startInnerCornerRadius,
      endOuterCornerRadius + endInnerCornerRadius
    );
    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;
    startOuterCornerRadius *= edgesScalingFactor;
    endOuterCornerRadius *= edgesScalingFactor;
    startInnerCornerRadius *= edgesScalingFactor;
    endInnerCornerRadius *= edgesScalingFactor;
    let startOuterCornerRadiusAngleSweep = 0;
    let endOuterCornerRadiusAngleSweep = 0;
    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);
    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);
    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {
      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);
    } else {
      startOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);
      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);
    }
    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {
      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);
    } else {
      endOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);
      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);
    }
    const startInnerCornerRadiusAngleSweep = Math.asin(
      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)
    );
    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));
    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;
    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);
    const outerArc = new Arc(
      0,
      0,
      outerArcRadius,
      startAngle + outerArcRadiusOffset,
      endAngle - outerArcRadiusOffset
    );
    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;
    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);
    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;
    if (clipSector != null) {
      outerArc.clipStart(clipSector.startAngle);
      outerArc.clipEnd(clipSector.endAngle);
      innerArc?.clipStart(clipSector.startAngle);
      innerArc?.clipEnd(clipSector.endAngle);
    }
    const startOuterArc = this.arc(
      startOuterCornerRadius,
      startOuterCornerRadiusAngleSweep,
      startAngle - Math.PI * 0.5,
      startAngle + startOuterCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      true,
      false
    );
    const endOuterArc = this.arc(
      endOuterCornerRadius,
      endOuterCornerRadiusAngleSweep,
      endAngle - endOuterCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      outerArc,
      innerArc,
      false,
      false
    );
    const endInnerArc = this.arc(
      endInnerCornerRadius,
      endInnerCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      false,
      true
    );
    const startInnerArc = this.arc(
      startInnerCornerRadius,
      startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI * 1.5,
      outerArc,
      innerArc,
      true,
      true
    );
    if (innerAngleExceeded) {
      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;
      let r;
      if (x > 0 && x < outerRadius) {
        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);
      } else {
        r = radialEdgeInset;
      }
      r = Math.max(r, innerRadius);
      const midAngle = startAngle + sweepAngle * 0.5;
      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {
    } else {
      const midAngle = startAngle + sweepAngle / 2;
      const cx = innerRadius * Math.cos(midAngle);
      const cy = innerRadius * Math.sin(midAngle);
      path.moveTo(centerX + cx, centerY + cy);
    }
    if (startOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = startOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (outerArc.isValid()) {
      const { r, a0, a1 } = outerArc;
      path.arc(centerX, centerY, r, a0, a1);
    }
    if (endOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = endOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (!innerAngleExceeded) {
      if (endInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = endInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
      if (innerArc?.isValid() === true) {
        const { r, a0, a1 } = innerArc;
        path.arc(centerX, centerY, r, a1, a0, true);
      }
      if (startInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = startInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
    }
    path.closePath();
  }
  isPointInPath(x, y) {
    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;
    return isPointInSector(x - this.centerX, y - this.centerY, {
      startAngle,
      endAngle,
      innerRadius: Math.min(innerRadius, outerRadius),
      outerRadius: Math.max(innerRadius, outerRadius)
    });
  }
};
Sector.className = "Sector";
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "centerX", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "centerY", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "innerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "outerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startAngle", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endAngle", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: (lhs, rhs) => lhs.equals(rhs) })
], Sector.prototype, "clipSector", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "concentricEdgeInset", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "radialEdgeInset", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startOuterCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endOuterCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startInnerCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endInnerCornerRadius", 2);

// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_STROKES = {
  BLUE: "#2b5c95",
  ORANGE: "#cc6f10",
  GREEN: "#1e652e",
  CYAN: "#18859e",
  YELLOW: "#a69400",
  VIOLET: "#603c88",
  GRAY: "#575757",
  MAGENTA: "#7d2f6d",
  BROWN: "#4f3508",
  RED: "#a82529"
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Property
], DonutTitle.prototype, "showInLegend", 2);
var DonutInnerLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.spacing = 2;
  }
  set(properties, _reset) {
    return super.set(properties);
  }
};
__decorateClass([
  Property
], DonutInnerLabel.prototype, "text", 2);
__decorateClass([
  Property
], DonutInnerLabel.prototype, "spacing", 2);
var DonutInnerCircle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "transparent";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Property
], DonutInnerCircle.prototype, "fill", 2);
__decorateClass([
  Property
], DonutInnerCircle.prototype, "fillOpacity", 2);
var DonutSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var DonutSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Property
], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Property
], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
var DonutSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
var DonutSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.defaultColorRange = [];
    this.defaultPatternFills = [];
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = 0;
    this.hideZeroValueSectorsInLegend = false;
    this.innerLabels = new PropertiesArray(DonutInnerLabel);
    this.title = new DonutTitle();
    this.innerCircle = new DonutInnerCircle();
    this.shadow = new DropShadow();
    this.calloutLabel = new DonutSeriesCalloutLabel();
    this.sectorLabel = new DonutSeriesSectorLabel();
    this.calloutLine = new DonutSeriesCalloutLine();
    this.tooltip = makeSeriesTooltip();
  }
};
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "defaultPatternFills", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "hideZeroValueSectorsInLegend", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];
  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];
  const rotation = Math.PI / -2 + toRadians(rotationDegrees);
  const phase = initialLoad ? "initial" : "update";
  const scaleToNewRadius = ({ radius }) => {
    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };
  };
  const scaleToOldRadius = ({ radius }) => {
    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };
  };
  const fromFn = (sect, datum, status, { prevFromProps }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = sect;
    let { fill, stroke: stroke2 } = datum.sectorFormat;
    if (status === "updated" && sect.previousDatum == null) {
      status = "added";
    }
    if (status === "unknown" || status === "added" && !prevFromProps) {
      startAngle = rotation;
      endAngle = rotation;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else if (status === "added" && prevFromProps) {
      startAngle = prevFromProps.endAngle ?? rotation;
      endAngle = prevFromProps.endAngle ?? rotation;
      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;
      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;
    }
    if (status === "added" && !initialLoad) {
      const radii = scaleToOldRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    if (status === "updated") {
      fill = sect.fill ?? fill;
      stroke2 = (typeof sect.stroke === "string" ? sect.stroke : void 0) ?? stroke2;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke: stroke2, phase };
  };
  const toFn = (_sect, datum, status, { prevLive }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = datum;
    const { stroke: stroke2, fill } = datum.sectorFormat;
    if (status === "removed" && prevLive) {
      startAngle = prevLive.datum?.endAngle;
      endAngle = prevLive.datum?.endAngle;
    } else if (status === "removed" && !prevLive) {
      startAngle = rotation;
      endAngle = rotation;
    }
    if (status === "removed") {
      const radii = scaleToNewRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    return { startAngle, endAngle, outerRadius, innerRadius, stroke: stroke2, fill };
  };
  const innerCircleFromFn = (node, _) => {
    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };
  };
  const innerCircleToFn = (_, datum) => {
    return { size: datum.radius ?? 0 };
  };
  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };
}
function resetPieSelectionsFn(_node, datum) {
  return {
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    stroke: datum.sectorFormat.stroke
  };
}
function pickByMatchingAngle(series, point) {
  const dy = point.y - series.centerY;
  const dx = point.x - series.centerX;
  const angle = Math.atan2(dy, dx);
  const sectors = series.getItemNodes();
  for (const sector of sectors) {
    if (sector.datum.missing === true)
      continue;
    if (isBetweenAngles(angle, sector.startAngle, sector.endAngle)) {
      const radius = Math.sqrt(dx * dx + dy * dy);
      let distance = 0;
      if (radius < sector.innerRadius) {
        distance = sector.innerRadius - radius;
      } else if (radius > sector.outerRadius) {
        distance = radius - sector.outerRadius;
      }
      return { datum: sector.datum, distance };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var PieDonutSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var DonutSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      propertyKeys: {
        ...DEFAULT_POLAR_DIRECTION_KEYS,
        sectorLabel: ["sectorLabelKey"],
        calloutLabel: ["calloutLabelKey"]
      },
      propertyNames: {
        ...DEFAULT_POLAR_DIRECTION_NAMES,
        sectorLabel: ["sectorLabelName"],
        calloutLabel: ["calloutLabelName"]
      },
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new DonutSeriesProperties();
    this.phantomNodeData = void 0;
    this.backgroundGroup = new TranslatableGroup({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this.noVisibleData = false;
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    this.phantomGroup = this.backgroundGroup.appendChild(new Group({ name: "phantom" }));
    this.phantomSelection = Selection.select(
      this.phantomGroup,
      () => this.nodeFactory(),
      false
    );
    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: "pieCalloutLabels" }));
    this.calloutLabelSelection = new Selection(
      this.calloutLabelGroup,
      Group
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: "innerLabels" }));
    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);
    this.innerCircleSelection = Selection.select(
      this.innerCircleGroup,
      () => new Marker({ shape: "circle" })
    );
    this.surroundingRadius = void 0;
    this.NodeEvent = PieDonutSeriesNodeEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    this.phantomGroup.opacity = 0.2;
    this.innerLabelsGroup.pointerEvents = 1 /* None */;
  }
  get calloutNodeData() {
    return this.phantomNodeData ?? this.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.backgroundGroup.zIndex = [0 /* BACKGROUND */, zIndex];
  }
  nodeFactory() {
    const sector = new Sector();
    sector.miterLimit = 1e9;
    return sector;
  }
  getSeriesDomain(direction) {
    if (direction === "angle" /* Angle */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const {
      visible,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const processor = () => (value, index) => {
      if (visible && legendManager.getItemEnabled({ seriesId, itemId: index })) {
        return value;
      }
      return 0;
    };
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const extraKeyProps = [];
    const extraProps = [];
    if (legendItemKey) {
      extraKeyProps.push(keyProperty(legendItemKey, "category", { id: `legendItemKey` }));
    } else if (calloutLabelKey) {
      extraKeyProps.push(keyProperty(calloutLabelKey, "category", { id: `calloutLabelKey` }));
    } else if (sectorLabelKey) {
      extraKeyProps.push(keyProperty(sectorLabelKey, "category", { id: `sectorLabelKey` }));
    }
    const radiusScaleType = this.radiusScale.type;
    const angleScaleType = this.angleScale.type;
    if (radiusKey) {
      extraProps.push(
        rangedValueProperty(radiusKey, {
          id: "radiusValue",
          min: this.properties.radiusMin ?? 0,
          max: this.properties.radiusMax,
          missingValue: this.properties.radiusMax ?? 1,
          processor
        }),
        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw`, processor }),
        // Raw value pass-through.
        normalisePropertyTo("radiusValue", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)
      );
    }
    if (calloutLabelKey) {
      extraProps.push(valueProperty(calloutLabelKey, "category", { id: `calloutLabelValue` }));
    }
    if (sectorLabelKey) {
      extraProps.push(valueProperty(sectorLabelKey, "category", { id: `sectorLabelValue` }));
    }
    if (legendItemKey) {
      extraProps.push(valueProperty(legendItemKey, "category", { id: `legendItemValue` }));
    }
    if (angleFilterKey) {
      extraProps.push(
        accumulativeValueProperty(angleFilterKey, angleScaleType, {
          id: `angleFilterValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),
        normalisePropertyTo("angleFilterValue", [0, 1], 0, 0)
      );
    }
    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {
      extraProps.push(diff(this.id, this.processedData));
    }
    extraProps.push(animationValidation());
    await this.requestDataModel(dataController, this.data, {
      props: [
        ...extraKeyProps,
        accumulativeValueProperty(angleKey, angleScaleType, {
          id: `angleValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("angleValue", [0, 1], 0, 0),
        ...extraProps
      ]
    });
    for (const valueDef of this.processedData?.defs?.values ?? []) {
      const { id, missing, property } = valueDef;
      const missCount = getMissCount(this, missing);
      if (id !== "angleRaw" && missCount > 0) {
        Logger37.warnOnce(
          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
        );
      }
    }
    this.animationState.transition("updateData");
  }
  maybeRefreshNodeData() {
    if (!this.nodeDataRefresh)
      return;
    const { nodeData = [], phantomNodeData } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.phantomNodeData = phantomNodeData;
    this.nodeDataRefresh = false;
  }
  getProcessedDataValues(dataModel, processedData) {
    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);
    const angleRawValues = dataModel.resolveColumnById(this, `angleRaw`, processedData);
    const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterValue`, processedData) : void 0;
    const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterRaw`, processedData) : void 0;
    const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusValue`, processedData) : void 0;
    const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusRaw`, processedData) : void 0;
    const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, `calloutLabelValue`, processedData) : void 0;
    const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, `sectorLabelValue`, processedData) : void 0;
    const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, `legendItemValue`, processedData) : void 0;
    return {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      calloutLabelValues,
      sectorLabelValues,
      legendItemValues
    };
  }
  createNodeData() {
    const {
      id: seriesId,
      processedData,
      dataModel,
      angleScale,
      ctx: { legendManager },
      visible
    } = this;
    const { rotation, innerRadiusRatio } = this.properties;
    if (!dataModel || processedData?.type !== "ungrouped")
      return;
    const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
    const {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      legendItemValues
    } = processedDataValues;
    const useFilterAngles = angleFilterRawValues?.some((filterRawValue, index) => {
      return filterRawValue > angleRawValues[index];
    }) ?? false;
    let currentStart = 0;
    let sum = 0;
    const nodes = [];
    const phantomNodes = angleFilterRawValues != null ? [] : void 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const invalidData = processedData.invalidData?.get(this.id);
    rawData.forEach((datum, datumIndex) => {
      if (invalidData?.[datumIndex] === true)
        return;
      const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];
      const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      sum += currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = angleRawValues[datumIndex];
      const radiusRaw = radiusValues?.[datumIndex] ?? 1;
      const radius = radiusRaw * crossFilterScale;
      const radiusValue = radiusRawValues?.[datumIndex];
      const legendItemValue = legendItemValues?.[datumIndex];
      const nodeLabels = this.getLabels(datumIndex, datum, midAngle, span, processedDataValues);
      const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
      const node = {
        itemId: datumIndex,
        series: this,
        datum,
        datumIndex,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0),
        sectorFormat,
        radiusValue,
        legendItemValue,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        focusable: true,
        ...nodeLabels
      };
      nodes.push(node);
      if (phantomNodes != null) {
        phantomNodes.push({
          ...node,
          radius: 1,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(1), 0),
          focusable: false
        });
      }
    });
    this.zerosumOuterRing.visible = sum === 0;
    this.zerosumInnerRing.visible = sum === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
    return {
      itemId: seriesId,
      nodeData: nodes,
      labelData: nodes,
      phantomNodeData: phantomNodes
    };
  }
  getLabelContent(datumIndex, datum, values) {
    const { id: seriesId, ctx, properties } = this;
    const { formatManager } = ctx;
    const { calloutLabel, sectorLabel, calloutLabelKey, sectorLabelKey, legendItemKey } = properties;
    const calloutLabelValue = values.calloutLabelValues?.[datumIndex];
    const sectorLabelValue = values.sectorLabelValues?.[datumIndex];
    const legendItemValue = values.legendItemValues?.[datumIndex];
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {
      callout: void 0,
      sector: void 0,
      legendItem: void 0
    };
    if (calloutLabelKey) {
      result.callout = this.getLabelText(
        calloutLabelValue,
        datum,
        calloutLabelKey,
        "calloutLabel",
        [],
        calloutLabel,
        { ...labelFormatterParams, value: calloutLabelValue }
      );
    }
    if (sectorLabelKey) {
      result.sector = this.getLabelText(
        sectorLabelValue,
        datum,
        sectorLabelKey,
        "sectorLabel",
        [],
        sectorLabel,
        { ...labelFormatterParams, value: sectorLabelValue }
      );
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value: legendItemValue,
        datum,
        seriesId,
        legendItemName: void 0,
        key: legendItemKey,
        source: "legend-label",
        property: "legendItem",
        domain: [],
        boundSeries: this.getFormatterContext("legendItem")
      }) ?? legendItemValue;
    }
    return result;
  }
  getLabels(datumIndex, datum, midAngle, span, values) {
    const { properties } = this;
    const { calloutLabel, sectorLabel, legendItemKey } = properties;
    const formats = this.getLabelContent(datumIndex, datum, values);
    const result = {};
    if (calloutLabel.enabled && formats.callout && span >= toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = {
        ...this.getTextAlignment(midAngle),
        text: formats.callout,
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      };
    }
    if (sectorLabel.enabled && formats.sector) {
      result.sectorLabel = { text: formats.sector };
    }
    if (legendItemKey && formats.legendItem) {
      result.legendItem = { key: legendItemKey, text: formats.legendItem };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "top" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -0.75 * Math.PI;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = modulus(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getNodeFill(fill, defaultColorRange, defaultPatternFill) {
    return getShapeFill(
      fill,
      {
        type: "gradient",
        bounds: "series",
        colorStops: defaultColorRange.map((color7) => ({ color: color7 })),
        gradient: "radial",
        rotation: 0,
        reverse: true
      },
      {
        type: "pattern",
        pattern: "forward-slanted-lines",
        fill: defaultPatternFill,
        fillOpacity: 1,
        backgroundFill: "none",
        backgroundFillOpacity: 1,
        stroke: defaultPatternFill,
        strokeOpacity: 1,
        strokeWidth: 4,
        rotation: 0
      },
      {
        type: "image",
        backgroundFill: defaultPatternFill,
        backgroundFillOpacity: 1,
        fit: "contain",
        repeat: "no-repeat",
        rotation: 0
      }
    );
  }
  getFillParams(fill, innerRadius, outerRadius) {
    if (!isGradientFill(fill) || fill.bounds === "item")
      return;
    return {
      centerX: 0,
      centerY: 0,
      innerRadius,
      outerRadius
    };
  }
  getSectorFormat(datum, datumIndex, isHighlight, nodeDatum, legendItemValues, activeHighlight) {
    const {
      angleKey,
      radiusKey,
      calloutLabelKey,
      sectorLabelKey,
      legendItemKey,
      fills,
      strokes,
      defaultColorRange,
      defaultPatternFills,
      itemStyler
    } = this.properties;
    const defaultStroke = strokes[datumIndex % strokes.length];
    const defaultFill = fills[datumIndex % fills.length];
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity
    } = mergeDefaults(
      this.getHighlightStyle(isHighlight, nodeDatum?.datumIndex, legendItemValues),
      {
        fill: defaultFill,
        stroke: defaultStroke
      },
      this.properties
    );
    const defaultColors = defaultColorRange[datumIndex % defaultColorRange.length];
    const defaultPatternFill = defaultPatternFills[datumIndex % defaultPatternFills.length];
    const sectorFill = fill ?? "black";
    let format;
    if (itemStyler) {
      format = this.cachedDatumCallback(
        this.getDatumId(datumIndex) + (isHighlight ? "-highlight" : "-hide"),
        () => this.callWithContext(itemStyler, {
          datum,
          angleKey,
          radiusKey,
          calloutLabelKey,
          sectorLabelKey,
          legendItemKey,
          fill: this.getNodeFill(sectorFill, defaultColors, defaultPatternFill),
          fillOpacity,
          stroke: stroke2,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          cornerRadius,
          highlighted: isHighlight,
          highlightState: this.getHighlightStateString(
            activeHighlight ?? this.ctx.highlightManager?.getActiveHighlight(),
            isHighlight,
            datumIndex
          ),
          seriesId: this.id
        })
      );
    }
    return {
      fill: this.getNodeFill(format?.fill ?? sectorFill, defaultColors, defaultPatternFill),
      fillOpacity: format?.fillOpacity ?? fillOpacity,
      stroke: format?.stroke ?? stroke2,
      strokeWidth: format?.strokeWidth ?? strokeWidth,
      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
      lineDash: format?.lineDash ?? lineDash,
      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
      cornerRadius: format?.cornerRadius ?? cornerRadius,
      opacity
    };
  }
  getInnerRadius() {
    const { radius } = this;
    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    const { outerRadiusRatio, outerRadiusOffset } = this.properties;
    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [this.getInnerRadius(), this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    const setRadii = (d) => ({
      ...d,
      innerRadius: Math.max(this.radiusScale.convert(0), 0),
      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
    });
    this.nodeData = this.nodeData.map(setRadii);
    this.phantomNodeData = this.phantomNodeData?.map(setRadii);
  }
  getTitleTranslationY() {
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = this.properties.title?.spacing ?? 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  update({ seriesRect }) {
    const { title } = this.properties;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width,
      seriesRectHeight: seriesRect?.height
    };
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    this.maybeRefreshNodeData();
    this.updateTitleNodes();
    this.updateRadiusScale(resize);
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    this.backgroundGroup.translationX = this.centerX;
    this.backgroundGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    if (title) {
      const dy = this.getTitleTranslationY();
      title.node.y = isFinite(dy) ? dy : 0;
      const titleBox = title.node.getBBox(false);
      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);
    }
    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
      circle.fillOpacity = 0;
      circle.stroke = this.properties.calloutLabel.color;
      circle.strokeWidth = 1;
      circle.strokeOpacity = 1;
    }
    this.updateNodeMidPoint();
    this.updateSelections();
    this.updateNodes(seriesRect);
  }
  updateTitleNodes() {
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        this.labelGroup?.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        this.labelGroup?.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    const setMidPoint = (d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    };
    this.nodeData.forEach(setMidPoint);
    this.phantomNodeData?.forEach(setMidPoint);
  }
  updateSelections() {
    this.updateGroupSelection();
    this.updateInnerCircleSelection();
  }
  updateGroupSelection() {
    const {
      itemSelection,
      highlightSelection,
      phantomSelection,
      calloutLabelSelection,
      labelSelection,
      innerLabelsSelection
    } = this;
    const highlightedNodeData = this.nodeData.map((datum) => ({
      ...datum,
      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
      // between normal and highlighted cases.
      sectorFormat: { ...datum.sectorFormat }
    }));
    const update = (selection, nodeData) => {
      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum.datumIndex));
      if (this.ctx.animationManager.isSkipped()) {
        selection.cleanup();
      }
    };
    update(itemSelection, this.nodeData);
    update(highlightSelection, highlightedNodeData);
    update(phantomSelection, this.phantomNodeData ?? []);
    calloutLabelSelection.update(this.calloutNodeData, (group) => {
      const line = new Line();
      line.tag = 0 /* Callout */;
      line.pointerEvents = 1 /* None */;
      group.appendChild(line);
      const text = new Text();
      text.tag = 1 /* Label */;
      text.pointerEvents = 1 /* None */;
      group.appendChild(text);
    });
    labelSelection.update(this.nodeData);
    innerLabelsSelection.update(this.properties.innerLabels, (node) => {
      node.pointerEvents = 1 /* None */;
    });
  }
  updateInnerCircleSelection() {
    const { innerCircle } = this.properties;
    let radius = 0;
    const innerRadius = this.getInnerRadius();
    if (innerRadius > 0) {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
    const datums = innerCircle ? [{ radius }] : [];
    this.innerCircleSelection.update(datums);
  }
  updateNodes(seriesRect) {
    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
    const { visible, dataModel, processedData } = this;
    this.backgroundGroup.visible = visible;
    this.contentGroup.visible = visible;
    if (!dataModel || !processedData)
      return;
    const { legendItemValues } = this.getProcessedDataValues(dataModel, processedData);
    const seriesHighlighted = this.isSeriesHighlighted(highlightedDatum, legendItemValues);
    this.highlightGroup.visible = visible && seriesHighlighted;
    this.labelGroup.visible = visible;
    this.innerCircleSelection.each((node, { radius }) => {
      node.setProperties({
        fill: this.getNodeFill(this.properties.innerCircle?.fill, ["black"], "black"),
        opacity: this.properties.innerCircle?.fillOpacity,
        size: radius
      });
    });
    const innerRadius = this.radiusScale.range[0];
    const outerRadius = this.radiusScale.range[1];
    const fillBBox = this.getShapeFillBBox();
    const animationDisabled = this.ctx.animationManager.isSkipped();
    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
      const format = this.getSectorFormat(
        datum.datum,
        datum.itemId,
        isDatumHighlighted,
        datum,
        legendItemValues,
        highlightedDatum
      );
      datum.sectorFormat.fill = format.fill;
      datum.sectorFormat.stroke = format.stroke;
      if (animationDisabled) {
        sector.startAngle = datum.startAngle;
        sector.endAngle = datum.endAngle;
        sector.innerRadius = datum.innerRadius;
        sector.outerRadius = datum.outerRadius;
      }
      if (isDatumHighlighted || animationDisabled) {
        sector.fill = format.fill;
        sector.stroke = format.stroke;
      }
      const fillParams = this.getFillParams(format.fill, innerRadius, outerRadius);
      applyShapeStyle(sector, format, fillBBox, fillParams);
      sector.cornerRadius = format.cornerRadius;
      sector.fillShadow = this.properties.shadow;
      const inset = Math.max(
        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,
        0
      );
      sector.inset = inset;
      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
    };
    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.highlightSelection.each((node, datum, index) => {
      updateSectorFn(node, datum, index, true);
      node.visible = datum.itemId === highlightedDatum?.itemId;
    });
    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.updateCalloutLineNodes();
    this.updateCalloutLabelNodes(seriesRect);
    this.updateSectorLabelNodes();
    this.updateInnerLabelNodes();
    this.updateZerosumRings();
    this.animationState.transition("update");
  }
  updateCalloutLineNodes() {
    const {
      calloutLine: { length: calloutLength, strokeWidth, colors },
      strokes
    } = this.properties;
    const calloutStrokeWidth = strokeWidth;
    const calloutColors = isStringFillArray(colors) ? colors ?? this.properties.strokes : strokes;
    const { offset } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line) => {
      const datum = line.closestDatum();
      const { calloutLabel: label, outerRadius, datumIndex } = datum;
      if (label?.text && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[datumIndex % calloutColors.length];
        line.strokeOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length - offset;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length;
            y2 = y2 + dy * paddedLength / length;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = -this.centerX;
    const seriesRight = seriesLeft + seriesRect.width;
    const seriesTop = -this.centerY;
    const seriesBottom = seriesTop + seriesRect.height;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x, y: box.y },
      { x: box.x + box.width, y: box.y },
      { x: box.x + box.width, y: box.y + box.height },
      { x: box.x, y: box.y + box.height }
    ];
    const sur2 = surroundingRadius ** 2;
    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.calloutNodeData;
    const data = fullData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const params = { angleKey: this.properties.angleKey };
    const getTextBBox = (datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return BBox.zero.clone();
      const style = getLabelStyles(this, datum, params, calloutLabel);
      const padding2 = expandLabelPadding(style);
      const labelRadius = datum.outerRadius + calloutLine.length + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const textAlign = label.collisionTextAlign ?? label.textAlign;
      const textBaseline = label.textBaseline;
      return Text.computeBBox(
        label.text,
        x,
        y,
        { font: this.properties.calloutLabel, textAlign, textBaseline },
        false
      ).grow(padding2);
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        next.calloutLabel.collisionOffsetY = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
      const datum = text.closestDatum();
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label?.text || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const isHighlight = false;
      const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
      const style = getLabelStyles(
        this,
        datum,
        this.properties,
        calloutLabel,
        isHighlight,
        highlightState
      );
      const labelRadius = outerRadius + calloutLine.length + calloutLabel.offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align2 = {
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(style);
      tempTextNode.setAlign(align2);
      tempTextNode.setBoxing(style);
      const box = tempTextNode.getBBox(false);
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(style);
      text.setAlign(align2);
      text.setBoxing(style);
      text.fill = style.color;
      text.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
      text.visible = visible;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset, maxCollisionOffset, minSpacing } = calloutLabel;
    if (!calloutLabel.avoidCollisions) {
      return null;
    }
    this.maybeRefreshNodeData();
    this.updateRadiusScale(false);
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text = new Text();
    let titleBox;
    const { title } = this.properties;
    if (title?.text && title.enabled) {
      const dy = this.getTitleTranslationY();
      if (isFinite(dy)) {
        text.text = title.text;
        text.x = 0;
        text.y = dy;
        text.setFont(title);
        text.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        });
        titleBox = text.getBBox(false);
        textBoxes.push(titleBox);
      }
    }
    const params = { angleKey: this.properties.angleKey };
    this.calloutNodeData.forEach((datum) => {
      const label = datum.calloutLabel;
      if (!label || datum.outerRadius === 0) {
        return null;
      }
      const style = getLabelStyles(this, datum, params, calloutLabel);
      const labelRadius = datum.outerRadius + calloutLength + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      text.text = label.text;
      text.x = x;
      text.y = y;
      text.setFont(style);
      text.setAlign({
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      });
      text.setBoxing(style);
      const box = text.getBBox(false);
      label.box = box;
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      if (titleBox) {
        const seriesTop = -this.centerY;
        const titleCleanArea = new BBox(
          titleBox.x - minSpacing,
          seriesTop,
          titleBox.width + 2 * minSpacing,
          titleBox.y + titleBox.height + minSpacing - seriesTop
        );
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
          label.text,
          box,
          seriesRect
        );
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  updateSectorLabelNodes() {
    const { properties } = this;
    const { positionOffset, positionRatio } = this.properties.sectorLabel;
    const innerRadius = this.radiusScale.convert(0);
    const shouldPutTextInCenter = innerRadius <= 0 && // is donut?
    this.ctx.legendManager.getData(this.id)?.filter((d) => d.enabled).length === 1;
    const align2 = { textAlign: "center", textBaseline: "middle" };
    const updateSectorLabel = (text, datum) => {
      const { outerRadius, startAngle, endAngle } = datum;
      let isTextVisible = false;
      if (datum.sectorLabel && outerRadius !== 0) {
        const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
        const isHighlight = false;
        const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
        const style = getLabelStyles(
          this,
          datum,
          properties,
          properties.sectorLabel,
          isHighlight,
          highlightState
        );
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = style.color;
        text.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
        text.text = datum.sectorLabel.text;
        if (shouldPutTextInCenter) {
          text.x = 0;
          text.y = 0;
        } else {
          text.x = datum.midCos * labelRadius;
          text.y = datum.midSin * labelRadius;
        }
        text.setFont(style);
        text.setAlign(align2);
        text.setBoxing(style);
        const bbox = text.getBBox(false);
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    };
    this.labelSelection.each(updateSectorLabel);
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text, datum) => {
      const { fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = datum;
      text.fontStyle = fontStyle;
      text.fontWeight = fontWeight;
      text.fontSize = fontSize;
      text.fontFamily = fontFamily;
      text.text = datum.text;
      text.x = 0;
      text.y = 0;
      text.fill = color7;
      text.textAlign = "center";
      text.textBaseline = "alphabetic";
      textBBoxes.push(text.getBBox());
      margins.push(datum.spacing);
    });
    const getMarginTop = (index) => index === 0 ? 0 : margins[index];
    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
    const totalWidth = textBBoxes.reduce((max, bbox) => max < bbox.width ? bbox.width : max, 0);
    const totalHeight = textBBoxes.reduce(
      (sum, bbox, i) => sum + bbox.height + getMarginTop(i) + getMarginBottom(i),
      0
    );
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text, _datum, index) => {
      text.visible = labelsVisible;
      if (Array.isArray(text.text)) {
        text.y = textBottoms[index] - textBBoxes[index].height;
      } else {
        text.y = textBottoms[index];
      }
    });
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
    this.zerosumInnerRing.size = this.getInnerRadius() * 2;
  }
  pickNodeClosestDatum(point) {
    return pickByMatchingAngle(this, point);
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      properties,
      ctx: { formatManager }
    } = this;
    const {
      legendItemKey,
      calloutLabelKey,
      calloutLabelName,
      sectorLabelKey,
      sectorLabelName,
      angleKey,
      angleName,
      radiusKey,
      radiusName,
      tooltip
    } = properties;
    const title = this.properties.title.node.getPlainText();
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
    const { angleRawValues } = processedDataValues;
    const angleRawValue = angleRawValues[datumIndex];
    const labelValues = this.getLabelContent(datumIndex, datum, processedDataValues);
    const label = labelValues.legendItem ?? labelValues.callout ?? labelValues.sector ?? angleName;
    const domain = dataModel.getDomain(this, `angleRaw`, "value", processedData);
    const angleContent = formatManager.format(this.callWithContext.bind(this), {
      type: "number",
      value: angleRawValue,
      datum,
      seriesId,
      legendItemName: void 0,
      key: angleKey,
      source: "tooltip",
      property: "angle",
      domain,
      boundSeries: this.getFormatterContext("angle"),
      fractionDigits: void 0
    }) ?? formatValue(angleRawValue, 3);
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(datumIndex),
        data: [{ label, fallbackLabel: angleKey, value: angleContent }]
      },
      {
        seriesId,
        datum,
        title: angleName,
        legendItemKey,
        calloutLabelKey,
        calloutLabelName,
        sectorLabelKey,
        sectorLabelName,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        ...this.getSectorFormat(datum, datumIndex, false)
      }
    );
  }
  legendItemSymbol(datumIndex) {
    const datum = this.processedData?.dataSources.get(this.id)?.[datumIndex];
    const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
    const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties;
    let { fill } = sectorFormat;
    const { stroke: stroke2 } = sectorFormat;
    if (isGradientFill(fill)) {
      fill = { ...fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return {
      marker: {
        fill,
        stroke: stroke2,
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      }
    };
  }
  getLegendData(legendType) {
    const {
      visible,
      processedData,
      dataModel,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    if (!dataModel || !processedData || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
      return [];
    }
    const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
    const { angleRawValues } = processedDataValues;
    const titleText = this.properties.title?.showInLegend && this.properties.title.text;
    const legendData = [];
    const hideZeros = this.properties.hideZeroValueSectorsInLegend;
    const rawData = processedData.dataSources.get(this.id);
    const invalidData = processedData.invalidData?.get(this.id);
    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {
      const datum = rawData?.[datumIndex];
      const angleRawValue = angleRawValues[datumIndex];
      if (invalidData?.[datumIndex] === true || hideZeros && angleRawValue === 0) {
        continue;
      }
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabelContent(datumIndex, datum, processedDataValues);
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.callout !== void 0) {
        labelParts.push(labels.callout);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sector !== void 0) {
        labelParts.push(labels.sector);
      }
      if (labelParts.length === 0)
        continue;
      legendData.push({
        legendType: "category",
        id: seriesId,
        datum,
        itemId: datumIndex,
        seriesId,
        hideToggleOtherSeries: true,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        label: {
          text: labelParts.join(" - ")
        },
        symbol: this.legendItemSymbol(datumIndex),
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,
        hideInLegend: !showInLegend
      });
    }
    return legendData;
  }
  // Used for grid
  setLegendState(enabledItems) {
    const {
      id: seriesId,
      ctx: { legendManager, updateService }
    } = this;
    enabledItems.forEach((enabled, itemId) => legendManager.toggleItem(enabled, seriesId, itemId));
    legendManager.update();
    updateService.update(5 /* SERIES_UPDATE */);
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [this.itemSelection, this.highlightSelection, this.phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const dataDiff = processedData?.reduced?.diff?.[this.id];
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;
    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;
    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const noVisibleData = !this.nodeData.some((n) => n.enabled);
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex),
      dataDiff
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    if (this.noVisibleData !== noVisibleData) {
      this.noVisibleData = noVisibleData;
      seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    }
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumId(datumIndex) {
    return `${datumIndex}`;
  }
  hasItemStylers() {
    const { itemStyler, calloutLabel, sectorLabel } = this.properties;
    return (itemStyler ?? calloutLabel.itemStyler ?? sectorLabel.itemStyler) != null;
  }
};
DonutSeries.className = "DonutSeries";
DonutSeries.type = "donut";

// packages/ag-charts-community/src/chart/series/polar/donutSeriesOptionsDef.ts
import {
  arrayOfDefs as arrayOfDefs4,
  constant as constant9,
  fontOptionsDef as fontOptionsDef4,
  labelBoxOptionsDef as labelBoxOptionsDef3,
  number as number11,
  positiveNumber as positiveNumber8,
  ratio as ratio5,
  required as required10,
  string as string12
} from "ag-charts-core";

// packages/ag-charts-community/src/chart/series/polar/pieSeriesOptionsDef.ts
import {
  arrayOf as arrayOf5,
  boolean as boolean11,
  callback as callback3,
  callbackDefs as callbackDefs3,
  color as color4,
  colorUnion as colorUnion2,
  constant as constant8,
  fillOptionsDef as fillOptionsDef6,
  fontOptionsDef as fontOptionsDef3,
  labelBoxOptionsDef as labelBoxOptionsDef2,
  lineDashOptionsDef as lineDashOptionsDef8,
  multiSeriesHighlightOptionsDef as multiSeriesHighlightOptionsDef7,
  number as number10,
  positiveNumber as positiveNumber7,
  ratio as ratio4,
  required as required9,
  shapeHighlightOptionsDef as shapeHighlightOptionsDef7,
  string as string11,
  strokeOptionsDef as strokeOptionsDef8,
  undocumented as undocumented7
} from "ag-charts-core";
var highlight4 = multiSeriesHighlightOptionsDef7(shapeHighlightOptionsDef7, shapeHighlightOptionsDef7);
var pieSeriesThemeableOptionsDef = {
  ...commonSeriesThemeableOptionsDefs,
  radiusMin: positiveNumber7,
  radiusMax: positiveNumber7,
  rotation: number10,
  outerRadiusOffset: number10,
  outerRadiusRatio: ratio4,
  hideZeroValueSectorsInLegend: boolean11,
  sectorSpacing: positiveNumber7,
  cornerRadius: positiveNumber7,
  itemStyler: callbackDefs3({
    ...fillOptionsDef6,
    ...strokeOptionsDef8,
    ...lineDashOptionsDef8,
    cornerRadius: positiveNumber7
  }),
  title: {
    enabled: boolean11,
    text: string11,
    showInLegend: boolean11,
    spacing: positiveNumber7,
    ...fontOptionsDef3
  },
  calloutLabel: {
    enabled: boolean11,
    offset: number10,
    minAngle: positiveNumber7,
    avoidCollisions: boolean11,
    formatter: callback3,
    format: string11,
    itemStyler: callbackDefs3({
      enabled: boolean11,
      ...labelBoxOptionsDef2,
      ...fontOptionsDef3
    }),
    ...labelBoxOptionsDef2,
    ...fontOptionsDef3
  },
  sectorLabel: {
    enabled: boolean11,
    positionOffset: number10,
    positionRatio: ratio4,
    formatter: callback3,
    format: string11,
    itemStyler: callbackDefs3({
      enabled: boolean11,
      ...labelBoxOptionsDef2,
      ...fontOptionsDef3
    }),
    ...labelBoxOptionsDef2,
    ...fontOptionsDef3
  },
  calloutLine: {
    colors: arrayOf5(color4),
    length: positiveNumber7,
    strokeWidth: positiveNumber7
  },
  fills: arrayOf5(colorUnion2),
  strokes: arrayOf5(color4),
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  highlight: highlight4,
  ...lineDashOptionsDef8,
  ...without(fillOptionsDef6, ["fill"]),
  ...without(strokeOptionsDef8, ["stroke"])
};
var pieSeriesOptionsDef = {
  ...pieSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required9(constant8("pie")),
  angleKey: required9(string11),
  radiusKey: string11,
  calloutLabelKey: string11,
  sectorLabelKey: string11,
  legendItemKey: string11,
  angleName: string11,
  radiusName: string11,
  calloutLabelName: string11,
  sectorLabelName: string11,
  highlight: highlight4
};
pieSeriesOptionsDef.defaultColorRange = undocumented7(arrayOf5(arrayOf5(color4)));
pieSeriesOptionsDef.defaultPatternFills = undocumented7(arrayOf5(color4));
pieSeriesOptionsDef.title._enabledFromTheme = undocumented7(boolean11);
pieSeriesOptionsDef.calloutLabel._enabledFromTheme = undocumented7(boolean11);
pieSeriesOptionsDef.sectorLabel._enabledFromTheme = undocumented7(boolean11);

// packages/ag-charts-community/src/chart/series/polar/donutSeriesOptionsDef.ts
var donutSeriesThemeableOptionsDef = {
  ...pieSeriesThemeableOptionsDef,
  innerRadiusOffset: number11,
  innerRadiusRatio: ratio5,
  innerCircle: {
    fill: string12,
    fillOpacity: ratio5
  },
  innerLabels: {
    spacing: positiveNumber8,
    ...fontOptionsDef4,
    ...labelBoxOptionsDef3
  }
};
var donutSeriesOptionsDef = {
  ...donutSeriesThemeableOptionsDef,
  ...pieSeriesOptionsDef,
  type: required10(constant9("donut")),
  innerLabels: arrayOfDefs4(
    {
      text: required10(string12),
      spacing: positiveNumber8,
      ...fontOptionsDef4,
      ...labelBoxOptionsDef3
    },
    "inner label options array"
  )
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var NewDonutSeriesModule = {
  type: "series",
  name: "donut",
  chartType: "polar",
  options: donutSeriesOptionsDef,
  create: (ctx) => new DonutSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeries = class extends DonutSeries {
};
PieSeries.className = "PieSeries";
PieSeries.type = "pie";

// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var NewPieSeriesModule = {
  type: "series",
  name: "pie",
  chartType: "polar",
  options: pieSeriesOptionsDef,
  create: (ctx) => new PieSeries(ctx)
};

// packages/ag-charts-community/src/module/axisModules.ts
import {
  and as and5,
  arrayOfDefs as arrayOfDefs6,
  attachDescription as attachDescription4,
  boolean as boolean13,
  color as color6,
  constant as constant10,
  date as date4,
  fontOptionsDef as fontOptionsDef6,
  greaterThan as greaterThan5,
  labelBoxOptionsDef as labelBoxOptionsDef5,
  lessThan as lessThan5,
  number as number13,
  or as or5,
  positiveNumber as positiveNumber10,
  positiveNumberNonZero as positiveNumberNonZero2,
  ratio as ratio7,
  required as required12,
  union as union10
} from "ag-charts-core";

// packages/ag-charts-community/src/chart/axesOptionsDefs.ts
import {
  and as and4,
  arrayLength as arrayLength4,
  arrayOf as arrayOf6,
  arrayOfDefs as arrayOfDefs5,
  attachDescription as attachDescription3,
  boolean as boolean12,
  callback as callback4,
  callbackDefs as callbackDefs4,
  callbackOf as callbackOf2,
  color as color5,
  date as date3,
  defined as defined5,
  fillOptionsDef as fillOptionsDef7,
  fontOptionsDef as fontOptionsDef5,
  greaterThan as greaterThan4,
  labelBoxOptionsDef as labelBoxOptionsDef4,
  lessThan as lessThan4,
  lineDashOptionsDef as lineDashOptionsDef9,
  number as number12,
  object as object2,
  optionsDefs as optionsDefs3,
  or as or4,
  positiveNumber as positiveNumber9,
  positiveNumberNonZero,
  ratio as ratio6,
  required as required11,
  string as string13,
  strokeOptionsDef as strokeOptionsDef9,
  themeOperator,
  undocumented as undocumented8,
  union as union9
} from "ag-charts-core";
var timeIntervalUnit = union9("millisecond", "second", "minute", "hour", "day", "month", "year");
var timeIntervalDefs = {
  unit: required11(timeIntervalUnit),
  step: positiveNumberNonZero,
  epoch: date3,
  utc: boolean12
};
timeIntervalDefs.every = callback4;
var timeInterval2 = optionsDefs3(timeIntervalDefs, "a time interval object");
var commonCrossLineLabelOptionsDefs = {
  enabled: boolean12,
  text: string13,
  padding: number12,
  ...fontOptionsDef5
};
var commonCrossLineOptionsDefs = attachDescription3(
  {
    enabled: boolean12,
    type: required11(union9("line", "range")),
    range: and4(
      attachDescription3((_, { options }) => options.type === "range", "crossLine type to be 'range'"),
      arrayOf6(defined5),
      arrayLength4(2, 2)
    ),
    value: and4(
      attachDescription3((_, { options }) => options.type === "line", "crossLine type to be 'line'"),
      defined5
    ),
    label: commonCrossLineLabelOptionsDefs,
    fill: color5,
    fillOpacity: ratio6,
    ...strokeOptionsDef9,
    ...lineDashOptionsDef9
  },
  "cross-line options"
);
var cartesianCrossLineOptionsDefs = {
  ...commonCrossLineOptionsDefs,
  label: {
    ...commonCrossLineLabelOptionsDefs,
    position: union9(
      "top",
      "left",
      "right",
      "bottom",
      "top-left",
      "top-right",
      "bottom-left",
      "bottom-right",
      "inside",
      "inside-left",
      "inside-right",
      "inside-top",
      "inside-bottom",
      "inside-top-left",
      "inside-bottom-left",
      "inside-top-right",
      "inside-bottom-right"
    ),
    rotation: number12
  }
};
var commonAxisLabelOptionsDefs = {
  enabled: boolean12,
  rotation: number12,
  avoidCollisions: boolean12,
  minSpacing: positiveNumber9,
  spacing: positiveNumber9,
  formatter: callback4,
  itemStyler: undocumented8(
    callbackDefs4({
      ...fontOptionsDef5,
      ...labelBoxOptionsDef4,
      spacing: number12
    })
  ),
  ...fontOptionsDef5,
  ...labelBoxOptionsDef4
};
var cartesianAxisLabelOptionsDefs = {
  autoRotate: boolean12,
  autoRotateAngle: number12,
  wrapping: union9("never", "always", "hyphenate", "on-space"),
  truncate: boolean12,
  ...commonAxisLabelOptionsDefs
};
var cartesianNumericAxisLabel = {
  format: numberFormatValidator,
  ...cartesianAxisLabelOptionsDefs
};
var cartesianTimeAxisLabel = {
  format: or4(string13, object2),
  ...cartesianAxisLabelOptionsDefs
};
var cartesianAxisTick = {
  enabled: boolean12,
  width: positiveNumber9,
  size: positiveNumber9,
  stroke: color5
};
var cartesianTimeAxisParentLevel = {
  enabled: boolean12,
  label: cartesianTimeAxisLabel,
  tick: cartesianAxisTick
};
var commonAxisIntervalOptionsDefs = {
  values: arrayOf6(defined5),
  minSpacing: positiveNumber9
};
var commonAxisOptionsDefs = {
  reverse: boolean12,
  gridLine: {
    enabled: boolean12,
    width: positiveNumber9,
    style: arrayOfDefs5(
      {
        fill: color5,
        fillOpacity: positiveNumber9,
        stroke: or4(color5, themeOperator),
        strokeWidth: positiveNumber9,
        lineDash: arrayOf6(positiveNumber9)
      },
      "a grid-line style object array"
    )
  },
  interval: commonAxisIntervalOptionsDefs,
  label: commonAxisLabelOptionsDefs,
  line: {
    enabled: boolean12,
    width: positiveNumber9,
    stroke: color5
  },
  tick: cartesianAxisTick,
  context: () => true
};
commonAxisOptionsDefs.layoutConstraints = undocumented8({
  stacked: required11(boolean12),
  align: required11(union9("start", "end")),
  unit: required11(union9("percent", "px")),
  width: required11(positiveNumber9)
});
var cartesianAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  keys: arrayOf6(string13),
  crossLines: arrayOfDefs5(cartesianCrossLineOptionsDefs, "a cross-line options array"),
  position: union9("top", "right", "bottom", "left"),
  thickness: positiveNumber9,
  maxThicknessRatio: ratio6,
  title: {
    enabled: boolean12,
    text: string13,
    spacing: positiveNumber9,
    formatter: callback4,
    ...fontOptionsDef5
  }
};
cartesianAxisOptionsDefs.title._enabledFromTheme = undocumented8(boolean12);
var cartesianAxisBandHighlightOptions = {
  enabled: boolean12,
  ...fillOptionsDef7,
  ...strokeOptionsDef9,
  ...lineDashOptionsDef9
};
function cartesianAxisCrosshairOptions(canFormat, timeFormat) {
  const baseCrosshairLabel = {
    enabled: boolean12,
    xOffset: number12,
    yOffset: number12,
    formatter: callbackOf2(string13),
    renderer: callbackOf2(
      or4(
        string13,
        optionsDefs3(
          {
            text: string13,
            color: color5,
            backgroundColor: color5,
            opacity: ratio6
          },
          "crosshair label renderer result object"
        )
      )
    )
  };
  let crosshairLabel;
  if (canFormat) {
    crosshairLabel = {
      ...baseCrosshairLabel,
      format: timeFormat ? or4(
        string13,
        optionsDefs3({
          millisecond: string13,
          second: string13,
          hour: string13,
          day: string13,
          month: string13,
          year: string13
        })
      ) : string13
    };
  }
  return {
    enabled: boolean12,
    snap: boolean12,
    label: crosshairLabel ?? baseCrosshairLabel,
    ...strokeOptionsDef9,
    ...lineDashOptionsDef9
  };
}
function continuousAxisOptions(validDatum, supportTimeInterval) {
  return {
    min: and4(validDatum, lessThan4("max")),
    max: and4(validDatum, greaterThan4("min")),
    nice: boolean12,
    interval: {
      step: supportTimeInterval ? or4(positiveNumberNonZero, timeIntervalUnit, timeInterval2) : positiveNumberNonZero,
      values: arrayOf6(validDatum),
      minSpacing: and4(positiveNumber9, lessThan4("maxSpacing")),
      maxSpacing: and4(positiveNumber9, greaterThan4("minSpacing"))
    }
  };
}
var discreteTimeAxisIntervalOptionsDefs = {
  step: or4(positiveNumberNonZero, timeIntervalUnit, timeInterval2),
  values: arrayOf6(or4(number12, date3)),
  minSpacing: and4(positiveNumber9, lessThan4("maxSpacing")),
  maxSpacing: and4(positiveNumber9, greaterThan4("minSpacing")),
  placement: union9("on", "between")
};

// packages/ag-charts-community/src/chart/axis/discreteTimeAxis.ts
var DiscreteTimeAxis = class extends CategoryAxis {
  calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks) {
    const { gridLine, horizontal, interval, range: range3 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks);
    }
    const prevTick = ticks[index - 1];
    const offset = prevTick ? translation - (translation - prevTick.translation) / 2 : range3[0];
    const [x1, y1, x2, y2] = horizontal ? [offset, Math.max(p1, p2), offset, Math.min(p1, p2)] : [Math.min(p1, p2), offset, Math.max(p1, p2), offset];
    const { style } = gridLine;
    const { stroke: stroke2, strokeWidth = 0, lineDash } = style[tickIndex % style.length] ?? {};
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
  }
  calculateGridFills(ticks, p1, p2) {
    if (this.interval.placement !== "between") {
      return super.calculateGridFills(ticks, p1, p2);
    }
    return ticks.map((tick, index) => this.calculateGridFill(tick, index, tick.index, p1, p2, ticks));
  }
  calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks) {
    const { gridLine, horizontal, interval, range: range3 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks);
    }
    const prevTick = ticks[index - 1];
    const nextTick = ticks[index + 1];
    const startOffset = prevTick ? translation - (translation - prevTick.translation) / 2 : range3[0];
    const endOffset = nextTick ? translation + (nextTick.translation - translation) / 2 : range3[1];
    const [x1, y1, x2, y2] = horizontal ? [startOffset, Math.max(p1, p2), endOffset, Math.min(p1, p2)] : [Math.min(p1, p2), startOffset, Math.max(p1, p2), endOffset];
    const { fill, fillOpacity } = gridLine.style[gridFillIndex % gridLine.style.length] ?? {};
    return { tickId, x1, y1, x2, y2, fill, fillOpacity };
  }
  calculateTickLine({ primary, tickId, translation }, index, direction, ticks) {
    const { horizontal, interval, primaryTick, range: range3, tick } = this;
    if (interval.placement !== "between") {
      return super.calculateTickLine({ primary, tickId, translation }, index, direction, ticks);
    }
    const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
    const h = -direction * this.getTickSize(datumTick);
    const prevTick = ticks[index - 1];
    const offset = prevTick ? translation - (translation - prevTick.translation) / 2 : range3[0];
    const [x1, y1, x2, y2] = horizontal ? [offset, 0, offset, h] : [0, offset, h, offset];
    const { stroke: stroke2, width: strokeWidth } = datumTick;
    const lineDash = void 0;
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
  }
};

// packages/ag-charts-community/src/chart/axis/unitTimeAxis.ts
var UnitTimeAxis = class extends DiscreteTimeAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new UnitTimeScale(), false);
    this.parentLevel = new TimeAxisParentLevel();
    this.min = void 0;
    this.max = void 0;
    // eslint-disable-next-line sonarjs/use-type-alias
    this.unit = void 0;
    this.defaultUnit = void 0;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  isCategoryLike() {
    return true;
  }
  processData() {
    super.processData();
    let defaultUnit;
    const { domain } = this.dataDomain;
    if (domain.length === 2 && domain[0].valueOf() === domain[1].valueOf()) {
      defaultUnit = lowestGranularityUnitForValue(domain[0]);
    } else {
      const { boundSeries, direction, min, max } = this;
      defaultUnit = calculateDefaultUnit(boundSeries, direction, min, max);
    }
    if (!objectsEqual(this.defaultUnit, defaultUnit)) {
      this.defaultUnit = defaultUnit;
    }
  }
  updateScale() {
    super.updateScale();
    this.scale.interval = this.unit ?? this.defaultUnit;
  }
  normaliseDataDomain(domain) {
    return normaliseTimeDataDomain(domain, this.min, this.max);
  }
  createDatumFormatter(_domain, _ticks) {
    const timeInterval3 = this.scale.interval;
    const { format } = this.label;
    if (format == null)
      return;
    const specifier = labelSpecifier(
      timeInterval3 != null ? deriveTimeSpecifier(format, intervalUnit(timeInterval3)) : format,
      timeInterval3
    );
    if (specifier == null)
      return;
    return buildDateFormatter(specifier);
  }
  tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
    timeInterval3 ?? (timeInterval3 = lowestGranularityUnitForTicks(ticks));
    const truncateDate = dateTruncationForDomain(domain);
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return { type: "date", unit, step, epoch, truncateDate };
  }
  datumFormatParams(value, params, _fractionDigits, timeInterval3, style) {
    const interval = this.unit ?? this.defaultUnit ?? "millisecond";
    value = intervalFloor(interval, value);
    if (typeof value === "number")
      value = new Date(value);
    timeInterval3 ?? (timeInterval3 = interval);
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return {
      type: "date",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      unit,
      step,
      epoch,
      style
    };
  }
};
UnitTimeAxis.className = "UnitTimeAxis";
UnitTimeAxis.type = "unit-time";
__decorateClass([
  Property
], UnitTimeAxis.prototype, "parentLevel", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "min", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "max", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "unit", 2);

// packages/ag-charts-community/src/module/axisModules.ts
var numberAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(number13),
  type: required12(constant10("number")),
  label: cartesianNumericAxisLabel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var logAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(number13),
  type: required12(constant10("log")),
  base: and5(
    positiveNumberNonZero2,
    attachDescription4((value) => value !== 1, "not equal to 1")
  ),
  label: cartesianNumericAxisLabel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var timeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(or5(number13, date4), true),
  type: required12(constant10("time")),
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  crosshair: cartesianAxisCrosshairOptions(true, true)
};
var categoryAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required12(constant10("category")),
  label: cartesianAxisLabelOptionsDefs,
  paddingInner: ratio7,
  paddingOuter: ratio7,
  groupPaddingInner: ratio7,
  crosshair: cartesianAxisCrosshairOptions(),
  bandHighlight: cartesianAxisBandHighlightOptions,
  interval: {
    ...commonAxisIntervalOptionsDefs,
    placement: union10("on", "between")
  }
};
var groupedCategoryAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required12(constant10("grouped-category")),
  label: cartesianAxisLabelOptionsDefs,
  crosshair: cartesianAxisCrosshairOptions(),
  bandHighlight: cartesianAxisBandHighlightOptions,
  paddingInner: ratio7,
  groupPaddingInner: ratio7,
  depthOptions: arrayOfDefs6(
    {
      label: {
        enabled: boolean13,
        avoidCollisions: boolean13,
        wrapping: union10("never", "always", "hyphenate", "on-space"),
        truncate: boolean13,
        rotation: number13,
        spacing: number13,
        ...fontOptionsDef6,
        ...labelBoxOptionsDef5
      },
      tick: {
        enabled: boolean13,
        stroke: color6,
        width: positiveNumber10
      }
    },
    "depth options objects array"
  )
};
var unitTimeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required12(constant10("unit-time")),
  unit: or5(timeInterval2, timeIntervalUnit),
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  paddingInner: ratio7,
  paddingOuter: ratio7,
  groupPaddingInner: ratio7,
  crosshair: cartesianAxisCrosshairOptions(true, true),
  bandHighlight: cartesianAxisBandHighlightOptions,
  min: and5(or5(number13, date4), lessThan5("max")),
  max: and5(or5(number13, date4), greaterThan5("min")),
  interval: discreteTimeAxisIntervalOptionsDefs
};
var NumberAxisModule = {
  type: "axis",
  name: "number",
  chartType: "cartesian",
  options: numberAxisOptionsDefs,
  create: (ctx) => new NumberAxis(ctx)
};
var LogAxisModule = {
  type: "axis",
  name: "log",
  chartType: "cartesian",
  options: logAxisOptionsDefs,
  create: (ctx) => new LogAxis(ctx)
};
var TimeAxisModule = {
  type: "axis",
  name: "time",
  chartType: "cartesian",
  options: timeAxisOptionsDefs,
  create: (ctx) => new TimeAxis(ctx)
};
var CategoryAxisModule = {
  type: "axis",
  name: "category",
  chartType: "cartesian",
  options: categoryAxisOptionsDefs,
  create: (ctx) => new CategoryAxis(ctx)
};
var GroupedCategoryAxisModule = {
  type: "axis",
  name: "grouped-category",
  chartType: "cartesian",
  options: groupedCategoryAxisOptionsDefs,
  create: (ctx) => new GroupedCategoryAxis(ctx)
};
var UnitTimeAxisModule = {
  type: "axis",
  name: "unit-time",
  chartType: "cartesian",
  options: unitTimeAxisOptionsDefs,
  create: (ctx) => new UnitTimeAxis(ctx)
};

// packages/ag-charts-community/src/main-modules.ts
import { ModuleRegistry as ModuleRegistry2 } from "ag-charts-core";
var AllCartesianCommunityModules = [
  CartesianChartModule,
  NumberAxisModule,
  LogAxisModule,
  TimeAxisModule,
  CategoryAxisModule,
  GroupedCategoryAxisModule,
  UnitTimeAxisModule,
  NewAreaSeriesModule,
  NewBarSeriesModule,
  NewBubbleSeriesModule,
  NewHistogramSeriesModule,
  NewLineSeriesModule,
  NewScatterSeriesModule
];
var AllPolarCommunityModules = [PolarChartModule, NewDonutSeriesModule, NewPieSeriesModule];
var AllCommunityModules = [
  ...AllCartesianCommunityModules,
  ...AllPolarCommunityModules,
  // Enterprise placeholders
  StandaloneChartModule,
  TopologyChartModule,
  // Presets
  PriceVolumePresetModule,
  GaugePresetModule,
  SparklinePresetModule
];
export {
  AllCartesianCommunityModules,
  AllCommunityModules,
  AllPolarCommunityModules,
  CartesianChartModule,
  CategoryAxisModule,
  GroupedCategoryAxisModule,
  LogAxisModule,
  ModuleRegistry2 as ModuleRegistry,
  NewAreaSeriesModule,
  NewBarSeriesModule,
  NewBubbleSeriesModule,
  NewDonutSeriesModule,
  NewHistogramSeriesModule,
  NewLineSeriesModule,
  NewPieSeriesModule,
  NewScatterSeriesModule,
  NumberAxisModule,
  PolarChartModule,
  TimeAxisModule,
  UnitTimeAxisModule
};
