(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define("agCharts", [], f);
    } else if ("object" == typeof exports) {
      exports["agCharts"] = f();
    } else {
      g["agCharts"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
if (typeof require === 'undefined') {
    function require(name) {
        
        throw new Error('Unknown module: ' + name);
    }
}
        
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/ag-charts-enterprise/dist/package/main.esm.mjs
var main_esm_exports = {};
__export(main_esm_exports, {
  AG_CHARTS_LOCALE_EN_US: () => AG_CHARTS_LOCALE_EN_US,
  AgCharts: () => AgCharts,
  AgChartsCommunityModule: () => AgChartsCommunityModule,
  AgChartsEnterpriseModule: () => AgChartsEnterpriseModule,
  AgErrorBarSupportedSeriesTypes: () => AgErrorBarSupportedSeriesTypes,
  AgTooltipAnchorToType: () => AgTooltipAnchorToType,
  AgTooltipPlacementType: () => AgTooltipPlacementType,
  LicenseManager: () => LicenseManager2,
  VERSION: () => VERSION,
  _ModuleSupport: () => module_support_exports,
  _Scene: () => integrated_charts_scene_exports,
  _Theme: () => integrated_charts_theme_exports,
  _Util: () => integrated_charts_util_exports,
  _Widget: () => exports_exports,
  setupCommunityModules: () => registerInbuiltModules,
  setupEnterpriseModules: () => setupEnterpriseModules2,
  time: () => time2
});
module.exports = __toCommonJS(main_esm_exports);

// packages/ag-charts-core/src/globals/logger.ts
var logger_exports = {};
__export(logger_exports, {
  error: () => error,
  errorOnce: () => errorOnce,
  log: () => log,
  logGroup: () => logGroup,
  reset: () => reset,
  table: () => table,
  warn: () => warn,
  warnOnce: () => warnOnce
});
var doOnceCache = /* @__PURE__ */ new Set();
function log(...logContent) {
  console.log(...logContent);
}
function warn(message, ...logContent) {
  console.warn(`AG Charts - ${message}`, ...logContent);
}
function error(message, ...logContent) {
  if (typeof message === "object") {
    console.error(`AG Charts error`, message, ...logContent);
  } else {
    console.error(`AG Charts - ${message}`, ...logContent);
  }
}
function table(...logContent) {
  console.table(...logContent);
}
function guardOnce(messageOrError, prefix, cb) {
  let message;
  if (messageOrError instanceof Error) {
    message = messageOrError.message;
  } else if (typeof messageOrError === "string") {
    message = messageOrError;
  } else if (typeof messageOrError === "object") {
    message = JSON.stringify(messageOrError);
  } else {
    message = String(messageOrError);
  }
  const cacheKey = `${prefix}: ${message}`;
  if (doOnceCache.has(cacheKey))
    return;
  cb(messageOrError);
  doOnceCache.add(cacheKey);
}
function warnOnce(messageOrError, ...logContent) {
  guardOnce(messageOrError, "Logger.warn", (message) => warn(message, ...logContent));
}
function errorOnce(messageOrError, ...logContent) {
  guardOnce(messageOrError, "Logger.error", (message) => error(message, ...logContent));
}
function reset() {
  doOnceCache.clear();
}
function logGroup(name, cb) {
  console.groupCollapsed(name);
  try {
    return cb();
  } finally {
    console.groupEnd();
  }
}

// packages/ag-charts-core/src/globals/moduleRegistry.ts
var moduleRegistry_exports = {};
__export(moduleRegistry_exports, {
  detectChartDefinition: () => detectChartDefinition,
  getAxisModule: () => getAxisModule,
  getPresetModule: () => getPresetModule,
  getSeriesModule: () => getSeriesModule,
  hasModule: () => hasModule,
  listModulesByType: () => listModulesByType,
  register: () => register,
  registerMany: () => registerMany,
  reset: () => reset2
});
var registeredModules = /* @__PURE__ */ new Map();
function register(definition, version) {
  const { def: existingDefinition, version: existingVersion } = registeredModules.get(definition.name) ?? {};
  if (!existingDefinition) {
    registeredModules.set(definition.name, { def: definition, version });
    return;
  }
  if (!existingDefinition.enterprise && definition.enterprise && version === existingVersion) {
    registeredModules.set(definition.name, { def: definition, version });
    return;
  }
  if (existingVersion === version) {
    warn(
      [
        `AG Charts - Module '${definition.name}' already registered,',
                'ignoring (version: ${existingVersion}).`,
        `Check your code for duplicate loading of charts NPM modules.`
      ].join(" ")
    );
    return;
  }
  throw new Error(
    [
      `AG Charts - Module '${definition.name}' already registered with different version:`,
      `${existingVersion} vs ${version}`,
      ``,
      `Check your package.json for conflicting dependencies - depending on your package manager`,
      `one of these commands may help:`,
      `- npm ls ag-charts-community`,
      `- yarn why ag-charts-community`
    ].join("\n")
  );
}
function registerMany(definitions, version) {
  for (const definition of definitions) {
    register(definition, version);
  }
}
function reset2() {
  registeredModules.clear();
}
function hasModule(moduleName) {
  return registeredModules.has(moduleName);
}
function* listModulesByType(moduleType) {
  for (const definition of registeredModules.values()) {
    if (isModuleType(moduleType, definition.def)) {
      yield definition.def;
    }
  }
}
function detectChartDefinition(options) {
  for (const definition of registeredModules.values()) {
    if (isModuleType("chart" /* Chart */, definition.def) && definition.def.detect(options)) {
      return definition.def;
    }
  }
  throw new Error(
    `AG Charts - Unknown chart type; Check options are correctly structured and series types are specified`
  );
}
function getAxisModule(moduleName) {
  const definition = registeredModules.get(moduleName);
  if (isModuleType("axis" /* Axis */, definition?.def)) {
    return definition?.def;
  }
}
function getPresetModule(moduleName) {
  const definition = registeredModules.get(moduleName);
  if (isModuleType("preset" /* Preset */, definition?.def)) {
    return definition?.def;
  }
}
function getSeriesModule(moduleName) {
  const definition = registeredModules.get(moduleName);
  if (isModuleType("series" /* Series */, definition?.def)) {
    return definition?.def;
  }
}
function isModuleType(moduleType, definition) {
  return definition?.type === moduleType;
}

// packages/ag-charts-core/src/classes/eventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  /**
   * Registers an event listener.
   * @param eventName The event name to listen for.
   * @param listener The callback to be invoked on the event.
   * @returns A function to unregister the listener.
   */
  on(eventName, listener) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, /* @__PURE__ */ new Set());
    }
    this.events.get(eventName)?.add(listener);
    return () => this.off(eventName, listener);
  }
  /**
   * Unregisters an event listener.
   * @param eventName The event name to stop listening for.
   * @param listener The callback to be removed.
   */
  off(eventName, listener) {
    const eventListeners = this.events.get(eventName);
    if (eventListeners) {
      eventListeners.delete(listener);
      if (eventListeners.size === 0) {
        this.events.delete(eventName);
      }
    }
  }
  /**
   * Emits an event to all registered listeners.
   * @param eventName The name of the event to emit.
   * @param event The event payload.
   */
  emit(eventName, event) {
    this.events.get(eventName)?.forEach((callback2) => callback2(event));
  }
  /**
   * Clears all listeners for a specific event or all events if no event name is provided.
   * @param eventName (Optional) The name of the event to clear listeners for. If not provided, all listeners for all events are cleared.
   */
  clear(eventName) {
    if (eventName) {
      this.events.delete(eventName);
    } else {
      this.events.clear();
    }
  }
};

// packages/ag-charts-core/src/utils/dom/globalsProxy.ts
var verifiedGlobals = {};
if (typeof window !== "undefined") {
  verifiedGlobals.window = window;
} else if (typeof global !== "undefined") {
  verifiedGlobals.window = global.window;
}
if (typeof document !== "undefined") {
  verifiedGlobals.document = document;
} else if (typeof global !== "undefined") {
  verifiedGlobals.document = global.document;
}
function getDocument(propertyName) {
  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;
}
function getWindow(propertyName) {
  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;
}
function setDocument(document2) {
  verifiedGlobals.document = document2;
}
function setWindow(window2) {
  verifiedGlobals.window = window2;
}

// packages/ag-charts-core/src/utils/dom/domElements.ts
function createElement(tagName, className, style2) {
  const element2 = getDocument().createElement(tagName);
  if (typeof className === "object") {
    style2 = className;
    className = void 0;
  }
  if (className) {
    for (const name of className.split(" ")) {
      element2.classList.add(name);
    }
  }
  if (style2) {
    Object.assign(element2.style, style2);
  }
  return element2;
}
function createSvgElement(elementName) {
  return getDocument().createElementNS("http://www.w3.org/2000/svg", elementName);
}

// packages/ag-charts-core/src/utils/dom/domDownload.ts
function downloadUrl(dataUrl, fileName) {
  const body = getDocument("body");
  const element2 = createElement("a", { display: "none" });
  element2.href = dataUrl;
  element2.download = fileName;
  body.appendChild(element2);
  element2.click();
  setTimeout(() => body.removeChild(element2));
}

// packages/ag-charts-core/src/utils/dom/domEvents.ts
function attachListener(element2, eventName, handler, options) {
  element2.addEventListener(eventName, handler, options);
  return () => element2.removeEventListener(eventName, handler, options);
}

// packages/ag-charts-core/src/utils/dom/domUtils.ts
var style;
function parseColor(color2) {
  if (style == null) {
    const OptionConstructor = getWindow("Option");
    style = new OptionConstructor().style;
  }
  style.color = color2;
  return style.color || null;
}

// packages/ag-charts-core/src/utils/typeGuards.ts
function isDefined(val) {
  return val != null;
}
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isDate(value) {
  return value instanceof Date;
}
function isValidDate(value) {
  return isDate(value) && !isNaN(Number(value));
}
function isRegExp(value) {
  return value instanceof RegExp;
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return typeof value === "object" && value !== null && !isArray(value);
}
function isObjectLike(value) {
  return isArray(value) || isPlainObject(value);
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && value.constructor?.name === "Object";
}
function isEmptyObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  for (const _ in value) {
    return false;
  }
  return true;
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isFiniteNumber(value) {
  return Number.isFinite(value);
}
function isHtmlElement(value) {
  return typeof window !== "undefined" && value instanceof HTMLElement;
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function isColor(value) {
  return isString(value) && (value === "none" || parseColor(value) != null);
}
function isKeyOf(value, container) {
  return value in container;
}

// packages/ag-charts-core/src/utils/functions.ts
function debounce(callback2, waitMs = 0, options) {
  const { leading = false, trailing = true, maxWait = Infinity } = options ?? {};
  let timerId;
  let startTime;
  if (maxWait < waitMs) {
    throw new Error("Value of maxWait cannot be lower than waitMs.");
  }
  function debounceCallback(...args) {
    if (leading && !startTime) {
      startTime = Date.now();
      timerId = setTimeout(() => startTime = null, waitMs);
      callback2(...args);
      return;
    }
    let adjustedWaitMs = waitMs;
    if (maxWait !== Infinity && startTime) {
      const elapsedTime = Date.now() - startTime;
      if (waitMs > maxWait - elapsedTime) {
        adjustedWaitMs = maxWait - elapsedTime;
      }
    }
    clearTimeout(timerId);
    startTime ?? (startTime = Date.now());
    timerId = setTimeout(() => {
      startTime = null;
      if (trailing) {
        callback2(...args);
      }
    }, adjustedWaitMs);
  }
  return Object.assign(debounceCallback, {
    cancel() {
      clearTimeout(timerId);
      startTime = null;
    }
  });
}
function throttle(callback2, waitMs, options) {
  const { leading = true, trailing = true } = options ?? {};
  let timerId;
  let lastArgs;
  let shouldWait = false;
  function timeoutHandler() {
    if (trailing && lastArgs) {
      timerId = setTimeout(timeoutHandler, waitMs);
      callback2(...lastArgs);
    } else {
      shouldWait = false;
    }
    lastArgs = null;
  }
  function throttleCallback(...args) {
    if (shouldWait) {
      lastArgs = args;
    } else {
      shouldWait = true;
      timerId = setTimeout(timeoutHandler, waitMs);
      if (leading) {
        callback2(...args);
      } else {
        lastArgs = args;
      }
    }
  }
  return Object.assign(throttleCallback, {
    cancel() {
      clearTimeout(timerId);
      shouldWait = false;
      lastArgs = null;
    }
  });
}
function safeCall(callback2, args, errorPath = "") {
  try {
    return callback2(...args);
  } catch (error2) {
    const postfix = errorPath ? ` \`${errorPath}\`` : "";
    warnOnce(`Uncaught exception in user callback${postfix}`, error2);
  }
}

// packages/ag-charts-core/src/utils/strings.ts
function joinFormatted(values, conjunction = "and", format = String, maxItems = Infinity) {
  if (values.length === 0) {
    return "";
  } else if (values.length === 1) {
    return format(values[0]);
  }
  values = values.map(format);
  const lastValue = values.pop();
  if (values.length >= maxItems) {
    const remainingCount = values.length - (maxItems - 1);
    return `${values.slice(0, maxItems - 1).join(", ")}, and ${remainingCount} more ${conjunction} ${lastValue}`;
  }
  return `${values.join(", ")} ${conjunction} ${lastValue}`;
}
function stringifyValue(value, maxLength = Infinity) {
  if (typeof value === "number") {
    if (isNaN(value)) {
      return "NaN";
    } else if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    }
  }
  const strValue = JSON.stringify(value) ?? typeof value;
  if (strValue.length > maxLength) {
    return `${strValue.slice(0, maxLength)}... (+${strValue.length - maxLength} characters)`;
  }
  return strValue;
}
function countLines(text2) {
  let count = 1;
  for (let i = 0; i < text2.length; i++) {
    if (text2.charCodeAt(i) === 10) {
      count++;
    }
  }
  return count;
}
function levenshteinDistance(a, b) {
  if (a === b)
    return 0;
  const [shorter, longer] = a.length < b.length ? [a, b] : [b, a];
  const m = shorter.length;
  const n = longer.length;
  let prevRow = new Array(m + 1).fill(0).map((_, i) => i);
  let currRow = new Array(m + 1);
  for (let i = 1; i <= n; i++) {
    currRow[0] = i;
    for (let j = 1; j <= m; j++) {
      const cost = longer[i - 1] === shorter[j - 1] ? 0 : 1;
      currRow[j] = Math.min(
        prevRow[j] + 1,
        // Deletion
        currRow[j - 1] + 1,
        // Insertion
        prevRow[j - 1] + cost
        // Substitution
      );
    }
    [prevRow, currRow] = [currRow, prevRow];
  }
  return prevRow[m];
}
function kebabCase(a) {
  return a.replace(KEBAB_CASE_REGEX, (match, offset) => (offset > 0 ? "-" : "") + match.toLowerCase());
}
var KEBAB_CASE_REGEX = /[A-Z]+(?![a-z])|[A-Z]/g;
function toPlainText(text2) {
  if (isArray(text2)) {
    return text2.map((segment) => segment.text).join("");
  }
  return text2 ?? "";
}

// packages/ag-charts-core/src/utils/validation.ts
var descriptionSymbol = Symbol("description");
var requiredSymbol = Symbol("required");
var markedSymbol = Symbol("marked");
var undocumentedSymbol = Symbol("undocumented");
var unionSymbol = Symbol("union");
var similarOptionsMap = [
  ["placement", "position"],
  ["padding", "spacing", "gap"],
  ["color", "fill", "stroke"],
  ["whisker", "wick"],
  ["nodeClick", "seriesNodeClick"],
  ["nodeDoubleClick", "seriesNodeDoubleClick"],
  ["src", "url"]
].reduce((map, words) => {
  for (const word of words) {
    map.set(word.toLowerCase(), new Set(words.filter((w) => w !== word)));
  }
  return map;
}, /* @__PURE__ */ new Map());
function extendPath(path, key) {
  if (isFiniteNumber(key)) {
    return `${path}[${key}]`;
  }
  return path ? `${path}.${key}` : key;
}
var ValidationError = class {
  constructor(type, description, value, path, key) {
    this.type = type;
    this.description = description;
    this.value = value;
    this.path = path;
    this.key = key;
  }
  setUnionType(unionType, path) {
    if (this.path.startsWith(path)) {
      const suffix = this.path.slice(path.length);
      this.altPath = `${path}[type=${unionType}]${suffix}`;
    }
  }
  getPrefix() {
    const { altPath: path = this.path, key } = this;
    if (!path && !key)
      return "Value";
    return `Option \`${key ? extendPath(path, key) : path}\``;
  }
  toString() {
    const { description = "unknown", type, value } = this;
    if (type === "required" /* Required */ && value == null) {
      return `${this.getPrefix()} is required and has not been provided; expecting ${description}, ignoring.`;
    }
    return `${this.getPrefix()} cannot be set to \`${stringifyValue(value, 50)}\`; expecting ${description}, ignoring.`;
  }
};
var UnknownError = class extends ValidationError {
  constructor(suggestions, value, path, key) {
    super("unknown" /* Unknown */, void 0, value, path, key);
    this.suggestions = suggestions;
    this.key = key;
  }
  getPrefix() {
    return `Unknown option \`${extendPath(this.altPath ?? this.path, this.key)}\``;
  }
  getPostfix() {
    const suggestions = joinFormatted(findSuggestions(this.key, this.suggestions), "or", (val) => `\`${val}\``);
    return suggestions ? `; Did you mean ${suggestions}? Ignoring.` : ", ignoring.";
  }
  toString() {
    return `${this.getPrefix()}${this.getPostfix()}`;
  }
};
function validate(options, optionsDefs2, path = "") {
  if (!isObject(options)) {
    return { cleared: null, invalid: [new ValidationError("required" /* Required */, "an object", options, path)] };
  }
  const cleared = {};
  const invalid = [];
  const optionsKeys = new Set(Object.keys(options));
  const unusedKeys = [];
  if (unionSymbol in optionsDefs2) {
    const validTypes = Object.keys(optionsDefs2);
    const defaultType = optionsDefs2[unionSymbol];
    if (options.type != null && validTypes.includes(options.type) || options.type == null && defaultType != null) {
      const { type = defaultType, ...rest } = options;
      const nestedResult = validate(rest, optionsDefs2[type], path);
      Object.assign(cleared, { type }, nestedResult.cleared);
      for (const error2 of nestedResult.invalid) {
        error2.setUnionType(type, path);
      }
      invalid.push(...nestedResult.invalid);
    } else {
      const keywords = joinFormatted(validTypes, "or", (val) => `'${val}'`);
      invalid.push(
        new ValidationError("required" /* Required */, `a keyword such as ${keywords}`, options.type, path, "type")
      );
    }
    return { cleared, invalid };
  }
  for (const key of Object.keys(optionsDefs2)) {
    const validatorOrDefs = optionsDefs2[key];
    const required3 = validatorOrDefs[requiredSymbol];
    const value = options[key];
    optionsKeys.delete(key);
    if (typeof value === "undefined") {
      if (!validatorOrDefs[undocumentedSymbol]) {
        unusedKeys.push(key);
      }
      if (!required3)
        continue;
    }
    const keyPath = extendPath(path, key);
    if (isFunction(validatorOrDefs)) {
      const context = { options, path: keyPath };
      const validatorResult = validatorOrDefs(value, context);
      const objectResult = typeof validatorResult === "object";
      if (objectResult) {
        invalid.push(...validatorResult.invalid);
        if (validatorResult.valid) {
          cleared[key] = validatorResult.cleared;
          continue;
        } else if (hasRequiredInPath(validatorResult.invalid, keyPath)) {
          continue;
        }
      } else if (validatorResult) {
        cleared[key] = value;
        continue;
      }
      invalid.push(
        new ValidationError(
          required3 ? "required" /* Required */ : "invalid" /* Invalid */,
          validatorOrDefs[descriptionSymbol],
          value,
          path,
          key
        )
      );
    } else {
      const nestedResult = validate(value, validatorOrDefs, keyPath);
      if (nestedResult.cleared != null) {
        cleared[key] = nestedResult.cleared;
      }
      invalid.push(...nestedResult.invalid);
    }
  }
  for (const key of optionsKeys) {
    const value = options[key];
    if (typeof value === "undefined")
      continue;
    invalid.push(new UnknownError(unusedKeys, value, path, key));
  }
  return { cleared, invalid };
}
function findSuggestions(value, suggestions, maxDistance = 2) {
  const result = [];
  const lowerCaseValue = value.toLowerCase();
  const similarValues = similarOptionsMap.get(lowerCaseValue);
  for (const key of suggestions) {
    const lowerCaseKey = key.toLowerCase();
    if (similarValues?.has(key) || lowerCaseKey.includes(lowerCaseValue) || levenshteinDistance(lowerCaseValue, lowerCaseKey) <= maxDistance) {
      result.push(key);
    }
  }
  return result;
}
function attachDescription(validatorOrDefs, description) {
  if (isFunction(validatorOrDefs)) {
    let clonedValidator2 = function(value, context) {
      return validatorOrDefs(value, context);
    };
    var clonedValidator = clonedValidator2;
    clonedValidator2[descriptionSymbol] = description;
    return clonedValidator2;
  } else {
    return { ...validatorOrDefs, [descriptionSymbol]: description };
  }
}
function required(validatorOrDefs) {
  return Object.assign(
    isFunction(validatorOrDefs) ? (value, context) => validatorOrDefs(value, context) : optionsDefs(validatorOrDefs),
    { [requiredSymbol]: true, [descriptionSymbol]: validatorOrDefs[descriptionSymbol] }
  );
}
function undocumented(validatorOrDefs) {
  return Object.assign(
    isFunction(validatorOrDefs) ? (value, context) => validatorOrDefs(value, context) : optionsDefs(validatorOrDefs),
    { [undocumentedSymbol]: true, [descriptionSymbol]: validatorOrDefs[descriptionSymbol] }
  );
}
var optionsDefs = (defs, description = "an object") => attachDescription((value, context) => {
  const result = validate(value, defs, context.path);
  const valid = !hasRequiredInPath(result.invalid, context.path);
  return { valid, cleared: result.cleared, invalid: result.invalid };
}, description);
var typeUnion = (defs, description, defaultType) => ({
  ...defs,
  [descriptionSymbol]: description,
  [unionSymbol]: defaultType
});
var and = (...validators) => attachDescription(
  (value, context) => {
    const invalid = [];
    for (const validator of validators) {
      const result = validator(value, context);
      if (typeof result === "object") {
        invalid.push(...result.invalid);
        if (!result.valid) {
          return { valid: false, cleared: value, invalid };
        }
        value = result.cleared;
      } else if (!result) {
        return false;
      }
    }
    return { valid: true, cleared: value, invalid };
  },
  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(" and ")
);
var or = (...validators) => attachDescription(
  (value, context) => {
    for (const validator of validators) {
      const result = validator(value, context);
      if (typeof result === "object" ? result.valid : result) {
        return result;
      }
    }
    return false;
  },
  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(" or ")
);
var isComparable = (value) => isFiniteNumber(value) || isValidDate(value);
var isValidDateValue = (value) => isDate(value) || (isFiniteNumber(value) || isString(value)) && isValidDate(new Date(value));
var array = attachDescription(isArray, "an array");
var boolean = attachDescription(isBoolean, "a boolean");
var callback = attachDescription(isFunction, "a function");
var color = attachDescription(isColor, "a color string");
var date = attachDescription(isValidDateValue, "a date");
var defined = attachDescription(isDefined, "a defined value");
var number = attachDescription(isFiniteNumber, "a number");
var object = attachDescription(isObject, "an object");
var string = attachDescription(isString, "a string");
var htmlElement = attachDescription(
  (value) => typeof HTMLElement === "undefined" || value instanceof HTMLElement,
  "an html element"
);
var arrayLength = (minLength, maxLength = Infinity) => {
  let message;
  if (maxLength === Infinity) {
    message = `an array of at least ${minLength} items`;
  } else if (minLength === maxLength) {
    message = `an array of exactly ${minLength} items`;
  } else if (minLength === 0) {
    message = `an array of no more than ${maxLength} items`;
  } else {
    message = `an array of at least ${minLength} and no more than ${maxLength} items`;
  }
  return attachDescription(
    (value) => isArray(value) && value.length >= minLength && value.length <= maxLength,
    message
  );
};
var stringLength = (minLength, maxLength = Infinity) => {
  let message;
  if (maxLength === Infinity) {
    message = `a string of at least ${minLength} characters`;
  } else if (minLength === maxLength) {
    message = `an string of exactly ${minLength} characters`;
  } else if (minLength === 0) {
    message = `an string of no more than ${maxLength} characters`;
  } else {
    message = `an string of at least ${minLength} and no more than ${maxLength} characters`;
  }
  return attachDescription(
    (value) => isString(value) && value.length >= minLength && value.length <= maxLength,
    message
  );
};
var numberMin = (min, inclusive = true) => attachDescription(
  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),
  `a number greater than ${inclusive ? "or equal to " : ""}${min}`
);
var numberRange = (min, max) => attachDescription(
  (value) => isFiniteNumber(value) && value >= min && value <= max,
  `a number between ${min} and ${max} inclusive`
);
var positiveNumber = numberMin(0);
var positiveNumberNonZero = numberMin(0, false);
var ratio = numberRange(0, 1);
var lessThan = (otherField) => attachDescription(
  (value, { options }) => !isComparable(value) || !isComparable(options[otherField]) || value < options[otherField],
  `the value to be less than \`${otherField}\``
);
var greaterThan = (otherField) => attachDescription(
  (value, { options }) => !isComparable(value) || !isComparable(options[otherField]) || value > options[otherField],
  `the value to be greater than \`${otherField}\``
);
function union(...allowed) {
  if (isObject(allowed[0])) {
    allowed = Object.values(allowed[0]);
  }
  const keywords = joinFormatted(allowed, "or", (value) => `'${value}'`);
  return attachDescription((value) => allowed.includes(value), `a keyword such as ${keywords}`);
}
var constant = (allowed) => attachDescription((value) => allowed === value, `the value ${JSON.stringify(allowed)}`);
var arrayOf = (validator, description, strict = true) => attachDescription(
  (value, context) => {
    if (!isArray(value))
      return false;
    let valid = strict;
    const cleared = [];
    const invalid = [];
    const setValid = (result) => valid = strict ? valid && result : valid || result;
    if (value.length === 0) {
      return { valid: true, cleared, invalid };
    }
    for (let i = 0; i < value.length; i++) {
      const options = value[i];
      const result = validator(options, { options, path: `${context.path}[${i}]` });
      if (typeof result === "object") {
        valid = setValid(result.valid);
        invalid.push(...result.invalid);
        if (result.cleared != null) {
          cleared.push(result.cleared);
        }
      } else {
        valid = setValid(result);
        if (result) {
          cleared.push(options);
        }
      }
    }
    return { valid, cleared: valid || !strict ? cleared : null, invalid };
  },
  description ?? `${validator[descriptionSymbol]} array`
);
var arrayOfDefs = (defs, description = "an object array") => attachDescription((value, context) => {
  if (!isArray(value))
    return false;
  const cleared = [];
  const invalid = [];
  for (let i = 0; i < value.length; i++) {
    const indexPath = `${context.path}[${i}]`;
    const result = validate(value[i], defs, indexPath);
    if (!hasRequiredInPath(result.invalid, indexPath)) {
      cleared.push(result.cleared);
    }
    invalid.push(...result.invalid);
  }
  return { valid: true, cleared, invalid };
}, description);
var callbackOf = (validator, description) => attachDescription((value, context) => {
  if (!isFunction(value))
    return false;
  if (markedSymbol in value)
    return true;
  const cbWithValidation = Object.assign(
    (...args) => {
      const result = safeCall(value, args);
      if (result == null)
        return;
      const validatorResult = validator(result, { options: result, path: "" });
      if (typeof validatorResult === "object") {
        validatorResult.invalid.forEach(
          callbackWarnInvalid(context, description ?? validator[descriptionSymbol])
        );
        if (validatorResult.valid) {
          return validatorResult.cleared;
        }
      } else if (validatorResult) {
        return result;
      } else {
        warnOnce(
          `Callback \`${context.path}\` returned an invalid value \`${stringifyValue(result, 50)}\`; expecting ${description ?? validator[descriptionSymbol]}, ignoring.`
        );
      }
    },
    { [markedSymbol]: true }
  );
  return { valid: true, cleared: cbWithValidation, invalid: [] };
}, "a function");
var callbackDefs = (defs, description = "an object") => attachDescription((value, context) => {
  if (!isFunction(value))
    return false;
  if (markedSymbol in value)
    return true;
  const cbWithValidation = Object.assign(
    (...args) => {
      const result = safeCall(value, args, context.path);
      if (result == null)
        return;
      const validatorResult = validate(result, defs);
      validatorResult.invalid.forEach(callbackWarnInvalid(context, description));
      return validatorResult.cleared;
    },
    { [markedSymbol]: true }
  );
  return { valid: true, cleared: cbWithValidation, invalid: [] };
}, "a function");
function hasRequiredInPath(errors, rootPath) {
  return errors.some((error2) => error2.type === "required" /* Required */ && error2.path === rootPath);
}
function callbackWarnInvalid(context, description) {
  return (error2) => {
    if (error2 instanceof UnknownError) {
      return warnOnce(
        `Callback \`${context.path}\` returned an unknown property \`${extendPath(error2.path, error2.key)}\`${error2.getPostfix()}`
      );
    }
    const errorValue = stringifyValue(error2.value, 50);
    warnOnce(
      error2.key ? `Callback \`${context.path}\` returned an invalid property \`${extendPath(error2.path, error2.key)}\`: \`${errorValue}\`; expecting ${error2.description}, ignoring.` : `Callback \`${context.path}\` returned an invalid value \`${errorValue}\`; expecting ${description ?? error2.description}, ignoring.`
    );
  };
}

// packages/ag-charts-core/src/options/commonOptionsDefs.ts
var themeOperator = (value) => {
  if (!isObject(value))
    return false;
  const keys = Object.keys(value);
  return keys.length === 1 && keys[0].startsWith("$");
};
var colorStop = optionsDefs({ color, stop: ratio }, "");
var colorStopsOrderValidator = attachDescription((value) => {
  let lastStop = -Infinity;
  for (const item of value) {
    if (item?.stop != null) {
      if (item.stop < lastStop) {
        return false;
      }
      lastStop = item.stop;
    }
  }
  return true;
}, "color stops to be defined in ascending order");
var gradientColorStops = and(arrayLength(2), arrayOf(colorStop), colorStopsOrderValidator);
var gradientBounds = union("axis", "item", "series");
var gradientStrict = optionsDefs(
  {
    type: required(constant("gradient")),
    colorStops: required(gradientColorStops),
    rotation: number,
    // @ts-expect-error undocumented options
    gradient: undocumented(union("linear", "radial", "conic")),
    bounds: undocumented(gradientBounds),
    reverse: undocumented(boolean)
  },
  "a gradient object with color stops"
);
var strokeOptionsDef = {
  stroke: color,
  strokeWidth: positiveNumber,
  strokeOpacity: ratio
};
var fillGradientDefaults = optionsDefs({
  type: required(constant("gradient")),
  gradient: required(union("linear", "radial", "conic")),
  bounds: required(gradientBounds),
  colorStops: required(or(gradientColorStops, and(arrayLength(2), arrayOf(color)))),
  rotation: required(number),
  reverse: required(boolean)
});
var fillPatternDefaults = optionsDefs({
  type: required(constant("pattern")),
  pattern: required(
    union(
      "vertical-lines",
      "horizontal-lines",
      "forward-slanted-lines",
      "backward-slanted-lines",
      "circles",
      "squares",
      "triangles",
      "diamonds",
      "stars",
      "hearts",
      "crosses"
    )
  ),
  path: stringLength(2),
  width: required(positiveNumber),
  height: required(positiveNumber),
  fill: required(color),
  fillOpacity: required(ratio),
  backgroundFill: required(color),
  backgroundFillOpacity: required(ratio),
  padding: required(positiveNumber),
  rotation: required(number),
  scale: required(positiveNumber),
  stroke: required(color),
  strokeWidth: required(positiveNumber),
  strokeOpacity: required(ratio)
});
var fillImageDefaults = optionsDefs({
  type: required(constant("image")),
  url: string,
  width: positiveNumber,
  height: positiveNumber,
  rotation: required(number),
  backgroundFill: required(color),
  backgroundFillOpacity: ratio,
  fit: required(union("stretch", "contain", "cover")),
  repeat: required(union("repeat", "repeat-x", "repeat-y", "no-repeat"))
});
var colorObject = typeUnion(
  {
    gradient: {
      colorStops: gradientColorStops,
      rotation: number,
      // @ts-expect-error undocumented option
      gradient: undocumented(union("linear", "radial", "conic")),
      bounds: undocumented(gradientBounds),
      reverse: undocumented(boolean)
    },
    pattern: {
      pattern: union(
        "vertical-lines",
        "horizontal-lines",
        "forward-slanted-lines",
        "backward-slanted-lines",
        "circles",
        "squares",
        "triangles",
        "diamonds",
        "stars",
        "hearts",
        "crosses"
      ),
      path: stringLength(2),
      width: positiveNumber,
      height: positiveNumber,
      rotation: number,
      scale: positiveNumber,
      fill: color,
      fillOpacity: ratio,
      backgroundFill: color,
      backgroundFillOpacity: ratio,
      ...strokeOptionsDef,
      // @ts-expect-error undocumented option
      padding: undocumented(positiveNumber)
    },
    image: {
      url: required(string),
      backgroundFill: color,
      backgroundFillOpacity: ratio,
      width: positiveNumber,
      height: positiveNumber,
      fit: union("stretch", "contain", "cover", "none"),
      repeat: union("repeat", "repeat-x", "repeat-y", "no-repeat"),
      rotation: number
    }
  },
  "a color object"
);
var colorUnion = or(color, optionsDefs(colorObject, "a color object"));
var fillOptionsDef = {
  fill: colorUnion,
  fillOpacity: ratio
};
fillOptionsDef.fillGradientDefaults = undocumented(fillGradientDefaults);
fillOptionsDef.fillPatternDefaults = undocumented(fillPatternDefaults);
fillOptionsDef.fillImageDefaults = undocumented(fillImageDefaults);
var lineDashOptionsDef = {
  lineDash: arrayOf(positiveNumber),
  lineDashOffset: number
};
var barHighlightOptionsDef = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  opacity: ratio,
  cornerRadius: positiveNumber
};
var lineHighlightOptionsDef = {
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  opacity: ratio
};
var shapeHighlightOptionsDef = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  opacity: ratio
};
function highlightOptionsDef(itemHighlightOptionsDef) {
  return {
    enabled: boolean,
    range: union("tooltip", "node"),
    highlightedItem: itemHighlightOptionsDef,
    unhighlightedItem: itemHighlightOptionsDef
  };
}
function multiSeriesHighlightOptionsDef(itemHighlightOptionsDef, seriesHighlightOptionsDef) {
  return {
    enabled: boolean,
    range: union("tooltip", "node"),
    highlightedItem: itemHighlightOptionsDef,
    unhighlightedItem: itemHighlightOptionsDef,
    highlightedSeries: seriesHighlightOptionsDef,
    unhighlightedSeries: seriesHighlightOptionsDef,
    bringToFront: boolean
  };
}
var googleFont = optionsDefs({ googleFont: string }, "google font");
var fontFamilyFull = or(string, themeOperator, googleFont, arrayOf(or(string, googleFont)));
var fontOptionsDef = {
  color,
  fontFamily: fontFamilyFull,
  fontSize: positiveNumber,
  fontStyle: union("normal", "italic", "oblique"),
  fontWeight: or(positiveNumber, union("normal", "bold", "bolder", "lighter"))
};
var paddingOptions = optionsDefs(
  { top: number, right: number, bottom: number, left: number },
  "padding object"
);
var padding = or(number, paddingOptions);
var borderOptionsDef = {
  enabled: boolean,
  stroke: color,
  strokeWidth: positiveNumber,
  strokeOpacity: ratio
};
var labelBoxOptionsDef = {
  border: { ...borderOptionsDef },
  cornerRadius: number,
  padding,
  ...fillOptionsDef
};

// packages/ag-charts-core/src/utils/math/shapeUtils.ts
function getMaxInnerRectSize(rotationDeg, containerWidth, containerHeight = Infinity) {
  const W = containerWidth;
  const H = containerHeight;
  const angle2 = rotationDeg % 180 * (Math.PI / 180);
  const sin = Math.abs(Math.sin(angle2));
  const cos = Math.abs(Math.cos(angle2));
  if (sin === 0)
    return { width: W, height: H };
  if (cos === 0)
    return { width: H, height: W };
  if (!isFinite(H)) {
    const r = cos / sin;
    const width2 = W / (cos + r * sin);
    return { width: width2, height: r * width2 };
  }
  const denominator = cos * cos - sin * sin;
  if (denominator === 0) {
    const side = Math.min(W, H) / Math.SQRT2;
    return { width: side, height: side };
  }
  return {
    width: Math.abs((W * cos - H * sin) / denominator),
    height: Math.abs((H * cos - W * sin) / denominator)
  };
}

// packages/ag-charts-core/src/utils/arrays.ts
function toArray(value) {
  if (typeof value === "undefined") {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function groupBy(array2, iteratee) {
  return array2.reduce((result, item) => {
    const groupKey = iteratee(item);
    result[groupKey] ?? (result[groupKey] = []);
    result[groupKey].push(item);
    return result;
  }, {});
}
function arraysEqual(a, b) {
  if (a == null || b == null || a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (Array.isArray(a[i]) && Array.isArray(b[i])) {
      if (!arraysEqual(a[i], b[i])) {
        return false;
      }
    } else if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function circularSliceArray(data, size, offset = 0) {
  if (data.length === 0) {
    return [];
  }
  const result = [];
  for (let i = 0; i < size; i++) {
    result.push(data.at((i + offset) % data.length));
  }
  return result;
}
function sortBasedOnArray(baseArray, orderArray) {
  const orderMap = /* @__PURE__ */ new Map();
  orderArray.forEach((item, index) => {
    orderMap.set(item, index);
  });
  return baseArray.sort((a, b) => {
    const indexA = orderMap.get(a) ?? Infinity;
    const indexB = orderMap.get(b) ?? Infinity;
    return indexA - indexB;
  });
}
function dropFirstWhile(array2, cond) {
  let i = 0;
  while (i < array2.length && cond(array2[i])) {
    i += 1;
  }
  const deleteCount = i;
  if (deleteCount !== 0)
    array2.splice(0, deleteCount);
}
function dropLastWhile(array2, cond) {
  let i = array2.length - 1;
  while (i >= 0 && cond(array2[i])) {
    i -= 1;
  }
  const deleteCount = array2.length - 1 - i;
  if (deleteCount !== 0)
    array2.splice(array2.length - deleteCount, deleteCount);
}

// packages/ag-charts-core/src/utils/async.ts
var AsyncAwaitQueue = class {
  constructor() {
    this.queue = [];
  }
  /** Await another async process to call notify(). */
  await(timeout = 50) {
    return new Promise((resolve) => {
      const successFn = () => {
        clearTimeout(timeoutHandle);
        resolve(true);
      };
      const timeoutFn = () => {
        const queueIndex = this.queue.indexOf(successFn);
        if (queueIndex < 0)
          return;
        this.queue.splice(queueIndex, 1);
        resolve(false);
      };
      const timeoutHandle = setTimeout(timeoutFn, timeout);
      this.queue.push(successFn);
    });
  }
  /** Trigger any await()ing async processes to continue. */
  notify() {
    this.queue.splice(0).forEach((cb) => cb());
  }
};
function pause(delayMilliseconds = 0) {
  return new Promise((resolve) => {
    setTimeout(resolve, delayMilliseconds);
  });
}

// packages/ag-charts-core/src/utils/iterators.ts
function* iterate(...iterators) {
  for (const iterator of iterators) {
    yield* iterator;
  }
}
function toIterable(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value ? value : [value];
}
function first(iterable) {
  for (const value of iterable) {
    return value;
  }
  throw new Error("AG Charts - no first() value found");
}
function* entries(obj) {
  const resultTuple = [void 0, void 0];
  for (const key of Object.keys(obj)) {
    resultTuple[0] = key;
    resultTuple[1] = obj[key];
    yield resultTuple;
  }
}

// packages/ag-charts-core/src/utils/attributeUtil.ts
function booleanParser(value) {
  return value === "true";
}
function numberParser(value) {
  return Number(value);
}
function stringParser(value) {
  return value;
}
var AttributeTypeParsers = {
  role: stringParser,
  "aria-checked": booleanParser,
  "aria-controls": stringParser,
  "aria-describedby": stringParser,
  "aria-disabled": booleanParser,
  "aria-expanded": booleanParser,
  "aria-haspopup": stringParser,
  "aria-hidden": booleanParser,
  "aria-label": stringParser,
  "aria-labelledby": stringParser,
  "aria-live": stringParser,
  "aria-orientation": stringParser,
  "aria-selected": booleanParser,
  "data-focus-override": booleanParser,
  "data-focus-visible-override": booleanParser,
  "data-preventdefault": booleanParser,
  class: stringParser,
  for: stringParser,
  id: stringParser,
  tabindex: numberParser,
  title: stringParser,
  placeholder: stringParser
};
function setAttribute(e, qualifiedName, value) {
  if (value == null || value === "" || value === "") {
    e?.removeAttribute(qualifiedName);
  } else {
    e?.setAttribute(qualifiedName, value.toString());
  }
}
function setAttributes(e, attrs) {
  if (attrs == null)
    return;
  for (const [key, value] of entries(attrs)) {
    if (key === "class")
      continue;
    setAttribute(e, key, value);
  }
}
function getAttribute(e, qualifiedName, defaultValue) {
  if (!(e instanceof HTMLElement))
    return void 0;
  const value = e.getAttribute(qualifiedName);
  if (value === null)
    return defaultValue;
  return AttributeTypeParsers[qualifiedName]?.(value) ?? void 0;
}
function setElementStyle(e, property, value) {
  if (e == null)
    return;
  if (value == null) {
    e.style.removeProperty(property);
  } else {
    e.style.setProperty(property, value.toString());
  }
}
function setElementStyles(e, styles) {
  for (const [key, value] of entries(styles)) {
    setElementStyle(e, key, value);
  }
}

// packages/ag-charts-core/src/utils/boxBounds.ts
function boxCollides(b, x, y, w, h) {
  return x < b.x + b.width && x + w > b.x && y < b.y + b.height && y + h > b.y;
}
function boxContains(b, x, y, w = 0, h = 0) {
  return x >= b.x && x + w <= b.x + b.width && y >= b.y && y + h <= b.y + b.height;
}
function boxEmpty(b) {
  return b == null || b.height === 0 || b.width === 0 || isNaN(b.height) || isNaN(b.width);
}
function boxesEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}

// packages/ag-charts-core/src/utils/binarySearch.ts
function findMaxIndex(min, max, iteratee) {
  if (min > max)
    return;
  let found;
  while (max >= min) {
    const index = Math.floor((max + min) / 2);
    const value = iteratee(index);
    if (value) {
      found = index;
      min = index + 1;
    } else {
      max = index - 1;
    }
  }
  return found;
}
function findMinIndex(min, max, iteratee) {
  if (min > max)
    return;
  let found;
  while (max >= min) {
    const index = Math.floor((max + min) / 2);
    const value = iteratee(index);
    if (value) {
      found = index;
      max = index - 1;
    } else {
      min = index + 1;
    }
  }
  return found;
}
function findMaxValue(min, max, iteratee) {
  if (min > max)
    return;
  let found;
  while (max >= min) {
    const index = Math.floor((max + min) / 2);
    const value = iteratee(index);
    if (value == null) {
      max = index - 1;
    } else {
      found = value;
      min = index + 1;
    }
  }
  return found;
}

// packages/ag-charts-core/src/utils/caching.ts
var WeakCache = class {
  constructor(getter) {
    this.getter = getter;
  }
  get() {
    let result = this.result?.deref();
    if (result)
      return result;
    result = this.getter();
    this.result = new WeakRef(result);
    return result;
  }
  clear() {
    this.result = void 0;
  }
};

// packages/ag-charts-core/src/utils/cleanupRegistry.ts
var CleanupRegistry = class {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
  }
  flush() {
    for (const cb of this.callbacks) {
      cb();
    }
    this.callbacks.clear();
  }
  merge(registry) {
    for (const cb of registry.callbacks) {
      this.callbacks.add(cb);
    }
  }
  register(...callbacks) {
    for (const cb of callbacks) {
      if (!cb)
        continue;
      this.callbacks.add(cb);
    }
  }
};

// packages/ag-charts-core/src/utils/diff.ts
function diffArrays(previous, current) {
  const size = Math.max(previous.length, current.length);
  const added = /* @__PURE__ */ new Set();
  const removed = /* @__PURE__ */ new Set();
  for (let i = 0; i < size; i++) {
    const prev = previous[i];
    const curr = current[i];
    if (prev === curr)
      continue;
    if (removed.has(curr)) {
      removed.delete(curr);
    } else if (curr) {
      added.add(curr);
    }
    if (added.has(prev)) {
      added.delete(prev);
    } else if (prev) {
      removed.add(prev);
    }
  }
  return { changed: added.size > 0 || removed.size > 0, added, removed };
}

// packages/ag-charts-core/src/utils/numbers.ts
function clamp(min, value, max) {
  return Math.min(max, Math.max(min, value));
}
function inRange(value, range4, epsilon2 = 1e-10) {
  return value >= range4[0] - epsilon2 && value <= range4[1] + epsilon2;
}
function isNumberEqual(a, b, epsilon2 = 1e-10) {
  return a === b || Math.abs(a - b) < epsilon2;
}
function isNegative(value) {
  return Math.sign(value) === -1 || Object.is(value, -0);
}
function isInteger(value) {
  return value % 1 === 0;
}
function roundTo(value, decimals = 2) {
  const base = 10 ** decimals;
  return Math.round(value * base) / base;
}
function modulus(n, m) {
  return Math.floor(n % m + (n < 0 ? Math.abs(m) : 0));
}
function countFractionDigits(value) {
  if (Math.floor(value) === value) {
    return 0;
  }
  let valueString = String(value);
  let exponent = 0;
  if (value < 1e-6 || value >= 1e21) {
    let exponentString;
    [valueString, exponentString] = valueString.split("e");
    if (exponentString != null) {
      exponent = Number(exponentString);
    }
  }
  const decimalPlaces2 = valueString.split(".")[1]?.length ?? 0;
  return Math.max(decimalPlaces2 - exponent, 0);
}

// packages/ag-charts-core/src/utils/geoJson.ts
function isValidCoordinate(value) {
  return Array.isArray(value) && value.length >= 2 && value.every(isFiniteNumber);
}
function isValidCoordinates(value) {
  return Array.isArray(value) && value.length >= 2 && value.every(isValidCoordinate);
}
function hasSameStartEndPoint(c) {
  const start2 = c[0];
  const end2 = c[c.length - 1];
  return isNumberEqual(start2[0], end2[0], 1e-3) && isNumberEqual(start2[1], end2[1], 1e-3);
}
function isValidPolygon(value) {
  return Array.isArray(value) && value.every(isValidCoordinates) && value.every(hasSameStartEndPoint);
}
function isValidGeometry(value) {
  if (value === null)
    return true;
  if (!isObject(value) || value.type == null)
    return false;
  const { type, coordinates } = value;
  switch (type) {
    case "GeometryCollection":
      return Array.isArray(value.geometries) && value.geometries.every(isValidGeometry);
    case "MultiPolygon":
      return Array.isArray(coordinates) && coordinates.every(isValidPolygon);
    case "Polygon":
      return isValidPolygon(coordinates);
    case "MultiLineString":
      return Array.isArray(coordinates) && coordinates.every(isValidCoordinates);
    case "LineString":
      return isValidCoordinates(coordinates);
    case "MultiPoint":
      return isValidCoordinates(coordinates);
    case "Point":
      return isValidCoordinate(coordinates);
    default:
      return false;
  }
}
function isValidFeature(value) {
  return isObject(value) && value.type === "Feature" && isValidGeometry(value.geometry);
}
function isValidFeatureCollection(value) {
  return isObject(value) && value.type === "FeatureCollection" && Array.isArray(value.features) && value.features.every(isValidFeature);
}
var geoJson = attachDescription(isValidFeatureCollection, "a GeoJSON object");

// packages/ag-charts-core/src/utils/graph.ts
var AdjacencyListGraph = class {
  constructor(cachedNeighboursEdge, processedEdge) {
    this._vertexCount = 0;
    this.pendingProcessingEdgesFrom = [];
    this.pendingProcessingEdgesTo = [];
    this.cachedNeighboursEdge = cachedNeighboursEdge;
    this.processedEdge = processedEdge;
  }
  clear() {
    this._vertexCount = 0;
    this.pendingProcessingEdgesFrom = [];
    this.pendingProcessingEdgesTo = [];
  }
  addVertex(value) {
    const vertex = new Vertex(value);
    this._vertexCount++;
    return vertex;
  }
  addEdge(from3, to, edge) {
    if (edge === this.cachedNeighboursEdge) {
      from3.updateCachedNeighbours().set(to.value, to);
    } else if (edge === this.processedEdge) {
      this.pendingProcessingEdgesFrom.push(from3);
      this.pendingProcessingEdgesTo.push(to);
    }
    const { edges } = from3;
    const vertices = edges.get(edge);
    if (!vertices) {
      edges.set(edge, [to]);
    } else if (vertices.indexOf(to) === -1) {
      vertices.push(to);
    }
  }
  removeVertex(vertex) {
    this._vertexCount--;
    const edges = vertex.edges;
    if (!edges)
      return;
    for (const [_edge, adjacentVertices] of edges) {
      this._vertexCount -= adjacentVertices.length;
    }
    vertex.clear();
  }
  removeEdge(from3, to) {
    for (const [edge, adjacentVertices] of from3.edges) {
      const index = adjacentVertices.indexOf(to);
      adjacentVertices.splice(index, 1);
      if (adjacentVertices.length === 0) {
        from3.edges.delete(edge);
      }
    }
  }
  removeEdges(from3, edgeValue) {
    from3.edges.delete(edgeValue);
  }
  getVertexValue(vertex) {
    return vertex.value;
  }
  // Iterate all the neighbours of a given vertex.
  *neighbours(from3) {
    for (const [_edge, adjacentVertices] of from3.edges) {
      for (const adjacentVertex of adjacentVertices) {
        yield adjacentVertex;
      }
    }
  }
  // Iterate all the neighbours and their edges of a given vertex
  *neighboursAndEdges(from3) {
    for (const [edge, adjacentVertices] of from3.edges) {
      for (const adjacentVertex of adjacentVertices) {
        yield [adjacentVertex, edge];
      }
    }
  }
  // Get the set of neighbours along a given edge.
  neighboursWithEdgeValue(from3, edgeValue) {
    return from3.edges.get(edgeValue);
  }
  // Find the first neighbour along the given edge.
  findNeighbour(from3, edgeValue) {
    return from3.edges.get(edgeValue)?.[0];
  }
  // Find the value of the first neighbour along the given edge.
  findNeighbourValue(from3, edgeValue) {
    const neighbour = this.findNeighbour(from3, edgeValue);
    if (!neighbour)
      return;
    return this.getVertexValue(neighbour);
  }
  // Find the first neighbour with a given value, optionally along a given edge.
  findNeighbourWithValue(from3, value, edgeValue) {
    const neighbours = edgeValue == null ? this.neighbours(from3) : this.neighboursWithEdgeValue(from3, edgeValue);
    if (!neighbours)
      return;
    for (const neighbour of neighbours) {
      if (this.getVertexValue(neighbour) === value) {
        return neighbour;
      }
    }
  }
  // Find a vertex by iterating an array of vertex values along a given edge.
  findVertexAlongEdge(from3, findValues, edgeValue) {
    if (edgeValue === this.cachedNeighboursEdge) {
      let found2;
      for (const value of findValues) {
        found2 = (found2 ?? from3).readCachedNeighbours()?.get(value);
        if (!found2)
          return;
      }
      return found2;
    }
    if (findValues.length === 0)
      return;
    let found = from3;
    for (const value of findValues) {
      const neighbours = found ? this.neighboursWithEdgeValue(found, edgeValue) : void 0;
      if (!neighbours)
        return;
      found = neighbours.find((n) => n.value === value);
    }
    return found;
  }
  adjacent(from3, to) {
    for (const [_edge, adjacentVertices] of from3.edges) {
      if (adjacentVertices.includes(to))
        return true;
    }
    return false;
  }
};
var Vertex = class {
  constructor(value) {
    this.value = value;
    this.edges = /* @__PURE__ */ new Map();
  }
  readCachedNeighbours() {
    return this._cachedNeighbours;
  }
  updateCachedNeighbours() {
    this._cachedNeighbours ?? (this._cachedNeighbours = /* @__PURE__ */ new Map());
    return this._cachedNeighbours;
  }
  clear() {
    this.edges.clear();
    this._cachedNeighbours?.clear();
  }
};

// packages/ag-charts-core/src/utils/id.ts
var ID_MAP = /* @__PURE__ */ new Map();
var elementIDBrand = Symbol("ElementID");
var nextElementID = 1;
function createId(instance) {
  const constructor = instance.constructor;
  const className = Object.hasOwn(constructor, "className") ? constructor.className : constructor.name;
  if (!className) {
    throw new Error(`The ${constructor} is missing the 'className' property.`);
  }
  const nextId = (ID_MAP.get(className) ?? 0) + 1;
  ID_MAP.set(className, nextId);
  return `${className}-${nextId}`;
}
function createElementId() {
  return `ag-charts-${nextElementID++}`;
}
function generateUUID() {
  return crypto.randomUUID?.() ?? generateUUIDv4();
}
function generateUUIDv4() {
  const uuidArray = new Uint8Array(16);
  crypto.getRandomValues(uuidArray);
  uuidArray[6] = uuidArray[6] & 15 | 64;
  uuidArray[8] = uuidArray[8] & 63 | 128;
  let uuid = "";
  for (let i = 0; i < uuidArray.length; i++) {
    if (i === 4 || i === 6 || i === 8 || i === 10) {
      uuid += "-";
    }
    uuid += uuidArray[i].toString(16).padStart(2, "0");
  }
  return uuid;
}

// packages/ag-charts-core/src/utils/linkedList.ts
var insertListItemsSorted = (list, items, cmp2) => {
  let head = list;
  let current = head;
  for (const value of items) {
    if (head == null || cmp2(head.value, value) > 0) {
      head = { value, next: head };
      current = head;
    } else {
      current = current;
      while (current.next != null && cmp2(current.next.value, value) <= 0) {
        current = current.next;
      }
      current.next = { value, next: current.next };
    }
  }
  return head;
};

// packages/ag-charts-core/src/utils/numberFormat.ts
var formatRegEx = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(?:\.(\d+))?(~)?([%a-z])?$/i;
var surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;
function isValidNumberFormat(value) {
  if (!isString(value))
    return false;
  const match = surroundedRegEx.exec(value);
  return formatRegEx.test(match ? match[2] : value);
}
function parseNumberFormat(format) {
  let prefix;
  let suffix;
  const surrounded = surroundedRegEx.exec(format);
  if (surrounded) {
    [, prefix, format, suffix] = surrounded;
  }
  const match = formatRegEx.exec(format);
  if (!match) {
    logger_exports.warnOnce(`The number formatter is invalid: ${format}`);
    return;
  }
  const [, fill, align2, sign, symbol, zero, width2, comma, precision, trim, type] = match;
  return {
    fill,
    align: align2,
    sign,
    symbol,
    zero,
    width: parseInt(width2),
    comma,
    precision: parseInt(precision),
    trim: Boolean(trim),
    type,
    prefix,
    suffix
  };
}
function createNumberFormatter(format) {
  const options = typeof format === "string" ? parseNumberFormat(format) : format;
  if (options == null)
    return;
  const { fill, align: align2, sign = "-", symbol, zero, width: width2, comma, type, prefix = "", suffix = "", precision } = options;
  let { trim } = options;
  const precisionIsNaN = precision == null || isNaN(precision);
  let formatBody;
  if (!type) {
    formatBody = decimalTypes["g"];
    trim = true;
  } else if (type in decimalTypes && type in integerTypes) {
    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];
  } else if (type in decimalTypes) {
    formatBody = decimalTypes[type];
  } else if (type in integerTypes) {
    formatBody = integerTypes[type];
  } else {
    throw new Error(`The number formatter type is invalid: ${type}`);
  }
  const defaultFormatterPrecision = type ? 6 : 12;
  let formatterPrecision;
  if (!precisionIsNaN) {
    formatterPrecision = precision;
  }
  return (n, fractionDigits) => {
    let result = formatBody(n, formatterPrecision ?? fractionDigits ?? defaultFormatterPrecision);
    if (trim) {
      result = removeTrailingZeros(result);
    }
    if (comma) {
      result = insertSeparator(result, comma);
    }
    result = addSign(n, result, sign);
    if (symbol && symbol !== "#") {
      result = `${symbol}${result}`;
    }
    if (symbol === "#" && type === "x") {
      result = `0x${result}`;
    }
    if (type === "s") {
      result = `${result}${getSIPrefix(n)}`;
    }
    if (type === "%" || type === "p") {
      result = `${result}%`;
    }
    if (width2 != null && !isNaN(width2)) {
      result = addPadding(result, width2, fill ?? zero, align2);
    }
    result = `${prefix}${result}${suffix}`;
    return result;
  };
}
var integerTypes = {
  b: (n) => absFloor(n).toString(2),
  c: (n) => String.fromCharCode(n),
  d: (n) => Math.round(Math.abs(n)).toFixed(0),
  o: (n) => absFloor(n).toString(8),
  x: (n) => absFloor(n).toString(16),
  X: (n) => integerTypes.x(n).toUpperCase(),
  n: (n) => integerTypes.d(n),
  "%": (n) => `${absFloor(n * 100).toFixed(0)}`
};
var decimalTypes = {
  e: (n, f) => Math.abs(n).toExponential(f),
  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),
  f: (n, f) => Math.abs(n).toFixed(f),
  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),
  g: (n, f) => {
    if (n === 0) {
      return "0";
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    if (p >= -4 && p < f) {
      return a.toFixed(f - 1 - p);
    }
    return a.toExponential(f - 1);
  },
  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),
  n: (n, f) => decimalTypes.g(n, f),
  p: (n, f) => decimalTypes.r(n * 100, f),
  r: (n, f) => {
    if (n === 0) {
      return "0";
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    const q = p - (f - 1);
    if (q <= 0) {
      return a.toFixed(-q);
    }
    const x = 10 ** q;
    return (Math.round(a / x) * x).toFixed();
  },
  s: (n, f) => {
    const p = getSIPrefixPower(n);
    return decimalTypes.r(n / 10 ** p, f);
  },
  "%": (n, f) => decimalTypes.f(n * 100, f)
};
var minSIPrefix = -24;
var maxSIPrefix = 24;
var siPrefixes = {
  [minSIPrefix]: "y",
  [-21]: "z",
  [-18]: "a",
  [-15]: "f",
  [-12]: "p",
  [-9]: "n",
  [-6]: "\xB5",
  [-3]: "m",
  [0]: "",
  [3]: "k",
  [6]: "M",
  [9]: "G",
  [12]: "T",
  [15]: "P",
  [18]: "E",
  [21]: "Z",
  [maxSIPrefix]: "Y"
};
var minusSign = "\u2212";
function absFloor(n) {
  return Math.floor(Math.abs(n));
}
function removeTrailingZeros(numString) {
  if (!numString.endsWith("0") || numString.indexOf(".") === -1)
    return numString;
  let endIndex = numString.length - 1;
  while (endIndex > 0) {
    if (numString[endIndex] == "0") {
      endIndex -= 1;
    } else if (numString[endIndex] == ".") {
      endIndex -= 1;
      break;
    } else {
      break;
    }
  }
  return numString.substring(0, endIndex + 1);
}
function insertSeparator(numString, separator) {
  let dotIndex = numString.indexOf(".");
  if (dotIndex < 0) {
    dotIndex = numString.length;
  }
  const integerChars = numString.substring(0, dotIndex).split("");
  const fractionalPart = numString.substring(dotIndex);
  for (let i = integerChars.length - 3; i > 0; i -= 3) {
    integerChars.splice(i, 0, separator);
  }
  return `${integerChars.join("")}${fractionalPart}`;
}
function getSIPrefix(n) {
  return siPrefixes[getSIPrefixPower(n)];
}
function getSIPrefixPower(n) {
  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);
}
function addSign(num, numString, signType = "") {
  if (signType === "(") {
    return num >= 0 ? numString : `(${numString})`;
  }
  const plusSign = signType === "+" ? "+" : "";
  return `${num >= 0 ? plusSign : minusSign}${numString}`;
}
function addPadding(numString, width2, fill = " ", align2 = ">") {
  let result = numString;
  if (align2 === ">" || !align2) {
    result = result.padStart(width2, fill);
  } else if (align2 === "<") {
    result = result.padEnd(width2, fill);
  } else if (align2 === "^") {
    const padWidth = Math.max(0, width2 - result.length);
    const padLeft = Math.ceil(padWidth / 2);
    const padRight = Math.floor(padWidth / 2);
    result = result.padStart(padLeft + result.length, fill);
    result = result.padEnd(padRight + result.length, fill);
  }
  return result;
}

// packages/ag-charts-community/src/module/module.ts
var BaseModuleInstance = class {
  constructor() {
    this.cleanup = new CleanupRegistry();
  }
  destroy() {
    this.cleanup.flush();
  }
};
var ModuleRegistry = class {
  constructor() {
    this.modules = [];
    this.dependencies = /* @__PURE__ */ new Map();
    this.modulesByOptionKey = /* @__PURE__ */ new Map();
  }
  register(...modules) {
    for (const module2 of modules) {
      this.registerDependencies(module2);
      const otherModule = this.modules.find(
        (other) => module2.type === other.type && ("optionsKey" in module2 && "optionsKey" in other ? module2.optionsKey === other.optionsKey : true) && module2.identifier === other.identifier
      );
      if (otherModule) {
        if (module2.packageType === "enterprise" && otherModule.packageType === "community") {
          const index = this.modules.indexOf(otherModule);
          this.modules.splice(index, 1, module2);
          if ("optionsKey" in module2) {
            this.modulesByOptionKey.set(module2.optionsKey, module2);
          }
        }
      } else {
        this.modules.push(module2);
        if ("optionsKey" in module2) {
          this.modulesByOptionKey.set(module2.optionsKey, module2);
        }
      }
    }
  }
  hasEnterpriseModules() {
    return this.modules.some((m) => m.packageType === "enterprise");
  }
  *byType(...types) {
    const yielded = /* @__PURE__ */ new Set();
    const modulesByType = this.modules.filter((module2) => types.includes(module2.type));
    const calculateDependencies = (module2) => {
      const deps = this.dependencies.get(module2);
      return deps?.flatMap(calculateDependencies).concat(deps) ?? [];
    };
    const unresolvable = [];
    for (const module2 of modulesByType) {
      const uniqueKey = "optionsKey" in module2 ? module2.optionsKey : module2.contextKey;
      if (yielded.has(uniqueKey))
        continue;
      for (const dependency of calculateDependencies(uniqueKey)) {
        if (yielded.has(dependency))
          continue;
        const dependencyModule = this.modulesByOptionKey.get(dependency);
        if (!dependencyModule) {
          unresolvable.push(dependency);
          continue;
        }
        if (!types.includes(dependencyModule.type))
          continue;
        yield dependencyModule;
        yielded.add(dependency);
      }
      yield module2;
      yielded.add(uniqueKey);
    }
    if (unresolvable.length > 0) {
      throw new Error(`Could not resolve module dependencies: ${unresolvable}`);
    }
  }
  registerDependencies(module2) {
    if (module2.dependencies == null || module2.dependencies.length === 0)
      return;
    const uniqueKey = "optionsKey" in module2 ? module2.optionsKey : module2.contextKey;
    this.dependencies.set(uniqueKey, module2.dependencies);
  }
};
var moduleRegistry = new ModuleRegistry();

// packages/ag-charts-community/src/util/interpolating.ts
var interpolate = Symbol("interpolate");
var isInterpolating = (x) => x[interpolate] != null;

// packages/ag-charts-community/src/util/nearest.ts
function nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const obj of objects) {
    const thisDistance = obj.distanceSquared(x, y);
    if (thisDistance === 0) {
      return { nearest: obj, distanceSquared: 0 };
    } else if (thisDistance < result.distanceSquared) {
      result.nearest = obj;
      result.distanceSquared = thisDistance;
    }
  }
  return result;
}
function nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {
  const { x: tx = x, y: ty = y } = container.transformPoint?.(x, y) ?? {};
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const child of container.children) {
    const { nearest, distanceSquared: distanceSquared2 } = child.nearestSquared(tx, ty, result.distanceSquared);
    if (distanceSquared2 === 0) {
      return { nearest, distanceSquared: distanceSquared2 };
    } else if (distanceSquared2 < result.distanceSquared) {
      result.nearest = nearest;
      result.distanceSquared = distanceSquared2;
    }
  }
  return result;
}

// packages/ag-charts-community/src/scene/bbox.ts
var _BBox = class _BBox {
  constructor(x, y, width2, height2) {
    this.x = x;
    this.y = y;
    this.width = width2;
    this.height = height2;
  }
  static fromDOMRect({ x, y, width: width2, height: height2 }) {
    return new _BBox(x, y, width2, height2);
  }
  static merge(boxes) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (const box of boxes) {
      if (box.x < left) {
        left = box.x;
      }
      if (box.y < top) {
        top = box.y;
      }
      if (box.x + box.width > right) {
        right = box.x + box.width;
      }
      if (box.y + box.height > bottom) {
        bottom = box.y + box.height;
      }
    }
    return new _BBox(left, top, right - left, bottom - top);
  }
  static nearestBox(x, y, boxes) {
    return nearestSquared(x, y, boxes);
  }
  toDOMRect() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.y,
      left: this.x,
      right: this.x + this.width,
      bottom: this.y + this.height,
      toJSON() {
        return {};
      }
    };
  }
  clone() {
    const { x, y, width: width2, height: height2 } = this;
    return new _BBox(x, y, width2, height2);
  }
  equals(other) {
    return boxesEqual(this, other);
  }
  containsPoint(x, y) {
    return boxContains(this, x, y);
  }
  intersection(other) {
    if (!this.collidesBBox(other))
      return;
    const newX1 = clamp(other.x, this.x, other.x + other.width);
    const newY1 = clamp(other.y, this.y, other.y + other.height);
    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);
    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);
    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);
  }
  collidesBBox(other) {
    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
  }
  computeCenter() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  isFinite() {
    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);
  }
  distanceSquared(x, y) {
    if (this.containsPoint(x, y)) {
      return 0;
    }
    const dx2 = x - clamp(this.x, x, this.x + this.width);
    const dy2 = y - clamp(this.y, y, this.y + this.height);
    return dx2 * dx2 + dy2 * dy2;
  }
  shrink(amount, position) {
    if (typeof amount === "number") {
      this.applyMargin(amount, position);
    } else {
      for (const key of Object.keys(amount)) {
        const value = amount[key];
        if (typeof value === "number") {
          this.applyMargin(value, key);
        }
      }
    }
    if (this.width < 0) {
      this.width = 0;
    }
    if (this.height < 0) {
      this.height = 0;
    }
    return this;
  }
  grow(amount, position) {
    if (typeof amount === "number") {
      this.applyMargin(-amount, position);
    } else {
      for (const key of Object.keys(amount)) {
        const value = amount[key];
        if (typeof value === "number") {
          this.applyMargin(-value, key);
        }
      }
    }
    return this;
  }
  applyMargin(value, position) {
    switch (position) {
      case "top":
        this.y += value;
      case "bottom":
        this.height -= value;
        break;
      case "left":
        this.x += value;
      case "right":
        this.width -= value;
        break;
      case "vertical":
        this.y += value;
        this.height -= value * 2;
        break;
      case "horizontal":
        this.x += value;
        this.width -= value * 2;
        break;
      case void 0:
        this.x += value;
        this.y += value;
        this.width -= value * 2;
        this.height -= value * 2;
        break;
    }
  }
  translate(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  [interpolate](other, d) {
    return new _BBox(
      this.x * (1 - d) + other.x * d,
      this.y * (1 - d) + other.y * d,
      this.width * (1 - d) + other.width * d,
      this.height * (1 - d) + other.height * d
    );
  }
};
_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));
_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));
var BBox = _BBox;

// packages/ag-charts-community/src/util/debug.ts
var LONG_TIME_PERIOD_THRESHOLD = 2e3;
var timeOfLastLog = Date.now();
var logTimeGap = () => {
  const timeSinceLastLog = Date.now() - timeOfLastLog;
  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
    logger_exports.log(`**** ${prettyDuration}s since last log message ****`);
  }
  timeOfLastLog = Date.now();
};
var Debug = {
  create(...debugSelectors) {
    const resultFn = (...logContent) => {
      if (Debug.check(...debugSelectors)) {
        if (typeof logContent[0] === "function") {
          logContent = toArray(logContent[0]());
        }
        logTimeGap();
        logger_exports.log(...logContent);
      }
    };
    return Object.assign(resultFn, {
      check: () => Debug.check(...debugSelectors),
      group: (name, cb) => {
        if (Debug.check(...debugSelectors)) {
          return logger_exports.logGroup(name, cb);
        }
        return cb();
      }
    });
  },
  check(...debugSelectors) {
    if (debugSelectors.length === 0) {
      debugSelectors.push(true);
    }
    const chartDebug = toArray(getWindow("agChartsDebug"));
    return chartDebug.some((selector) => debugSelectors.includes(selector));
  },
  inDevelopmentMode(fn) {
    if (Debug.check("dev")) {
      return fn();
    }
  }
};

// packages/ag-charts-community/src/scene/canvas/canvasUtil.ts
function clearContext({
  context,
  pixelRatio,
  width: width2,
  height: height2
}) {
  context.save();
  try {
    context.resetTransform();
    context.clearRect(0, 0, Math.ceil(width2 * pixelRatio), Math.ceil(height2 * pixelRatio));
  } finally {
    context.restore();
  }
}
function debugContext(ctx) {
  if (Debug.check("canvas")) {
    const save = ctx.save.bind(ctx);
    const restore = ctx.restore.bind(ctx);
    let depth = 0;
    Object.assign(ctx, {
      save() {
        save();
        depth++;
      },
      restore() {
        if (depth === 0) {
          throw new Error("AG Charts - Unable to restore() past depth 0");
        }
        restore();
        depth--;
      },
      verifyDepthZero() {
        if (depth !== 0) {
          throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);
        }
      }
    });
  }
}

// packages/ag-charts-community/src/scene/canvas/hdpiOffscreenCanvas.ts
function canvasDimensions(width2, height2, pixelRatio) {
  return [Math.floor(width2 * pixelRatio), Math.floor(height2 * pixelRatio)];
}
var HdpiOffscreenCanvas = class {
  constructor(options) {
    const { width: width2, height: height2, pixelRatio, willReadFrequently = false } = options;
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
    const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
    this.canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    this.context = this.canvas.getContext("2d", { willReadFrequently });
    this.context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    debugContext(this.context);
  }
  drawImage(context, dx2 = 0, dy2 = 0) {
    return context.drawImage(this.canvas, dx2, dy2);
  }
  transferToImageBitmap() {
    return this.canvas.transferToImageBitmap();
  }
  resize(width2, height2, pixelRatio) {
    if (!(width2 > 0 && height2 > 0))
      return;
    const { canvas, context } = this;
    if (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio) {
      const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
    }
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
  }
  clear() {
    clearContext(this);
  }
  destroy() {
    this.canvas.width = 0;
    this.canvas.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    this.canvas = null;
    this.context = null;
    Object.freeze(this);
  }
};

// packages/ag-charts-community/src/util/decorator.ts
var BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
var CONFIG_KEY = "__decorator_config";
var ACCESSORS_KEY = "__decorator_accessors";
function addFakeTransformToInstanceProperty(target, propertyKeyOrSymbol) {
  initialiseConfig(target, propertyKeyOrSymbol).optional = true;
}
function initialiseConfig(target, propertyKeyOrSymbol) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, { value: {} });
  }
  if (Object.getOwnPropertyDescriptor(target, ACCESSORS_KEY) == null) {
    const parentAccessors = Object.getPrototypeOf(target)?.[ACCESSORS_KEY];
    const accessors = parentAccessors?.slice() ?? [];
    Object.defineProperty(target, ACCESSORS_KEY, { value: accessors });
  }
  const config = target[CONFIG_KEY];
  const propertyKey = propertyKeyOrSymbol.toString();
  if (config[propertyKey] != null) {
    return config[propertyKey];
  }
  config[propertyKey] = { setters: [], getters: [], observers: [] };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  let prevGet = descriptor?.get;
  let prevSet = descriptor?.set;
  if (prevGet == null || prevSet == null) {
    const accessors = target[ACCESSORS_KEY];
    let index = accessors.indexOf(propertyKeyOrSymbol);
    if (index === -1) {
      index = accessors.push(propertyKeyOrSymbol) - 1;
    }
    prevGet ?? (prevGet = function() {
      let accessorValues = this.__accessors;
      if (accessorValues == null) {
        accessorValues = accessors.slice().fill(void 0);
        Object.defineProperty(this, "__accessors", { value: accessorValues });
      }
      return accessorValues[index];
    });
    prevSet ?? (prevSet = function(value) {
      let accessorValues = this.__accessors;
      if (accessorValues == null) {
        accessorValues = accessors.slice().fill(void 0);
        Object.defineProperty(this, "__accessors", { value: accessorValues });
      }
      accessorValues[index] = value;
    });
  }
  const getter = function() {
    let value = prevGet.call(this);
    for (const transformFn of config[propertyKey].getters) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    return value;
  };
  const setter = function(value) {
    const { setters, observers } = config[propertyKey];
    let oldValue;
    if (setters.some((f) => f.length > 2)) {
      oldValue = prevGet.call(this);
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    prevSet.call(this, value);
    for (const observerFn of observers) {
      observerFn(this, value, oldValue);
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
  return (target, propertyKeyOrSymbol) => {
    const config = initialiseConfig(target, propertyKeyOrSymbol);
    config.setters.push(setTransform);
    if (getTransform) {
      config.getters.unshift(getTransform);
    }
    if (configMetadata) {
      Object.assign(config, configMetadata);
    }
  };
}
function addObserverToInstanceProperty(setObserver) {
  return (target, propertyKeyOrSymbol) => {
    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
  };
}
function isDecoratedObject(target) {
  return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
  const targets = /* @__PURE__ */ new Set();
  while (isDecoratedObject(target)) {
    targets.add(target?.[CONFIG_KEY]);
    target = Object.getPrototypeOf(target);
  }
  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));
}
function extractDecoratedProperties(target) {
  return listDecoratedProperties(target).reduce((result, key) => {
    result[String(key)] = target[key] ?? null;
    return result;
  }, {});
}

// packages/ag-charts-community/src/util/object.ts
function objectsEqual(a, b) {
  if (Array.isArray(a)) {
    if (!Array.isArray(b))
      return false;
    if (a.length !== b.length)
      return false;
    return a.every((av, i) => objectsEqual(av, b[i]));
  } else if (isPlainObject(a)) {
    if (!isPlainObject(b))
      return false;
    return objectsEqualWith(a, b, objectsEqual);
  }
  return a === b;
}
function objectsEqualWith(a, b, cmp2) {
  if (Object.is(a, b))
    return true;
  for (const key of Object.keys(b)) {
    if (!(key in a))
      return false;
  }
  for (const key of Object.keys(a)) {
    if (!(key in b))
      return false;
    if (!cmp2(a[key], b[key]))
      return false;
  }
  return true;
}
function mergeDefaults(...sources) {
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = mergeDefaults(target[key], source[key]);
      } else {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function merge(...sources) {
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = merge(target[key], source[key]);
      } else if (!(key in target)) {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function mergeArrayDefaults(dataArray, ...itemDefaults) {
  if (itemDefaults && isArray(dataArray)) {
    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));
  }
  return dataArray;
}
function mapValues(object2, mapper) {
  const result = {};
  for (const [key, value] of entries(object2)) {
    result[key] = mapper(value, key, object2);
  }
  return result;
}
function without(object2, keys) {
  const clone2 = { ...object2 };
  for (const key of keys) {
    delete clone2[key];
  }
  return clone2;
}
function pick(object2, keys) {
  if (object2 == null)
    return;
  const picked = {};
  for (const key of keys) {
    if (Object.hasOwn(object2, key)) {
      picked[key] = object2[key];
    }
  }
  return picked;
}
function getPath(object2, path) {
  const pathArray = isArray(path) ? path : path.split(".");
  return pathArray.reduce((value, pathKey) => value[pathKey], object2);
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function setPath(object2, path, newValue) {
  const pathArray = isArray(path) ? path.slice() : path.split(".");
  const lastKey = pathArray.pop();
  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))
    return;
  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);
  lastObject[lastKey] = newValue;
  return lastObject[lastKey];
}
function partialAssign(keysToCopy, target, source) {
  if (source === void 0) {
    return target;
  }
  for (const key of keysToCopy) {
    const value = source[key];
    if (value !== void 0) {
      target[key] = value;
    }
  }
  return target;
}
function deepFreeze(obj) {
  if (obj == null || typeof obj !== "object" || !isPlainObject(obj)) {
    return obj;
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach((prop) => {
    const value = obj[prop];
    if (value !== null && (typeof value === "object" || typeof value === "function") && !Object.isFrozen(value)) {
      deepFreeze(value);
    }
  });
  return obj;
}
function isObjectWithProperty(obj, key) {
  return isPlainObject(obj) && key in obj;
}
function isObjectWithStringProperty(obj, key) {
  return isObjectWithProperty(obj, key) && typeof obj[key] === "string";
}

// packages/ag-charts-community/src/scene/changeDetectable.ts
var TRIPLE_EQ = (lhs, rhs) => lhs === rhs;
function SceneChangeDetection(opts) {
  return function(target, key) {
    const privateKey = `__${key}`;
    if (target[key])
      return;
    prepareGetSet(target, key, privateKey, opts);
  };
}
function SceneRefChangeDetection(opts) {
  return SceneChangeDetection(opts);
}
function SceneObjectChangeDetection(opts) {
  return SceneChangeDetection(opts);
}
function SceneArrayChangeDetection(opts) {
  const baseOpts = opts ?? {};
  baseOpts.equals = arraysEqual;
  return SceneChangeDetection(opts);
}
function prepareGetSet(target, key, privateKey, opts) {
  const { changeCb, convertor, checkDirtyOnAssignment = false } = opts ?? {};
  const requiredOpts = { changeCb, checkDirtyOnAssignment, convertor };
  const setter = buildCheckDirtyChain(
    privateKey,
    buildChangeCallbackChain(
      buildConvertorChain(buildSetter(privateKey, requiredOpts), requiredOpts),
      requiredOpts
    ),
    requiredOpts
  );
  const getter = function() {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
function buildConvertorChain(setterFn, opts) {
  const { convertor } = opts;
  if (convertor) {
    return function(value) {
      setterFn.call(this, convertor(value));
    };
  }
  return setterFn;
}
var NO_CHANGE = Symbol("no-change");
function buildChangeCallbackChain(setterFn, opts) {
  const { changeCb } = opts;
  if (changeCb) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (change !== NO_CHANGE) {
        changeCb.call(this, this);
      }
      return change;
    };
  }
  return setterFn;
}
function buildCheckDirtyChain(privateKey, setterFn, opts) {
  const { checkDirtyOnAssignment } = opts;
  if (checkDirtyOnAssignment) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (value?._dirty === true) {
        this.markDirty(privateKey);
      }
      return change;
    };
  }
  return setterFn;
}
function buildSetter(privateKey, opts) {
  const { equals = TRIPLE_EQ } = opts;
  return function(value) {
    const oldValue = this[privateKey];
    if (!equals(value, oldValue)) {
      this[privateKey] = value;
      this.onChangeDetection(privateKey);
      return value;
    }
    return NO_CHANGE;
  };
}

// packages/ag-charts-community/src/scene/zIndex.ts
var cmp = (a, b) => Math.sign(a - b);
function compareZIndex(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return cmp(a, b);
  }
  const aArray = typeof a === "number" ? [a] : a;
  const bArray = typeof b === "number" ? [b] : b;
  const length2 = Math.min(aArray.length, bArray.length);
  for (let i = 0; i < length2; i += 1) {
    const diff8 = cmp(aArray[i], bArray[i]);
    if (diff8 !== 0)
      return diff8;
  }
  return cmp(aArray.length, bArray.length);
}

// packages/ag-charts-community/src/scene/node.ts
var PointerEvents = /* @__PURE__ */ ((PointerEvents14) => {
  PointerEvents14[PointerEvents14["All"] = 0] = "All";
  PointerEvents14[PointerEvents14["None"] = 1] = "None";
  return PointerEvents14;
})(PointerEvents || {});
var MAX_ERROR_COUNT = 5;
var _Node = class _Node {
  constructor(options) {
    /** Unique number to allow creation order to be easily determined. */
    this.serialNumber = _Node._nextSerialNumber++;
    this.childNodeCounts = { groups: 0, nonGroups: 0, thisComplexity: 0, complexity: 0 };
    /** Unique node ID in the form `ClassName-NaturalNumber`. */
    this.id = createId(this);
    this.name = void 0;
    this.transitionOut = void 0;
    this.pointerEvents = 0 /* All */;
    this._datum = void 0;
    this._previousDatum = void 0;
    this.scene = void 0;
    this._debugDirtyProperties = void 0;
    this.parentNode = void 0;
    this.cachedBBox = void 0;
    /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */
    this.isContainerNode = false;
    this.visible = true;
    this.zIndex = 0;
    this.batchLevel = 0;
    this.batchDirty = false;
    this.name = options?.name;
    this.tag = options?.tag ?? NaN;
    this.zIndex = options?.zIndex ?? 0;
    this.scene = options?.scene;
    if (options?.debugDirty ?? _Node._debugEnabled) {
      this._debugDirtyProperties = /* @__PURE__ */ new Map([["__first__", []]]);
    }
  }
  static toSVG(node, width2, height2) {
    const svg = node?.toSVG();
    if (svg == null || !svg.elements.length && !svg.defs?.length)
      return;
    const root = createSvgElement("svg");
    root.setAttribute("width", String(width2));
    root.setAttribute("height", String(height2));
    root.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    root.setAttribute("overflow", "visible");
    if (svg.defs?.length) {
      const defs = createSvgElement("defs");
      defs.append(...svg.defs);
      root.append(defs);
    }
    root.append(...svg.elements);
    return root.outerHTML;
  }
  static *extractBBoxes(nodes, skipInvisible) {
    for (const n of nodes) {
      if (!skipInvisible || n.visible && !n.transitionOut) {
        const bbox = n.getBBox();
        if (bbox)
          yield bbox;
      }
    }
  }
  /**
   * Some arbitrary data bound to the node.
   */
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    if (this._datum !== datum) {
      this._previousDatum = this._datum;
      this._datum = datum;
    }
  }
  get previousDatum() {
    return this._previousDatum;
  }
  get layerManager() {
    return this.scene?.layersManager;
  }
  get imageLoader() {
    return this.scene?.imageLoader;
  }
  closestDatum() {
    for (const { datum } of this.traverseUp(true)) {
      if (datum != null) {
        return datum;
      }
    }
  }
  /** Perform any pre-rendering initialization. */
  preRender(_renderCtx, thisComplexity = 1) {
    this.childNodeCounts.groups = 0;
    this.childNodeCounts.nonGroups = 1;
    this.childNodeCounts.complexity = thisComplexity;
    this.childNodeCounts.thisComplexity = thisComplexity;
    if (this.batchLevel > 0 || this.batchDirty) {
      throw new Error("AG Charts - illegal rendering state; batched update in progress");
    }
    return this.childNodeCounts;
  }
  /** Guaranteed isolated render - if there is any failure, the Cavans2D context is returned to its prior state. */
  isolatedRender(renderCtx) {
    renderCtx.ctx.save();
    try {
      this.render(renderCtx);
    } catch (e) {
      const errorCount = e.errorCount ?? 1;
      if (errorCount >= MAX_ERROR_COUNT) {
        e.errorCount = errorCount;
        throw e;
      }
      logger_exports.warnOnce("Error during rendering", e, e.stack);
    } finally {
      renderCtx.ctx.restore();
    }
  }
  render(renderCtx) {
    const { stats } = renderCtx;
    this.debugDirtyProperties();
    if (renderCtx.debugNodeSearch) {
      const idOrName = this.name ?? this.id;
      if (renderCtx.debugNodeSearch.some((v) => typeof v === "string" ? v === idOrName : v.test(idOrName))) {
        renderCtx.debugNodes[this.name ?? this.id] = this;
      }
    }
    if (stats) {
      stats.nodesRendered++;
      stats.opsPerformed += this.childNodeCounts.thisComplexity;
    }
  }
  setScene(scene) {
    this.scene = scene;
  }
  *traverseUp(includeSelf) {
    let node = this;
    if (includeSelf) {
      yield node;
    }
    while (node = node.parentNode) {
      yield node;
    }
  }
  /**
   * Checks if the node is the root (has no parent).
   */
  isRoot() {
    return !this.parentNode;
  }
  removeChild(node) {
    throw new Error(
      `AG Charts - internal error, unknown child node ${node.name ?? node.id} in $${this.name ?? this.id}`
    );
  }
  remove() {
    this.parentNode?.removeChild(this);
  }
  destroy() {
    this.parentNode?.removeChild(this);
  }
  batchedUpdate(fn) {
    this.batchLevel++;
    fn();
    this.batchLevel--;
    if (this.batchLevel === 0 && this.batchDirty) {
      this.markDirty();
      this.batchDirty = false;
    }
  }
  setProperties(styles) {
    this.batchLevel++;
    Object.assign(this, styles);
    this.batchLevel--;
    if (this.batchLevel === 0 && this.batchDirty) {
      this.markDirty();
      this.batchDirty = false;
    }
    return this;
  }
  containsPoint(_x, _y) {
    return false;
  }
  pickNode(x, y) {
    if (this.containsPoint(x, y)) {
      return this;
    }
  }
  pickNodes(x, y, into = []) {
    if (this.containsPoint(x, y)) {
      into.push(this);
    }
    return into;
  }
  getBBox() {
    this.cachedBBox ?? (this.cachedBBox = Object.freeze(this.computeBBox()));
    return this.cachedBBox;
  }
  computeBBox() {
    return;
  }
  onChangeDetection(property) {
    this.markDirty(property);
  }
  markDirtyChildrenOrder() {
    this.cachedBBox = void 0;
  }
  markDirty(property) {
    if (this.batchLevel > 0) {
      this.batchDirty = true;
      return;
    }
    if (property != null && this._debugDirtyProperties) {
      this.markDebugProperties(property);
    }
    this.cachedBBox = void 0;
    this.parentNode?.markDirty();
  }
  markDebugProperties(property) {
    const sources = this._debugDirtyProperties?.get(property) ?? [];
    const caller = new Error().stack?.split("\n").filter((line) => {
      return line !== "Error" && !line.includes(".markDebugProperties") && !line.includes(".markDirty") && !line.includes("Object.assign ") && !line.includes(`${this.constructor.name}.`);
    }) ?? "unknown";
    sources.push(caller[0].replace(" at ", "").trim());
    this._debugDirtyProperties?.set(property, sources);
  }
  debugDirtyProperties() {
    if (this._debugDirtyProperties == null)
      return;
    if (!this._debugDirtyProperties.has("__first__")) {
      this._debugDirtyProperties.forEach((sources, property) => {
        if (sources.length > 1) {
          console.groupCollapsed(
            `Property changed multiple times before render: ${this.constructor.name}.${property} (${sources.length}x)`
          );
          sources.forEach((source) => console.log(source));
          console.groupEnd();
        }
      });
    }
    this._debugDirtyProperties.clear();
  }
  onZIndexChange() {
    this.parentNode?.markDirtyChildrenOrder();
  }
  toSVG() {
    return;
  }
};
_Node._nextSerialNumber = 0;
// eslint-disable-next-line sonarjs/public-static-readonly
_Node._debugEnabled = false;
__decorateClass([
  SceneChangeDetection()
], _Node.prototype, "visible", 2);
__decorateClass([
  SceneObjectChangeDetection({
    equals: objectsEqual,
    changeCb: (target) => target.onZIndexChange()
  })
], _Node.prototype, "zIndex", 2);
var Node2 = _Node;

// packages/ag-charts-community/src/util/angle.ts
var twoPi = Math.PI * 2;
var halfPi = Math.PI / 2;
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle360Inclusive(radians) {
  radians %= twoPi;
  radians += twoPi;
  if (radians !== twoPi) {
    radians %= twoPi;
  }
  return radians;
}
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function isBetweenAngles(targetAngle, startAngle, endAngle) {
  const t = normalizeAngle360(targetAngle);
  const a0 = normalizeAngle360(startAngle);
  const a1 = normalizeAngle360(endAngle);
  if (a0 < a1) {
    return a0 <= t && t <= a1;
  } else if (a0 > a1) {
    return a0 <= t || t <= a1;
  } else {
    return startAngle !== endAngle;
  }
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function toDegrees(radians) {
  return radians / Math.PI * 180;
}
function angleBetween(angle0, angle1) {
  angle0 = normalizeAngle360(angle0);
  angle1 = normalizeAngle360(angle1);
  return angle1 - angle0 + (angle0 > angle1 ? twoPi : 0);
}
function getAngleRatioRadians(angle2) {
  const normalizedAngle = normalizeAngle360(angle2);
  if (normalizedAngle <= halfPi) {
    return normalizedAngle / halfPi;
  } else if (normalizedAngle <= Math.PI) {
    return (Math.PI - normalizedAngle) / halfPi;
  } else if (normalizedAngle <= 1.5 * Math.PI) {
    return (normalizedAngle - Math.PI) / halfPi;
  } else {
    return (twoPi - normalizedAngle) / halfPi;
  }
}
function angularPadding(hPadding, vPadding, angle2) {
  const angleRatio = getAngleRatioRadians(angle2);
  return hPadding * angleRatio + vPadding * Math.abs(1 - angleRatio);
}
function normalizeAngle360FromDegrees(degrees) {
  return degrees ? normalizeAngle360(toRadians(degrees)) : 0;
}

// packages/ag-charts-community/src/util/color.ts
var lerp = (x, y, t) => x * (1 - t) + y * t;
var srgbToLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs <= 0.04045)
    return value / 12.92;
  return sign * ((abs + 0.055) / 1.055) ** 2.4;
};
var srgbFromLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs > 31308e-7) {
    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
  }
  return 12.92 * value;
};
var _Color = class _Color {
  /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */
  constructor(r, g, b, a = 1) {
    this.r = clamp(0, r || 0, 1);
    this.g = clamp(0, g || 0, 1);
    this.b = clamp(0, b || 0, 1);
    this.a = clamp(0, a || 0, 1);
  }
  /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */
  static validColorString(str) {
    if (str.indexOf("#") >= 0) {
      return !!_Color.parseHex(str);
    }
    if (str.indexOf("rgb") >= 0) {
      return !!_Color.stringToRgba(str);
    }
    return _Color.nameToHex.has(str.toLowerCase());
  }
  /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */
  static fromString(str) {
    if (str.indexOf("#") >= 0) {
      return _Color.fromHexString(str);
    }
    const hex = _Color.nameToHex.get(str.toLowerCase());
    if (hex) {
      return _Color.fromHexString(hex);
    }
    if (str.indexOf("rgb") >= 0) {
      return _Color.fromRgbaString(str);
    }
    throw new Error(`Invalid color string: '${str}'`);
  }
  // See https://drafts.csswg.org/css-color/#hex-notation
  static parseHex(input) {
    input = input.replace(/ /g, "").slice(1);
    let parts;
    switch (input.length) {
      case 6:
      case 8:
        parts = [];
        for (let i = 0; i < input.length; i += 2) {
          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
        }
        break;
      case 3:
      case 4:
        parts = input.split("").map((p) => parseInt(p, 16)).map((p) => p + p * 16);
        break;
    }
    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {
      if (parts.length === 3) {
        parts.push(255);
      }
      return parts;
    }
  }
  static fromHexString(str) {
    const values = _Color.parseHex(str);
    if (values) {
      const [r, g, b, a] = values;
      return new _Color(r / 255, g / 255, b / 255, a / 255);
    }
    throw new Error(`Malformed hexadecimal color string: '${str}'`);
  }
  static stringToRgba(str) {
    let po = -1;
    let pc = -1;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (po === -1 && c === "(") {
        po = i;
      } else if (c === ")") {
        pc = i;
        break;
      }
    }
    if (po === -1 || pc === -1)
      return;
    const contents = str.substring(po + 1, pc);
    const parts = contents.split(",");
    const rgba = [];
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      let value = parseFloat(part);
      if (!Number.isFinite(value)) {
        return;
      }
      if (part.indexOf("%") >= 0) {
        value = clamp(0, value, 100);
        value /= 100;
      } else if (i === 3) {
        value = clamp(0, value, 1);
      } else {
        value = clamp(0, value, 255);
        value /= 255;
      }
      rgba.push(value);
    }
    return rgba;
  }
  static fromRgbaString(str) {
    const rgba = _Color.stringToRgba(str);
    if (rgba) {
      if (rgba.length === 3) {
        return new _Color(rgba[0], rgba[1], rgba[2]);
      } else if (rgba.length === 4) {
        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
    }
    throw new Error(`Malformed rgb/rgba color string: '${str}'`);
  }
  static fromArray(arr) {
    if (arr.length === 4) {
      return new _Color(arr[0], arr[1], arr[2], arr[3]);
    }
    if (arr.length === 3) {
      return new _Color(arr[0], arr[1], arr[2]);
    }
    throw new Error("The given array should contain 3 or 4 color components (numbers).");
  }
  static fromHSB(h, s, b, alpha = 1) {
    const rgb = _Color.HSBtoRGB(h, s, b);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromHSL(h, s, l, alpha = 1) {
    const rgb = _Color.HSLtoRGB(h, s, l);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromOKLCH(l, c, h, alpha = 1) {
    const rgb = _Color.OKLCHtoRGB(l, c, h);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static padHex(str) {
    return str.length === 1 ? "0" + str : str;
  }
  toHexString() {
    let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
    if (this.a < 1) {
      hex += _Color.padHex(Math.round(this.a * 255).toString(16));
    }
    return hex;
  }
  toRgbaString(fractionDigits = 3) {
    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
    const k = Math.pow(10, fractionDigits);
    if (this.a !== 1) {
      components.push(Math.round(this.a * k) / k);
      return `rgba(${components.join(", ")})`;
    }
    return `rgb(${components.join(", ")})`;
  }
  toString() {
    if (this.a === 1) {
      return this.toHexString();
    }
    return this.toRgbaString();
  }
  toHSB() {
    return _Color.RGBtoHSB(this.r, this.g, this.b);
  }
  static RGBtoOKLCH(r, g, b) {
    const LSRGB0 = srgbToLinear(r);
    const LSRGB1 = srgbToLinear(g);
    const LSRGB2 = srgbToLinear(b);
    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
    const OKLCH0 = OKLAB0;
    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
    const OKLCH2 = hue >= 0 ? hue : hue + 360;
    return [OKLCH0, OKLCH1, OKLCH2];
  }
  static OKLCHtoRGB(l, c, h) {
    const OKLAB0 = l;
    const OKLAB1 = c * Math.cos(h * Math.PI / 180);
    const OKLAB2 = c * Math.sin(h * Math.PI / 180);
    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;
    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;
    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;
    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
    const SRGB0 = srgbFromLinear(LSRGB0);
    const SRGB1 = srgbFromLinear(LSRGB1);
    const SRGB2 = srgbFromLinear(LSRGB2);
    return [SRGB0, SRGB1, SRGB2];
  }
  static RGBtoHSL(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const l = (max + min) / 2;
    let h;
    let s;
    if (max === min) {
      h = 0;
      s = 0;
    } else {
      const delta4 = max - min;
      s = l > 0.5 ? delta4 / (2 - max - min) : delta4 / (max + min);
      if (max === r) {
        h = (g - b) / delta4 + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / delta4 + 2;
      } else {
        h = (r - g) / delta4 + 4;
      }
      h *= 360 / 6;
    }
    return [h, s, l];
  }
  static HSLtoRGB(h, s, l) {
    h = (h % 360 + 360) % 360;
    if (s === 0) {
      return [l, l, l];
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    function hueToRgb(t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    const r = hueToRgb(h / 360 + 1 / 3);
    const g = hueToRgb(h / 360);
    const b = hueToRgb(h / 360 - 1 / 3);
    return [r, g, b];
  }
  /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   */
  static RGBtoHSB(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const S = max === 0 ? 0 : (max - min) / max;
    let H = 0;
    if (min !== max) {
      const delta4 = max - min;
      const rc = (max - r) / delta4;
      const gc = (max - g) / delta4;
      const bc = (max - b) / delta4;
      if (r === max) {
        H = bc - gc;
      } else if (g === max) {
        H = 2 + rc - bc;
      } else {
        H = 4 + gc - rc;
      }
      H /= 6;
      if (H < 0) {
        H = H + 1;
      }
    }
    return [H * 360, S, max];
  }
  /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */
  static HSBtoRGB(H, S, B) {
    H = (H % 360 + 360) % 360 / 360;
    let r = 0;
    let g = 0;
    let b = 0;
    if (S === 0) {
      r = g = b = B;
    } else {
      const h = (H - Math.floor(H)) * 6;
      const f = h - Math.floor(h);
      const p = B * (1 - S);
      const q = B * (1 - S * f);
      const t = B * (1 - S * (1 - f));
      switch (h >> 0) {
        case 0:
          r = B;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = B;
          b = p;
          break;
        case 2:
          r = p;
          g = B;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = B;
          break;
        case 4:
          r = t;
          g = p;
          b = B;
          break;
        case 5:
          r = B;
          g = p;
          b = q;
          break;
      }
    }
    return [r, g, b];
  }
  static mix(c0, c1, t) {
    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));
  }
  static lighten(c, t) {
    const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
    return _Color.fromOKLCH(clamp(0, oklch[0] + t, 1), oklch[1], oklch[2]);
  }
  static darken(c, t) {
    const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
    return _Color.fromOKLCH(clamp(0, oklch[0] - t, 1), oklch[1], oklch[2]);
  }
  static interpolate(colors, count) {
    const step = 1 / (colors.length - 1);
    const oklchColors = colors.map((c) => _Color.RGBtoOKLCH(c.r, c.g, c.b));
    return Array.from({ length: count }, (_, i) => {
      const t = i / (count - 1);
      const index = colors.length <= 2 ? 0 : Math.min(Math.floor(t * (colors.length - 1)), colors.length - 2);
      const q = (t - index * step) / step;
      const c0 = oklchColors[index];
      const c1 = oklchColors[index + 1];
      return _Color.fromOKLCH(lerp(c0[0], c1[0], q), lerp(c0[1], c1[1], q), lerp(c0[2], c1[2], q));
    });
  }
};
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */
_Color.nameToHex = /* @__PURE__ */ new Map([
  ["aliceblue", "#F0F8FF"],
  ["antiquewhite", "#FAEBD7"],
  ["aqua", "#00FFFF"],
  ["aquamarine", "#7FFFD4"],
  ["azure", "#F0FFFF"],
  ["beige", "#F5F5DC"],
  ["bisque", "#FFE4C4"],
  ["black", "#000000"],
  ["blanchedalmond", "#FFEBCD"],
  ["blue", "#0000FF"],
  ["blueviolet", "#8A2BE2"],
  ["brown", "#A52A2A"],
  ["burlywood", "#DEB887"],
  ["cadetblue", "#5F9EA0"],
  ["chartreuse", "#7FFF00"],
  ["chocolate", "#D2691E"],
  ["coral", "#FF7F50"],
  ["cornflowerblue", "#6495ED"],
  ["cornsilk", "#FFF8DC"],
  ["crimson", "#DC143C"],
  ["cyan", "#00FFFF"],
  ["darkblue", "#00008B"],
  ["darkcyan", "#008B8B"],
  ["darkgoldenrod", "#B8860B"],
  ["darkgray", "#A9A9A9"],
  ["darkgreen", "#006400"],
  ["darkgrey", "#A9A9A9"],
  ["darkkhaki", "#BDB76B"],
  ["darkmagenta", "#8B008B"],
  ["darkolivegreen", "#556B2F"],
  ["darkorange", "#FF8C00"],
  ["darkorchid", "#9932CC"],
  ["darkred", "#8B0000"],
  ["darksalmon", "#E9967A"],
  ["darkseagreen", "#8FBC8F"],
  ["darkslateblue", "#483D8B"],
  ["darkslategray", "#2F4F4F"],
  ["darkslategrey", "#2F4F4F"],
  ["darkturquoise", "#00CED1"],
  ["darkviolet", "#9400D3"],
  ["deeppink", "#FF1493"],
  ["deepskyblue", "#00BFFF"],
  ["dimgray", "#696969"],
  ["dimgrey", "#696969"],
  ["dodgerblue", "#1E90FF"],
  ["firebrick", "#B22222"],
  ["floralwhite", "#FFFAF0"],
  ["forestgreen", "#228B22"],
  ["fuchsia", "#FF00FF"],
  ["gainsboro", "#DCDCDC"],
  ["ghostwhite", "#F8F8FF"],
  ["gold", "#FFD700"],
  ["goldenrod", "#DAA520"],
  ["gray", "#808080"],
  ["green", "#008000"],
  ["greenyellow", "#ADFF2F"],
  ["grey", "#808080"],
  ["honeydew", "#F0FFF0"],
  ["hotpink", "#FF69B4"],
  ["indianred", "#CD5C5C"],
  ["indigo", "#4B0082"],
  ["ivory", "#FFFFF0"],
  ["khaki", "#F0E68C"],
  ["lavender", "#E6E6FA"],
  ["lavenderblush", "#FFF0F5"],
  ["lawngreen", "#7CFC00"],
  ["lemonchiffon", "#FFFACD"],
  ["lightblue", "#ADD8E6"],
  ["lightcoral", "#F08080"],
  ["lightcyan", "#E0FFFF"],
  ["lightgoldenrodyellow", "#FAFAD2"],
  ["lightgray", "#D3D3D3"],
  ["lightgreen", "#90EE90"],
  ["lightgrey", "#D3D3D3"],
  ["lightpink", "#FFB6C1"],
  ["lightsalmon", "#FFA07A"],
  ["lightseagreen", "#20B2AA"],
  ["lightskyblue", "#87CEFA"],
  ["lightslategray", "#778899"],
  ["lightslategrey", "#778899"],
  ["lightsteelblue", "#B0C4DE"],
  ["lightyellow", "#FFFFE0"],
  ["lime", "#00FF00"],
  ["limegreen", "#32CD32"],
  ["linen", "#FAF0E6"],
  ["magenta", "#FF00FF"],
  ["maroon", "#800000"],
  ["mediumaquamarine", "#66CDAA"],
  ["mediumblue", "#0000CD"],
  ["mediumorchid", "#BA55D3"],
  ["mediumpurple", "#9370DB"],
  ["mediumseagreen", "#3CB371"],
  ["mediumslateblue", "#7B68EE"],
  ["mediumspringgreen", "#00FA9A"],
  ["mediumturquoise", "#48D1CC"],
  ["mediumvioletred", "#C71585"],
  ["midnightblue", "#191970"],
  ["mintcream", "#F5FFFA"],
  ["mistyrose", "#FFE4E1"],
  ["moccasin", "#FFE4B5"],
  ["navajowhite", "#FFDEAD"],
  ["navy", "#000080"],
  ["oldlace", "#FDF5E6"],
  ["olive", "#808000"],
  ["olivedrab", "#6B8E23"],
  ["orange", "#FFA500"],
  ["orangered", "#FF4500"],
  ["orchid", "#DA70D6"],
  ["palegoldenrod", "#EEE8AA"],
  ["palegreen", "#98FB98"],
  ["paleturquoise", "#AFEEEE"],
  ["palevioletred", "#DB7093"],
  ["papayawhip", "#FFEFD5"],
  ["peachpuff", "#FFDAB9"],
  ["peru", "#CD853F"],
  ["pink", "#FFC0CB"],
  ["plum", "#DDA0DD"],
  ["powderblue", "#B0E0E6"],
  ["purple", "#800080"],
  ["rebeccapurple", "#663399"],
  ["red", "#FF0000"],
  ["rosybrown", "#BC8F8F"],
  ["royalblue", "#4169E1"],
  ["saddlebrown", "#8B4513"],
  ["salmon", "#FA8072"],
  ["sandybrown", "#F4A460"],
  ["seagreen", "#2E8B57"],
  ["seashell", "#FFF5EE"],
  ["sienna", "#A0522D"],
  ["silver", "#C0C0C0"],
  ["skyblue", "#87CEEB"],
  ["slateblue", "#6A5ACD"],
  ["slategray", "#708090"],
  ["slategrey", "#708090"],
  ["snow", "#FFFAFA"],
  ["springgreen", "#00FF7F"],
  ["steelblue", "#4682B4"],
  ["tan", "#D2B48C"],
  ["teal", "#008080"],
  ["thistle", "#D8BFD8"],
  ["tomato", "#FF6347"],
  ["transparent", "#00000000"],
  ["turquoise", "#40E0D0"],
  ["violet", "#EE82EE"],
  ["wheat", "#F5DEB3"],
  ["white", "#FFFFFF"],
  ["whitesmoke", "#F5F5F5"],
  ["yellow", "#FFFF00"],
  ["yellowgreen", "#9ACD32"]
]);
var Color = _Color;

// packages/ag-charts-community/src/scale/scale.ts
var ScaleAlignment = /* @__PURE__ */ ((ScaleAlignment2) => {
  ScaleAlignment2[ScaleAlignment2["Leading"] = 0] = "Leading";
  ScaleAlignment2[ScaleAlignment2["Trailing"] = 1] = "Trailing";
  ScaleAlignment2[ScaleAlignment2["Interpolate"] = 2] = "Interpolate";
  return ScaleAlignment2;
})(ScaleAlignment || {});

// packages/ag-charts-community/src/scale/abstractScale.ts
var AbstractScale = class {
  ticks(_ticks, _domain, _visibleRange) {
    return void 0;
  }
  niceDomain(_ticks, domain = this.domain) {
    return domain;
  }
  get bandwidth() {
    return void 0;
  }
  get step() {
    return void 0;
  }
  get inset() {
    return void 0;
  }
};

// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating = (target, propertyKey) => {
  const mappedProperty = Symbol(String(propertyKey));
  target[mappedProperty] = void 0;
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[mappedProperty];
    },
    set(newValue) {
      const oldValue = this[mappedProperty];
      if (oldValue !== newValue) {
        this[mappedProperty] = newValue;
        this.invalid = true;
      }
    },
    enumerable: true,
    configurable: false
  });
};

// packages/ag-charts-community/src/scale/colorScale.ts
var convertColorStringToOklcha = (v) => {
  const color2 = Color.fromString(v);
  const [l, c, h] = Color.RGBtoOKLCH(color2.r, color2.g, color2.b);
  return { l, c, h, a: color2.a };
};
var delta = 1e-6;
var isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;
var interpolateOklch = (x, y, d) => {
  d = clamp(0, d, 1);
  let h;
  if (isAchromatic(x)) {
    h = y.h;
  } else if (isAchromatic(y)) {
    h = x.h;
  } else {
    const xH = x.h;
    let yH = y.h;
    const deltaH = y.h - x.h;
    if (deltaH > 180) {
      yH -= 360;
    } else if (deltaH < -180) {
      yH += 360;
    }
    h = xH * (1 - d) + yH * d;
  }
  const c = x.c * (1 - d) + y.c * d;
  const l = x.l * (1 - d) + y.l * d;
  const a = x.a * (1 - d) + y.a * d;
  return Color.fromOKLCH(l, c, h, a);
};
var ColorScale = class extends AbstractScale {
  constructor() {
    super(...arguments);
    this.type = "color";
    this.defaultTickCount = 0;
    this.invalid = true;
    this.domain = [0, 1];
    this.range = ["red", "blue"];
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  update() {
    const { domain, range: range4 } = this;
    if (domain.length < 2) {
      logger_exports.warnOnce("`colorDomain` should have at least 2 values.");
      if (domain.length === 0) {
        domain.push(0, 1);
      } else if (domain.length === 1) {
        domain.push(domain[0] + 1);
      }
    }
    for (let i = 1; i < domain.length; i++) {
      const a = domain[i - 1];
      const b = domain[i];
      if (a > b) {
        logger_exports.warnOnce("`colorDomain` values should be supplied in ascending order.");
        domain.sort((a2, b2) => a2 - b2);
        break;
      }
    }
    if (range4.length < domain.length) {
      for (let i = range4.length; i < domain.length; i++) {
        range4.push(range4.length > 0 ? range4[0] : "black");
      }
    }
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  normalizeDomains(...domains) {
    return { domain: domains.flat(), animatable: true };
  }
  toDomain() {
    return;
  }
  convert(x) {
    this.refresh();
    const { domain, range: range4, parsedRange } = this;
    const d0 = domain[0];
    const d1 = domain.at(-1);
    const r0 = range4[0];
    const r1 = range4[range4.length - 1];
    if (x <= d0) {
      return r0;
    }
    if (x >= d1) {
      return r1;
    }
    let index;
    let q;
    if (domain.length === 2) {
      const t = (x - d0) / (d1 - d0);
      const step = 1 / (range4.length - 1);
      index = range4.length <= 2 ? 0 : Math.min(Math.floor(t * (range4.length - 1)), range4.length - 2);
      q = (t - index * step) / step;
    } else {
      for (index = 0; index < domain.length - 2; index++) {
        if (x < domain[index + 1]) {
          break;
        }
      }
      const a = domain[index];
      const b = domain[index + 1];
      q = (x - a) / (b - a);
    }
    const c0 = parsedRange[index];
    const c1 = parsedRange[index + 1];
    return interpolateOklch(c0, c1, q).toRgbaString();
  }
  invert() {
    return;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      logger_exports.warnOnce("Expected update to not invalidate scale");
    }
  }
};
__decorateClass([
  Invalidating
], ColorScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], ColorScale.prototype, "range", 2);

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient = class {
  constructor(colorSpace, stops = [], bbox) {
    this.colorSpace = colorSpace;
    this.stops = stops;
    this.bbox = bbox;
    this._cache = void 0;
  }
  createGradient(ctx, shapeBbox, params) {
    const bbox = this.bbox ?? shapeBbox;
    if (!bbox.isFinite()) {
      return;
    }
    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {
      return this._cache.gradient;
    }
    const { stops, colorSpace } = this;
    if (stops.length === 0)
      return;
    if (stops.length === 1)
      return stops[0].color;
    let gradient2 = this.createCanvasGradient(ctx, bbox, params);
    if (gradient2 == null)
      return;
    const isOkLch = colorSpace === "oklch";
    const step = 0.05;
    let c0 = stops[0];
    gradient2.addColorStop(c0.stop, c0.color);
    for (let i = 1; i < stops.length; i += 1) {
      const c1 = stops[i];
      if (isOkLch) {
        const scale2 = new ColorScale();
        scale2.domain = [c0.stop, c1.stop];
        scale2.range = [c0.color, c1.color];
        for (let stop = c0.stop + step; stop < c1.stop; stop += step) {
          gradient2.addColorStop(stop, scale2.convert(stop));
        }
      }
      gradient2.addColorStop(c1.stop, c1.color);
      c0 = c1;
    }
    if ("createPattern" in gradient2) {
      gradient2 = gradient2.createPattern();
    }
    this._cache = { ctx, bbox, gradient: gradient2 };
    return gradient2;
  }
  toSvg(shapeBbox) {
    const bbox = this.bbox ?? shapeBbox;
    const gradient2 = this.createSvgGradient(bbox);
    this.stops.forEach(({ stop: offset, color: color2 }) => {
      const stop = createSvgElement("stop");
      stop.setAttribute("offset", `${offset}`);
      stop.setAttribute("stop-color", `${color2}`);
      gradient2.appendChild(stop);
    });
    return gradient2;
  }
};

// packages/ag-charts-community/src/scene/gradient/conicGradient.ts
var ConicGradient = class extends Gradient {
  constructor(colorSpace, stops, angle2 = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle2;
  }
  createCanvasGradient(ctx, bbox, params) {
    const angleOffset = -90;
    const { angle: angle2 } = this;
    const radians = normalizeAngle360FromDegrees(angle2 + angleOffset);
    const cx = params?.centerX ?? bbox.x + bbox.width * 0.5;
    const cy = params?.centerY ?? bbox.y + bbox.height * 0.5;
    return ctx.createConicGradient(radians, cx, cy);
  }
  createSvgGradient(_bbox) {
    return createSvgElement("linearGradient");
  }
};

// packages/ag-charts-community/src/scene/gradient/linearGradient.ts
var LinearGradient = class extends Gradient {
  constructor(colorSpace, stops, angle2 = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle2;
  }
  getGradientPoints(bbox) {
    const angleOffset = 90;
    const { angle: angle2 } = this;
    const radians = normalizeAngle360FromDegrees(angle2 + angleOffset);
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const w = bbox.width;
    const h = bbox.height;
    const cx = bbox.x + w * 0.5;
    const cy = bbox.y + h * 0.5;
    const diagonal = Math.sqrt(h * h + w * w) / 2;
    const diagonalAngle = Math.atan2(h, w);
    let quarteredAngle;
    if (radians < Math.PI / 2) {
      quarteredAngle = radians;
    } else if (radians < Math.PI) {
      quarteredAngle = Math.PI - radians;
    } else if (radians < 1.5 * Math.PI) {
      quarteredAngle = radians - Math.PI;
    } else {
      quarteredAngle = 2 * Math.PI - radians;
    }
    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
    return { x0: cx + cos * l, y0: cy + sin * l, x1: cx - cos * l, y1: cy - sin * l };
  }
  createCanvasGradient(ctx, bbox) {
    const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
    if (isNaN(x0) || isNaN(y0) || isNaN(x1) || isNaN(y1)) {
      return void 0;
    }
    return ctx.createLinearGradient(x0, y0, x1, y1);
  }
  createSvgGradient(bbox) {
    const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
    const gradient2 = createSvgElement("linearGradient");
    gradient2.setAttribute("x1", String(x0));
    gradient2.setAttribute("y1", String(y0));
    gradient2.setAttribute("x2", String(x1));
    gradient2.setAttribute("y2", String(y1));
    gradient2.setAttribute("gradientUnits", "userSpaceOnUse");
    return gradient2;
  }
};

// packages/ag-charts-community/src/scene/gradient/radialGradient.ts
var RadialGradient = class extends Gradient {
  constructor(colorSpace, stops, bbox) {
    super(colorSpace, stops, bbox);
  }
  createCanvasGradient(ctx, bbox, params) {
    const cx = params?.centerX ?? bbox.x + bbox.width * 0.5;
    const cy = params?.centerY ?? bbox.y + bbox.height * 0.5;
    const innerRadius = params?.innerRadius ?? 0;
    const outerRadius = params?.outerRadius ?? Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2;
    return ctx.createRadialGradient(cx, cy, innerRadius, cx, cy, outerRadius);
  }
  createSvgGradient(bbox) {
    const cx = bbox.x + bbox.width * 0.5;
    const cy = bbox.y + bbox.height * 0.5;
    const gradient2 = createSvgElement("radialGradient");
    gradient2.setAttribute("cx", String(cx));
    gradient2.setAttribute("cy", String(cy));
    gradient2.setAttribute("r", String(Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2));
    gradient2.setAttribute("gradientUnits", "userSpaceOnUse");
    return gradient2;
  }
};

// packages/ag-charts-community/src/util/properties.ts
var Property = addFakeTransformToInstanceProperty;
var BaseProperties = class {
  handleUnknownProperties(_unknownKeys, _properties) {
  }
  set(properties) {
    const { className = this.constructor.name } = this.constructor;
    if (properties == null) {
      this.clear();
      return this;
    }
    if (typeof properties !== "object") {
      logger_exports.warn(`unable to set ${className} - expecting a properties object`);
      return this;
    }
    const keys = new Set(Object.keys(properties));
    for (const propertyKey of listDecoratedProperties(this)) {
      if (keys.has(propertyKey)) {
        const value = properties[propertyKey];
        const self = this;
        if (isProperties(self[propertyKey])) {
          if (self[propertyKey] instanceof PropertiesArray) {
            const array2 = self[propertyKey].reset(value);
            if (array2 == null) {
              logger_exports.warn(`unable to set [${String(propertyKey)}] - expecting a properties array`);
            } else {
              self[propertyKey] = array2;
            }
          } else {
            self[propertyKey].set(value);
          }
        } else if (isPlainObject(value)) {
          self[propertyKey] = merge(value, self[propertyKey] ?? {});
        } else {
          self[propertyKey] = value;
        }
        keys.delete(propertyKey);
      }
    }
    this.handleUnknownProperties(keys, properties);
    for (const unknownKey of keys) {
      logger_exports.warn(`unable to set [${String(unknownKey)}] in ${className} - property is unknown`);
    }
    return this;
  }
  clear() {
    for (const propertyKey of listDecoratedProperties(this)) {
      const currentValue = this[propertyKey];
      if (isProperties(currentValue)) {
        currentValue.clear();
      } else {
        this[propertyKey] = void 0;
      }
    }
    return this;
  }
  toJson() {
    return listDecoratedProperties(this).reduce((object2, propertyKey) => {
      const propertyValue = this[propertyKey];
      object2[String(propertyKey)] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
      return object2;
    }, {});
  }
};
var PropertiesArray = class _PropertiesArray extends Array {
  constructor(itemFactory, ...properties) {
    super(properties.length);
    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);
    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;
    Object.defineProperty(this, "itemFactory", { value, enumerable: false, configurable: false });
    this.set(properties);
  }
  set(properties) {
    if (isArray(properties)) {
      this.length = properties.length;
      for (let i = 0; i < properties.length; i++) {
        this[i] = this.itemFactory(properties[i]);
      }
    }
    return this;
  }
  reset(properties) {
    if (Array.isArray(properties)) {
      return new _PropertiesArray(this.itemFactory, ...properties);
    }
  }
  toJson() {
    return this.map((value) => value?.toJson?.() ?? value);
  }
};
function isProperties(value) {
  return value instanceof BaseProperties || value instanceof PropertiesArray;
}

// packages/ag-charts-community/src/scene/gradient/stops.ts
var StopProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Property
], StopProperties.prototype, "stop", 2);
__decorateClass([
  Property
], StopProperties.prototype, "color", 2);
function stopsAreAscending(fills) {
  let currentStop;
  for (const fill of fills) {
    if (fill?.stop == null)
      continue;
    if (currentStop != null && fill.stop < currentStop) {
      return false;
    }
    currentStop = fill.stop;
  }
  return true;
}
function discreteColorStops(colorStops) {
  return colorStops.flatMap((colorStop2, i) => {
    const { stop } = colorStop2;
    const nextColor = colorStops.at(i + 1)?.color;
    return nextColor != null ? [colorStop2, { stop, color: nextColor }] : [colorStop2];
  });
}
function getDefaultColorStops(defaultColorStops, fillMode) {
  const stopOffset = fillMode === "discrete" ? 1 : 0;
  const colorStops = defaultColorStops.map(
    (color2, index, { length: length2 }) => ({
      stop: (index + stopOffset) / (length2 - 1 + stopOffset),
      color: color2
    })
  );
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}
function getColorStops(baseFills, defaultColorStops, domain, fillMode = "continuous") {
  const fills = baseFills.map((fill) => typeof fill === "string" ? { color: fill } : fill);
  if (fills.length === 0) {
    return getDefaultColorStops(defaultColorStops, fillMode);
  } else if (!stopsAreAscending(fills)) {
    logger_exports.warnOnce(`[fills] must have the stops defined in ascending order`);
    return [];
  }
  const d0 = Math.min(...domain);
  const d1 = Math.max(...domain);
  const isDiscrete = fillMode === "discrete";
  const stops = new Float64Array(fills.length);
  let previousDefinedStopIndex = 0;
  let nextDefinedStopIndex = -1;
  for (let i = 0; i < fills.length; i += 1) {
    const colorStop2 = fills[i];
    if (i >= nextDefinedStopIndex) {
      nextDefinedStopIndex = fills.length - 1;
      for (let j = i + 1; j < fills.length; j += 1) {
        if (fills[j]?.stop != null) {
          nextDefinedStopIndex = j;
          break;
        }
      }
    }
    let stop = colorStop2?.stop;
    if (stop == null) {
      const stop0 = fills[previousDefinedStopIndex]?.stop;
      const stop1 = fills[nextDefinedStopIndex]?.stop;
      const value0 = stop0 ?? d0;
      const value1 = stop1 ?? d1;
      const stopOffset = isDiscrete && stop0 == null ? 1 : 0;
      stop = value0 + (value1 - value0) * (i - previousDefinedStopIndex + stopOffset) / (nextDefinedStopIndex - previousDefinedStopIndex + stopOffset);
    } else {
      previousDefinedStopIndex = i;
    }
    stops[i] = Math.max(0, Math.min(1, (stop - d0) / (d1 - d0)));
  }
  let lastDefinedColor = fills.find((c) => c.color != null)?.color;
  let colorScale;
  const colorStops = fills.map((fill, i) => {
    let color2 = fill?.color;
    const stop = stops[i];
    if (color2 != null) {
      lastDefinedColor = color2;
    } else if (lastDefinedColor != null) {
      color2 = lastDefinedColor;
    } else {
      if (colorScale == null) {
        colorScale = new ColorScale();
        colorScale.domain = [0, 1];
        colorScale.range = defaultColorStops;
      }
      color2 = colorScale.convert(stop);
    }
    return { stop, color: color2 };
  });
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}

// packages/ag-charts-community/src/scene/image/image.ts
var Image2 = class {
  constructor(imageLoader, imageOptions) {
    this.imageLoader = imageLoader;
    this._cache = void 0;
    this.url = imageOptions.url;
    this.backgroundFill = imageOptions.backgroundFill ?? "black";
    this.backgroundFillOpacity = imageOptions.backgroundFillOpacity ?? 1;
    this.repeat = imageOptions.repeat ?? "no-repeat";
    this.width = imageOptions.width;
    this.height = imageOptions.height;
    this.fit = imageOptions.fit ?? "stretch";
    this.rotation = imageOptions.rotation ?? 0;
  }
  createCanvasImage(ctx, image, width2, height2) {
    if (!image)
      return null;
    const [renderedWidth, renderedHeight] = this.getSize(image.width, image.height, width2, height2);
    if (renderedWidth < 1 || renderedHeight < 1) {
      logger_exports.warnOnce("Image fill is too small to render, ignoring.");
      return null;
    }
    return ctx.createPattern(image, this.repeat);
  }
  getSize(imageWidth, imageHeight, width2, height2) {
    const { fit } = this;
    let dw = imageWidth;
    let dh = imageHeight;
    let scale2 = 1;
    const shapeAspectRatio = width2 / height2;
    const imageAspectRatio = imageWidth / imageHeight;
    if (fit === "stretch" || imageWidth === 0 || imageHeight === 0) {
      dw = width2;
      dh = height2;
    } else if (fit === "contain") {
      scale2 = imageAspectRatio > shapeAspectRatio ? width2 / imageWidth : height2 / imageHeight;
    } else if (fit === "cover") {
      scale2 = imageAspectRatio > shapeAspectRatio ? height2 / imageHeight : width2 / imageWidth;
    }
    return [Math.max(1, dw * scale2), Math.max(1, dh * scale2)];
  }
  setImageTransform(pattern, bbox) {
    if (typeof pattern === "string")
      return;
    const { url, rotation, width: width2, height: height2 } = this;
    const image = this.imageLoader?.loadImage(url);
    if (!image) {
      return;
    }
    const angle2 = normalizeAngle360FromDegrees(rotation);
    const cos = Math.cos(angle2);
    const sin = Math.sin(angle2);
    const [renderedWidth, renderedHeight] = this.getSize(
      image.width,
      image.height,
      width2 ?? bbox.width,
      height2 ?? bbox.height
    );
    const widthScale = renderedWidth / image.width;
    const heightScale = renderedHeight / image.height;
    const bboxCenterX = bbox.x + bbox.width / 2;
    const bboxCenterY = bbox.y + bbox.height / 2;
    const rotatedW = cos * renderedWidth - sin * renderedHeight;
    const rotatedH = sin * renderedWidth + cos * renderedHeight;
    const shapeCenterX = rotatedW / 2;
    const shapeCenterY = rotatedH / 2;
    pattern?.setTransform(
      new DOMMatrix([
        cos * widthScale,
        sin * heightScale,
        -sin * widthScale,
        cos * heightScale,
        bboxCenterX - shapeCenterX,
        bboxCenterY - shapeCenterY
      ])
    );
  }
  createPattern(ctx, shapeWidth, shapeHeight, node) {
    const width2 = this.width ?? shapeWidth;
    const height2 = this.height ?? shapeHeight;
    const cache = this._cache;
    if (cache != null && cache.ctx === ctx && cache.width === width2 && cache.height === height2) {
      return cache.pattern;
    }
    const image = this.imageLoader?.loadImage(this.url, node);
    const pattern = this.createCanvasImage(ctx, image, width2, height2);
    if (pattern == null)
      return;
    this._cache = { ctx, pattern, width: width2, height: height2 };
    return pattern;
  }
  toSvg(bbox, pixelRatio) {
    const { url, rotation, backgroundFill, backgroundFillOpacity } = this;
    const { x, y, width: width2, height: height2 } = bbox;
    const pattern = createSvgElement("pattern");
    pattern.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    pattern.setAttribute("x", String(x));
    pattern.setAttribute("y", String(y));
    pattern.setAttribute("width", String(width2));
    pattern.setAttribute("height", String(height2));
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    const rect = createSvgElement("rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width2));
    rect.setAttribute("height", String(height2));
    rect.setAttribute("fill", backgroundFill);
    rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
    pattern.appendChild(rect);
    const image = createSvgElement("image");
    image.setAttribute("href", url);
    image.setAttribute("x", "0");
    image.setAttribute("y", "0");
    image.setAttribute("width", String(width2));
    image.setAttribute("height", String(height2));
    image.setAttribute("preserveAspectRatio", "none");
    image.setAttribute("transform", `scale(${1 / pixelRatio}) rotate(${rotation}, ${width2 / 2}, ${height2 / 2})`);
    pattern.appendChild(image);
    return pattern;
  }
};

// packages/ag-charts-community/src/util/distance.ts
function pointsDistanceSquared(x1, y1, x2, y2) {
  const dx2 = x1 - x2;
  const dy2 = y1 - y2;
  return dx2 * dx2 + dy2 * dy2;
}
function lineDistanceSquared(x, y, x1, y1, x2, y2, best) {
  if (x1 === x2 && y1 === y2) {
    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));
  }
  const dx2 = x2 - x1;
  const dy2 = y2 - y1;
  const t = Math.max(0, Math.min(1, ((x - x1) * dx2 + (y - y1) * dy2) / (dx2 * dx2 + dy2 * dy2)));
  const ix = x1 + t * dx2;
  const iy = y1 + t * dy2;
  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));
}

// packages/ag-charts-community/src/util/svg.ts
var commandEx = /^[\t\n\f\r ]*([achlmqstvz])[\t\n\f\r ]*/i;
var coordinateEx = /^[+-]?((\d*\.\d+)|(\d+\.)|(\d+))(e[+-]?\d+)?/i;
var commaEx = /[\t\n\f\r ]*,?[\t\n\f\r ]*/;
var flagEx = /^[01]/;
var pathParams = {
  z: [],
  h: [coordinateEx],
  v: [coordinateEx],
  m: [coordinateEx, coordinateEx],
  l: [coordinateEx, coordinateEx],
  t: [coordinateEx, coordinateEx],
  s: [coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  q: [coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  c: [coordinateEx, coordinateEx, coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  a: [coordinateEx, coordinateEx, coordinateEx, flagEx, flagEx, coordinateEx, coordinateEx]
};
function parseSvg(d) {
  if (!d)
    return;
  const segments = [];
  let i = 0;
  let currentCommand;
  while (i < d.length) {
    const commandMatch = commandEx.exec(d.slice(i));
    let command;
    if (commandMatch == null) {
      if (!currentCommand) {
        logger_exports.warnOnce(`Invalid SVG path, error at index ${i}: Missing command.`);
        return;
      }
      command = currentCommand;
    } else {
      command = commandMatch[1];
      i += commandMatch[0].length;
    }
    const segment = parseSegment(command, d, i);
    if (!segment)
      return;
    i = segment[0];
    currentCommand = command;
    segments.push(segment[1]);
  }
  return segments;
}
function parseSegment(command, d, index) {
  const params = pathParams[command.toLocaleLowerCase()];
  const pathSeg = { command, params: [] };
  for (const regex of params) {
    const segment = d.slice(index);
    const match = regex.exec(segment);
    if (match != null) {
      pathSeg.params.push(parseFloat(match[0]));
      index += match[0].length;
      const next = commaEx.exec(segment.slice(match[0].length));
      if (next != null) {
        index += next[0].length;
      }
    } else if (pathSeg.params.length === 1) {
      return [index, pathSeg];
    } else {
      logger_exports.warnOnce(
        `Invalid SVG path, error at index ${index}: No path segment parameters for command [${command}]`
      );
      return;
    }
  }
  return [index, pathSeg];
}

// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function quadraticRoots(a, b, c, delta4 = 1e-6) {
  if (Math.abs(a) < delta4) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c;
  const roots = [];
  if (Math.abs(D) < delta4) {
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  return roots;
}
function cubicRoots(a, b, c, d, delta4 = 1e-6) {
  if (Math.abs(a) < delta4) {
    return quadraticRoots(b, c, d, delta4);
  }
  const A = b / a;
  const B = c / a;
  const C2 = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C2 - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R;
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
    const t = -third * A + (S + T);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Math.abs(Im) < delta4) {
      const t2 = -third * A - (S + T) / 2;
      if (t2 >= 0 && t2 <= 1) {
        roots.push(t2);
      }
    }
  } else {
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}

// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    return 0;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return 1;
  }
  return 0;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  let intersections = 0;
  const A = y1 - y2;
  const B = x2 - x1;
  const C2 = x1 * (y2 - y1) - y1 * (x2 - x1);
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0];
  const b = A * bx[1] + B * by[1];
  const c = A * bx[2] + B * by[2];
  const d = A * bx[3] + B * by[3] + C2;
  const roots = cubicRoots(a, b, c, d);
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    let s;
    if (x1 === x2) {
      s = (y - y1) / (y2 - y1);
    } else {
      s = (x - x1) / (x2 - x1);
    }
    if (s >= 0 && s <= 1) {
      intersections++;
    }
  }
  return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
  return [
    // Bzier expressed as matrix operations:
    //                 |-1  3 -3  1| |P1|
    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
    //                 |-3  3  0  0| |P3|
    //                 | 1  0  0  0| |P4|
    -P1 + 3 * P2 - 3 * P3 + P4,
    3 * P1 - 6 * P2 + 3 * P3,
    -3 * P1 + 3 * P2,
    P1
  ];
}

// packages/ag-charts-community/src/scene/util/bezier.ts
function evaluateBezier(p0, p1, p2, p3, t) {
  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;
}
function solveBezier(p0, p1, p2, p3, value) {
  if (value <= Math.min(p0, p3)) {
    return p0 < p3 ? 0 : 1;
  } else if (value >= Math.max(p0, p3)) {
    return p0 < p3 ? 1 : 0;
  }
  let t0 = 0;
  let t1 = 1;
  let t = NaN;
  for (let i = 0; i < 12; i += 1) {
    t = (t0 + t1) / 2;
    const curveValue = evaluateBezier(p0, p1, p2, p3, t);
    if (curveValue < value) {
      t0 = t;
    } else {
      t1 = t;
    }
  }
  return t;
}
function splitBezier2D(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {
  const x01 = (1 - t) * p0x + t * p1x;
  const y01 = (1 - t) * p0y + t * p1y;
  const x12 = (1 - t) * p1x + t * p2x;
  const y12 = (1 - t) * p1y + t * p2y;
  const x23 = (1 - t) * p2x + t * p3x;
  const y23 = (1 - t) * p2y + t * p3y;
  const x012 = (1 - t) * x01 + t * x12;
  const y012 = (1 - t) * y01 + t * y12;
  const x123 = (1 - t) * x12 + t * x23;
  const y123 = (1 - t) * y12 + t * y23;
  const x0123 = (1 - t) * x012 + t * x123;
  const y0123 = (1 - t) * y012 + t * y123;
  return [
    [
      { x: p0x, y: p0y },
      { x: x01, y: y01 },
      { x: x012, y: y012 },
      { x: x0123, y: y0123 }
    ],
    [
      { x: x0123, y: y0123 },
      { x: x123, y: y123 },
      { x: x23, y: y23 },
      { x: p3x, y: p3y }
    ]
  ];
}
function calculateDerivativeExtrema(p0, p1, p2, p3) {
  const a = -p0 + 3 * p1 - 3 * p2 + p3;
  const b = 2 * (p0 - 2 * p1 + p2);
  const c = -p0 + p1;
  if (a === 0) {
    if (b !== 0) {
      const t = -c / b;
      if (t > 0 && t < 1) {
        return [t];
      }
    }
    return [];
  }
  const discriminant = b * b - 4 * a * c;
  if (discriminant >= 0) {
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b + sqrtDiscriminant) / (2 * a);
    const t2 = (-b - sqrtDiscriminant) / (2 * a);
    return [t1, t2].filter((t) => t > 0 && t < 1);
  }
  return [];
}
function bezier2DExtrema(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {
  const tx = calculateDerivativeExtrema(cp0x, cp1x, cp2x, cp3x);
  const ty = calculateDerivativeExtrema(cp0y, cp1y, cp2y, cp3y);
  return [...tx, ...ty];
}
function bezierCandidate(points, x, y) {
  const midX = evaluateBezier(points[0].x, points[1].x, points[2].x, points[3].x, 0.5);
  const midY = evaluateBezier(points[0].y, points[1].y, points[2].y, points[3].y, 0.5);
  const distance2 = Math.hypot(midX - x, midY - y);
  const minDistance = Math.min(
    Math.hypot(points[0].x - x, points[0].y - y),
    Math.hypot(points[1].x - x, points[1].y - y),
    Math.hypot(points[2].x - x, points[2].y - y),
    Math.hypot(points[3].x - x, points[3].y - y)
  );
  return { points, distance: distance2, minDistance };
}
function bezier2DDistance(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, x, y, precision = 1) {
  const points0 = [
    { x: cp0x, y: cp0y },
    { x: cp1x, y: cp1y },
    { x: cp2x, y: cp2y },
    { x: cp3x, y: cp3y }
  ];
  let queue = {
    value: bezierCandidate(points0, x, y),
    next: null
  };
  let bestResult;
  while (queue != null) {
    const { points, distance: distance2, minDistance } = queue.value;
    queue = queue.next;
    if (bestResult == null || distance2 < bestResult.distance) {
      bestResult = { distance: distance2, minDistance };
    }
    if (bestResult != null && bestResult.distance - minDistance <= precision) {
      continue;
    }
    const [leftPoints, rightPoints] = splitBezier2D(
      points[0].x,
      points[0].y,
      points[1].x,
      points[1].y,
      points[2].x,
      points[2].y,
      points[3].x,
      points[3].y,
      0.5
    );
    const newCandidates = [bezierCandidate(leftPoints, x, y), bezierCandidate(rightPoints, x, y)].sort(
      bezierCandidateCmp
    );
    queue = insertListItemsSorted(queue, newCandidates, bezierCandidateCmp);
  }
  return bestResult?.distance ?? Infinity;
}
var bezierCandidateCmp = (a, b) => b.minDistance - a.minDistance;

// packages/ag-charts-community/src/scene/extendedPath2D.ts
var ExtendedPath2D = class {
  constructor() {
    // The methods of this class will likely be called many times per animation frame,
    // and any allocation can trigger a GC cycle during animation, so we attempt
    // to minimize the number of allocations.
    this.path2d = new Path2D();
    this.previousCommands = [];
    this.previousParams = [];
    this.previousClosedPath = false;
    this.commands = [];
    this.params = [];
    this.cx = NaN;
    this.cy = NaN;
    this.sx = NaN;
    this.sy = NaN;
    this.openedPath = false;
    this.closedPath = false;
  }
  isEmpty() {
    return this.commands.length === 0;
  }
  isDirty() {
    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();
  }
  getPath2D() {
    return this.path2d;
  }
  moveTo(x, y) {
    this.openedPath = true;
    this.sx = x;
    this.sy = y;
    this.cx = x;
    this.cy = y;
    this.path2d.moveTo(x, y);
    this.commands.push(0 /* Move */);
    this.params.push(x, y);
  }
  lineTo(x, y) {
    if (this.openedPath) {
      this.cx = x;
      this.cy = y;
      this.path2d.lineTo(x, y);
      this.commands.push(1 /* Line */);
      this.params.push(x, y);
    } else {
      this.moveTo(x, y);
    }
  }
  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
    if (!this.openedPath) {
      this.moveTo(cx1, cy1);
    }
    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
    this.commands.push(2 /* Curve */);
    this.params.push(cx1, cy1, cx2, cy2, x, y);
  }
  closePath() {
    if (this.openedPath) {
      this.cx = this.sx;
      this.cy = this.sy;
      this.sx = NaN;
      this.sy = NaN;
      this.path2d.closePath();
      this.commands.push(3 /* ClosePath */);
      this.openedPath = false;
      this.closedPath = true;
    }
  }
  rect(x, y, width2, height2) {
    this.moveTo(x, y);
    this.lineTo(x + width2, y);
    this.lineTo(x + width2, y + height2);
    this.lineTo(x, y + height2);
    this.closePath();
  }
  roundRect(x, y, width2, height2, radii) {
    radii = Math.min(radii, width2 / 2, height2 / 2);
    this.moveTo(x, y + radii);
    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);
    this.lineTo(x + radii, y);
    this.lineTo(x + width2 - radii, y);
    this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);
    this.lineTo(x + width2, y + radii);
    this.lineTo(x + width2, y + height2 - radii);
    this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);
    this.lineTo(x + width2 - radii, y + height2);
    this.lineTo(x + radii, y + height2);
    this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);
    this.lineTo(x, y + height2 - radii);
    this.closePath();
  }
  ellipse(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise = false) {
    const r = rx;
    const scaleY = ry / rx;
    const mxx = Math.cos(rotation);
    const myx = Math.sin(rotation);
    const mxy = -scaleY * myx;
    const myy = scaleY * mxx;
    const x0 = r * Math.cos(sAngle);
    const y0 = r * Math.sin(sAngle);
    const sx = cx + mxx * x0 + mxy * y0;
    const sy = cy + myx * x0 + myy * y0;
    const distanceSquared2 = (sx - this.cx) ** 2 + (sy - this.cy) ** 2;
    if (!this.openedPath) {
      this.moveTo(sx, sy);
    } else if (distanceSquared2 > 1e-6) {
      this.lineTo(sx, sy);
    }
    let sweep = counterClockwise ? -normalizeAngle360(sAngle - eAngle) : normalizeAngle360(eAngle - sAngle);
    if (Math.abs(Math.abs(eAngle - sAngle) - 2 * Math.PI) < 1e-6 && sweep < 2 * Math.PI) {
      sweep += 2 * Math.PI * (counterClockwise ? -1 : 1);
    }
    const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);
    const step = sweep / arcSections;
    const h = 4 / 3 * Math.tan(step / 4);
    for (let i = 0; i < arcSections; i += 1) {
      const a0 = sAngle + step * (i + 0);
      const a1 = sAngle + step * (i + 1);
      const rSinStart = r * Math.sin(a0);
      const rCosStart = r * Math.cos(a0);
      const rSinEnd = r * Math.sin(a1);
      const rCosEnd = r * Math.cos(a1);
      const cp1x = rCosStart - h * rSinStart;
      const cp1y = rSinStart + h * rCosStart;
      const cp2x = rCosEnd + h * rSinEnd;
      const cp2y = rSinEnd - h * rCosEnd;
      const cp3x = rCosEnd;
      const cp3y = rSinEnd;
      this.cubicCurveTo(
        cx + mxx * cp1x + mxy * cp1y,
        cy + myx * cp1x + myy * cp1y,
        cx + mxx * cp2x + mxy * cp2y,
        cy + myx * cp2x + myy * cp2y,
        cx + mxx * cp3x + mxy * cp3y,
        cy + myx * cp3x + myy * cp3y
      );
    }
  }
  arc(x, y, r, sAngle, eAngle, counterClockwise) {
    this.ellipse(x, y, r, r, 0, sAngle, eAngle, counterClockwise);
  }
  appendSvg(svg) {
    const parts = parseSvg(svg);
    if (parts == null)
      return false;
    let sx = 0;
    let sy = 0;
    let cx;
    let cy;
    let cpx = 0;
    let cpy = 0;
    for (const { command, params } of parts) {
      cx ?? (cx = params[0]);
      cy ?? (cy = params[1]);
      const relative = command === command.toLowerCase();
      const dx2 = relative ? cx : 0;
      const dy2 = relative ? cy : 0;
      switch (command.toLowerCase()) {
        case "m":
          this.moveTo(dx2 + params[0], dy2 + params[1]);
          cx = dx2 + params[0];
          cy = dy2 + params[1];
          sx = cx;
          sy = cy;
          break;
        case "c":
          this.cubicCurveTo(
            dx2 + params[0],
            dy2 + params[1],
            dx2 + params[2],
            dy2 + params[3],
            dx2 + params[4],
            dy2 + params[5]
          );
          cpx = dx2 + params[2];
          cpy = dy2 + params[3];
          cx = dx2 + params[4];
          cy = dy2 + params[5];
          break;
        case "s":
          this.cubicCurveTo(
            cx + cx - cpx,
            cy + cy - cpy,
            dx2 + params[0],
            dy2 + params[1],
            dx2 + params[2],
            dy2 + params[3]
          );
          cpx = dx2 + params[0];
          cpy = dy2 + params[1];
          cx = dx2 + params[2];
          cy = dy2 + params[3];
          break;
        case "q":
          this.cubicCurveTo(
            (dx2 + 2 * params[0]) / 3,
            (dy2 + 2 * params[1]) / 3,
            (2 * params[0] + params[2]) / 3,
            (2 * params[1] + params[3]) / 3,
            params[2],
            params[3]
          );
          cpx = params[0];
          cpy = params[1];
          cx = params[2];
          cy = params[3];
          break;
        case "t":
          this.cubicCurveTo(
            (cx + 2 * (cx + cx - cpx)) / 3,
            (cy + 2 * (cy + cy - cpy)) / 3,
            (2 * (cx + cx - cpx) + params[0]) / 3,
            (2 * (cy + cy - cpy) + params[1]) / 3,
            params[0],
            params[1]
          );
          cpx = cx + cx - cpx;
          cpy = cy + cy - cpy;
          cx = params[0];
          cy = params[1];
          break;
        case "a":
          this.svgEllipse(
            cx,
            cy,
            params[0],
            params[1],
            params[2] * Math.PI / 180,
            params[3],
            params[4],
            dx2 + params[5],
            dy2 + params[6]
          );
          cx = dx2 + params[5];
          cy = dy2 + params[6];
          break;
        case "h":
          this.lineTo(dx2 + params[0], cy);
          cx = dx2 + params[0];
          break;
        case "l":
          this.lineTo(dx2 + params[0], dy2 + params[1]);
          cx = dx2 + params[0];
          cy = dy2 + params[1];
          break;
        case "v":
          this.lineTo(cx, dy2 + params[0]);
          cy = dy2 + params[0];
          break;
        case "z":
          this.closePath();
          cx = sx;
          cy = sy;
          break;
        default:
          throw new Error(`Could not translate command '${command}' with '${params.join(" ")}'`);
      }
    }
    return true;
  }
  svgEllipse(x1, y1, rx, ry, rotation, fA, fS, x2, y2) {
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const dx2 = (x1 - x2) / 2;
    const dy2 = (y1 - y2) / 2;
    const sin = Math.sin(rotation);
    const cos = Math.cos(rotation);
    const rotX = cos * dx2 + sin * dy2;
    const rotY = -sin * dx2 + cos * dy2;
    const normX = rotX / rx;
    const normY = rotY / ry;
    let scale2 = normX * normX + normY * normY;
    let cx = (x1 + x2) / 2;
    let cy = (y1 + y2) / 2;
    let cpx = 0;
    let cpy = 0;
    if (scale2 >= 1) {
      scale2 = Math.sqrt(scale2);
      rx *= scale2;
      ry *= scale2;
    } else {
      scale2 = Math.sqrt(1 / scale2 - 1);
      if (fA === fS)
        scale2 = -scale2;
      cpx = scale2 * rx * normY;
      cpy = -scale2 * ry * normX;
      cx += cos * cpx - sin * cpy;
      cy += sin * cpx + cos * cpy;
    }
    const sAngle = Math.atan2((rotY - cpy) / ry, (rotX - cpx) / rx);
    const deltaTheta = Math.atan2((-rotY - cpy) / ry, (-rotX - cpx) / rx) - sAngle;
    const eAngle = sAngle + deltaTheta;
    const counterClockwise = !!(1 - fS);
    this.ellipse(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise);
  }
  clear(trackChanges) {
    if (trackChanges) {
      this.previousCommands = this.commands;
      this.previousParams = this.params;
      this.previousClosedPath = this.closedPath;
    }
    this.path2d = new Path2D();
    this.openedPath = false;
    this.closedPath = false;
    this.commands = [];
    this.params = [];
  }
  isPointInPath(x, y) {
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    const ox = -1e4;
    const oy = -1e4;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    let intersectionCount = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          px = params[pi++];
          sx = px;
          py = params[pi++];
          sy = py;
          break;
        case 1 /* Line */:
          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 2 /* Curve */:
          intersectionCount += cubicSegmentIntersections(
            px,
            py,
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            ox,
            oy,
            x,
            y
          );
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 3 /* ClosePath */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          break;
      }
    }
    return intersectionCount % 2 === 1;
  }
  distanceSquared(x, y) {
    let best = Infinity;
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    let sx = NaN;
    let sy = NaN;
    let cx = 0;
    let cy = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          cx = sx = params[pi++];
          cy = sy = params[pi++];
          break;
        case 1 /* Line */: {
          const x0 = cx;
          const y0 = cy;
          cx = params[pi++];
          cy = params[pi++];
          best = lineDistanceSquared(x, y, x0, y0, cx, cy, best);
          break;
        }
        case 2 /* Curve */:
          const cp0x = cx;
          const cp0y = cy;
          const cp1x = params[pi++];
          const cp1y = params[pi++];
          const cp2x = params[pi++];
          const cp2y = params[pi++];
          cx = params[pi++];
          cy = params[pi++];
          best = bezier2DDistance(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cx, cy, x, y) ** 2;
          break;
        case 3 /* ClosePath */:
          best = lineDistanceSquared(x, y, cx, cy, sx, sy, best);
          break;
      }
    }
    return best;
  }
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
  toSVG(transform = (x, y) => ({ x, y })) {
    const buffer = [];
    const { commands, params } = this;
    const addCommand = (command, count) => {
      buffer.push(command);
      for (let i = 0; i < count; i += 2) {
        const { x, y } = transform(params[pi++], params[pi++]);
        buffer.push(x, y);
      }
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          addCommand("M", 2);
          break;
        case 1 /* Line */:
          addCommand("L", 2);
          break;
        case 2 /* Curve */:
          addCommand("C", 6);
          break;
        case 3 /* ClosePath */:
          addCommand("Z", 0);
          break;
      }
    }
    return buffer.join(" ");
  }
  computeBBox() {
    const { commands, params } = this;
    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];
    let [cx, cy] = [NaN, NaN];
    let [sx, sy] = [NaN, NaN];
    const joinPoint = (x, y) => {
      top = Math.min(y, top);
      left = Math.min(x, left);
      right = Math.max(x, right);
      bot = Math.max(y, bot);
      cx = x;
      cy = y;
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          joinPoint(params[pi++], params[pi++]);
          sx = cx;
          sy = cy;
          break;
        case 1 /* Line */:
          joinPoint(params[pi++], params[pi++]);
          break;
        case 2 /* Curve */: {
          const cp0x = cx;
          const cp0y = cy;
          const cp1x = params[pi++];
          const cp1y = params[pi++];
          const cp2x = params[pi++];
          const cp2y = params[pi++];
          const cp3x = params[pi++];
          const cp3y = params[pi++];
          const ts = bezier2DExtrema(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
          ts.forEach((t) => {
            const px = evaluateBezier(cp0x, cp1x, cp2x, cp3x, t);
            const py = evaluateBezier(cp0y, cp1y, cp2y, cp3y, t);
            joinPoint(px, py);
          });
          joinPoint(cp3x, cp3y);
          break;
        }
        case 3 /* ClosePath */:
          joinPoint(sx, sy);
          sx = NaN;
          sy = NaN;
          break;
      }
    }
    return new BBox(left, top, right - left, bot - top);
  }
};

// packages/ag-charts-community/src/scene/util/pixel.ts
function align(pixelRatio, start2, length2) {
  const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;
  if (length2 == null) {
    return alignedStart;
  } else if (length2 === 0) {
    return 0;
  } else if (length2 < 1) {
    return Math.ceil(length2 * pixelRatio) / pixelRatio;
  }
  return Math.round((length2 + start2) * pixelRatio) / pixelRatio - alignedStart;
}
function alignBefore(pixelRatio, start2) {
  return Math.floor(start2 * pixelRatio) / pixelRatio;
}

// packages/ag-charts-community/src/scene/pattern/patterns.ts
function drawPatternUnitPolygon(path, params, moves) {
  const { width: width2, height: height2, padding: padding2, strokeWidth } = params;
  const x0 = width2 / 2;
  const y0 = height2 / 2;
  const w = Math.max(1, width2 - padding2 - strokeWidth / 2);
  const h = Math.max(1, height2 - padding2 - strokeWidth / 2);
  let didMove = false;
  for (const [dx2, dy2] of moves) {
    const x = x0 + (dx2 - 0.5) * w;
    const y = y0 + (dy2 - 0.5) * h;
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
    }
    didMove = true;
  }
  path.closePath();
}
var PATTERNS = {
  circles(path, { width: width2, strokeWidth, padding: padding2 }) {
    const c = width2 / 2;
    const r = Math.max(1, c - padding2 - strokeWidth / 2);
    path.arc(c, c, r, 0, Math.PI * 2);
  },
  squares(path, { width: width2, height: height2, pixelRatio, padding: padding2, strokeWidth }) {
    const offset = padding2 + strokeWidth / 2;
    path.moveTo(align(pixelRatio, offset), align(pixelRatio, offset));
    path.lineTo(align(pixelRatio, width2 - offset), align(pixelRatio, offset));
    path.lineTo(align(pixelRatio, width2 - offset), align(pixelRatio, height2 - offset));
    path.lineTo(align(pixelRatio, offset), align(pixelRatio, height2 - offset));
    path.closePath();
  },
  triangles(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.5, 0],
      [1, 1],
      [0, 1]
    ]);
  },
  diamonds(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.5, 0],
      [1, 0.5],
      [0.5, 1],
      [0, 0.5]
    ]);
  },
  stars(path, { width: width2, height: height2, padding: padding2 }) {
    const spikes = 5;
    const outerRadius = Math.max(1, (width2 - padding2) / 2);
    const innerRadius = outerRadius / 2;
    const rotation = Math.PI / 2;
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle2 = i * Math.PI / spikes - rotation;
      const xCoordinate = width2 / 2 + Math.cos(angle2) * radius;
      const yCoordinate = height2 / 2 + Math.sin(angle2) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  },
  hearts(path, { width: width2, height: height2, padding: padding2 }) {
    const r = Math.max(1, width2 / 4 - padding2 / 2);
    const x = width2 / 2;
    const y = height2 / 2 + r / 2;
    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
    path.lineTo(x, y + r);
    path.closePath();
  },
  crosses(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.25, 0],
      [0.5, 0.25],
      [0.75, 0],
      [1, 0.25],
      [0.75, 0.5],
      [1, 0.75],
      [0.75, 1],
      [0.5, 0.75],
      [0.25, 1],
      [0, 0.75],
      [0.25, 0.5],
      [0, 0.25]
    ]);
  },
  "vertical-lines"(path, { width: width2, height: height2, pixelRatio, strokeWidth }) {
    const x = align(pixelRatio, width2 / 2) - strokeWidth % 2 / 2;
    path.moveTo(x, 0);
    path.lineTo(x, height2);
  },
  "horizontal-lines"(path, { width: width2, height: height2, pixelRatio, strokeWidth }) {
    const y = align(pixelRatio, height2 / 2) - strokeWidth % 2 / 2;
    path.moveTo(0, y);
    path.lineTo(width2, y);
  },
  "forward-slanted-lines"(path, { width: width2, height: height2, strokeWidth }) {
    const angle2 = Math.atan2(height2, width2);
    const insetX = strokeWidth * Math.cos(angle2);
    const insetY = strokeWidth * Math.sin(angle2);
    path.moveTo(-insetX, insetY);
    path.lineTo(insetX, -insetY);
    path.moveTo(-insetX, height2 + insetY);
    path.lineTo(width2 + insetX, -insetY);
    path.moveTo(width2 - insetX, height2 + insetY);
    path.lineTo(width2 + insetX, height2 - insetY);
  },
  "backward-slanted-lines"(path, { width: width2, height: height2, strokeWidth }) {
    const angle2 = Math.atan2(height2, width2);
    const insetX = strokeWidth * Math.cos(angle2);
    const insetY = strokeWidth * Math.sin(angle2);
    path.moveTo(width2 - insetX, -insetY);
    path.lineTo(width2 + insetX, insetY);
    path.moveTo(-insetX, -insetY);
    path.lineTo(width2 + insetX, height2 + insetY);
    path.moveTo(-insetX, height2 - insetY);
    path.lineTo(insetX, height2 + insetY);
  }
};

// packages/ag-charts-community/src/scene/pattern/pattern.ts
var Pattern = class {
  constructor(patternOptions) {
    this._cache = void 0;
    this.width = Math.max(patternOptions?.width ?? 10, 1);
    this.height = Math.max(patternOptions?.height ?? 10, 1);
    this.fill = patternOptions.fill ?? "none";
    this.fillOpacity = patternOptions.fillOpacity ?? 1;
    this.backgroundFill = patternOptions.backgroundFill ?? "none";
    this.backgroundFillOpacity = patternOptions.backgroundFillOpacity ?? 1;
    this.stroke = patternOptions.stroke ?? "black";
    this.strokeOpacity = patternOptions.strokeOpacity ?? 1;
    this.strokeWidth = patternOptions.strokeWidth ?? 1;
    this.padding = patternOptions.padding ?? 1;
    this.pattern = patternOptions.pattern ?? "forward-slanted-lines";
    this.rotation = patternOptions.rotation ?? 0;
    this.scale = patternOptions.scale ?? 1;
    this.path = patternOptions.path;
  }
  getPath(pixelRatio) {
    const { pattern, width: width2, height: height2, padding: padding2, strokeWidth, path: svgPath } = this;
    const path = new ExtendedPath2D();
    let renderPattern = PATTERNS[pattern] != null;
    if (svgPath) {
      renderPattern && (renderPattern = !path.appendSvg(svgPath));
    }
    if (renderPattern) {
      PATTERNS[pattern](path, { width: width2, height: height2, pixelRatio, strokeWidth, padding: padding2 });
    }
    return path;
  }
  renderStroke(path2d, ctx) {
    const { stroke: stroke3, strokeWidth, strokeOpacity } = this;
    if (!strokeWidth)
      return;
    ctx.strokeStyle = stroke3;
    ctx.lineWidth = strokeWidth;
    ctx.globalAlpha = strokeOpacity;
    ctx.stroke(path2d);
  }
  renderFill(path2d, ctx) {
    const { fill, fillOpacity } = this;
    if (fill === "none") {
      return;
    }
    ctx.fillStyle = fill;
    ctx.globalAlpha = fillOpacity;
    ctx.fill(path2d);
  }
  createCanvasPattern(ctx, pixelRatio) {
    const { width: width2, height: height2, scale: scale2, backgroundFill, backgroundFillOpacity } = this;
    if (width2 * scale2 < 1 || height2 * scale2 < 1) {
      logger_exports.warnOnce("Pattern fill is too small to render, ignoring.");
      return null;
    }
    const offscreenPattern = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio: pixelRatio * scale2 });
    const offscreenPatternCtx = offscreenPattern.context;
    if (backgroundFill !== "none") {
      offscreenPatternCtx.fillStyle = backgroundFill;
      offscreenPatternCtx.globalAlpha = backgroundFillOpacity;
      offscreenPatternCtx.fillRect(0, 0, width2, height2);
    }
    const path2d = this.getPath(pixelRatio).getPath2D();
    this.renderFill(path2d, offscreenPatternCtx);
    this.renderStroke(path2d, offscreenPatternCtx);
    const pattern = ctx.createPattern(offscreenPattern.canvas, "repeat");
    this.setPatternTransform(pattern, pixelRatio);
    offscreenPattern.destroy();
    return pattern;
  }
  setPatternTransform(pattern, pixelRatio, tx = 0, ty = 0) {
    if (pattern == null)
      return;
    const angle2 = normalizeAngle360FromDegrees(this.rotation);
    const scale2 = 1 / pixelRatio;
    const cos = Math.cos(angle2) * scale2;
    const sin = Math.sin(angle2) * scale2;
    pattern.setTransform(new DOMMatrix([cos, sin, -sin, cos, tx, ty]));
  }
  createPattern(ctx, pixelRatio) {
    if (this._cache != null && this._cache.ctx === ctx && this._cache.pixelRatio === pixelRatio) {
      return this._cache.pattern;
    }
    const pattern = this.createCanvasPattern(ctx, pixelRatio);
    if (pattern == null)
      return;
    this._cache = { ctx, pattern, pixelRatio };
    return pattern;
  }
  toSvg() {
    const {
      width: width2,
      height: height2,
      fill,
      fillOpacity,
      backgroundFill,
      backgroundFillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      rotation,
      scale: scale2
    } = this;
    const pattern = createSvgElement("pattern");
    pattern.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    pattern.setAttribute("width", String(width2));
    pattern.setAttribute("height", String(height2));
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    const rect = createSvgElement("rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width2));
    rect.setAttribute("height", String(height2));
    rect.setAttribute("fill", backgroundFill);
    rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
    pattern.appendChild(rect);
    const path = createSvgElement("path");
    path.setAttribute("fill", fill);
    path.setAttribute("fill-opacity", String(fillOpacity));
    path.setAttribute("stroke-opacity", String(strokeOpacity));
    path.setAttribute("stroke", stroke3);
    path.setAttribute("stroke-width", String(strokeWidth));
    path.setAttribute("transform", `rotate(${rotation}) scale(${scale2})`);
    path.setAttribute("d", this.getPath(1).toSVG());
    pattern.appendChild(path);
    return pattern;
  }
};

// packages/ag-charts-community/src/scene/util/fill.ts
function isGradientFill(fill) {
  return isObject(fill) && fill.type == "gradient";
}
function isStringFillArray(fills) {
  return isArray(fills) && fills.every((fill) => typeof fill === "string");
}
function isPatternFill(fill) {
  return fill !== null && isObject(fill) && fill.type == "pattern";
}
function isImageFill(fill) {
  return fill !== null && isObject(fill) && fill.type == "image";
}
function isGradientOrPatternFill(fill) {
  return isGradientFill(fill) || isPatternFill(fill);
}

// packages/ag-charts-community/src/scene/shape/svgUtils.ts
function setSvgFontAttributes(element2, options) {
  const { fontStyle, fontWeight, fontSize, fontFamily } = options;
  if (fontStyle)
    element2.setAttribute("font-style", fontStyle);
  if (fontWeight)
    element2.setAttribute("font-weight", String(fontWeight));
  if (fontSize != null)
    element2.setAttribute("font-size", String(fontSize));
  if (fontFamily)
    element2.setAttribute("font-family", fontFamily);
}
function setSvgStrokeAttributes(element2, options) {
  const { stroke: stroke3, strokeWidth, strokeOpacity } = options;
  if (stroke3)
    element2.setAttribute("stroke", stroke3);
  if (strokeWidth != null)
    element2.setAttribute("stroke-width", String(strokeWidth));
  if (strokeOpacity != null)
    element2.setAttribute("stroke-opacity", String(strokeOpacity));
}
function setSvgLineDashAttributes(element2, options) {
  const { lineDash, lineDashOffset } = options;
  if (lineDash?.some((d) => d !== 0)) {
    const lineDashArray = lineDash.length % 2 === 1 ? [...lineDash, ...lineDash] : lineDash;
    element2.setAttribute("stroke-dasharray", lineDashArray.join(" "));
    if (lineDashOffset != null)
      element2.setAttribute("stroke-dashoffset", String(lineDashOffset));
  }
}

// packages/ag-charts-community/src/scene/shape/shape.ts
var Shape = class extends Node2 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.fill = "black";
    this.strokeWidth = 0;
    this.lineDashOffset = 0;
    this.opacity = 1;
  }
  getGradient(fill) {
    if (isGradientFill(fill))
      return this.createGradient(fill);
  }
  createGradient(fill) {
    const { colorSpace = "rgb", gradient: gradient2 = "linear", colorStops, rotation = 0, reverse = false } = fill;
    if (colorStops == null)
      return;
    let stops = getColorStops(colorStops, ["black"], [0, 1]);
    if (reverse) {
      stops = stops.map((s) => ({ color: s.color, stop: 1 - s.stop })).reverse();
    }
    switch (gradient2) {
      case "linear":
        return new LinearGradient(colorSpace, stops, rotation);
      case "radial":
        return new RadialGradient(colorSpace, stops);
      case "conic":
        return new ConicGradient(colorSpace, stops, rotation);
    }
  }
  getPattern(fill) {
    if (isPatternFill(fill))
      return this.createPattern(fill);
  }
  createPattern(fill) {
    return new Pattern(fill);
  }
  getImage(fill) {
    if (isImageFill(fill))
      return this.createImage(fill);
  }
  createImage(fill) {
    return new Image2(this.imageLoader, fill);
  }
  onFillChange() {
    if (typeof this.fill === "object") {
      if (objectsEqual(this._cachedFill ?? {}, this.fill)) {
        return;
      }
    }
    this.fillGradient = this.getGradient(this.fill);
    this.fillPattern = this.getPattern(this.fill);
    this.fillImage = this.getImage(this.fill);
    this._cachedFill = this.fill;
  }
  onStrokeChange() {
    this.strokeGradient = this.getGradient(this.stroke);
  }
  /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */
  align(start2, length2) {
    return align(this.layerManager?.canvas?.pixelRatio ?? 1, start2, length2);
  }
  markDirty(property) {
    super.markDirty(property);
    this.cachedDefaultGradientFillBBox = void 0;
  }
  fillStroke(ctx, path) {
    this.renderFill(ctx, path);
    this.renderStroke(ctx, path);
  }
  renderFill(ctx, path) {
    const { fill, fillOpacity, fillImage } = this;
    if (fill != null && fill !== "none" && fillOpacity > 0) {
      const { globalAlpha } = ctx;
      if (fillImage) {
        ctx.globalAlpha = fillImage.backgroundFillOpacity;
        ctx.fillStyle = fillImage.backgroundFill;
        this.executeFill(ctx, path);
        ctx.globalAlpha = globalAlpha;
      }
      this.applyFillAndAlpha(ctx);
      this.applyShadow(ctx);
      this.executeFill(ctx, path);
      ctx.globalAlpha = globalAlpha;
      ctx.shadowColor = "rgba(0, 0, 0, 0)";
    }
  }
  executeFill(ctx, path) {
    if (path) {
      ctx.fill(path);
    } else {
      ctx.fill();
    }
  }
  applyFillAndAlpha(ctx) {
    const { fill, fillGradient, fillPattern, fillImage, fillOpacity = 1, opacity = 1 } = this;
    ctx.globalAlpha *= opacity * fillOpacity;
    if (fillGradient) {
      const { fillBBox = this.getDefaultGradientFillBBox() ?? this.getBBox(), fillParams } = this;
      ctx.fillStyle = fillGradient.createGradient(ctx, fillBBox, fillParams) ?? "black";
    } else if (fillPattern) {
      const { x, y } = this.getBBox();
      const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
      const pattern = fillPattern.createPattern(ctx, pixelRatio);
      fillPattern.setPatternTransform(pattern, pixelRatio, x, y);
      if (pattern) {
        ctx.fillStyle = pattern;
      } else {
        ctx.fillStyle = fillPattern.fill;
        ctx.globalAlpha *= fillPattern.fillOpacity;
      }
    } else if (fillImage) {
      const bbox = this.getBBox();
      const image = fillImage.createPattern(ctx, bbox.width, bbox.height, this);
      fillImage.setImageTransform(image, bbox);
      ctx.fillStyle = image ?? "transparent";
    } else {
      ctx.fillStyle = typeof fill === "string" ? fill : "black";
    }
  }
  applyStrokeAndAlpha(ctx) {
    const { stroke: stroke3, strokeOpacity = 1, strokeGradient, opacity = 1 } = this;
    ctx.strokeStyle = strokeGradient?.createGradient(ctx, this.getBBox()) ?? (typeof stroke3 === "string" ? stroke3 : void 0) ?? "black";
    ctx.globalAlpha *= opacity * strokeOpacity;
  }
  applyShadow(ctx) {
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const fillShadow = this.fillShadow;
    if (fillShadow?.enabled) {
      ctx.shadowColor = fillShadow.color;
      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
      ctx.shadowBlur = fillShadow.blur * pixelRatio;
    }
  }
  renderStroke(ctx, path) {
    const { stroke: stroke3, strokeWidth, strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin, miterLimit } = this;
    if (stroke3 != null && stroke3 !== "none" && strokeWidth > 0 && strokeOpacity > 0) {
      const { globalAlpha } = ctx;
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      if (miterLimit != null) {
        ctx.miterLimit = miterLimit;
      }
      this.executeStroke(ctx, path);
      ctx.globalAlpha = globalAlpha;
    }
  }
  executeStroke(ctx, path) {
    if (path) {
      ctx.stroke(path);
    } else {
      ctx.stroke();
    }
  }
  getDefaultGradientFillBBox() {
    this.cachedDefaultGradientFillBBox ?? (this.cachedDefaultGradientFillBBox = Object.freeze(this.computeDefaultGradientFillBBox()));
    return this.cachedDefaultGradientFillBBox;
  }
  computeDefaultGradientFillBBox() {
    return;
  }
  containsPoint(x, y) {
    return this.isPointInPath(x, y);
  }
  applySvgFillAttributes(element2, defs) {
    const { fill, fillOpacity } = this;
    if (typeof fill === "string") {
      element2.setAttribute("fill", fill);
    } else if (isGradientFill(fill) && this.fillGradient) {
      defs ?? (defs = []);
      const gradient2 = this.fillGradient.toSvg(this.fillBBox ?? this.getBBox());
      const id = generateUUID();
      gradient2.setAttribute("id", id);
      defs.push(gradient2);
      element2.setAttribute("fill", `url(#${id})`);
    } else if (isPatternFill(fill) && this.fillPattern) {
      defs ?? (defs = []);
      const pattern = this.fillPattern.toSvg();
      const id = generateUUID();
      pattern.setAttribute("id", id);
      defs.push(pattern);
      element2.setAttribute("fill", `url(#${id})`);
    } else if (isImageFill(fill) && this.fillImage) {
      defs ?? (defs = []);
      const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
      const pattern = this.fillImage.toSvg(this.getBBox(), pixelRatio);
      const id = generateUUID();
      pattern.setAttribute("id", id);
      defs.push(pattern);
      element2.setAttribute("fill", `url(#${id})`);
    } else {
      element2.setAttribute("fill", "none");
    }
    element2.setAttribute("fill-opacity", String(fillOpacity));
    return defs;
  }
  applySvgStrokeAttributes(element2) {
    const { stroke: stroke3, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this;
    setSvgStrokeAttributes(element2, { stroke: isString(stroke3) ? stroke3 : void 0, strokeOpacity, strokeWidth });
    setSvgLineDashAttributes(element2, { lineDash, lineDashOffset });
  }
};
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "fillOpacity", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "strokeOpacity", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onFillChange() })
], Shape.prototype, "fill", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onStrokeChange() })
], Shape.prototype, "stroke", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "strokeWidth", 2);
__decorateClass([
  SceneArrayChangeDetection()
], Shape.prototype, "lineDash", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "lineDashOffset", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "lineCap", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "lineJoin", 2);
__decorateClass([
  SceneChangeDetection()
], Shape.prototype, "miterLimit", 2);
__decorateClass([
  SceneChangeDetection({ convertor: (v) => clamp(0, v ?? 1, 1) })
], Shape.prototype, "opacity", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: TRIPLE_EQ, checkDirtyOnAssignment: true })
], Shape.prototype, "fillShadow", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: boxesEqual, changeCb: (s) => s.onFillChange() })
], Shape.prototype, "fillBBox", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onFillChange() })
], Shape.prototype, "fillParams", 2);

// packages/ag-charts-community/src/scene/matrix.ts
var IDENTITY_MATRIX_ELEMENTS = [1, 0, 0, 1, 0, 0];
var Matrix = class _Matrix {
  get e() {
    return [...this.elements];
  }
  constructor(elements = IDENTITY_MATRIX_ELEMENTS) {
    this.elements = [...elements];
  }
  setElements(elements) {
    const e = this.elements;
    e[0] = elements[0];
    e[1] = elements[1];
    e[2] = elements[2];
    e[3] = elements[3];
    e[4] = elements[4];
    e[5] = elements[5];
    return this;
  }
  get identity() {
    const e = this.elements;
    return isNumberEqual(e[0], 1) && isNumberEqual(e[1], 0) && isNumberEqual(e[2], 0) && isNumberEqual(e[3], 1) && isNumberEqual(e[4], 0) && isNumberEqual(e[5], 0);
  }
  /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */
  AxB(A, B, C2) {
    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
    C2 = C2 ?? A;
    C2[0] = a;
    C2[1] = b;
    C2[2] = c;
    C2[3] = d;
    C2[4] = e;
    C2[5] = f;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */
  multiplySelf(other) {
    this.AxB(this.elements, other.elements);
    return this;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */
  multiply(other) {
    const elements = new Array(6);
    if (other instanceof _Matrix) {
      this.AxB(this.elements, other.elements, elements);
    } else {
      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements);
    }
    return new _Matrix(elements);
  }
  preMultiplySelf(other) {
    this.AxB(other.elements, this.elements, this.elements);
    return this;
  }
  /**
   * Returns the inverse of this matrix as a new matrix.
   */
  inverse() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
  }
  invertSelf() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    el[0] = d;
    el[1] = -b;
    el[2] = -c;
    el[3] = a;
    el[4] = c * f - d * e;
    el[5] = b * e - a * f;
    return this;
  }
  transformPoint(x, y) {
    const e = this.elements;
    return {
      x: x * e[0] + y * e[2] + e[4],
      y: x * e[1] + y * e[3] + e[5]
    };
  }
  transformBBox(bbox, target) {
    const el = this.elements;
    const xx = el[0];
    const xy = el[1];
    const yx = el[2];
    const yy = el[3];
    const h_w = bbox.width * 0.5;
    const h_h = bbox.height * 0.5;
    const cx = bbox.x + h_w;
    const cy = bbox.y + h_h;
    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
    target ?? (target = new BBox(0, 0, 0, 0));
    target.x = cx * xx + cy * yx + el[4] - w;
    target.y = cx * xy + cy * yy + el[5] - h;
    target.width = w + w;
    target.height = h + h;
    return target;
  }
  toContext(ctx) {
    if (this.identity) {
      return;
    }
    const e = this.elements;
    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
    const sx = scalingX;
    const sy = scalingY;
    let scx;
    let scy;
    if (sx === 1 && sy === 1) {
      scx = 0;
      scy = 0;
    } else {
      scx = opts?.scalingCenterX ?? 0;
      scy = opts?.scalingCenterY ?? 0;
    }
    const r = rotation;
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    let rcx;
    let rcy;
    if (r === 0) {
      rcx = 0;
      rcy = 0;
    } else {
      rcx = opts?.rotationCenterX ?? 0;
      rcy = opts?.rotationCenterY ?? 0;
    }
    const tx = translationX;
    const ty = translationY;
    const tx4 = scx * (1 - sx) - rcx;
    const ty4 = scy * (1 - sy) - rcy;
    matrix.setElements([
      cos * sx,
      sin * sx,
      -sin * sy,
      cos * sy,
      cos * tx4 - sin * ty4 + rcx + tx,
      sin * tx4 + cos * ty4 + rcy + ty
    ]);
    return matrix;
  }
};

// packages/ag-charts-community/src/scene/transformable.ts
function isMatrixTransform(node) {
  return isMatrixTransformType(node.constructor);
}
var MATRIX_TRANSFORM_TYPE = Symbol("isMatrixTransform");
function isMatrixTransformType(cstr) {
  return cstr[MATRIX_TRANSFORM_TYPE] === true;
}
function MatrixTransform(Parent) {
  var _a, _b;
  const ParentNode = Parent;
  if (isMatrixTransformType(Parent)) {
    return Parent;
  }
  const TRANSFORM_MATRIX = Symbol("matrix_combined_transform");
  class MatrixTransformInternal extends ParentNode {
    constructor() {
      super(...arguments);
      this[_b] = new Matrix();
      this._dirtyTransform = true;
    }
    onChangeDetection(property) {
      super.onChangeDetection(property);
      this._dirtyTransform = true;
      if (this.batchLevel > 0) {
        return;
      }
      this.markDirty("transform");
    }
    updateMatrix(_matrix) {
    }
    computeTransformMatrix() {
      if (!this._dirtyTransform)
        return;
      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);
      this.updateMatrix(this[TRANSFORM_MATRIX]);
      this._dirtyTransform = false;
    }
    toParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].transformBBox(bbox);
    }
    toParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].transformPoint(x, y);
    }
    fromParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);
    }
    fromParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);
    }
    computeBBox() {
      const bbox = super.computeBBox();
      if (!bbox)
        return bbox;
      return this.toParent(bbox);
    }
    computeBBoxWithoutTransforms() {
      return super.computeBBox();
    }
    pickNode(x, y) {
      ({ x, y } = this.fromParentPoint(x, y));
      return super.pickNode(x, y);
    }
    pickNodes(x, y, into) {
      ({ x, y } = this.fromParentPoint(x, y));
      return super.pickNodes(x, y, into);
    }
    render(renderCtx) {
      this.computeTransformMatrix();
      const { ctx } = renderCtx;
      const matrix = this[TRANSFORM_MATRIX];
      let performRestore = false;
      try {
        if (!matrix.identity) {
          ctx.save();
          performRestore = true;
          matrix.toContext(ctx);
        }
        super.render(renderCtx);
      } finally {
        if (performRestore) {
          ctx.restore();
        }
      }
    }
    toSVG() {
      this.computeTransformMatrix();
      const svg = super.toSVG();
      const matrix = this[TRANSFORM_MATRIX];
      if (matrix.identity || svg == null)
        return svg;
      const g = createSvgElement("g");
      g.append(...svg.elements);
      const [a, b, c, d, e, f] = matrix.e;
      g.setAttribute("transform", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
      return {
        elements: [g],
        defs: svg.defs
      };
    }
  }
  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;
  MatrixTransformInternal[_a] = true;
  return MatrixTransformInternal;
}
function Rotatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const ROTATABLE_MATRIX = Symbol("matrix_rotation");
  class RotatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.rotationCenterX = 0;
      this.rotationCenterY = 0;
      this.rotation = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { rotation, rotationCenterX, rotationCenterY } = this;
      if (rotation === 0)
        return;
      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {
        rotationCenterX,
        rotationCenterY
      });
      matrix.multiplySelf(this[ROTATABLE_MATRIX]);
    }
  }
  _a = ROTATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotationCenterX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotationCenterY", 2);
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotation", 2);
  return RotatableInternal;
}
function Scalable(Parent) {
  var _a;
  const ParentNode = Parent;
  const SCALABLE_MATRIX = Symbol("matrix_scale");
  class ScalableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.scalingX = 1;
      this.scalingY = 1;
      this.scalingCenterX = 0;
      this.scalingCenterY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;
      if (scalingX === 1 && scalingY === 1)
        return;
      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {
        scalingCenterX,
        scalingCenterY
      });
      matrix.multiplySelf(this[SCALABLE_MATRIX]);
    }
  }
  _a = SCALABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingY", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingCenterX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingCenterY", 2);
  return ScalableInternal;
}
function Translatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const TRANSLATABLE_MATRIX = Symbol("matrix_translation");
  class TranslatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.translationX = 0;
      this.translationY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { translationX, translationY } = this;
      if (translationX === 0 && translationY === 0)
        return;
      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);
      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);
    }
  }
  _a = TRANSLATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], TranslatableInternal.prototype, "translationX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], TranslatableInternal.prototype, "translationY", 2);
  return TranslatableInternal;
}
var Transformable = class {
  /**
   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvas(node, bbox) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      bbox = parent.fromParent(bbox);
    }
    if (isMatrixTransform(node)) {
      bbox = node.fromParent(bbox);
    }
    return bbox;
  }
  /**
   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space
   * into the Canvas coordinate space.
   */
  static toCanvas(node, bbox) {
    if (bbox == null) {
      bbox = node.getBBox();
    } else if (isMatrixTransform(node)) {
      bbox = node.toParent(bbox);
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        bbox = parent.toParent(bbox);
      }
    }
    return bbox;
  }
  /**
   * Converts a point from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvasPoint(node, x, y) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      ({ x, y } = parent.fromParentPoint(x, y));
    }
    if (isMatrixTransform(node)) {
      ({ x, y } = node.fromParentPoint(x, y));
    }
    return { x, y };
  }
  /**
   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.
   */
  static toCanvasPoint(node, x, y) {
    if (isMatrixTransform(node)) {
      ({ x, y } = node.toParentPoint(x, y));
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        ({ x, y } = parent.toParentPoint(x, y));
      }
    }
    return { x, y };
  }
};

// packages/ag-charts-community/src/scene/group.ts
var sharedOffscreenCanvas;
var _Group = class _Group extends Node2 {
  // optimizeForInfrequentRedraws: true
  constructor(opts) {
    super(opts);
    this.childNodes = /* @__PURE__ */ new Set();
    this.dirty = false;
    this.dirtyZIndex = false;
    this.clipRect = void 0;
    this.opacity = 1;
    this.renderToOffscreenCanvas = false;
    this.optimizeForInfrequentRedraws = false;
    // Used when renderToOffscreenCanvas: true
    this.layer = void 0;
    // optimizeForInfrequentRedraws: false
    this.image = void 0;
    this._lastWidth = NaN;
    this._lastHeight = NaN;
    this._lastDevicePixelRatio = NaN;
    this.isContainerNode = true;
    this.renderToOffscreenCanvas = opts?.renderToOffscreenCanvas === true;
  }
  static is(value) {
    return value instanceof _Group;
  }
  static computeChildrenBBox(nodes, skipInvisible = true) {
    return BBox.merge(Node2.extractBBoxes(nodes, skipInvisible));
  }
  static compareChildren(a, b) {
    return compareZIndex(a.zIndex, b.zIndex) || a.serialNumber - b.serialNumber;
  }
  // We consider a group to be boundless, thus any point belongs to it.
  containsPoint(_x, _y) {
    return true;
  }
  computeBBox() {
    return _Group.computeChildrenBBox(this.children());
  }
  computeSafeClippingBBox(pixelRatio) {
    const bbox = this.computeBBox();
    if (bbox?.isFinite() !== true)
      return;
    let strokeWidth = 0;
    const strokeMiterAmount = 4;
    for (const child of this.descendants()) {
      if (child instanceof Shape) {
        strokeWidth = Math.max(strokeWidth, child.strokeWidth);
      }
    }
    const padding2 = Math.max(
      // Account for anti-aliasing artefacts
      1,
      // Account for strokes (incl. miters) - this may not be the best place to include this
      strokeWidth / 2 * strokeMiterAmount
    );
    const { x: originX, y: originY } = Transformable.toCanvasPoint(this, 0, 0);
    const x = alignBefore(pixelRatio, originX + bbox.x - padding2) - originX;
    const y = alignBefore(pixelRatio, originY + bbox.y - padding2) - originY;
    const width2 = Math.ceil(bbox.x + bbox.width - x + padding2);
    const height2 = Math.ceil(bbox.y + bbox.height - y + padding2);
    return new BBox(x, y, width2, height2);
  }
  prepareSharedCanvas(width2, height2, pixelRatio) {
    if (sharedOffscreenCanvas == null || sharedOffscreenCanvas.pixelRatio !== pixelRatio) {
      sharedOffscreenCanvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });
    } else {
      sharedOffscreenCanvas.resize(width2, height2, pixelRatio);
    }
    return sharedOffscreenCanvas;
  }
  setScene(scene) {
    super.setScene(scene);
    if (this.layer) {
      this.scene?.layersManager.removeLayer(this.layer);
      this.layer = void 0;
    }
    for (const child of this.children()) {
      child.setScene(scene);
    }
  }
  markDirty(property) {
    this.dirty = true;
    super.markDirty(property);
  }
  markDirtyChildrenOrder() {
    super.markDirtyChildrenOrder();
    this.dirtyZIndex = true;
    this.markDirty();
  }
  /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */
  append(nodes) {
    for (const node of toIterable(nodes)) {
      node.parentNode?.removeChild(node);
      this.childNodes.add(node);
      node.parentNode = this;
      node.setScene(this.scene);
    }
    this.markDirtyChildrenOrder();
    this.markDirty();
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  removeChild(node) {
    if (!this.childNodes?.delete(node)) {
      throw new Error(
        `AG Charts - internal error, unknown child node ${node.name ?? node.id} in $${this.name ?? this.id}`
      );
    }
    node.parentNode = void 0;
    node.setScene();
    this.markDirtyChildrenOrder();
    this.markDirty();
  }
  clear() {
    for (const child of this.children()) {
      delete child.parentNode;
      child.setScene();
    }
    this.childNodes?.clear();
    this.markDirty();
  }
  /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */
  pickNode(x, y) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return;
    }
    if (this.childNodes != null && this.childNodes.size !== 0) {
      const children = [...this.children()];
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const hit = child.pickNode(x, y);
        if (hit != null) {
          return hit;
        }
      }
    } else if (!this.isContainerNode) {
      return this;
    }
  }
  pickNodes(x, y, into = []) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return into;
    }
    if (!this.isContainerNode) {
      into.push(this);
    }
    for (const child of this.children()) {
      child.pickNodes(x, y, into);
    }
    return into;
  }
  isDirty(renderCtx) {
    const { width: width2, height: height2, devicePixelRatio } = renderCtx;
    const { dirty, layer } = this;
    const layerResized = layer != null && (this._lastWidth !== width2 || this._lastHeight !== height2);
    const pixelRatioChanged = this._lastDevicePixelRatio !== devicePixelRatio;
    this._lastWidth = width2;
    this._lastHeight = height2;
    this._lastDevicePixelRatio = devicePixelRatio;
    return dirty || layerResized || pixelRatioChanged;
  }
  preRender(renderCtx) {
    let counts;
    if (this.dirty) {
      counts = super.preRender(renderCtx, 0);
      for (const child of this.children()) {
        const childCounts = child.preRender(renderCtx);
        counts.groups += childCounts.groups;
        counts.nonGroups += childCounts.nonGroups;
        counts.complexity += childCounts.complexity;
      }
      counts.groups += 1;
      counts.nonGroups -= 1;
    } else {
      counts = this.childNodeCounts;
    }
    if (this.renderToOffscreenCanvas && !this.optimizeForInfrequentRedraws && counts.nonGroups > 0 && this.getVisibility()) {
      this.layer ?? (this.layer = this.layerManager?.addLayer({ name: this.name }));
    } else if (this.layer != null) {
      this.layerManager?.removeLayer(this.layer);
      this.layer = void 0;
    }
    return counts;
  }
  render(renderCtx) {
    const { layer, renderToOffscreenCanvas } = this;
    const childRenderCtx = { ...renderCtx };
    const dirty = this.isDirty(renderCtx);
    this.dirty = false;
    if (!renderToOffscreenCanvas) {
      this.renderInContext(childRenderCtx);
      super.render(childRenderCtx);
      return;
    }
    const { ctx, stats, devicePixelRatio: pixelRatio } = renderCtx;
    let { image } = this;
    if (dirty) {
      image?.bitmap.close();
      image = void 0;
      const bbox = layer ? void 0 : this.computeSafeClippingBBox(pixelRatio);
      const renderOffscreen = (offscreenCanvas, ...transform) => {
        const offscreenCtx = offscreenCanvas.context;
        childRenderCtx.ctx = offscreenCtx;
        offscreenCanvas.clear();
        offscreenCtx.save();
        try {
          offscreenCtx.setTransform(...transform);
          offscreenCtx.globalAlpha = 1;
          this.renderInContext(childRenderCtx);
        } finally {
          offscreenCtx.restore();
          offscreenCtx.verifyDepthZero?.();
        }
      };
      if (layer) {
        renderOffscreen(layer, ctx.getTransform());
      } else if (bbox) {
        const { x, y, width: width2, height: height2 } = bbox;
        const canvas = this.prepareSharedCanvas(width2, height2, pixelRatio);
        renderOffscreen(canvas, pixelRatio, 0, 0, pixelRatio, -x * pixelRatio, -y * pixelRatio);
        image = { bitmap: canvas.transferToImageBitmap(), x, y, width: width2, height: height2 };
      }
      this.image = image;
      if (stats)
        stats.layersRendered++;
    } else if (stats) {
      stats.layersSkipped++;
    }
    const { globalAlpha } = ctx;
    ctx.globalAlpha = globalAlpha * this.opacity;
    if (layer) {
      ctx.save();
      try {
        ctx.resetTransform();
        layer.drawImage(ctx);
      } finally {
        ctx.restore();
      }
    } else if (image) {
      const { bitmap, x, y, width: width2, height: height2 } = image;
      ctx.drawImage(bitmap, 0, 0, width2 * pixelRatio, height2 * pixelRatio, x, y, width2, height2);
    }
    ctx.globalAlpha = globalAlpha;
    super.render(childRenderCtx);
  }
  applyClip(ctx, clipRect) {
    const { x, y, width: width2, height: height2 } = clipRect;
    ctx.beginPath();
    ctx.rect(x, y, width2, height2);
    ctx.clip();
  }
  renderInContext(childRenderCtx) {
    const { ctx, stats } = childRenderCtx;
    if (this.dirtyZIndex) {
      this.sortChildren(_Group.compareChildren);
      this.dirtyZIndex = false;
    }
    ctx.save();
    try {
      ctx.globalAlpha *= this.opacity;
      if (this.clipRect != null) {
        this.applyClip(ctx, this.clipRect);
        childRenderCtx.clipBBox = Transformable.toCanvas(this, this.clipRect);
      }
      for (const child of this.children()) {
        if (!child.visible) {
          if (stats) {
            stats.nodesSkipped += child.childNodeCounts.nonGroups + child.childNodeCounts.groups;
            stats.opsSkipped += child.childNodeCounts.complexity;
          }
          continue;
        }
        child.isolatedRender(childRenderCtx);
      }
    } finally {
      ctx.restore();
    }
  }
  sortChildren(compareFn) {
    if (!this.childNodes)
      return;
    const sortedChildren = [...this.childNodes].sort(compareFn);
    this.childNodes.clear();
    for (const child of sortedChildren) {
      this.childNodes.add(child);
    }
  }
  *children() {
    yield* this.childNodes;
  }
  *excludeChildren(exclude) {
    for (const child of this.children()) {
      if (exclude.instance && !(child instanceof exclude.instance) || exclude.name && child.name !== exclude.name) {
        yield child;
      }
    }
  }
  *descendants() {
    for (const child of this.children()) {
      yield child;
      if (child instanceof _Group) {
        yield* child.descendants();
      }
    }
  }
  /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRect(bbox) {
    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;
  }
  /**
   * Set the clip rect within the canvas coordinate space.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRectCanvasSpace(bbox) {
    this.clipRect = bbox;
  }
  getVisibility() {
    for (const node of this.traverseUp(true)) {
      if (!node.visible) {
        return false;
      }
    }
    return true;
  }
  toSVG() {
    if (!this.visible)
      return;
    const defs = [];
    const elements = [];
    for (const child of this.children()) {
      const svg = child.toSVG();
      if (svg != null) {
        elements.push(...svg.elements);
        if (svg.defs != null) {
          defs.push(...svg.defs);
        }
      }
    }
    return { elements, defs };
  }
};
_Group.className = "Group";
__decorateClass([
  SceneChangeDetection({ convertor: (v) => clamp(0, v, 1) })
], _Group.prototype, "opacity", 2);
var Group = _Group;
var ScalableGroup = class extends Scalable(Group) {
};
var RotatableGroup = class extends Rotatable(Group) {
};
var TranslatableGroup = class extends Translatable(Group) {
};
var TransformableGroup = class extends Rotatable(Translatable(Group)) {
};

// packages/ag-charts-community/src/util/callbackCache.ts
function needsContext(caller, _params) {
  return "context" in caller;
}
function maybeSetContext(caller, params) {
  if (caller != null && needsContext(caller, params)) {
    if (params[0] != null && typeof params[0] === "object" && params[0].context === void 0) {
      params[0].context = caller.context;
      return true;
    }
  }
  return false;
}
function callWithContext(callers, fn, ...params) {
  if (Array.isArray(callers)) {
    for (const caller of callers) {
      if (maybeSetContext(caller, params)) {
        break;
      }
    }
  } else {
    maybeSetContext(callers, params);
  }
  return fn(...params);
}
var CallbackCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
  call(callers, fn, ...params) {
    let serialisedParams;
    let paramCache = this.cache.get(fn);
    try {
      serialisedParams = JSON.stringify(params);
    } catch {
      return this.invoke(callers, fn, paramCache, void 0, ...params);
    }
    if (paramCache == null) {
      paramCache = /* @__PURE__ */ new Map();
      this.cache.set(fn, paramCache);
    }
    if (!paramCache.has(serialisedParams)) {
      return this.invoke(callers, fn, paramCache, serialisedParams, ...params);
    }
    return paramCache.get(serialisedParams);
  }
  invoke(callers, fn, paramCache, serialisedParams, ...params) {
    try {
      const result = callWithContext(callers, fn, ...params);
      if (paramCache && serialisedParams != null) {
        paramCache.set(serialisedParams, result);
      }
      return result;
    } catch (e) {
      logger_exports.warnOnce(`User callback errored, ignoring`, e);
      return;
    }
  }
  invalidateCache() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};

// packages/ag-charts-community/src/util/dom.ts
function setElementBBox(element2, bbox) {
  if (!element2)
    return;
  const { x, y, width: width2, height: height2 } = normalizeBounds(bbox);
  setPixelValue(element2.style, "width", width2);
  setPixelValue(element2.style, "height", height2);
  setPixelValue(element2.style, "left", x);
  setPixelValue(element2.style, "top", y);
}
function getElementBBox(element2) {
  const width2 = parseFloat(element2.style.width) || element2.offsetWidth;
  const height2 = parseFloat(element2.style.height) || element2.offsetHeight;
  const x = parseFloat(element2.style.left) || element2.offsetLeft;
  const y = parseFloat(element2.style.top) || element2.offsetTop;
  return { x, y, width: width2, height: height2 };
}
function focusCursorAtEnd(element2) {
  element2.focus({ preventScroll: true });
  if (element2.lastChild?.textContent == null)
    return;
  const range4 = getDocument().createRange();
  range4.setStart(element2.lastChild, element2.lastChild.textContent.length);
  range4.setEnd(element2.lastChild, element2.lastChild.textContent.length);
  const selection = getWindow().getSelection();
  selection?.removeAllRanges();
  selection?.addRange(range4);
}
function isInputPending() {
  const navigator = getWindow("navigator");
  if ("scheduling" in navigator) {
    const scheduling = navigator.scheduling;
    if ("isInputPending" in scheduling) {
      return scheduling.isInputPending({ includeContinuous: true });
    }
  }
  return false;
}
function getIconClassNames(icon) {
  return `ag-charts-icon ag-charts-icon-${icon}`;
}
function normalizeBounds(bbox) {
  let { x, y, width: width2, height: height2 } = bbox;
  if ((width2 == null || width2 > 0) && (height2 == null || height2 > 0)) {
    return bbox;
  }
  if (x != null && width2 != null && width2 < 0) {
    width2 = -width2;
    x = x - width2;
  }
  if (y != null && height2 != null && height2 < 0) {
    height2 = -height2;
    y = y - height2;
  }
  return { x, y, width: width2, height: height2 };
}
function setPixelValue(style2, key, value) {
  if (value == null) {
    style2.removeProperty(key);
  } else {
    style2.setProperty(key, `${value}px`);
  }
}

// packages/ag-charts-community/src/util/json.ts
var CLASS_INSTANCE_TYPE = "class-instance";
function jsonDiff(source, target, shallow) {
  if (isArray(target)) {
    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v, shallow) != null)) {
      return target;
    }
  } else if (isPlainObject(target)) {
    if (!isPlainObject(source)) {
      return target;
    }
    const result = {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(source),
      ...Object.keys(target)
    ]);
    for (const key of allKeys) {
      if (source[key] === target[key]) {
        continue;
      } else if (shallow?.has(key)) {
        result[key] = target[key];
      } else if (typeof source[key] === typeof target[key]) {
        const diff8 = jsonDiff(source[key], target[key], shallow);
        if (diff8 !== null) {
          result[key] = diff8;
        }
      } else {
        result[key] = target[key];
      }
    }
    return Object.keys(result).length ? result : null;
  } else if (source !== target) {
    return target;
  }
  return null;
}
function jsonPropertyCompare(source, target) {
  for (const key of Object.keys(source)) {
    if (source[key] === target?.[key])
      continue;
    return false;
  }
  return true;
}
function deepClone(source, opts) {
  if (isArray(source)) {
    return cloneArray(source, opts);
  }
  if (isPlainObject(source)) {
    return clonePlainObject(source, opts);
  }
  if (source instanceof Map) {
    return new Map(deepClone(Array.from(source)));
  }
  return shallowClone(source);
}
function cloneArray(source, opts) {
  const result = [];
  const seen = opts?.seen;
  for (const item of source) {
    if (typeof item === "object" && seen?.includes(item)) {
      logger_exports.warn("cycle detected in array", item);
      continue;
    }
    seen?.push(item);
    result.push(deepClone(item, opts));
    seen?.pop();
  }
  return result;
}
function clonePlainObject(source, opts) {
  const target = {};
  for (const key of Object.keys(source)) {
    if (opts?.assign?.has(key)) {
      target[key] = source[key];
    } else if (opts?.shallow?.has(key)) {
      target[key] = shallowClone(source[key]);
    } else {
      target[key] = deepClone(source[key], opts);
    }
  }
  return target;
}
function shallowClone(source) {
  if (isArray(source)) {
    return source.slice(0);
  }
  if (isPlainObject(source)) {
    return { ...source };
  }
  if (isDate(source)) {
    return new Date(source);
  }
  if (isRegExp(source)) {
    return new RegExp(source.source, source.flags);
  }
  return source;
}
function jsonWalk(json, visit, skip, parallelJson, ctx, acc) {
  if (isArray(json)) {
    acc = visit(json, parallelJson, ctx, acc);
    let index = 0;
    for (const node of json) {
      acc = jsonWalk(node, visit, skip, parallelJson?.[index], ctx, acc);
      index++;
    }
  } else if (isPlainObject(json)) {
    acc = visit(json, parallelJson, ctx, acc);
    for (const key of Object.keys(json)) {
      if (skip?.has(key)) {
        continue;
      }
      const value = json[key];
      acc = jsonWalk(value, visit, skip, parallelJson?.[key], ctx, acc);
    }
  }
  return acc;
}
function jsonApply(target, source, params = {}) {
  const { path, matcherPath = path?.replace(/(\[[0-9+]+])/i, "[]"), skip = [] } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path ?? "<root>"}`);
  }
  if (source == null) {
    return target;
  }
  if (isProperties(target)) {
    return target.set(source);
  }
  const targetAny = target;
  const targetType = classify(target);
  for (const property of Object.keys(source)) {
    if (SKIP_JS_BUILTINS.has(property))
      continue;
    const propertyMatcherPath = `${matcherPath ? matcherPath + "." : ""}${property}`;
    if (skip.includes(propertyMatcherPath))
      continue;
    const newValue = source[property];
    const propertyPath = `${path ? path + "." : ""}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === CLASS_INSTANCE_TYPE && !(property in target || property === "context")) {
        if (newValue === void 0)
          continue;
        logger_exports.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
        continue;
      }
      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== "object")) {
        logger_exports.warn(
          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`
        );
        continue;
      }
      if (isProperties(currentValue)) {
        if (newValue === void 0) {
          currentValue.clear();
        } else {
          currentValue.set(newValue);
        }
      } else if (newValueType === "object" && property !== "context") {
        if (!(property in targetAny)) {
          logger_exports.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
          continue;
        }
        if (currentValue == null) {
          targetAny[property] = newValue;
        } else {
          jsonApply(currentValue, newValue, {
            ...params,
            path: propertyPath,
            matcherPath: propertyMatcherPath
          });
        }
      } else {
        targetAny[property] = newValue;
      }
    } catch (error2) {
      logger_exports.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error2.message}`);
    }
  }
  return target;
}
function classify(value) {
  if (value == null) {
    return null;
  }
  if (isHtmlElement(value) || isDate(value)) {
    return "primitive";
  }
  if (isArray(value)) {
    return "array";
  }
  if (isObject(value)) {
    return isPlainObject(value) ? "object" : CLASS_INSTANCE_TYPE;
  }
  if (isFunction(value)) {
    return "function";
  }
  return "primitive";
}

// packages/ag-charts-community/src/util/mutex.ts
var Mutex = class {
  constructor() {
    this.available = true;
    this.acquireQueue = [];
  }
  acquire(cb) {
    return new Promise((resolve) => {
      this.acquireQueue.push([cb, resolve]);
      if (this.available) {
        this.dispatchNext().catch((e) => logger_exports.errorOnce(e));
      }
    });
  }
  async acquireImmediately(cb) {
    if (!this.available) {
      return false;
    }
    await this.acquire(cb);
    return true;
  }
  async waitForClearAcquireQueue() {
    return this.acquire(() => Promise.resolve(void 0));
  }
  async dispatchNext() {
    this.available = false;
    let [next, done] = this.acquireQueue.shift() ?? [];
    while (next) {
      try {
        await next();
        done?.();
      } catch (error2) {
        logger_exports.error("mutex callback error", error2);
        done?.();
      }
      [next, done] = this.acquireQueue.shift() ?? [];
    }
    this.available = true;
  }
};

// packages/ag-charts-community/src/util/observable.ts
var Observable = class {
  constructor() {
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(eventType, listener) {
    if (typeof listener !== "function") {
      throw new Error("AG Charts - listener must be a Function");
    }
    const eventTypeListeners = this.eventListeners.get(eventType);
    if (eventTypeListeners) {
      eventTypeListeners.add(listener);
    } else {
      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));
    }
  }
  removeEventListener(type, listener) {
    const listeners = this.eventListeners.get(type);
    if (listeners == null)
      return;
    listeners.delete(listener);
    if (listeners.size === 0) {
      this.eventListeners.delete(type);
    }
  }
  hasEventListener(type) {
    return this.eventListeners.has(type);
  }
  clearEventListeners() {
    this.eventListeners.clear();
  }
  fireEvent(event) {
    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));
  }
};

// packages/ag-charts-community/src/util/padding.ts
var Padding = class extends BaseProperties {
  constructor(top = 0, right = top, bottom = top, left = right) {
    super();
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
};
__decorateClass([
  Property
], Padding.prototype, "top", 2);
__decorateClass([
  Property
], Padding.prototype, "right", 2);
__decorateClass([
  Property
], Padding.prototype, "bottom", 2);
__decorateClass([
  Property
], Padding.prototype, "left", 2);

// packages/ag-charts-community/src/util/proxy.ts
function ProxyProperty(proxyPath, configMetadata) {
  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(".");
  if (pathArray.length === 1) {
    const [property] = pathArray;
    return addTransformToInstanceProperty(
      (target, _, value) => target[property] = value,
      (target) => target[property],
      configMetadata
    );
  }
  return addTransformToInstanceProperty(
    (target, _, value) => setPath(target, pathArray, value),
    (target) => getPath(target, pathArray),
    configMetadata
  );
}
function ProxyOnWrite(proxyProperty) {
  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);
}
function ActionOnSet(opts) {
  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== void 0) {
        oldValueFn?.call(target, oldValue);
      }
      if (newValue !== void 0) {
        newValueFn?.call(target, newValue);
      }
      changeValueFn?.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
function ObserveChanges(observerFn) {
  return addObserverToInstanceProperty(observerFn);
}

// packages/ag-charts-community/src/util/render.ts
function debouncedAnimationFrame(cb) {
  return buildScheduler((innerCb, _delayMs) => getWindow().requestAnimationFrame(innerCb), cb);
}
function debouncedCallback(cb) {
  return buildScheduler((innerCb, delayMs = 0) => {
    if (delayMs === 0) {
      queueMicrotask(innerCb);
    } else {
      setTimeout(innerCb, delayMs);
    }
  }, cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone?.();
    awaitingDone = void 0;
    awaitingPromise = void 0;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({ count });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done, done);
  };
  return {
    schedule(delayMs) {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb, delayMs);
      }
      scheduleCount++;
    },
    async await() {
      if (!busy()) {
        return;
      }
      awaitingPromise ?? (awaitingPromise = new Promise((resolve) => {
        awaitingDone = resolve;
      }));
      while (busy()) {
        await awaitingPromise;
      }
    }
  };
}

// packages/ag-charts-community/src/widget/widgetEvents.ts
var WIDGET_HTML_EVENTS = [
  "blur",
  "change",
  "contextmenu",
  "focus",
  "keydown",
  "keyup",
  "click",
  "dblclick",
  "mouseenter",
  "mousemove",
  "mouseleave",
  "wheel",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel"
];
function allocMouseEvent(type, sourceEvent, current) {
  const { offsetX, offsetY, clientX, clientY } = sourceEvent;
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current, sourceEvent);
  return { type, device: "mouse", offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };
}
function allocTouchEvent(type, sourceEvent, _current) {
  return { type, sourceEvent };
}
var WidgetAllocators = {
  blur: (sourceEvent) => {
    return { type: "blur", sourceEvent };
  },
  change: (sourceEvent) => {
    return { type: "change", sourceEvent };
  },
  contextmenu: (sourceEvent, current) => {
    return allocMouseEvent("contextmenu", sourceEvent, current);
  },
  focus: (sourceEvent) => {
    return { type: "focus", sourceEvent };
  },
  keydown: (sourceEvent) => {
    return { type: "keydown", sourceEvent };
  },
  keyup: (sourceEvent) => {
    return { type: "keyup", sourceEvent };
  },
  click: (sourceEvent, current) => {
    return allocMouseEvent("click", sourceEvent, current);
  },
  dblclick: (sourceEvent, current) => {
    return allocMouseEvent("dblclick", sourceEvent, current);
  },
  mouseenter: (sourceEvent, current) => {
    return allocMouseEvent("mouseenter", sourceEvent, current);
  },
  mousemove: (sourceEvent, current) => {
    return allocMouseEvent("mousemove", sourceEvent, current);
  },
  mouseleave: (sourceEvent, current) => {
    return allocMouseEvent("mouseleave", sourceEvent, current);
  },
  wheel: (sourceEvent) => {
    const { offsetX, offsetY, clientX, clientY } = sourceEvent;
    const factor = sourceEvent.deltaMode === 0 ? 0.01 : 1;
    const deltaX = sourceEvent.deltaX * factor;
    const deltaY = sourceEvent.deltaY * factor;
    return { type: "wheel", offsetX, offsetY, clientX, clientY, deltaX, deltaY, sourceEvent };
  },
  touchstart: (sourceEvent, current) => {
    return allocTouchEvent("touchstart", sourceEvent, current);
  },
  touchmove: (sourceEvent, current) => {
    return allocTouchEvent("touchmove", sourceEvent, current);
  },
  touchend: (sourceEvent, current) => {
    return allocTouchEvent("touchend", sourceEvent, current);
  },
  touchcancel: (sourceEvent, current) => {
    return allocTouchEvent("touchcancel", sourceEvent, current);
  }
};
var WidgetEventUtil = class {
  static alloc(type, sourceEvent, current) {
    return WidgetAllocators[type](sourceEvent, current);
  }
  static isHTMLEvent(type) {
    const htmlTypes = WIDGET_HTML_EVENTS;
    return htmlTypes.includes(type);
  }
  static calcCurrentXY(current, event) {
    const currentRect = current.getBoundingClientRect();
    return { currentX: event.clientX - currentRect.x, currentY: event.clientY - currentRect.y };
  }
};

// packages/ag-charts-community/src/widget/widgetListenerHTML.ts
var WidgetListenerHTML = class {
  constructor() {
    this.widgetListeners = {};
    this.sourceListeners = {};
  }
  initSourceHandler(type, handler) {
    this.sourceListeners ?? (this.sourceListeners = {});
    this.sourceListeners[type] = handler;
  }
  lazyGetWidgetListeners(type, target) {
    var _a;
    if (!(type in (this.sourceListeners ?? {}))) {
      const sourceHandler = (sourceEvent) => {
        const widgetEvent = WidgetEventUtil.alloc(type, sourceEvent, target.getElement());
        this.dispatch(type, target, widgetEvent);
      };
      const opts = {};
      if (type.startsWith("touch"))
        opts.passive = false;
      this.initSourceHandler(type, sourceHandler);
      target.getElement().addEventListener(type, sourceHandler, opts);
    }
    this.widgetListeners ?? (this.widgetListeners = {});
    (_a = this.widgetListeners)[type] ?? (_a[type] = []);
    return this.widgetListeners[type];
  }
  add(type, target, handler) {
    const listeners = this.lazyGetWidgetListeners(type, target);
    listeners.push(handler);
  }
  remove(type, target, handler) {
    const listeners = this.lazyGetWidgetListeners(type, target);
    const index = listeners.indexOf(handler);
    if (index > -1)
      listeners.splice(index, 1);
  }
  destroy(target) {
    this.widgetListeners = void 0;
    if (this.sourceListeners) {
      for (const [key, sourceHandler] of entries(this.sourceListeners)) {
        target.getElement().removeEventListener(key, sourceHandler);
      }
      this.sourceListeners = void 0;
    }
  }
  dispatch(type, target, event) {
    for (const widgetListener of this.widgetListeners?.[type] ?? []) {
      widgetListener(event, target);
    }
  }
};

// packages/ag-charts-community/src/widget/mouseDragger.ts
var MouseDragger = class {
  constructor(glob, self, myCallbacks, downEvent) {
    this.glob = glob;
    this.self = self;
    this.window = getWindow();
    this.cleanup = new CleanupRegistry();
    this.mousegeneral = (generalEvent) => {
      generalEvent.stopPropagation();
      generalEvent.stopImmediatePropagation();
    };
    this.mousemove = (moveEvent) => {
      moveEvent.stopPropagation();
      moveEvent.stopImmediatePropagation();
      this.glob.globalMouseDragCallbacks?.mousemove(moveEvent);
    };
    this.mouseup = (upEvent) => {
      if (upEvent.button === 0) {
        upEvent.stopPropagation();
        upEvent.stopImmediatePropagation();
        this.glob.globalMouseDragCallbacks?.mouseup(upEvent);
        this.destroy();
      }
    };
    const { window: window2, mousegeneral, mousemove, mouseup } = this;
    this.cleanup.register(
      attachListener(window2, "mousedown", mousegeneral, { capture: true }),
      attachListener(window2, "mouseenter", mousegeneral, { capture: true }),
      attachListener(window2, "mouseleave", mousegeneral, { capture: true }),
      attachListener(window2, "mouseout", mousegeneral, { capture: true }),
      attachListener(window2, "mouseover", mousegeneral, { capture: true }),
      attachListener(window2, "mousemove", mousemove, { capture: true }),
      attachListener(window2, "mouseup", mouseup, { capture: true })
    );
    self.mouseDragger = this;
    glob.globalMouseDragCallbacks = myCallbacks;
    glob.globalMouseDragCallbacks.mousedown(downEvent);
    downEvent.stopPropagation();
    downEvent.stopImmediatePropagation();
  }
  destroy() {
    this.cleanup.flush();
    this.glob.globalMouseDragCallbacks = void 0;
    this.self.mouseDragger = void 0;
  }
};
function startMouseDrag(glob, self, myCallbacks, downEvent) {
  if (glob.globalMouseDragCallbacks != null)
    return void 0;
  return new MouseDragger(glob, self, myCallbacks, downEvent);
}

// packages/ag-charts-community/src/widget/touchDragger.ts
var LONG_TAP_DURATION_MS = 500;
var LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX = 100;
function deltaClientSquared(a, b) {
  const dx2 = a.clientX - b.clientX;
  const dy2 = a.clientY - b.clientY;
  return dx2 * dx2 + dy2 * dy2;
}
var gIsInLongTap = false;
var TouchDragger = class {
  constructor(glob, self, myCallbacks, initialTouch, target) {
    this.glob = glob;
    this.self = self;
    this.initialTouch = initialTouch;
    this.target = target;
    this.cleanup = new CleanupRegistry();
    this.longTapInterrupted = false;
    this.longtap = () => {
      const { target, initialTouch } = this;
      if (!this.longTapInterrupted) {
        const cleanup = new CleanupRegistry();
        target.dispatchEvent(new TouchEvent("touchcancel", { touches: [initialTouch], bubbles: true }));
        gIsInLongTap = true;
        const longTapMove = (e) => e.preventDefault();
        const longTapEnd = (e) => {
          gIsInLongTap = false;
          e.preventDefault();
          cleanup.flush();
        };
        cleanup.register(
          attachListener(target, "touchmove", longTapMove, { passive: false }),
          attachListener(target, "touchend", longTapEnd, { passive: false }),
          attachListener(target, "touchcancel", longTapEnd, { passive: false })
        );
        const { clientX, clientY } = initialTouch;
        const contextMenuEvent = new PointerEvent("contextmenu", {
          bubbles: true,
          cancelable: true,
          view: getWindow(),
          clientX,
          clientY,
          pointerType: "touch"
        });
        target.dispatchEvent(contextMenuEvent);
      }
    };
    this.touchmove = (moveEvent) => {
      const { glob, self, initialTouch } = this;
      const touch = this.findInitialFinger(moveEvent.targetTouches);
      if (touch != null) {
        this.longTapInterrupted = this.longTapInterrupted || deltaClientSquared(initialTouch, touch) > LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX;
        if (self.dragTouchEnabled) {
          glob.globalTouchDragCallbacks?.touchmove(moveEvent, touch);
        }
      }
    };
    this.touchend = (endEvent) => {
      this.longTapInterrupted = true;
      const touch = this.findInitialFinger(endEvent.changedTouches, endEvent.touches);
      if (touch != null) {
        this.glob.globalTouchDragCallbacks?.touchend(endEvent, touch);
      }
      this.destroy();
    };
    this.longtapTimer = setTimeout(this.longtap, LONG_TAP_DURATION_MS);
    const { touchmove, touchend } = this;
    this.cleanup.register(
      attachListener(target, "touchmove", touchmove, { passive: false }),
      attachListener(target, "touchstart", touchend, { passive: false }),
      attachListener(target, "touchend", touchend, { passive: false }),
      attachListener(target, "touchcancel", touchend, { passive: false })
    );
    self.touchDragger = this;
    glob.globalTouchDragCallbacks = myCallbacks;
  }
  destroy() {
    clearTimeout(this.longtapTimer);
    this.cleanup.flush();
    this.glob.globalTouchDragCallbacks = void 0;
    this.self.touchDragger = void 0;
  }
  findInitialFinger(...touchLists) {
    const touches = touchLists.map((touchList) => Array.from(touchList)).flat();
    return Array.from(touches).find((v) => v.identifier === this.initialTouch.identifier);
  }
};
function startOneFingerTouch(glob, self, myCallbacks, initialTouch, target) {
  if (glob.globalTouchDragCallbacks != null || gIsInLongTap)
    return void 0;
  return new TouchDragger(glob, self, myCallbacks, initialTouch, target);
}

// packages/ag-charts-community/src/widget/widgetListenerInternal.ts
function makeMouseDrag(current, type, origin3, sourceEvent) {
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), sourceEvent);
  const originDeltaX = sourceEvent.pageX - origin3.pageX;
  const originDeltaY = sourceEvent.pageY - origin3.pageY;
  return {
    type,
    device: "mouse",
    offsetX: origin3.offsetX + originDeltaX,
    offsetY: origin3.offsetY + originDeltaY,
    clientX: sourceEvent.clientX,
    clientY: sourceEvent.clientY,
    currentX,
    currentY,
    originDeltaX,
    originDeltaY,
    sourceEvent
  };
}
function getTouchOffsets(current, { pageX, pageY }) {
  const { x, y } = current.getElement().getBoundingClientRect();
  return { offsetX: pageX - x, offsetY: pageY - y };
}
function makeTouchDrag(current, type, origin3, sourceEvent, touch) {
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), touch);
  const originDeltaX = touch.pageX - origin3.pageX;
  const originDeltaY = touch.pageY - origin3.pageY;
  return {
    type,
    device: "touch",
    offsetX: origin3.offsetX + originDeltaX,
    offsetY: origin3.offsetY + originDeltaY,
    clientX: touch.clientX,
    clientY: touch.clientY,
    currentX,
    currentY,
    originDeltaX,
    originDeltaY,
    sourceEvent
  };
}
var GlobalCallbacks = {};
var WidgetListenerInternal = class {
  constructor(dispatchCallback) {
    this.dispatchCallback = dispatchCallback;
    this.dragTouchEnabled = true;
  }
  destroy() {
    this.dragTriggerRemover?.();
    this.dragTriggerRemover = void 0;
    this.listeners?.clear();
    this.mouseDragger?.destroy();
    this.touchDragger?.destroy();
  }
  getListenerSet(type) {
    this.listeners ?? (this.listeners = /* @__PURE__ */ new Map());
    let result = this.listeners.get(type);
    if (result === void 0) {
      result = /* @__PURE__ */ new Set();
      this.listeners.set(type, result);
    }
    return result;
  }
  add(type, target, handler) {
    this.getListenerSet(type).add(handler);
    switch (type) {
      case "drag-start":
      case "drag-move":
      case "drag-end": {
        this.registerDragTrigger(target);
        break;
      }
    }
  }
  remove(type, _target, handler) {
    this.getListenerSet(type).delete(handler);
  }
  registerDragTrigger(target) {
    if (this.dragTriggerRemover == null) {
      const element2 = target.getElement();
      const cleanup = new CleanupRegistry();
      cleanup.register(
        attachListener(element2, "mousedown", (event) => this.triggerMouseDrag(target, event)),
        attachListener(element2, "touchstart", (event) => this.triggerTouchDrag(target, event), {
          passive: false
        })
      );
      this.dragTriggerRemover = () => cleanup.flush();
    }
  }
  triggerMouseDrag(current, downEvent) {
    if (downEvent.button === 0) {
      this.startMouseDrag(current, downEvent);
    }
  }
  startMouseDrag(current, initialDownEvent) {
    const origin3 = { pageX: NaN, pageY: NaN, offsetX: NaN, offsetY: NaN };
    partialAssign(["pageX", "pageY", "offsetX", "offsetY"], origin3, initialDownEvent);
    const dragCallbacks = {
      mousedown: (downEvent) => {
        const dragStartEvent = makeMouseDrag(current, "drag-start", origin3, downEvent);
        this.dispatch("drag-start", current, dragStartEvent);
      },
      mousemove: (moveEvent) => {
        const dragMoveEvent = makeMouseDrag(current, "drag-move", origin3, moveEvent);
        this.dispatch("drag-move", current, dragMoveEvent);
      },
      mouseup: (upEvent) => {
        const dragEndEvent = makeMouseDrag(current, "drag-end", origin3, upEvent);
        this.dispatch("drag-end", current, dragEndEvent);
        this.endDrag(current, dragEndEvent);
      }
    };
    this.mouseDragger = startMouseDrag(GlobalCallbacks, this, dragCallbacks, initialDownEvent);
  }
  endDrag(target, { sourceEvent, clientX, clientY }) {
    const elem = target.getElement();
    const rect = elem.getBoundingClientRect();
    if (!boxContains(rect, clientX, clientY)) {
      elem.dispatchEvent(new MouseEvent("mouseleave", sourceEvent));
      sourceEvent.target?.dispatchEvent(new MouseEvent("mouseenter", sourceEvent));
    }
  }
  triggerTouchDrag(current, startEvent) {
    const touch = startEvent.targetTouches[0];
    if (startEvent.targetTouches.length === 1 && touch != null) {
      this.startOneFingerTouch(current, startEvent, touch);
    }
  }
  startOneFingerTouch(current, initialEvent, initialTouch) {
    const origin3 = { pageX: NaN, pageY: NaN, ...getTouchOffsets(current, initialTouch) };
    partialAssign(["pageX", "pageY"], origin3, initialTouch);
    const dragCallbacks = {
      touchmove: (moveEvent, touch) => {
        const dragMoveEvent = makeTouchDrag(current, "drag-move", origin3, moveEvent, touch);
        this.dispatch("drag-move", current, dragMoveEvent);
      },
      touchend: (cancelEvent, touch) => {
        const dragMoveEvent = makeTouchDrag(current, "drag-end", origin3, cancelEvent, touch);
        this.dispatch("drag-end", current, dragMoveEvent);
      }
    };
    const target = current.getElement();
    this.touchDragger = startOneFingerTouch(GlobalCallbacks, this, dragCallbacks, initialTouch, target);
    const dragStartEvent = makeTouchDrag(current, "drag-start", origin3, initialEvent, initialTouch);
    this.dispatch("drag-start", current, dragStartEvent);
  }
  dispatch(type, current, event) {
    for (const handler of this.getListenerSet(type)) {
      handler(event, current);
    }
    this.dispatchCallback(type, event);
  }
};

// packages/ag-charts-community/src/widget/widget.ts
var WidgetBounds = class {
  constructor(elem) {
    this.elem = elem;
  }
  setBounds(bounds) {
    setElementBBox(this.elemContainer ?? this.elem, bounds);
  }
  getBounds() {
    return getElementBBox(this.elemContainer ?? this.elem);
  }
  static setElementContainer(widget, elemContainer) {
    const currentBounds = widget.getBounds();
    setElementBBox(elemContainer, currentBounds);
    setElementStyles(widget.elem, { width: "100%", height: "100%" });
    widget.elem.remove();
    widget.elemContainer = elemContainer;
    widget.elemContainer.replaceChildren(widget.elem);
  }
};
var Widget = class extends WidgetBounds {
  constructor() {
    super(...arguments);
    this.index = NaN;
    this.children = [];
  }
  set id(elementId) {
    setAttribute(this.elem, "id", elementId);
  }
  get id() {
    return getAttribute(this.elem, "id");
  }
  getElement() {
    return this.elem;
  }
  getBoundingClientRect() {
    return this.elem.getBoundingClientRect();
  }
  get clientWidth() {
    return this.elem.clientWidth;
  }
  get clientHeight() {
    return this.elem.clientHeight;
  }
  destroy() {
    this.destroyListener?.();
    this.destroyListener = void 0;
    this.parent?.removeChild(this);
    this.children.forEach((child) => {
      child.parent = void 0;
      child.destroy();
    });
    this.children.length = 0;
    this.destructor();
    this.remove();
    this.internalListener?.destroy();
    this.htmlListener?.destroy(this);
  }
  remove() {
    this.elem.remove();
    this.elemContainer?.remove();
  }
  setHidden(hidden) {
    setElementStyle(this.elem, "display", hidden ? "none" : void 0);
  }
  isHidden() {
    return getWindow()?.getComputedStyle?.(this.elem).display === "none";
  }
  setCursor(cursor) {
    setElementStyle(this.elem, "cursor", cursor);
  }
  setTextContent(textContent) {
    this.elem.textContent = textContent ?? null;
  }
  setAriaDescribedBy(ariaDescribedBy) {
    setAttribute(this.elem, "aria-describedby", ariaDescribedBy);
  }
  setAriaHidden(ariaHidden) {
    setAttribute(this.elem, "aria-hidden", ariaHidden);
  }
  setAriaLabel(ariaLabel) {
    setAttribute(this.elem, "aria-label", ariaLabel);
  }
  setAriaExpanded(ariaExpanded) {
    setAttribute(this.elem, "aria-expanded", ariaExpanded);
  }
  setAriaControls(ariaControls) {
    setAttribute(this.elem, "aria-controls", ariaControls);
  }
  setAriaHasPopup(ariaHasPopup) {
    setAttribute(this.elem, "aria-haspopup", ariaHasPopup);
  }
  setInnerHTML(html) {
    this.elem.innerHTML = html;
  }
  setPointerEvents(pointerEvents) {
    setElementStyle(this.elem, "pointer-events", pointerEvents);
  }
  isDisabled() {
    return getAttribute(this.elem, "aria-disabled", false);
  }
  hasPopup() {
    const ariaHasPopup = getAttribute(this.elem, "aria-haspopup");
    return ariaHasPopup !== void 0 && ariaHasPopup !== "false";
  }
  parseFloat(s) {
    return s === "" ? 0 : parseFloat(s);
  }
  cssLeft() {
    return this.parseFloat(this.elem.style.left);
  }
  cssTop() {
    return this.parseFloat(this.elem.style.top);
  }
  cssWidth() {
    return this.parseFloat(this.elem.style.width);
  }
  cssHeight() {
    return this.parseFloat(this.elem.style.height);
  }
  focus(opts) {
    this.elem.focus(opts);
  }
  setFocusOverride(focus) {
    setAttribute(this.elem, "data-focus-override", focus);
  }
  setPreventsDefault(preventDefault) {
    setAttribute(this.elem, "data-preventdefault", preventDefault);
  }
  setTabIndex(tabIndex) {
    setAttribute(this.elem, "tabindex", tabIndex);
  }
  addChild(child) {
    this.addChildToDOM(child, this.getBefore(child));
    this.children.push(child);
    child.index = this.children.length - 1;
    child.parent = this;
    this.onChildAdded(child);
  }
  removeChild(child) {
    const i = this.children.findIndex((value) => value === child);
    this.children.splice(i, 1);
    this.removeChildFromDOM(child);
    this.onChildRemoved(child);
  }
  moveChild(child, domIndex) {
    if (child.domIndex === domIndex)
      return;
    child.domIndex = domIndex;
    this.removeChildFromDOM(child);
    this.addChildToDOM(child, this.getBefore(child));
  }
  addClass(...tokens) {
    this.elem.classList.add(...tokens);
  }
  removeClass(...tokens) {
    this.elem.classList.remove(...tokens);
  }
  toggleClass(token, force) {
    this.elem.classList.toggle(token, force);
  }
  appendOrInsert(child, before) {
    if (before) {
      before.getElement().insertAdjacentElement("beforebegin", child);
    } else {
      this.elem.appendChild(child);
    }
  }
  addChildToDOM(child, before) {
    this.appendOrInsert(child.getElement(), before);
  }
  removeChildFromDOM(child) {
    this.elem.removeChild(child.getElement());
  }
  onChildAdded(_child) {
  }
  onChildRemoved(_child) {
  }
  getBefore({ domIndex }) {
    if (domIndex === void 0)
      return void 0;
    return this.children.filter((child) => child.domIndex !== void 0 && child.domIndex > domIndex).reduce((prev, curr) => !prev || curr.domIndex < prev.domIndex ? curr : prev, void 0);
  }
  addListener(type, listener) {
    if (WidgetEventUtil.isHTMLEvent(type)) {
      this.htmlListener ?? (this.htmlListener = new WidgetListenerHTML());
      this.htmlListener.add(type, this, listener);
    } else {
      this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));
      this.internalListener.add(type, this, listener);
    }
    return () => this.removeListener(type, listener);
  }
  removeListener(type, listener) {
    if (WidgetEventUtil.isHTMLEvent(type)) {
      this.htmlListener?.remove(type, this, listener);
    } else if (this.htmlListener != null) {
      this.internalListener?.remove(type, this, listener);
    }
  }
  setDragTouchEnabled(dragTouchEnabled) {
    this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));
    this.internalListener.dragTouchEnabled = dragTouchEnabled;
  }
  onDispatch(type, event) {
    if (!event.sourceEvent?.bubbles)
      return;
    let { parent } = this;
    while (parent != null) {
      const { internalListener } = parent;
      if (internalListener != null) {
        const parentEvent = { ...event, ...WidgetEventUtil.calcCurrentXY(parent.getElement(), event) };
        internalListener.dispatch(type, parent, parentEvent);
      }
      parent = parent.parent;
    }
  }
  static addWindowEvent(_type, listener) {
    const pagehideHandler = (event) => {
      if (event.persisted) {
        return;
      }
      listener();
    };
    return attachListener(getWindow(), "pagehide", pagehideHandler);
  }
};

// packages/ag-charts-community/src/util/canvas.util.ts
function createCanvasContext(width2 = 0, height2 = 0) {
  return new OffscreenCanvas(width2, height2).getContext("2d");
}

// packages/ag-charts-community/src/util/lruCache.ts
var LRUCache = class {
  constructor(maxCacheSize = 5) {
    this.maxCacheSize = maxCacheSize;
    this.store = /* @__PURE__ */ new Map();
  }
  get(key) {
    if (!this.store.has(key))
      return void 0;
    const hit = this.store.get(key);
    this.store.delete(key);
    this.store.set(key, hit);
    return hit;
  }
  has(key) {
    return this.store.has(key);
  }
  set(key, value) {
    this.store.set(key, value);
    if (this.store.size > this.maxCacheSize) {
      const iterator = this.store.keys();
      let evictCount = this.store.size - this.maxCacheSize;
      while (evictCount > 0) {
        const evictKeyIterator = iterator.next();
        if (!evictKeyIterator.done) {
          this.store.delete(evictKeyIterator.value);
        }
        evictCount--;
      }
    }
    return value;
  }
  clear() {
    this.store.clear();
  }
};

// packages/ag-charts-community/src/util/textMeasurer.ts
var CachedTextMeasurerPool = class {
  // Measures the dimensions of the provided text, handling multiline if needed.
  static measureText(text2, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureText(text2);
  }
  static measureLines(text2, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureLines(text2);
  }
  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.
  static getMeasurer(options) {
    const font3 = TextUtils.toFontString(options.font);
    const key = `${font3}-${options.textAlign ?? "start"}-${options.textBaseline ?? "top"}`;
    return this.instanceMap.get(key) ?? this.createFontMeasurer(font3, options, key);
  }
  static clear() {
    this.instanceMap.clear();
  }
  // Creates or retrieves a TextMeasurer instance for a specific font.
  static createFontMeasurer(font3, options, key) {
    const ctx = createCanvasContext();
    ctx.font = font3;
    ctx.textAlign = options.textAlign ?? "start";
    ctx.textBaseline = options.textBaseline ?? "top";
    const measurer3 = new CachedTextMeasurer(ctx, options);
    this.instanceMap.set(key, measurer3);
    return measurer3;
  }
};
CachedTextMeasurerPool.instanceMap = new LRUCache(10);
var CachedTextMeasurer = class {
  constructor(ctx, options) {
    this.ctx = ctx;
    // cached text measurements
    this.measureMap = new LRUCache(100);
    if (options.textAlign) {
      ctx.textAlign = options.textAlign;
    }
    if (options.textBaseline) {
      ctx.textBaseline = options.textBaseline;
    }
    ctx.font = TextUtils.toFontString(options.font);
    this.textMeasurer = new SimpleTextMeasurer(
      (t) => this.cachedCtxMeasureText(t),
      options.textBaseline ?? "alphabetic"
    );
  }
  textWidth(text2, estimate) {
    return this.textMeasurer.textWidth(text2, estimate);
  }
  measureText(text2) {
    return this.textMeasurer.measureText(text2);
  }
  measureLines(text2) {
    return this.textMeasurer.measureLines(text2);
  }
  cachedCtxMeasureText(text2) {
    if (!this.measureMap.has(text2)) {
      const rawResult = this.ctx.measureText(text2);
      this.measureMap.set(text2, {
        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,
        emHeightAscent: rawResult.emHeightAscent,
        emHeightDescent: rawResult.emHeightDescent,
        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,
        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,
        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,
        alphabeticBaseline: rawResult.alphabeticBaseline,
        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,
        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,
        hangingBaseline: rawResult.hangingBaseline,
        ideographicBaseline: rawResult.ideographicBaseline,
        width: rawResult.width
      });
    }
    return this.measureMap.get(text2);
  }
};
var TextUtils = class {
  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily }) {
    let fontString = "";
    if (fontStyle && fontStyle !== "normal") {
      fontString += `${fontStyle} `;
    }
    if (fontWeight && fontWeight !== "normal" && fontWeight !== 400) {
      fontString += `${fontWeight} `;
    }
    fontString += `${fontSize}px`;
    fontString += ` ${fontFamily}`;
    return fontString.trim();
  }
  static getLineHeight(fontSize) {
    return Math.ceil(fontSize * this.defaultLineHeight);
  }
  static getHorizontalModifier(textAlign) {
    switch (textAlign) {
      case "left":
      case "start":
        return 0;
      case "center":
        return 0.5;
      case "right":
      case "end":
        return 1;
      default:
        return 0;
    }
  }
  // Determines vertical offset modifier based on text baseline.
  static getVerticalModifier(textBaseline) {
    switch (textBaseline) {
      case "hanging":
      case "top":
        return 0;
      case "middle":
        return 0.5;
      case "alphabetic":
      case "bottom":
      case "ideographic":
      default:
        return 1;
    }
  }
};
TextUtils.EllipsisChar = "\u2026";
// Representation for text clipping.
TextUtils.defaultLineHeight = 1.15;
// Normally between 1.1 and 1.2
TextUtils.lineSplitter = /\r?\n/g;
var SimpleTextMeasurer = class {
  constructor(measureTextFn, textBaseline = "alphabetic") {
    this.measureTextFn = measureTextFn;
    this.textBaseline = textBaseline;
    // local chars width cache per TextMeasurer
    this.charMap = /* @__PURE__ */ new Map();
  }
  // Measures metrics for a single line of text.
  getMetrics(text2) {
    const m = this.measureTextFn(text2);
    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
    return {
      width: m.width,
      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent
    };
  }
  // Calculates aggregated metrics for multiline text.
  getMultilineMetrics(lines) {
    let width2 = 0;
    let height2 = 0;
    let offsetTop = 0;
    let offsetLeft = 0;
    let baselineDistance = 0;
    let alphabeticBaseline = 0;
    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);
    const lineMetrics = [];
    let index = 0;
    const length2 = lines.length;
    for (const line of lines) {
      const m = this.measureTextFn(line);
      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
      if (width2 < m.width) {
        width2 = m.width;
      }
      if (offsetLeft < m.actualBoundingBoxLeft) {
        offsetLeft = m.actualBoundingBoxLeft;
      }
      if (index === 0) {
        height2 += m.actualBoundingBoxAscent;
        offsetTop += m.actualBoundingBoxAscent;
        alphabeticBaseline = m.alphabeticBaseline;
      } else {
        baselineDistance += m.fontBoundingBoxAscent;
      }
      if (index === length2 - 1) {
        height2 += m.actualBoundingBoxDescent;
      } else {
        baselineDistance += m.fontBoundingBoxDescent;
      }
      lineMetrics.push({
        text: line,
        width: m.width,
        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
        offsetTop: m.actualBoundingBoxAscent,
        offsetLeft: m.actualBoundingBoxLeft
      });
      index++;
    }
    height2 += baselineDistance;
    offsetTop += baselineDistance * verticalModifier;
    return { width: width2, height: height2, offsetTop, offsetLeft, alphabeticBaseline, lineMetrics };
  }
  textWidth(text2, estimate) {
    if (estimate) {
      let estimatedWidth = 0;
      for (let i = 0; i < text2.length; i++) {
        estimatedWidth += this.textWidth(text2.charAt(i));
      }
      return estimatedWidth;
    }
    if (text2.length > 1) {
      return this.measureTextFn(text2).width;
    }
    return this.charMap.get(text2) ?? this.charWidth(text2);
  }
  measureText(text2) {
    return this.getMetrics(text2);
  }
  // Measures the dimensions of the provided text, handling multiline if needed.
  measureLines(text2) {
    const lines = typeof text2 === "string" ? text2.split(TextUtils.lineSplitter) : text2;
    return this.getMultilineMetrics(lines);
  }
  charWidth(char) {
    const { width: width2 } = this.measureTextFn(char);
    this.charMap.set(char, width2);
    return width2;
  }
};

// packages/ag-charts-community/src/scene/sceneDebug.ts
function formatBytes(value) {
  for (const unit of ["B", "KB", "MB", "GB"]) {
    if (value < 1536) {
      return `${value.toFixed(1)}${unit}`;
    }
    value /= 1024;
  }
  return `${value.toFixed(1)}TB}`;
}
function memoryUsage() {
  if (!("memory" in performance))
    return;
  const { totalJSHeapSize, usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
  const result = [];
  for (const amount of [usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit]) {
    if (typeof amount !== "number")
      continue;
    result.push(formatBytes(amount));
  }
  return `Heap ${result.join(" / ")}`;
}
function debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {
  if (!Debug.check("scene:stats" /* SCENE_STATS */, "scene:stats:verbose" /* SCENE_STATS_VERBOSE */))
    return;
  const {
    layersRendered = 0,
    layersSkipped = 0,
    nodesRendered = 0,
    nodesSkipped = 0,
    opsPerformed = 0,
    opsSkipped = 0
  } = renderCtxStats ?? {};
  const end2 = performance.now();
  const { start: start2, ...durations } = debugSplitTimes;
  const splits = Object.entries(durations).map(([n, t]) => {
    return time(n, t);
  }).filter((v) => v != null).join(" + ");
  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join(" ; ");
  const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */);
  const memUsage = memoryUsage();
  const stats = [
    `${time("\u23F1\uFE0F", start2, end2)} (${splits})`,
    `${extras}`,
    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,
    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null,
    detailedStats ? `Ops: ${pct(opsPerformed, opsSkipped)}` : null,
    detailedStats && memUsage ? memUsage : null
  ].filter(isString);
  const measurer3 = new SimpleTextMeasurer((t) => ctx.measureText(t));
  const statsSize = new Map(stats.map((t) => [t, measurer3.measureLines(t)]));
  const width2 = Math.max(...Array.from(statsSize.values(), (s) => s.width));
  const height2 = accumulate(statsSize.values(), (s) => s.height);
  const x = 2 + seriesRect.x;
  ctx.save();
  try {
    ctx.fillStyle = "white";
    ctx.fillRect(x, 0, width2, height2);
    ctx.fillStyle = "black";
    let y = 0;
    for (const [stat, size] of statsSize.entries()) {
      y += size.height;
      ctx.fillText(stat, x, y);
    }
  } catch (e) {
    logger_exports.warnOnce("Error during debug stats rendering", e);
  } finally {
    ctx.restore();
  }
}
function prepareSceneNodeHighlight(ctx) {
  const config = toArray(getWindow("agChartsSceneDebug"));
  const result = [];
  for (const name of config) {
    if (name === "layout") {
      result.push("seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/);
    } else {
      result.push(name);
    }
  }
  ctx.debugNodeSearch = result;
}
function debugSceneNodeHighlight(ctx, debugNodes) {
  ctx.save();
  try {
    for (const [name, node] of Object.entries(debugNodes)) {
      const bbox = Transformable.toCanvas(node);
      if (!bbox) {
        logger_exports.log(`Scene.render() - no bbox for debugged node [${name}].`);
        continue;
      }
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
      ctx.fillStyle = "red";
      ctx.strokeStyle = "white";
      ctx.font = "16px sans-serif";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.lineWidth = 2;
      ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
      ctx.fillText(name, bbox.x, bbox.y, bbox.width);
    }
  } catch (e) {
    logger_exports.warnOnce("Error during debug rendering", e);
  } finally {
    ctx.restore();
  }
}
var skippedProperties = /* @__PURE__ */ new Set();
var allowedProperties = /* @__PURE__ */ new Set([
  "gradient",
  // '_datum',
  "zIndex",
  "clipRect",
  "cachedBBox",
  "childNodeCounts",
  "path",
  "__zIndex",
  "name",
  "__scalingCenterX",
  "__scalingCenterY",
  "__rotationCenterX",
  "__rotationCenterY",
  "_previousDatum",
  "__fill",
  "__lineDash",
  "borderPath",
  "borderClipPath",
  "_clipPath"
]);
function nodeProps(node) {
  const { ...allProps } = node;
  for (const prop of Object.keys(allProps)) {
    if (allowedProperties.has(prop))
      continue;
    if (typeof allProps[prop] === "number")
      continue;
    if (typeof allProps[prop] === "string")
      continue;
    if (typeof allProps[prop] === "boolean")
      continue;
    skippedProperties.add(prop);
    delete allProps[prop];
  }
  return allProps;
}
function buildTree(node, mode) {
  if (!Debug.check(true, "scene" /* SCENE */)) {
    return {};
  }
  let order = 0;
  return {
    node: mode === "json" ? nodeProps(node) : node,
    name: node.name ?? node.id,
    dirty: node instanceof Group ? node.dirty : void 0,
    ...Array.from(node instanceof Group ? node.children() : [], (c) => buildTree(c, mode)).reduce((result, childTree) => {
      let { name: treeNodeName } = childTree;
      const {
        node: { visible, opacity, zIndex, translationX, translationY, rotation, scalingX, scalingY },
        node: childNode
      } = childTree;
      if (!visible || opacity <= 0) {
        treeNodeName = `(${treeNodeName})`;
      }
      if (Group.is(childNode) && childNode.renderToOffscreenCanvas) {
        treeNodeName = `*${treeNodeName}*`;
      }
      const zIndexString = Array.isArray(zIndex) ? `(${zIndex.join(", ")})` : zIndex;
      const key = [
        `${(order++).toString().padStart(3, "0")}|`,
        `${treeNodeName ?? "<unknown>"}`,
        `z: ${zIndexString}`,
        translationX && `x: ${translationX}`,
        translationY && `y: ${translationY}`,
        rotation && `r: ${rotation}`,
        scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,
        scalingY != null && scalingY !== 1 && `sy: ${scalingY}`
      ].filter((v) => !!v).join(" ");
      let selectedKey = key;
      let index = 1;
      while (result[selectedKey] != null && index < 100) {
        selectedKey = `${key} (${index++})`;
      }
      result[selectedKey] = childTree;
      return result;
    }, {})
  };
}
function buildDirtyTree(node) {
  const nodeDirty = node instanceof Group ? node.dirty : void 0;
  if (!nodeDirty) {
    return { dirtyTree: {}, paths: [] };
  }
  const childrenDirtyTree = Array.from(node instanceof Group ? node.children() : [], (c) => buildDirtyTree(c)).filter(
    (c) => c.paths.length > 0
  );
  const name = Group.is(node) ? node.name ?? node.id : node.id;
  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];
  return {
    dirtyTree: {
      name,
      node,
      dirty: nodeDirty,
      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {
        result[childTree.name ?? "<unknown>"] = childTree;
        return result;
      }, {})
    },
    paths
  };
}
function pct(rendered, skipped) {
  const total = rendered + skipped;
  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
}
function time(name, start2, end2) {
  const duration = end2 != null ? end2 - start2 : start2;
  return `${name}: ${Math.round(duration * 100) / 100}ms`;
}
function accumulate(iterator, mapper) {
  let sum2 = 0;
  for (const item of iterator) {
    sum2 += mapper(item);
  }
  return sum2;
}

// packages/ag-charts-community/src/scene/util/corner.ts
var drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {
  if (move) {
    path.moveTo(x0, y0);
  }
  if (x0 !== x1 || y0 !== y1) {
    const r0 = Math.atan2(y0 - cy, x0 - cx);
    const r1 = Math.atan2(y1 - cy, x1 - cx);
    path.arc(cx, cy, cornerRadius, r0, r1);
  } else {
    path.lineTo(x0, y0);
  }
};

// packages/ag-charts-community/src/scene/shape/path.ts
var Path = class extends Shape {
  constructor() {
    super(...arguments);
    /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */
    this.path = new ExtendedPath2D();
    this._clipX = NaN;
    this._clipY = NaN;
    this.clip = false;
    /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */
    this._dirtyPath = true;
    this.lastPixelRatio = NaN;
  }
  set clipX(value) {
    this._clipX = value;
    this.dirtyPath = true;
  }
  set clipY(value) {
    this._clipY = value;
    this.dirtyPath = true;
  }
  set dirtyPath(value) {
    if (this._dirtyPath !== value) {
      this._dirtyPath = value;
      if (value) {
        this.markDirty("path");
      }
    }
  }
  get dirtyPath() {
    return this._dirtyPath;
  }
  checkPathDirty() {
    if (this._dirtyPath) {
      return;
    }
    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);
  }
  resetPathDirty() {
    this.path.clear(true);
    this._dirtyPath = false;
  }
  isPathDirty() {
    return this.path.isDirty();
  }
  onChangeDetection(property) {
    if (!this._dirtyPath) {
      this._dirtyPath = true;
      super.onChangeDetection(property);
    }
  }
  computeBBox() {
    this.updatePathIfDirty();
    return this.path.computeBBox();
  }
  isPointInPath(x, y) {
    this.updatePathIfDirty();
    return this.path.closedPath && this.path.isPointInPath(x, y);
  }
  distanceSquared(x, y) {
    return this.distanceSquaredTransformedPoint(x, y);
  }
  svgPathData(transform) {
    this.updatePathIfDirty();
    return this.path.toSVG(transform);
  }
  distanceSquaredTransformedPoint(x, y) {
    this.updatePathIfDirty();
    if (this.path.closedPath && this.path.isPointInPath(x, y)) {
      return 0;
    }
    return this.path.distanceSquared(x, y);
  }
  isDirtyPath() {
    return false;
  }
  updatePath() {
  }
  updatePathIfDirty() {
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
  }
  preRender(renderCtx) {
    if (renderCtx.devicePixelRatio !== this.lastPixelRatio) {
      this.dirtyPath = true;
    }
    this.lastPixelRatio = renderCtx.devicePixelRatio;
    this.updatePathIfDirty();
    return super.preRender(renderCtx, this.path.commands.length);
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {
      ctx.save();
      try {
        const margin = this.strokeWidth / 2;
        this._clipPath ?? (this._clipPath = new ExtendedPath2D());
        this._clipPath.clear();
        this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
        ctx.clip(this._clipPath?.getPath2D());
        if (this._clipX > 0 && this._clipY > 0) {
          this.drawPath(ctx);
        }
      } finally {
        ctx.restore();
      }
    } else {
      this._clipPath = void 0;
      this.drawPath(ctx);
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  drawPath(ctx) {
    this.fillStroke(ctx, this.path.getPath2D());
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = createSvgElement("path");
    element2.setAttribute("d", this.svgPathData());
    const defs = this.applySvgFillAttributes(element2, []);
    this.applySvgStrokeAttributes(element2);
    return {
      elements: [element2],
      defs
    };
  }
};
Path.className = "Path";
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clip", 2);
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clipX", 1);
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clipY", 1);

// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon = 1e-6;
var cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {
  let leadingClipped = false;
  let trailingClipped = false;
  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));
  let leading1 = 0;
  let trailing0 = 0;
  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));
  if (leading0 > leadingEdge) {
    leadingClipped = true;
    leading0 = leadingEdge;
    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));
  } else if (leading0 < epsilon) {
    leading0 = 0;
  }
  if (trailing1 > trailingEdge) {
    trailingClipped = true;
    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));
    trailing1 = trailingEdge;
  } else if (trailing1 < epsilon) {
    trailing1 = 0;
  }
  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };
};
var clippedRoundRect = (path, x, y, width2, height2, cornerRadii, clipBBox) => {
  let {
    topLeft: topLeftCornerRadius,
    topRight: topRightCornerRadius,
    bottomRight: bottomRightCornerRadius,
    bottomLeft: bottomLeftCornerRadius
  } = cornerRadii;
  const maxVerticalCornerRadius = Math.max(
    topLeftCornerRadius + bottomLeftCornerRadius,
    topRightCornerRadius + bottomRightCornerRadius
  );
  const maxHorizontalCornerRadius = Math.max(
    topLeftCornerRadius + topRightCornerRadius,
    bottomLeftCornerRadius + bottomRightCornerRadius
  );
  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
    if (clipBBox == null) {
      path.rect(x, y, width2, height2);
    } else {
      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);
    }
    return;
  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
    path.roundRect(x, y, width2, height2, topLeftCornerRadius);
    return;
  }
  if (width2 < 0) {
    x += width2;
    width2 = Math.abs(width2);
  }
  if (height2 < 0) {
    y += height2;
    height2 = Math.abs(height2);
  }
  if (width2 <= 0 || height2 <= 0)
    return;
  if (clipBBox == null) {
    clipBBox = new BBox(x, y, width2, height2);
  } else {
    const x0 = Math.max(x, clipBBox.x);
    const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);
    const y0 = Math.max(y, clipBBox.y);
    const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);
    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);
  }
  const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);
  if (borderScale > 1) {
    topLeftCornerRadius /= borderScale;
    topRightCornerRadius /= borderScale;
    bottomRightCornerRadius /= borderScale;
    bottomLeftCornerRadius /= borderScale;
  }
  let drawTopLeftCorner = true;
  let drawTopRightCorner = true;
  let drawBottomRightCorner = true;
  let drawBottomLeftCorner = true;
  let topLeftCorner;
  let topRightCorner;
  let bottomRightCorner;
  let bottomLeftCorner;
  if (drawTopLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),
      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),
      topLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomLeftCorner = false;
    if (nodes.trailingClipped)
      drawTopRightCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);
    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);
    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);
    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);
    const cx = x + topLeftCornerRadius;
    const cy = y + topLeftCornerRadius;
    topLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawTopRightCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(y + topRightCornerRadius - clipBBox.y, 0),
      Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0),
      topRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopLeftCorner = false;
    if (nodes.trailingClipped)
      drawBottomRightCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);
    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);
    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);
    const cx = x + width2 - topRightCornerRadius;
    const cy = y + topRightCornerRadius;
    topRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomRightCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0),
      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0),
      bottomRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopRightCorner = false;
    if (nodes.trailingClipped)
      drawBottomLeftCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);
    const cx = x + width2 - bottomRightCornerRadius;
    const cy = y + height2 - bottomRightCornerRadius;
    bottomRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0),
      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),
      bottomLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomRightCorner = false;
    if (nodes.trailingClipped)
      drawTopLeftCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);
    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);
    const cx = x + bottomLeftCornerRadius;
    const cy = y + height2 - bottomLeftCornerRadius;
    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  let didMove = false;
  if (drawTopLeftCorner && topLeftCorner != null) {
    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawTopRightCorner && topRightCorner != null) {
    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomRightCorner && bottomRightCorner != null) {
    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomLeftCorner && bottomLeftCorner != null) {
    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
  }
  path.closePath();
};
var Rect = class extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new ExtendedPath2D();
    this.x = 0;
    this.y = 0;
    this.width = 10;
    this.height = 10;
    this.topLeftCornerRadius = 0;
    this.topRightCornerRadius = 0;
    this.bottomRightCornerRadius = 0;
    this.bottomLeftCornerRadius = 0;
    this.clipBBox = void 0;
    this.crisp = false;
    this.lastUpdatePathStrokeWidth = this.strokeWidth;
    this.effectiveStrokeWidth = this.strokeWidth;
    this.hittester = super.isPointInPath.bind(this);
    this.distanceCalculator = super.distanceSquaredTransformedPoint.bind(this);
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    this.microPixelEffectOpacity = 1;
  }
  set cornerRadius(cornerRadius) {
    this.topLeftCornerRadius = cornerRadius;
    this.topRightCornerRadius = cornerRadius;
    this.bottomRightCornerRadius = cornerRadius;
    this.bottomLeftCornerRadius = cornerRadius;
  }
  isDirtyPath() {
    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());
  }
  updatePath() {
    const {
      path,
      borderPath,
      crisp,
      topLeftCornerRadius: topLeft,
      topRightCornerRadius: topRight,
      bottomRightCornerRadius: bottomRight,
      bottomLeftCornerRadius: bottomLeft
    } = this;
    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const pixelSize = 1 / pixelRatio;
    let microPixelEffectOpacity = 1;
    path.clear(true);
    borderPath.clear(true);
    if (w === 0 || h === 0) {
      this.effectiveStrokeWidth = 0;
      this.lastUpdatePathStrokeWidth = 0;
      this.microPixelEffectOpacity = 0;
      return;
    }
    if (crisp) {
      if (w <= pixelSize) {
        microPixelEffectOpacity *= w / pixelSize;
      }
      if (h <= pixelSize) {
        microPixelEffectOpacity *= h / pixelSize;
      }
      w = this.align(x, w);
      h = this.align(y, h);
      x = this.align(x);
      y = this.align(y);
      clipBBox = clipBBox != null ? new BBox(
        this.align(clipBBox.x),
        this.align(clipBBox.y),
        this.align(clipBBox.x, clipBBox.width),
        this.align(clipBBox.y, clipBBox.height)
      ) : void 0;
    }
    if (strokeWidth) {
      if (w < pixelSize) {
        const lx = x + pixelSize / 2;
        borderPath.moveTo(lx, y);
        borderPath.lineTo(lx, y + h);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (h < pixelSize) {
        const ly = y + pixelSize / 2;
        borderPath.moveTo(x, ly);
        borderPath.lineTo(x + w, ly);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (strokeWidth < w && strokeWidth < h) {
        const halfStrokeWidth = strokeWidth / 2;
        x += halfStrokeWidth;
        y += halfStrokeWidth;
        w -= strokeWidth;
        h -= strokeWidth;
        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);
        const cornerRadii = {
          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,
          topRight: topRight > 0 ? topRight - strokeWidth : 0,
          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,
          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0
        };
        this.borderClipPath = void 0;
        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {
          clippedRoundRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);
          clippedRoundRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);
        }
      } else {
        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();
        this.borderClipPath.clear(true);
        this.borderClipPath.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      }
    } else {
      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };
      this.borderClipPath = void 0;
      clippedRoundRect(path, x, y, w, h, cornerRadii, clipBBox);
    }
    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {
      const bbox = this.getBBox();
      this.hittester = bbox.containsPoint.bind(bbox);
      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);
    } else {
      this.hittester = super.isPointInPath;
      this.distanceCalculator = super.distanceSquaredTransformedPoint;
    }
    this.effectiveStrokeWidth = strokeWidth;
    this.lastUpdatePathStrokeWidth = strokeWidth;
    this.microPixelEffectOpacity = microPixelEffectOpacity;
  }
  computeBBox() {
    const { x, y, width: width2, height: height2, clipBBox } = this;
    return clipBBox?.clone() ?? new BBox(x, y, width2, height2);
  }
  isPointInPath(x, y) {
    return this.hittester(x, y);
  }
  get midPoint() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  distanceSquared(x, y) {
    return this.distanceCalculator(x, y);
  }
  applyFillAndAlpha(ctx) {
    super.applyFillAndAlpha(ctx);
    ctx.globalAlpha *= this.microPixelEffectOpacity;
  }
  applyStrokeAndAlpha(ctx) {
    super.applyStrokeAndAlpha(ctx);
    ctx.globalAlpha *= this.microPixelEffectOpacity;
  }
  renderStroke(ctx) {
    const { stroke: stroke3, effectiveStrokeWidth } = this;
    if (stroke3 && effectiveStrokeWidth) {
      const { globalAlpha } = ctx;
      const { lineDash, lineDashOffset, lineCap, lineJoin, borderPath, borderClipPath } = this;
      if (borderClipPath) {
        ctx.clip(borderClipPath.getPath2D());
      }
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = effectiveStrokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.stroke(borderPath.getPath2D());
      ctx.globalAlpha = globalAlpha;
    }
  }
};
Rect.className = "Rect";
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "height", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "topLeftCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "topRightCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "bottomRightCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "bottomLeftCornerRadius", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: boxesEqual })
], Rect.prototype, "clipBBox", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "crisp", 2);

// packages/ag-charts-community/src/scene/shape/text.ts
var externUseGlyphIndependentMeasurements = false;
var _Text = class _Text extends Shape {
  constructor(options) {
    super(options);
    this.x = 0;
    this.y = 0;
    this.lines = [];
    this.text = void 0;
    this.fontSize = _Text.defaultFontSize;
    this.fontFamily = "sans-serif";
    this.textAlign = "start";
    this.textBaseline = "alphabetic";
    this.boxPadding = 0;
    this.trimText = options?.trimText ?? true;
  }
  onTextChange() {
    this.richText?.clear();
    this.textMap?.clear();
    if (isArray(this.text)) {
      this.lines = [];
      this.richText ?? (this.richText = new Group());
      this.richText.setScene(this.scene);
      this.richText.append(this.text.map(() => new _Text({ trimText: false })));
    } else {
      const lines = this.text?.split("\n") ?? [];
      this.lines = this.trimText ? lines.map((line) => line.trim()) : lines;
    }
  }
  static computeBBox(lines, x, y, opts, useGlyphIndependentMeasurements = true) {
    const {
      font: font3,
      font: { fontSize },
      textAlign,
      textBaseline,
      lineHeight = useGlyphIndependentMeasurements ? TextUtils.getLineHeight(fontSize) : void 0
    } = opts;
    const {
      width: width2,
      alphabeticBaseline,
      offsetLeft: exactOffsetLeft,
      offsetTop: exactOffsetTop,
      height: exactHeight
    } = CachedTextMeasurerPool.measureLines(
      lines,
      useGlyphIndependentMeasurements ? { font: font3, lineHeight, textAlign: "start", textBaseline: "top" } : opts
    );
    const height2 = lineHeight == null ? exactHeight : lineHeight * lines.length;
    let offsetTop;
    if (lineHeight == null) {
      offsetTop = exactOffsetTop;
    } else if (textBaseline === "alphabetic") {
      const padding2 = (lineHeight - fontSize) / 2;
      offsetTop = padding2 - alphabeticBaseline;
    } else {
      offsetTop = TextUtils.getVerticalModifier(textBaseline) * height2;
    }
    const offsetLeft = useGlyphIndependentMeasurements ? width2 * TextUtils.getHorizontalModifier(textAlign) : exactOffsetLeft;
    return new BBox(x - offsetLeft, y - offsetTop, width2, height2);
  }
  computeBBox(useGlyphIndependentMeasurements = externUseGlyphIndependentMeasurements) {
    this.generateTextMap();
    if (this.textMap?.size) {
      const bbox = BBox.merge(this.textMap.values());
      bbox.x = this.x;
      bbox.y = this.y;
      return bbox;
    }
    const { x, y, lines, textBaseline, textAlign, lineHeight } = this;
    const measuredTextBounds = _Text.computeBBox(
      lines,
      x,
      y,
      { font: this, textBaseline, textAlign, lineHeight },
      useGlyphIndependentMeasurements
    );
    if (this.boxing != null)
      measuredTextBounds.grow(this.boxPadding);
    return measuredTextBounds;
  }
  getBBox(useGlyphIndependentMeasurements = true) {
    if (useGlyphIndependentMeasurements) {
      externUseGlyphIndependentMeasurements = true;
      const bbox = this.computeBBox(true);
      externUseGlyphIndependentMeasurements = false;
      return bbox;
    }
    return super.getBBox();
  }
  getPlainText() {
    return toPlainText(this.text);
  }
  getTextMeasureBBox() {
    return this.computeBBox();
  }
  isPointInPath(x, y) {
    return this.getBBox()?.containsPoint(x, y) ?? false;
  }
  setScene(scene) {
    this.richText?.setScene(scene);
    super.setScene(scene);
  }
  generateTextMap() {
    if (!isArray(this.text) || this.textMap?.size)
      return;
    this.textMap ?? (this.textMap = /* @__PURE__ */ new Map());
    let index = 0;
    let totalWidth = 0;
    let offsetY = 0;
    const mainStyle = {
      fill: this.fill,
      fontSize: this.fontSize,
      fontFamily: this.fontFamily,
      fontStyle: this.fontStyle,
      fontWeight: this.fontWeight
    };
    for (const textNode of this.richText.children()) {
      const { color: color2, ...textSegment } = this.text[index++];
      textNode.x = 0;
      textNode.y = 0;
      textNode.setProperties(mergeDefaults({ fill: color2 }, textSegment, mainStyle));
      const textBBox = textNode.getBBox();
      this.textMap.set(textNode, textBBox);
      offsetY = Math.max(
        offsetY,
        textBBox.y + textBBox.height / 2 + (textNode.lineHeight ?? TextUtils.getLineHeight(textNode.fontSize))
      );
      totalWidth += textBBox.x + textBBox.width;
    }
    let offsetX = this.x - totalWidth / 2;
    for (const [textNode, bbox] of this.textMap) {
      textNode.x += offsetX;
      textNode.y += offsetY;
      offsetX += bbox.width;
    }
  }
  render(renderCtx) {
    const { ctx, stats } = renderCtx;
    if (!this.text || !this.layerManager) {
      if (stats)
        stats.nodesSkipped += 1;
      return super.render(renderCtx);
    }
    if (isArray(this.text)) {
      this.generateTextMap();
      const { width: width2 } = this.richText.getBBox();
      let translateX = 0;
      switch (this.textAlign) {
        case "left":
        case "start":
          translateX = width2 / 2;
          break;
        case "right":
        case "end":
          translateX = width2 / -2;
      }
      ctx.save();
      ctx.translate(translateX, this.y);
      this.richText.render(renderCtx);
      ctx.restore();
    } else {
      this.renderText(renderCtx);
    }
    if (_Text.debug.check() && !this.textMap?.size) {
      const bbox = this.getBBox(true);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
    }
    super.render(renderCtx);
  }
  markDirty(property) {
    this.textMap?.clear();
    return super.markDirty(property);
  }
  renderText(renderCtx) {
    const { fill, stroke: stroke3, strokeWidth } = this;
    if (!fill && !(stroke3 && strokeWidth) || !this.layerManager) {
      return super.render(renderCtx);
    }
    const { ctx } = renderCtx;
    const font3 = TextUtils.toFontString(this);
    if (ctx.font !== font3) {
      ctx.font = font3;
    }
    const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textAlign, textBaseline } = this;
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    if (this.boxing) {
      const opts = { font: this, textBaseline, textAlign, lineHeight };
      const textBBox = _Text.computeBBox(this.lines, this.x, this.y, opts);
      if (textBBox.width !== 0 && textBBox.height !== 0) {
        const { x, y, width: width2, height: height2 } = textBBox.grow(this.boxPadding);
        this.boxing.opacity = this.opacity;
        this.boxing.x = x;
        this.boxing.y = y;
        this.boxing.width = width2;
        this.boxing.height = height2;
        this.boxing.preRender(renderCtx);
        this.boxing.render(renderCtx);
      }
    }
    this.fillStroke(ctx);
  }
  executeFill(ctx) {
    const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textBaseline, lines } = this;
    const lineOriginY = textBaseline === "alphabetic" ? 0 : TextUtils.getVerticalModifier(textBaseline) * lineHeight * (1 - lines.length);
    this.renderLines(lineOriginY, lineHeight, (line, x, y) => ctx.fillText(line, x, y));
  }
  executeStroke(ctx) {
    const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textBaseline, lines } = this;
    const lineOriginY = textBaseline === "alphabetic" ? 0 : TextUtils.getVerticalModifier(textBaseline) * lineHeight * (1 - lines.length);
    this.renderLines(lineOriginY, lineHeight, (line, x, y) => ctx.strokeText(line, x, y));
  }
  renderLines(offsetY, lineHeight, renderCallback) {
    const { lines, x, y } = this;
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(offsetY) || !Number.isFinite(lineHeight)) {
      return;
    }
    for (const line of lines) {
      renderCallback(line, x, y + offsetY);
      offsetY += lineHeight;
    }
  }
  setFont(props) {
    this.fontFamily = props.fontFamily;
    this.fontSize = props.fontSize;
    this.fontStyle = props.fontStyle;
    this.fontWeight = props.fontWeight;
  }
  setAlign(props) {
    this.textAlign = props.textAlign;
    this.textBaseline = props.textBaseline;
  }
  setBoxing(props) {
    const stroke3 = props.border?.enabled ? props.border?.stroke : void 0;
    if (props.fill != null || stroke3 != null) {
      this.boxing ?? (this.boxing = new Rect({ scene: this.scene }));
      this.boxing.fill = props.fill;
      this.boxing.fillOpacity = props.fillOpacity ?? 1;
      this.boxing.cornerRadius = props.cornerRadius ?? 0;
      this.boxing.stroke = stroke3;
      this.boxing.strokeWidth = props.border?.strokeWidth ?? 0;
      this.boxing.strokeOpacity = props.border?.strokeOpacity ?? 1;
      this.boxPadding = props.padding ?? 0;
    } else if (this.boxing) {
      this.boxing.destroy();
      this.boxing = void 0;
    }
  }
  getBoxingProperties() {
    const { fill, fillOpacity, cornerRadius, stroke: stroke3, strokeWidth, strokeOpacity } = this.boxing ?? {};
    return {
      border: { enabled: stroke3 != null, stroke: stroke3, strokeWidth, strokeOpacity },
      cornerRadius,
      fill,
      fillOpacity,
      padding: this.boxPadding
    };
  }
  toSVG() {
    if (!this.visible || !this.text)
      return;
    const element2 = createSvgElement("text");
    if (isString(this.text)) {
      this.applySvgFillAttributes(element2);
      setSvgFontAttributes(element2, this);
      element2.setAttribute(
        "text-anchor",
        {
          center: "middle",
          left: "start",
          right: "end",
          start: "start",
          end: "end"
        }[this.textAlign ?? "start"]
      );
      element2.setAttribute("alignment-baseline", this.textBaseline);
      element2.setAttribute("x", String(this.x));
      element2.setAttribute("y", String(this.y));
      element2.textContent = this.text;
    } else {
      for (const segment of this.text) {
        const segmentElement = createSvgElement("tspan");
        setSvgFontAttributes(segmentElement, {
          fontSize: segment.fontSize ?? this.fontSize,
          fontFamily: segment.fontFamily ?? this.fontFamily,
          fontWeight: segment.fontWeight ?? this.fontWeight,
          fontStyle: segment.fontStyle ?? this.fontStyle
        });
        this.applySvgFillAttributes(segmentElement);
        segmentElement.textContent = segment.text;
        element2.append(segmentElement);
      }
    }
    return { elements: [element2] };
  }
};
_Text.className = "Text";
_Text.debug = Debug.create(true, "scene:text" /* SCENE_TEXT */);
_Text.defaultFontSize = 10;
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "y", 2);
__decorateClass([
  SceneRefChangeDetection({
    changeCb: (o) => o.onTextChange()
  })
], _Text.prototype, "text", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontStyle", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontWeight", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontSize", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontFamily", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "textAlign", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "textBaseline", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "lineHeight", 2);
var Text = _Text;
var RotatableText = class extends Rotatable(Text) {
};
var TransformableText = class extends Rotatable(Translatable(Text)) {
};

// packages/ag-charts-community/src/util/textWrapper.ts
var TextWrapper = class {
  static wrapText(text2, options) {
    return this.wrapLines(text2, options).join("\n");
  }
  static wrapLines(text2, options) {
    const clippedResult = this.textWrap(text2, options);
    if (options.overflow === "hide" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {
      return [];
    }
    return clippedResult;
  }
  static appendEllipsis(text2) {
    return text2.replace(/[.,]{1,5}$/, "") + TextUtils.EllipsisChar;
  }
  static truncateLine(text2, measurer3, maxWidth, ellipsisForce) {
    const ellipsisWidth = measurer3.textWidth(TextUtils.EllipsisChar);
    let estimatedWidth = 0;
    let i = 0;
    for (; i < text2.length; i++) {
      const charWidth = measurer3.textWidth(text2.charAt(i));
      if (estimatedWidth + charWidth > maxWidth)
        break;
      estimatedWidth += charWidth;
    }
    if (text2.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {
      return ellipsisForce ? text2 + TextUtils.EllipsisChar : text2;
    }
    text2 = text2.slice(0, i).trimEnd();
    while (text2.length && measurer3.textWidth(text2) + ellipsisWidth > maxWidth) {
      text2 = text2.slice(0, -1).trimEnd();
    }
    return text2 + TextUtils.EllipsisChar;
  }
  static textWrap(text2, options) {
    const lines = text2.split(TextUtils.lineSplitter);
    const measurer3 = CachedTextMeasurerPool.getMeasurer(options);
    if (options.textWrap === "never") {
      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer3, options.maxWidth));
    }
    const result = [];
    const wrapHyphenate = options.textWrap === "hyphenate";
    const wrapOnSpace = options.textWrap == null || options.textWrap === "on-space";
    for (const untrimmedLine of lines) {
      let line = untrimmedLine.trimEnd();
      if (line === "") {
        result.push(line);
        continue;
      }
      let i = 0;
      let estimatedWidth = 0;
      let lastSpaceIndex = 0;
      while (i < line.length) {
        const char = line.charAt(i);
        estimatedWidth += measurer3.textWidth(char);
        if (char === " ") {
          lastSpaceIndex = i;
        }
        if (estimatedWidth > options.maxWidth) {
          if (i === 0)
            break;
          const actualWidth = measurer3.textWidth(line.slice(0, i + 1));
          if (actualWidth <= options.maxWidth) {
            estimatedWidth = actualWidth;
            i++;
            continue;
          }
          if (lastSpaceIndex) {
            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);
            const textWidth = measurer3.textWidth(nextWord);
            if (textWidth <= options.maxWidth) {
              result.push(line.slice(0, lastSpaceIndex).trimEnd());
              line = line.slice(lastSpaceIndex).trimStart();
              i = 0;
              estimatedWidth = 0;
              lastSpaceIndex = 0;
              continue;
            } else if (wrapOnSpace && textWidth > options.maxWidth) {
              result.push(
                line.slice(0, lastSpaceIndex).trimEnd(),
                this.truncateLine(
                  line.slice(lastSpaceIndex).trimStart(),
                  measurer3,
                  options.maxWidth,
                  true
                )
              );
            }
          } else if (wrapOnSpace) {
            result.push(this.truncateLine(line, measurer3, options.maxWidth, true));
          }
          if (wrapOnSpace) {
            line = "";
            break;
          }
          const postfix = wrapHyphenate ? "-" : "";
          let newLine = line.slice(0, i).trim();
          while (newLine.length && measurer3.textWidth(newLine + postfix) > options.maxWidth) {
            newLine = newLine.slice(0, -1).trimEnd();
          }
          result.push(newLine + postfix);
          if (!newLine.length) {
            line = "";
            break;
          }
          line = line.slice(newLine.length).trimStart();
          i = -1;
          estimatedWidth = 0;
          lastSpaceIndex = 0;
        }
        i++;
      }
      if (line) {
        result.push(line);
      }
    }
    this.avoidOrphans(result, measurer3, options);
    return this.clipLines(result, measurer3, options);
  }
  static getWordAt(text2, position) {
    const nextSpaceIndex = text2.indexOf(" ", position);
    return nextSpaceIndex === -1 ? text2.slice(position) : text2.slice(position, nextSpaceIndex);
  }
  static clipLines(lines, measurer3, options) {
    if (!options.maxHeight) {
      return lines;
    }
    const { height: height2, lineMetrics } = measurer3.measureLines(lines);
    if (height2 <= options.maxHeight) {
      return lines;
    }
    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {
      const { lineHeight } = lineMetrics[i];
      cumulativeHeight += lineHeight;
      if (cumulativeHeight > options.maxHeight) {
        if (options.overflow === "hide") {
          return [];
        }
        const clippedResults = lines.slice(0, i || 1);
        const lastLine = clippedResults.pop();
        return clippedResults.concat(this.truncateLine(lastLine, measurer3, options.maxWidth, true));
      }
    }
    return lines;
  }
  static avoidOrphans(lines, measurer3, options) {
    if (options.avoidOrphans === false || lines.length < 2)
      return;
    const { length: length2 } = lines;
    const lastLine = lines[length2 - 1];
    const beforeLast = lines[length2 - 2];
    if (beforeLast.length < lastLine.length)
      return;
    const lastSpaceIndex = beforeLast.lastIndexOf(" ");
    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(" ") || lastLine.includes(" "))
      return;
    const lastWord = beforeLast.slice(lastSpaceIndex + 1);
    if (measurer3.textWidth(lastLine + lastWord) <= options.maxWidth) {
      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);
      lines[length2 - 1] = lastWord + " " + lastLine;
    }
  }
};

// packages/ag-charts-community/src/chart/themes/constants.ts
var constants_exports = {};
__export(constants_exports, {
  BASE_FONT_SIZE: () => BASE_FONT_SIZE,
  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,
  CARTESIAN_POSITION: () => CARTESIAN_POSITION,
  FONT_SIZE: () => FONT_SIZE,
  FONT_SIZE_RATIO: () => FONT_SIZE_RATIO,
  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,
  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE
});
var FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE3) => {
  FONT_SIZE3[FONT_SIZE3["SMALLEST"] = 8] = "SMALLEST";
  FONT_SIZE3[FONT_SIZE3["SMALLER"] = 10] = "SMALLER";
  FONT_SIZE3[FONT_SIZE3["SMALL"] = 12] = "SMALL";
  FONT_SIZE3[FONT_SIZE3["MEDIUM"] = 13] = "MEDIUM";
  FONT_SIZE3[FONT_SIZE3["LARGE"] = 14] = "LARGE";
  FONT_SIZE3[FONT_SIZE3["LARGEST"] = 17] = "LARGEST";
  return FONT_SIZE3;
})(FONT_SIZE || {});
var BASE_FONT_SIZE = 12 /* SMALL */;
var FONT_SIZE_RATIO = ((FONT_SIZE_RATIO5) => {
  FONT_SIZE_RATIO5[FONT_SIZE_RATIO5["SMALLEST"] = 8 /* SMALLEST */ / BASE_FONT_SIZE] = "SMALLEST";
  FONT_SIZE_RATIO5[FONT_SIZE_RATIO5["SMALLER"] = 10 /* SMALLER */ / BASE_FONT_SIZE] = "SMALLER";
  FONT_SIZE_RATIO5[FONT_SIZE_RATIO5["SMALL"] = 12 /* SMALL */ / BASE_FONT_SIZE] = "SMALL";
  FONT_SIZE_RATIO5[FONT_SIZE_RATIO5["MEDIUM"] = 13 /* MEDIUM */ / BASE_FONT_SIZE] = "MEDIUM";
  FONT_SIZE_RATIO5[FONT_SIZE_RATIO5["LARGE"] = 14 /* LARGE */ / BASE_FONT_SIZE] = "LARGE";
  FONT_SIZE_RATIO5[FONT_SIZE_RATIO5["LARGEST"] = 17 /* LARGEST */ / BASE_FONT_SIZE] = "LARGEST";
  return FONT_SIZE_RATIO5;
})(FONT_SIZE_RATIO || {});
var CARTESIAN_POSITION = /* @__PURE__ */ ((CARTESIAN_POSITION6) => {
  CARTESIAN_POSITION6["TOP"] = "top";
  CARTESIAN_POSITION6["TOP_RIGHT"] = "top-right";
  CARTESIAN_POSITION6["TOP_LEFT"] = "top-left";
  CARTESIAN_POSITION6["RIGHT"] = "right";
  CARTESIAN_POSITION6["RIGHT_TOP"] = "right-top";
  CARTESIAN_POSITION6["RIGHT_BOTTOM"] = "right-bottom";
  CARTESIAN_POSITION6["BOTTOM"] = "bottom";
  CARTESIAN_POSITION6["BOTTOM_RIGHT"] = "bottom-right";
  CARTESIAN_POSITION6["BOTTOM_LEFT"] = "bottom-left";
  CARTESIAN_POSITION6["LEFT"] = "left";
  CARTESIAN_POSITION6["LEFT_TOP"] = "left-top";
  CARTESIAN_POSITION6["LEFT_BOTTOM"] = "left-bottom";
  return CARTESIAN_POSITION6;
})(CARTESIAN_POSITION || {});
var CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE9) => {
  CARTESIAN_AXIS_TYPE9["CATEGORY"] = "category";
  CARTESIAN_AXIS_TYPE9["GROUPED_CATEGORY"] = "grouped-category";
  CARTESIAN_AXIS_TYPE9["ORDINAL_TIME"] = "ordinal-time";
  CARTESIAN_AXIS_TYPE9["UNIT_TIME"] = "unit-time";
  CARTESIAN_AXIS_TYPE9["TIME"] = "time";
  CARTESIAN_AXIS_TYPE9["NUMBER"] = "number";
  CARTESIAN_AXIS_TYPE9["LOG"] = "log";
  return CARTESIAN_AXIS_TYPE9;
})(CARTESIAN_AXIS_TYPE || {});
var POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE10) => {
  POLAR_AXIS_TYPE10["ANGLE_CATEGORY"] = "angle-category";
  POLAR_AXIS_TYPE10["ANGLE_NUMBER"] = "angle-number";
  POLAR_AXIS_TYPE10["RADIUS_CATEGORY"] = "radius-category";
  POLAR_AXIS_TYPE10["RADIUS_NUMBER"] = "radius-number";
  return POLAR_AXIS_TYPE10;
})(POLAR_AXIS_TYPE || {});
var POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE3) => {
  POLAR_AXIS_SHAPE3["CIRCLE"] = "circle";
  POLAR_AXIS_SHAPE3["POLYGON"] = "polygon";
  return POLAR_AXIS_SHAPE3;
})(POLAR_AXIS_SHAPE || {});

// packages/ag-charts-community/src/chart/caption.ts
var Caption = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.id = createId(this);
    this.node = new RotatableText({ zIndex: 1 }).setProperties({
      textAlign: "center",
      pointerEvents: 1 /* None */
    });
    this.enabled = false;
    this.textAlign = "center";
    this.fontSize = 10 /* SMALLER */;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
    this.padding = 0;
    this.layoutStyle = "block";
    this.truncated = false;
  }
  registerInteraction(moduleCtx, where) {
    return moduleCtx.eventsHub.on("layout:complete", () => this.updateA11yText(moduleCtx, where));
  }
  computeTextWrap(containerWidth, containerHeight) {
    const { text: text2, padding: padding2, wrapping } = this;
    if (isArray(text2))
      return;
    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding2 * 2;
    const maxHeight = this.maxHeight ?? containerHeight - padding2 * 2;
    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
      this.node.text = text2;
      return;
    }
    const wrappedText = TextWrapper.wrapText(text2 ?? "", { maxWidth, maxHeight, font: this, textWrap: wrapping });
    this.node.text = wrappedText;
    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);
  }
  updateA11yText(moduleCtx, where) {
    const { proxyInteractionService } = moduleCtx;
    if (this.enabled && this.text) {
      const bbox = Transformable.toCanvas(this.node);
      if (bbox) {
        const { id: domManagerId } = this;
        this.proxyText ?? (this.proxyText = proxyInteractionService.createProxyElement({ type: "text", domManagerId, where }));
        this.proxyText.textContent = toPlainText(this.text);
        this.proxyText.setBounds(bbox);
        this.proxyText.addListener("mousemove", (ev) => this.handleMouseMove(moduleCtx, ev));
        this.proxyText.addListener("mouseleave", (ev) => this.handleMouseLeave(moduleCtx, ev));
      }
    } else {
      this.proxyText?.destroy();
      this.proxyText = void 0;
    }
  }
  handleMouseMove(moduleCtx, event) {
    if (event != null && this.enabled && this.truncated) {
      const { x, y } = Transformable.toCanvas(this.node);
      const canvasX = event.sourceEvent.offsetX + x;
      const canvasY = event.sourceEvent.offsetY + y;
      moduleCtx.tooltipManager.updateTooltip(this.id, { canvasX, canvasY, showArrow: false }, [
        { type: "structured", title: toPlainText(this.text) }
      ]);
    }
  }
  handleMouseLeave(moduleCtx, _event) {
    moduleCtx.tooltipManager.removeTooltip(this.id);
  }
};
Caption.SMALL_PADDING = 10;
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "visible")
], Caption.prototype, "enabled", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "text", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "textAlign", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontStyle", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontWeight", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontSize", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontFamily", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "fill")
], Caption.prototype, "color", 2);
__decorateClass([
  Property
], Caption.prototype, "spacing", 2);
__decorateClass([
  Property
], Caption.prototype, "maxWidth", 2);
__decorateClass([
  Property
], Caption.prototype, "maxHeight", 2);
__decorateClass([
  Property
], Caption.prototype, "wrapping", 2);
__decorateClass([
  Property
], Caption.prototype, "padding", 2);
__decorateClass([
  Property
], Caption.prototype, "layoutStyle", 2);

// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection32) => {
  ChartAxisDirection32["X"] = "x";
  ChartAxisDirection32["Y"] = "y";
  ChartAxisDirection32["Angle"] = "angle";
  ChartAxisDirection32["Radius"] = "radius";
  return ChartAxisDirection32;
})(ChartAxisDirection || {});
function isChartAxisDirection(d) {
  switch (d) {
    case "x":
    case "y":
    case "angle":
    case "radius":
      return true;
    default:
      return false;
  }
}

// packages/ag-charts-community/src/chart/chartCaptions.ts
var ChartCaptions = class {
  constructor() {
    this.title = new Caption();
    this.subtitle = new Caption();
    this.footnote = new Caption();
  }
  positionCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const maxHeight = ctx.layoutBox.height / 10;
    if (title.enabled) {
      this.positionCaption("top", title, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", title, ctx.layoutBox);
    }
    if (subtitle.enabled) {
      this.positionCaption("top", subtitle, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", subtitle, ctx.layoutBox);
    }
    if (footnote.enabled) {
      this.positionCaption("bottom", footnote, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("bottom", footnote, ctx.layoutBox);
    }
  }
  positionAbsoluteCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const { rect } = ctx.series;
    for (const caption of [title, subtitle, footnote]) {
      if (caption.layoutStyle !== "overlay")
        continue;
      if (caption.textAlign === "left") {
        caption.node.x = rect.x + caption.padding;
      } else if (caption.textAlign === "right") {
        const bbox = caption.node.getBBox();
        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;
      }
    }
  }
  computeX(align2, layoutBox) {
    if (align2 === "left") {
      return layoutBox.x;
    } else if (align2 === "right") {
      return layoutBox.x + layoutBox.width;
    }
    return layoutBox.x + layoutBox.width / 2;
  }
  positionCaption(vAlign, caption, layoutBox, maxHeight) {
    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);
    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;
    caption.node.y = layoutBox.y + (vAlign === "top" ? 0 : layoutBox.height) + caption.padding;
    caption.node.textBaseline = vAlign;
    caption.computeTextWrap(layoutBox.width, containerHeight);
  }
  shrinkLayoutByCaption(vAlign, caption, layoutBox) {
    if (caption.layoutStyle === "block") {
      const bbox = caption.node.getBBox();
      const { spacing = 0 } = caption;
      if (vAlign === "bottom" && isArray(caption.text)) {
        caption.node.y -= bbox.height;
        bbox.y -= bbox.height;
      }
      layoutBox.shrink(
        vAlign === "top" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),
        vAlign
      );
    }
  }
};
__decorateClass([
  Property
], ChartCaptions.prototype, "title", 2);
__decorateClass([
  Property
], ChartCaptions.prototype, "subtitle", 2);
__decorateClass([
  Property
], ChartCaptions.prototype, "footnote", 2);

// packages/ag-charts-community/src/api/preset/chartTypeOriginator.ts
var chartTypes = [
  "candlestick",
  "hollow-candlestick",
  "ohlc",
  "line",
  "step-line",
  "hlc",
  "high-low"
];
var ChartTypeOriginator = class {
  constructor(chartService) {
    this.chartService = chartService;
    this.mementoOriginatorKey = "chartType";
  }
  createMemento() {
    let chartType = this.chartService.publicApi?.getOptions()?.chartType;
    chartType ?? (chartType = "candlestick");
    return chartType;
  }
  guardMemento(blob) {
    return blob == null || chartTypes.includes(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    if (memento == null)
      return;
    const options = { chartType: memento };
    this.chartService.publicApi?.updateDelta(options).catch((e) => logger_exports.error("error restoring state", e));
  }
};

// packages/ag-charts-community/src/version.ts
var VERSION = "12.1.2";

// packages/ag-charts-community/src/api/state/historyManager.ts
var NOT_FOUND = Symbol("previous-memento-not-found");
var HistoryManager = class {
  constructor(eventsHub) {
    this.history = [];
    this.historyIndex = -1;
    this.originators = /* @__PURE__ */ new Map();
    this.clearState = /* @__PURE__ */ new Map();
    this.maxHistoryLength = 100;
    this.debug = Debug.create(true, "history");
    this.cleanup = new CleanupRegistry();
    this.cleanup.register(
      eventsHub.on("series:undo", this.undo.bind(this)),
      eventsHub.on("series:redo", this.redo.bind(this))
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  addMementoOriginator(originator) {
    this.originators.set(originator.mementoOriginatorKey, originator);
    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());
    this.debugEvent("History add originator:", originator.mementoOriginatorKey);
  }
  clear() {
    this.debug(`History clear:`, Object.keys(this.originators));
    this.history = [];
    this.historyIndex = -1;
    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {
      this.clearState.set(mementoOriginatorKey, originator.createMemento());
    }
  }
  record(label, ...originators) {
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }
    if (this.history.length > this.maxHistoryLength) {
      this.history = this.history.slice(-this.maxHistoryLength);
    }
    const mementos = /* @__PURE__ */ new Map();
    for (const originator of originators) {
      if (!this.originators.has(originator.mementoOriginatorKey)) {
        throw new Error(
          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`
        );
      }
      mementos.set(originator.mementoOriginatorKey, originator.createMemento());
    }
    this.history.push({ label, mementos });
    this.historyIndex = this.history.length - 1;
    this.debugEvent(`History record: [${label}]`);
  }
  undo() {
    const undoAction = this.history[this.historyIndex];
    if (!undoAction)
      return;
    for (const mementoOriginatorKey of undoAction.mementos.keys()) {
      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);
      if (previousMemento === NOT_FOUND) {
        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);
      }
      this.restoreMemento(mementoOriginatorKey, previousMemento);
    }
    this.historyIndex -= 1;
    this.debugEvent(`History undo: [${undoAction.label}]`);
  }
  redo() {
    const redoAction = this.history[this.historyIndex + 1];
    if (!redoAction)
      return;
    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {
      this.restoreMemento(mementoOriginatorKey, memento);
    }
    this.historyIndex += 1;
    this.debugEvent(`History redo: [${redoAction.label}]`);
  }
  findPreviousMemento(mementoOriginatorKey) {
    for (let i = this.historyIndex - 1; i >= 0; i--) {
      if (this.history[i].mementos.has(mementoOriginatorKey)) {
        return this.history[i].mementos.get(mementoOriginatorKey);
      }
    }
    if (this.clearState.has(mementoOriginatorKey)) {
      return this.clearState.get(mementoOriginatorKey);
    }
    return NOT_FOUND;
  }
  restoreMemento(mementoOriginatorKey, memento) {
    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);
  }
  debugEvent(...logContent) {
    this.debug(
      ...logContent,
      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)
    );
  }
};

// packages/ag-charts-community/src/api/state/memento.ts
var MementoCaretaker = class _MementoCaretaker {
  constructor(version) {
    this.version = version.split("-")[0];
  }
  save(...originators) {
    const packet = { version: this.version };
    for (const originator of Object.values(originators)) {
      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());
    }
    return packet;
  }
  restore(blob, ...originators) {
    if (typeof blob !== "object") {
      logger_exports.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);
      return;
    }
    if (blob == null) {
      logger_exports.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);
      return;
    }
    if (!("version" in blob) || typeof blob.version !== "string") {
      logger_exports.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);
      return;
    }
    for (const originator of originators) {
      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);
      const messages = [];
      if (!originator.guardMemento(memento, messages)) {
        const messagesString = messages.length > 0 ? `

${messages.join("\n\n")}

` : "";
        logger_exports.warnOnce(
          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.${messagesString}`,
          memento
        );
        return;
      }
      originator.restoreMemento(this.version, blob.version, memento);
    }
  }
  /**
   * Encode a memento as a serializable object, encoding any non-serializble types.
   */
  encode(originator, memento) {
    try {
      return JSON.parse(JSON.stringify(memento, _MementoCaretaker.encodeTypes));
    } catch (error2) {
      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error2}].`, {
        cause: error2
      });
    }
  }
  /**
   * Decode an encoded memento, decoding any non-serializable types.
   */
  decode(originator, encoded) {
    if (encoded == null)
      return encoded;
    try {
      return JSON.parse(JSON.stringify(encoded), _MementoCaretaker.decodeTypes);
    } catch (error2) {
      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error2}].`, {
        cause: error2
      });
    }
  }
  static encodeTypes(key, value) {
    if (isDate(this[key])) {
      return { __type: "date", value: this[key].toISOString() };
    }
    return value;
  }
  static decodeTypes(key, value) {
    if (isObject(this[key]) && "__type" in this[key] && this[key].__type === "date") {
      return new Date(this[key].value);
    }
    return value;
  }
};

// packages/ag-charts-community/src/api/state/stateManager.ts
var StateManager = class {
  constructor() {
    this.caretaker = new MementoCaretaker(VERSION);
    this.state = /* @__PURE__ */ new Map();
  }
  setState(originator, value) {
    if (objectsEqual(this.state.get(originator.mementoOriginatorKey), value)) {
      return;
    }
    this.setStateAndRestore(originator, value);
  }
  setStateAndRestore(originator, value) {
    this.state.set(originator.mementoOriginatorKey, value);
    this.restoreState(originator);
  }
  restoreState(originator) {
    const { caretaker, state } = this;
    if (!state.has(originator.mementoOriginatorKey))
      return;
    const value = state.get(originator.mementoOriginatorKey);
    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);
  }
};

// packages/ag-charts-community/src/styles.css
var styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box}.ag-charts-wrapper{--align-items: center;--justify-content: center;position:relative;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ag-charts-wrapper--safe-horizontal{--justify-content: flex-start}.ag-charts-wrapper--safe-vertical{--align-items: flex-start}.ag-charts-tab-guard{width:0%;height:0%;position:absolute;pointer-events:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;pointer-events:auto;display:flex;align-items:var(--align-items);justify-content:var(--justify-content)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none;-webkit-user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{pointer-events:none}.ag-charts-canvas canvas{display:block}.ag-charts-series-area{outline:none;pointer-events:auto;position:absolute}.ag-charts-swapchain{top:0;left:0;outline:none;opacity:0;pointer-events:none;position:absolute;width:100%;height:100%}.ag-charts-swapchain:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none;-webkit-user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-accent-color: #2196f3;--ag-charts-background-color: #fff;--ag-charts-border-color: #dddddd;--ag-charts-border-radius: 4px;--ag-charts-chart-background-color: #fff;--ag-charts-chart-padding: 20px;--ag-charts-focus-shadow: 0 0 0 3px #2196f3;--ag-charts-foreground-color: #181d1f;--ag-charts-font-family: Verdana, sans-serif;--ag-charts-font-size: 12px;--ag-charts-font-weight: 400;--ag-charts-popup-shadow: 0 0 16px rgba(0, 0, 0, .15);--ag-charts-subtle-text-color: #8c8c8c;--ag-charts-text-color: #181d1f;--ag-charts-chrome-background-color: #fafafa;--ag-charts-chrome-font-family: Verdana, sans-serif;--ag-charts-chrome-font-size: 12px;--ag-charts-chrome-font-weight: 400;--ag-charts-chrome-subtle-text-color: #8c8c8c;--ag-charts-chrome-text-color: #181d1f;--ag-charts-button-background-color: #fff;--ag-charts-button-border: 1px solid #dddddd;--ag-charts-button-font-weight: normal;--ag-charts-button-text-color: inherit;--ag-charts-input-background-color: #fff;--ag-charts-input-border: 1px solid #dddddd;--ag-charts-input-text-color: #181d1f;--ag-charts-menu-background-color: #fafafa;--ag-charts-menu-border: 1px solid #dddddd;--ag-charts-menu-text-color: #181d1f;--ag-charts-panel-background-color: #fafafa;--ag-charts-panel-text-color: #181d1f;--ag-charts-tooltip-background-color: #fafafa;--ag-charts-tooltip-border: 1px solid #dddddd;--ag-charts-tooltip-text-color: #181d1f;--ag-charts-tooltip-subtle-text-color: #8c8c8c;--ag-charts-crosshair-label-background-color: #fafafa;--ag-charts-crosshair-label-text-color: #181d1f;--ag-charts-spacing: 4px;--ag-charts-icon-size: 16px;--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 12%);--ag-charts-input-border-radius: var(--ag-charts-border-radius);--ag-charts-input-focus-border-color: var(--ag-charts-accent-color);--ag-charts-input-focus-text-color: var(--ag-charts-accent-color);--ag-charts-input-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-input-disabled-border-color: var(--ag-charts-border-color);--ag-charts-input-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-input-text-color) 50% );--ag-charts-input-placeholder-text-color: color-mix( in srgb, var(--ag-charts-input-background-color), var(--ag-charts-input-text-color) 60% );--ag-charts-button-border-radius: var(--ag-charts-border-radius);--ag-charts-button-focus-background-color: color-mix( in srgb, var(--ag-charts-button-background-color), var(--ag-charts-accent-color) 12% );--ag-charts-button-focus-border-color: var(--ag-charts-accent-color);--ag-charts-button-focus-text-color: var(--ag-charts-accent-color);--ag-charts-button-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-button-disabled-border-color: var(--ag-charts-border-color);--ag-charts-button-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-chrome-text-color) 50% );--ag-charts-checkbox-background-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 35% );--ag-charts-checkbox-checked-background-color: var(--ag-charts-accent-color);--ag-charts-tooltip-border-radius: var(--ag-charts-border-radius);--ag-charts-menu-border-radius: var(--ag-charts-border-radius);--ag-charts-chrome-font-size-small: var(--ag-charts-chrome-font-size);--ag-charts-chrome-font-size-medium: calc(var(--ag-charts-chrome-font-size) * (13 / 12));--ag-charts-chrome-font-size-large: calc(var(--ag-charts-chrome-font-size) * (14 / 12));--ag-charts-border: 1px solid var(--ag-charts-border-color);--ag-charts-focus-border: 1px solid var(--ag-charts-accent-color);--ag-charts-focus-border-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%);--ag-charts-layer-menu: 6;--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1}.ag-charts-theme-default-dark{--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 22%)}.ag-chart-canvas-wrapper .ag-charts-theme-default{--ag-charts-border-radius: var(--ag-border-radius, 4px);--ag-charts-border: var(--ag-borders-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-focus-shadow: var(--ag-focus-shadow, 0 0 0 3px var(--ag-charts-accent-color));--ag-charts-focus-border-shadow: var( --ag-focus-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%) )}.ag-charts-icon{display:block;width:20px;height:20px;speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA1aDEydjFIMnoiLz48Y2lyY2xlIGN4PSIxNS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4yNSIgY3k9IjE0LjUiIHI9IjEuNzUiIHN0cm9rZT0iIzAwMCIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0xOCAxNUg2di0xaDEyem0wLTQuNUgydi0xaDE2eiIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-trend-based-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJtNC45OTYgMTIuNjc0IDMuMjkxLTUuNzQzLjg2OC40OTctMy4yOTEgNS43NDN6Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4zNTEiIGN5PSIxNC41IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTggNmgtN1Y1aDd6bTAgNC41aC03di0xaDd6bTAgNC41SDZ2LTFoMTJ6Ii8+PC9zdmc+)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-chevron-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjQ3IDUuNDdhLjc1Ljc1IDAgMCAxIDEuMDYgMGw0IDRhLjc1Ljc1IDAgMCAxIDAgMS4wNmwtNCA0YS43NS43NSAwIDAgMS0xLjA2LTEuMDZMMTAuOTQgMTAgNy40NyA2LjUzYS43NS43NSAwIDAgMSAwLTEuMDYiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;--input-padding: calc(var(--ag-charts-spacing) * 2);--input-padding-large: calc(var(--ag-charts-spacing) * 2.5);color:var(--ag-charts-input-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);transition-duration:.25s;transition-property:none;transition-timing-function:ease-out}.ag-charts-input:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-button-background-color);border:var(--ag-charts-button-border);border-radius:var(--ag-charts-button-border-radius);color:var(--ag-charts-button-text-color);cursor:pointer;padding:var(--input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-focus-color)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{--checkbox-transition-duration: .1s;appearance:none;background:var(--ag-charts-checkbox-background-color);border-radius:calc(var(--ag-charts-border-radius) * 9);cursor:pointer;height:18px;margin:0;transition-duration:var(--checkbox-transition-duration);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:calc(var(--ag-charts-border-radius) * 7);content:" ";height:14px;margin:2px;transition-duration:var(--checkbox-transition-duration);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-checkbox-checked-background-color)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:var(--ag-charts-input-border);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--textarea-line-height: 1.38;background:var(--ag-charts-input-background-color);border:var(--ag-charts-input-border);border-radius:var(--ag-charts-input-border-radius);line-height:var(--textarea-line-height);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);padding:var(--input-padding-large) var(--input-padding)}.ag-charts-textarea::placeholder{color:var(--ag-charts-input-placeholder-text-color)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-legend-toolbar{pointer-events:auto}.ag-charts-proxy-legend-toolbar>div[role=listitem]{pointer-events:none}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:auto;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;-webkit-user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:solid 1px var(--ag-charts-chrome-background-color);box-shadow:var(--ag-charts-focus-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;overflow:visible}.ag-charts-focus-svg-outer-path{stroke:var(--ag-charts-chrome-background-color);stroke-width:4px}.ag-charts-focus-svg-inner-path{stroke:var(--ag-charts-accent-color);stroke-width:2px}.ag-charts-overlay{color:#181d1f;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay{color:#fff}.ag-charts-overlay--loading{color:#8c8c8c}.ag-charts-overlay__loading-background{background:#fff;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay .ag-charts-overlay__loading-background{background:#192232}.ag-charts-tooltip{--tooltip-arrow-size: 8px;--tooltip-row-spacing: 8px;--tooltip-column-spacing: 16px;position:fixed;inset:unset;margin:0;padding:0;overflow:visible;top:var(--top, 0px);left:var(--left, 0px);width:max-content;max-width:100%;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);color:var(--ag-charts-tooltip-text-color);background:var(--ag-charts-tooltip-background-color);border:var(--ag-charts-tooltip-border);border-radius:var(--ag-charts-tooltip-border-radius);box-shadow:var(--ag-charts-popup-shadow)}.ag-charts-tooltip--compact .ag-charts-tooltip-content{--tooltip-row-spacing: 2px;--tooltip-column-spacing: 8px;padding:3px 6px}.ag-charts-tooltip--arrow-top:before,.ag-charts-tooltip--arrow-right:before,.ag-charts-tooltip--arrow-bottom:before,.ag-charts-tooltip--arrow-left:before{content:"";position:absolute;display:block;width:var(--tooltip-arrow-size);height:var(--tooltip-arrow-size);border:inherit;border-bottom-color:transparent;border-right-color:transparent;background:inherit;clip-path:polygon(0 0,100% 0,100% 1px,1px 100%,0 100%)}.ag-charts-tooltip--arrow-top:before{bottom:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * .5)) rotate(45deg)}.ag-charts-tooltip--arrow-bottom:before{top:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * -.5)) rotate(225deg)}.ag-charts-tooltip--arrow-left:before{right:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * .5)) rotate(315deg)}.ag-charts-tooltip--arrow-right:before{left:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * -.5)) rotate(135deg)}.ag-charts-tooltip--no-interaction{pointer-events:none;user-select:none;-webkit-user-select:none}.ag-charts-tooltip--wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-charts-tooltip--wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-charts-tooltip--wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-charts-tooltip--wrap-never{white-space:nowrap}.ag-charts-tooltip-heading,.ag-charts-tooltip-title,.ag-charts-tooltip-label,.ag-charts-tooltip-value{overflow:hidden;text-overflow:ellipsis}.ag-charts-tooltip-content{display:grid;grid:auto-flow minmax(1em,auto) / 1fr;padding:8px 12px;gap:var(--tooltip-row-spacing)}.ag-charts-tooltip-content:has(.ag-charts-tooltip-symbol){grid:auto-flow minmax(1em,auto) / auto 1fr}.ag-charts-tooltip-heading{grid-column:1 / -1}.ag-charts-tooltip-symbol{grid-column:1 / 2;place-self:center}.ag-charts-tooltip-symbol svg{display:block}.ag-charts-tooltip-title{grid-column:-2 / -1}.ag-charts-tooltip-row{grid-column:1 / -1;display:flex;gap:var(--tooltip-column-spacing);align-items:baseline;justify-content:space-between;overflow:hidden}.ag-charts-tooltip-row--inline{grid-column:-2 / -1}.ag-charts-tooltip-label{flex:1;min-width:0}.ag-charts-tooltip-value{min-width:0}.ag-charts-tooltip-footer{grid-column:1 / -1;color:var(--ag-charts-tooltip-subtle-text-color);text-align:center}.ag-charts-popover{position:absolute;border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);background:var(--ag-charts-panel-background-color);color:var(--ag-charts-chrome-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);box-shadow:var(--ag-charts-popup-shadow);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-menu{--item-padding: 6px 12px;--icon-color: var(--ag-charts-menu-text-color);display:grid;grid:auto-flow auto / 1fr;column-gap:12px;font-size:var(--ag-charts-chrome-font-size)}.ag-charts-menu:has(.ag-charts-menu__icon,.ag-charts-menu__row--stroke-width-visible){grid:auto-flow auto / auto 1fr}.ag-charts-menu__row--stroke-width-visible:before{content:"";height:var(--strokeWidth);width:12px;background:var(--icon-color)}.ag-charts-menu__row--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-menu__row{display:grid;grid-column:1 / -1;grid-template-columns:subgrid;align-items:center;padding:var(--item-padding)}.ag-charts-menu__row:not(.ag-charts-menu__row--active){cursor:pointer}.ag-charts-menu__row:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.ag-charts-menu__row:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.ag-charts-menu__row:focus{background:var(--ag-charts-focus-color)}.ag-charts-menu__row:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--ag-charts-layer-menu)}.ag-charts-menu__row--active{--icon-color: var(--ag-charts-accent-color);background:var(--ag-charts-focus-color);color:var(--ag-charts-accent-color)}.ag-charts-menu__label{grid-column:-1 / span 1}.ag-charts-toolbar{--toolbar-gap: calc(var(--ag-charts-spacing) * 2);--toolbar-size: 34px;--toolbar-button-padding: 6px;align-items:center;display:flex;flex-wrap:nowrap;position:absolute}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-button-border);color:var(--ag-charts-button-text-color);cursor:pointer;display:flex;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-medium);font-weight:var(--ag-charts-chrome-font-weight);justify-content:center;min-height:var(--toolbar-size);min-width:var(--toolbar-size);padding:var(--toolbar-button-padding);position:relative;transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out;white-space:nowrap}.ag-charts-toolbar__button:hover{background:var(--ag-charts-focus-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button--active{background:var(--ag-charts-focus-color);border-color:var(--ag-charts-accent-color);color:var(--ag-charts-accent-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-button-disabled-background-color);color:var(--ag-charts-button-disabled-text-color);cursor:default}.ag-charts-toolbar--horizontal{flex-direction:row;.ag-charts-toolbar__button{margin:0 0 0 -1px}.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar--vertical{flex-direction:column;.ag-charts-toolbar__button{margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-border-radius);border-bottom-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-charts-floating-toolbar{border:none;display:flex;.ag-charts-toolbar{align-items:unset;position:unset}}.ag-charts-floating-toolbar__drag-handle{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);cursor:grab;display:flex;justify-content:center;min-width:24px;padding-left:0;padding-right:0}.ag-charts-floating-toolbar__drag-handle--dragging{cursor:grabbing}\n';

// packages/ag-charts-community/src/util/baseManager.ts
var BaseManager = class {
  constructor() {
    this.cleanup = new CleanupRegistry();
    this.destroyed = false;
  }
  destroy() {
    this.cleanup.flush();
    this.destroyed = true;
  }
};

// packages/ag-charts-community/src/util/guardedElement.ts
var GuardedElement = class _GuardedElement {
  constructor(element2, topTabGuard, bottomTabGuard) {
    this.element = element2;
    this.topTabGuard = topTabGuard;
    this.bottomTabGuard = bottomTabGuard;
    this.cleanup = new CleanupRegistry();
    this.guardTabIndex = 0;
    this.hasFocus = false;
    this.initTabGuard(this.topTabGuard, false);
    this.initTabGuard(this.bottomTabGuard, true);
    this.element.addEventListener("focus", () => this.onFocus(), { capture: true });
    this.element.addEventListener("blur", (ev) => this.onBlur(ev), { capture: true });
  }
  set tabIndex(index) {
    this.guardTabIndex = index;
    if (this.guardTabIndex === 0) {
      this.setGuardIndices(void 0);
    } else if (!this.hasFocus) {
      this.setGuardIndices(this.guardTabIndex);
    }
  }
  destroy() {
    this.cleanup.flush();
  }
  initTabGuard(guard, reverse) {
    this.cleanup.register(attachListener(guard, "focus", () => this.onTab(guard, reverse)));
  }
  setGuardIndices(index) {
    const tabindex = index;
    setAttribute(this.topTabGuard, "tabindex", tabindex);
    setAttribute(this.bottomTabGuard, "tabindex", tabindex);
  }
  onFocus() {
    this.hasFocus = true;
    if (this.guardTabIndex !== 0) {
      this.setGuardIndices(0);
    }
  }
  onBlur({ relatedTarget }) {
    const { topTabGuard: top, bottomTabGuard: bot } = this;
    this.hasFocus = false;
    if (this.guardTabIndex !== 0 && relatedTarget !== top && relatedTarget !== bot) {
      this.setGuardIndices(this.guardTabIndex);
    }
  }
  onTab(guard, reverse) {
    if (this.guardTabIndex !== 0) {
      let focusTarget;
      if (guard.tabIndex === 0) {
        focusTarget = this.findExitTarget(!reverse);
        this.setGuardIndices(this.guardTabIndex);
      } else {
        focusTarget = this.findEnterTarget(reverse);
      }
      focusTarget?.focus();
    }
  }
  static queryFocusable(element2, selectors) {
    const myWindow = getWindow();
    return Array.from(element2.querySelectorAll(selectors)).filter((e) => {
      if (e instanceof HTMLElement) {
        const style2 = myWindow.getComputedStyle(e);
        return style2.display !== "none" && style2.visibility !== "none";
      }
      return false;
    });
  }
  findEnterTarget(reverse) {
    const focusables = _GuardedElement.queryFocusable(this.element, '[tabindex="0"]');
    const index = reverse ? focusables.length - 1 : 0;
    return focusables[index];
  }
  findExitTarget(reverse) {
    const focusables = _GuardedElement.queryFocusable(getDocument(), "[tabindex]").filter((e) => e.tabIndex > 0).sort((a, b) => a.tabIndex - b.tabIndex);
    const { before, after } = _GuardedElement.findBeforeAndAfter(focusables, this.guardTabIndex);
    return reverse ? before : after;
  }
  static findBeforeAndAfter(elements, targetTabIndex) {
    let left = 0;
    let right = elements.length - 1;
    let before = void 0;
    let after = void 0;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const currentTabIndex = elements[mid].tabIndex;
      if (currentTabIndex === targetTabIndex) {
        before = elements[mid - 1] || void 0;
        after = elements[mid + 1] || void 0;
        break;
      } else if (currentTabIndex < targetTabIndex) {
        before = elements[mid];
        left = mid + 1;
      } else {
        after = elements[mid];
        right = mid - 1;
      }
    }
    return { before, after };
  }
};

// packages/ag-charts-community/src/util/keynavUtil.ts
function addEscapeEventListener(elem, onEscape, keyCodes = ["Escape"]) {
  return attachListener(elem, "keydown", (event) => {
    if (matchesKey(event, ...keyCodes)) {
      onEscape(event);
    }
  });
}
function addMouseCloseListener(menu, hideCallback) {
  const removeEvent = attachListener(getWindow(), "mousedown", (event) => {
    if ([0, 2].includes(event.button) && !containsEvent(menu, event)) {
      hideCallback();
      removeEvent();
    }
  });
  return removeEvent;
}
function addTouchCloseListener(menu, hideCallback) {
  const removeEvent = attachListener(getWindow(), "touchstart", (event) => {
    const touches = Array.from(event.targetTouches);
    if (touches.some((touch) => !containsEvent(menu, touch))) {
      hideCallback();
      removeEvent();
    }
  });
  return removeEvent;
}
function containsEvent(container, event) {
  if (event.target instanceof Element && event.target.shadowRoot != null) {
    return true;
  }
  return event.target instanceof Node && container.contains(event.target);
}
function addOverrideFocusVisibleEventListener(menu, buttons2, overrideFocusVisible) {
  const setFocusVisible = (value) => {
    for (const btn of buttons2) {
      setAttribute(btn, "data-focus-visible-override", value);
    }
  };
  setFocusVisible(overrideFocusVisible);
  return attachListener(menu, "keydown", () => setFocusVisible(true), { once: true });
}
function hasNoModifiers(event) {
  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);
}
function matchesKey(event, ...keys) {
  return hasNoModifiers(event) && keys.some((key) => event.key === key);
}
function linkTwoButtons(src, dst, key) {
  return attachListener(src, "keydown", (event) => {
    if (matchesKey(event, key)) {
      dst.focus();
    }
  });
}
var PREV_NEXT_KEYS = {
  horizontal: { nextKey: "ArrowRight", prevKey: "ArrowLeft" },
  vertical: { nextKey: "ArrowDown", prevKey: "ArrowUp" }
};
function initRovingTabIndex(opts) {
  const { orientation, buttons: buttons2, wrapAround = false, onEscape, onFocus, onBlur } = opts;
  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];
  const setTabIndices = (event) => {
    if (event.target && "tabIndex" in event.target) {
      buttons2.forEach((b) => b.tabIndex = -1);
      event.target.tabIndex = 0;
    }
  };
  const [c, m] = wrapAround ? [buttons2.length, buttons2.length] : [0, Infinity];
  const cleanup = new CleanupRegistry();
  for (let i = 0; i < buttons2.length; i++) {
    const prev = buttons2[(c + i - 1) % m];
    const curr = buttons2[i];
    const next = buttons2[(c + i + 1) % m];
    cleanup.register(
      attachListener(curr, "focus", setTabIndices),
      onFocus && attachListener(curr, "focus", onFocus),
      onBlur && attachListener(curr, "blur", onBlur),
      onEscape && addEscapeEventListener(curr, onEscape),
      prev && linkTwoButtons(curr, prev, prevKey),
      next && linkTwoButtons(curr, next, nextKey),
      attachListener(curr, "keydown", (event) => {
        if (matchesKey(event, nextKey, prevKey)) {
          event.preventDefault();
        }
      })
    );
    curr.tabIndex = i === 0 ? 0 : -1;
  }
  return cleanup;
}
var MenuCloserImp = class {
  constructor(menu, lastFocus, closeCallback) {
    this.lastFocus = lastFocus;
    this.closeCallback = closeCallback;
    this.cleanup = new CleanupRegistry();
    this.cleanup.register(
      addMouseCloseListener(menu, () => this.close(true)),
      addTouchCloseListener(menu, () => this.close(true))
    );
  }
  close(mousedown) {
    this.cleanup.flush();
    this.closeCallback();
    this.finishClosing(mousedown);
  }
  finishClosing(mousedown) {
    this.cleanup.flush();
    setAttribute(this.lastFocus, "aria-expanded", false);
    if (!mousedown) {
      this.lastFocus?.focus({ preventScroll: true });
    }
    this.lastFocus = void 0;
  }
};
function initMenuKeyNav(opts) {
  const { sourceEvent, orientation, menu, buttons: buttons2, closeCallback, overrideFocusVisible } = opts;
  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];
  const lastFocus = getLastFocus(sourceEvent);
  setAttribute(lastFocus, "aria-expanded", true);
  const menuCloser = new MenuCloserImp(menu, lastFocus, closeCallback);
  const onEscape = () => menuCloser.close();
  const { cleanup } = menuCloser;
  menu.role = "menu";
  menu.ariaOrientation = orientation;
  cleanup.merge(initRovingTabIndex({ orientation, buttons: buttons2, onEscape, wrapAround: true }));
  menu.tabIndex = -1;
  cleanup.register(
    addEscapeEventListener(menu, onEscape),
    attachListener(menu, "keydown", (ev) => {
      if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {
        ev.preventDefault();
        buttons2[0]?.focus();
      }
    })
  );
  buttons2[0]?.focus({ preventScroll: true });
  if (overrideFocusVisible !== void 0) {
    cleanup.register(addOverrideFocusVisibleEventListener(menu, buttons2, overrideFocusVisible));
  }
  return menuCloser;
}
function makeAccessibleClickListener(element2, onclick) {
  return (event) => {
    if (element2.ariaDisabled === "true") {
      return event.preventDefault();
    }
    onclick(event);
  };
}
function isButtonClickEvent(event) {
  if ("button" in event) {
    return event.button === 0;
  }
  return hasNoModifiers(event) && (event.code === "Space" || event.key === "Enter");
}
function getLastFocus(sourceEvent) {
  if (sourceEvent?.target instanceof HTMLElement && "tabindex" in sourceEvent.target.attributes) {
    return sourceEvent.target;
  }
  return void 0;
}
function stopPageScrolling(element2) {
  return attachListener(element2, "keydown", (event) => {
    if (event.defaultPrevented)
      return;
    const shouldPrevent = getAttribute(event.target, "data-preventdefault", true);
    if (shouldPrevent && matchesKey(event, "ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp")) {
      event.preventDefault();
    }
  });
}

// packages/ag-charts-community/src/util/pixelRatioObserver.ts
var PixelRatioObserver = class {
  constructor(callback2) {
    this.callback = callback2;
    this.devicePixelRatio = getWindow("devicePixelRatio") ?? 1;
    this.devicePixelRatioMediaQuery = void 0;
    this.devicePixelRatioListener = (e) => {
      if (e.matches)
        return;
      this.devicePixelRatio = getWindow("devicePixelRatio") ?? 1;
      this.unregisterDevicePixelRatioListener();
      this.registerDevicePixelRatioListener();
      this.callback(this.pixelRatio);
    };
  }
  get pixelRatio() {
    return this.devicePixelRatio;
  }
  observe() {
    this.registerDevicePixelRatioListener();
  }
  disconnect() {
    this.unregisterDevicePixelRatioListener();
  }
  unregisterDevicePixelRatioListener() {
    this.devicePixelRatioMediaQuery?.removeEventListener("change", this.devicePixelRatioListener);
    this.devicePixelRatioMediaQuery = void 0;
  }
  registerDevicePixelRatioListener() {
    const devicePixelRatioMediaQuery = getWindow("matchMedia")?.(`(resolution: ${this.pixelRatio}dppx)`);
    devicePixelRatioMediaQuery?.addEventListener("change", this.devicePixelRatioListener);
    this.devicePixelRatioMediaQuery = devicePixelRatioMediaQuery;
  }
};

// packages/ag-charts-community/src/util/sizeMonitor.ts
var SizeMonitor = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
    this.documentReady = false;
    this.queuedObserveRequests = [];
    this.onLoad = () => {
      this.documentReady = true;
      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));
      this.queuedObserveRequests = [];
      this.observeWindow();
    };
    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver((entries2) => {
        for (const {
          target,
          contentRect: { width: width2, height: height2 }
        } of entries2) {
          const entry = this.elements.get(target);
          this.checkSize(entry, target, width2, height2);
        }
      });
    }
    let animationFrame;
    this.pixelRatioObserver = new PixelRatioObserver(() => {
      clearTimeout(animationFrame);
      animationFrame = setTimeout(() => this.checkPixelRatio(), 0);
    });
    this.documentReady = getDocument("readyState") === "complete";
    if (this.documentReady) {
      this.observeWindow();
    } else {
      getWindow()?.addEventListener("load", this.onLoad);
    }
  }
  destroy() {
    getWindow()?.removeEventListener("load", this.onLoad);
    this.resizeObserver?.disconnect();
    this.resizeObserver = void 0;
    this.pixelRatioObserver?.disconnect();
    this.pixelRatioObserver = void 0;
  }
  observeWindow() {
    this.pixelRatioObserver?.observe();
  }
  checkPixelRatio() {
    const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;
    for (const [element2, entry] of this.elements) {
      if (entry.size != null && entry.size.pixelRatio !== pixelRatio) {
        const { width: width2, height: height2 } = entry.size;
        entry.size = { width: width2, height: height2, pixelRatio };
        entry.cb(entry.size, element2);
      }
    }
  }
  checkSize(entry, element2, width2, height2) {
    if (!entry)
      return;
    if (width2 !== entry.size?.width || height2 !== entry.size?.height) {
      const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;
      entry.size = { width: width2, height: height2, pixelRatio };
      entry.cb(entry.size, element2);
    }
  }
  // Only a single callback is supported.
  observe(element2, cb) {
    if (!this.documentReady) {
      this.queuedObserveRequests.push([element2, cb]);
      return;
    }
    if (this.elements.has(element2)) {
      this.removeFromQueue(element2);
    } else {
      this.resizeObserver?.observe(element2);
    }
    const entry = { cb };
    this.elements.set(element2, entry);
  }
  unobserve(element2) {
    this.resizeObserver?.unobserve(element2);
    this.elements.delete(element2);
    this.removeFromQueue(element2);
    if (!this.elements.size) {
      this.destroy();
    }
  }
  removeFromQueue(element2) {
    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);
  }
};

// packages/ag-charts-community/src/util/stateTracker.ts
var StateTracker = class extends Map {
  constructor(defaultValue, defaultState) {
    super();
    this.defaultValue = defaultValue;
    this.defaultState = defaultState;
  }
  set(key, value) {
    this.delete(key);
    if (typeof value !== "undefined") {
      super.set(key, value);
    }
    delete this.cachedState;
    delete this.cachedValue;
    return this;
  }
  stateId() {
    this.cachedState ?? (this.cachedState = Array.from(this.keys()).pop() ?? this.defaultState);
    return this.cachedState;
  }
  stateValue() {
    this.cachedValue ?? (this.cachedValue = Array.from(this.values()).pop() ?? this.defaultValue);
    return this.cachedValue;
  }
};

// packages/ag-charts-community/src/dom/domLayout.html
var domLayout_default = '<div role="presentation" class="ag-charts-wrapper ag-charts-styles" data-ag-charts><div role="presentation" class="ag-charts-canvas-center"><div role="presentation" class="ag-charts-canvas-container"><div role="presentation" class="ag-charts-canvas" aria-hidden="true"></div><div role="figure" class="ag-charts-canvas-proxy"><div role="presentation" class="ag-charts-series-area"></div></div><div role="presentation" class="ag-charts-canvas-overlay ag-charts-tooltip-container"></div></div></div></div>';

// packages/ag-charts-community/src/dom/domManager.ts
var DOM_ELEMENT_CLASSES = [
  "styles",
  "canvas",
  "canvas-center",
  "canvas-container",
  "canvas-overlay",
  "canvas-proxy",
  "series-area",
  "tooltip-container"
];
var MINIMAL_DOM_ELEMENT_ROLES = /* @__PURE__ */ new Set(["styles", "canvas-container", "canvas", "tooltip-container"]);
var CONTAINER_MODIFIERS = {
  safeHorizontal: "ag-charts-wrapper--safe-horizontal",
  safeVertical: "ag-charts-wrapper--safe-vertical"
};
var domElementConfig = /* @__PURE__ */ new Map([
  ["styles", { childElementType: "style" }],
  ["canvas", { childElementType: "canvas" }],
  ["canvas-proxy", { childElementType: "div" }],
  ["canvas-overlay", { childElementType: "div" }],
  ["canvas-center", { childElementType: "div" }],
  ["series-area", { childElementType: "div" }],
  ["tooltip-container", { childElementType: "div" }]
]);
function setupObserver(element2, cb) {
  if (typeof IntersectionObserver === "undefined")
    return;
  const observer = new IntersectionObserver(
    (observedEntries) => {
      for (const entry of observedEntries) {
        if (entry.target === element2) {
          cb(entry.intersectionRatio);
        }
      }
    },
    { root: element2 }
  );
  observer.observe(element2);
  return observer;
}
var NULL_DOMRECT = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  toJSON() {
    return NULL_DOMRECT;
  }
};
function createTabGuardElement(guardedElem, where) {
  const div = createElement("div");
  div.className = "ag-charts-tab-guard";
  guardedElem.insertAdjacentElement(where, div);
  return div;
}
var _DOMManager = class _DOMManager extends BaseManager {
  constructor(eventsHub, chart, initialContainer, styleContainer, mode = "normal") {
    super();
    this.eventsHub = eventsHub;
    this.chart = chart;
    this.styleContainer = styleContainer;
    this.mode = mode;
    this.anchorName = `--${createId(this)}`;
    this.styles = /* @__PURE__ */ new Map();
    this.pendingContainer = void 0;
    this.container = void 0;
    this.documentRoot = void 0;
    this.initiallyConnected = void 0;
    this.containerSize = void 0;
    this.sizeMonitor = new SizeMonitor();
    this.cursorState = new StateTracker("default");
    this.minWidth = 0;
    this.minHeight = 0;
    this.element = this.initDOM();
    this.rootElements = this.initRootElements();
    this.rootElements["canvas"].element.style.setProperty("anchor-name", this.anchorName);
    let hidden = false;
    this.observer = setupObserver(this.element, (intersectionRatio) => {
      if (intersectionRatio === 0 && !hidden) {
        this.eventsHub.emit("dom:hidden", null);
      }
      hidden = intersectionRatio === 0;
    });
    this.setSizeOptions();
    this.updateContainerSize();
    this.addStyles("ag-charts-community", styles_default);
    this.setContainer(initialContainer);
    this.cleanup.register(stopPageScrolling(this.element));
    if (this.mode === "normal") {
      const guardedElement = this.rootElements["canvas-center"].element;
      if (guardedElement == null)
        throw new Error("Error initializing tab guards");
      const topGuard = createTabGuardElement(guardedElement, "beforebegin");
      const botGuard = createTabGuardElement(guardedElement, "afterend");
      this.tabGuards = new GuardedElement(guardedElement, topGuard, botGuard);
    }
  }
  initDOM() {
    if (this.mode === "normal") {
      const templateEl = createElement("div");
      templateEl.innerHTML = domLayout_default;
      return templateEl.firstChild;
    }
    const element2 = createElement("div");
    element2.role = "presentation";
    element2.dataset.agCharts = "";
    element2.classList.add("ag-charts-wrapper");
    const seriesArea = createElement("div");
    element2.appendChild(seriesArea);
    seriesArea.role = "presentation";
    seriesArea.classList.add("ag-charts-series-area");
    return element2;
  }
  initRootElements() {
    const { mode, element: element2 } = this;
    const rootElements = {};
    for (const domElement of DOM_ELEMENT_CLASSES) {
      const className = `ag-charts-${domElement}`;
      let el;
      if (mode === "normal") {
        el = element2.classList.contains(className) ? element2 : element2.getElementsByClassName(className)[0];
      } else if (MINIMAL_DOM_ELEMENT_ROLES.has(domElement)) {
        el = element2;
      } else {
        el = element2.getElementsByClassName(className)[0] ?? createElement("div");
      }
      if (el == null) {
        throw new Error(`AG Charts - unable to find DOM element ${className}`);
      }
      rootElements[domElement] = {
        element: el,
        children: /* @__PURE__ */ new Map(),
        listeners: []
      };
    }
    return rootElements;
  }
  destroy() {
    super.destroy();
    this.observer?.unobserve(this.element);
    if (this.container) {
      this.sizeMonitor.unobserve(this.container);
    }
    this.pendingContainer = void 0;
    Object.values(this.rootElements).forEach((el) => {
      el.children.forEach((c) => c.remove());
      el.element.remove();
    });
    this.element.remove();
  }
  postRenderUpdate() {
    if (this.mode === "minimal")
      return;
    if (this.pendingContainer == null || this.pendingContainer === this.container)
      return;
    if (_DOMManager.batchedUpdateContainer.length === 0) {
      getWindow().setTimeout(this.applyBatchedUpdateContainer.bind(this), 0);
    }
    _DOMManager.batchedUpdateContainer.push(this);
  }
  applyBatchedUpdateContainer() {
    for (const manager of _DOMManager.batchedUpdateContainer) {
      if (!manager.destroyed) {
        manager.updateContainer();
      }
    }
    _DOMManager.batchedUpdateContainer.splice(0);
  }
  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {
    const { style: style2 } = this.element;
    style2.width = `${optionsWidth ?? minWidth}px`;
    style2.height = `${optionsHeight ?? minHeight}px`;
    this.minWidth = optionsWidth ?? minWidth;
    this.minHeight = optionsHeight ?? minHeight;
    this.updateContainerClassName();
  }
  updateContainerSize() {
    const { style: centerStyle } = this.rootElements["canvas-center"].element;
    centerStyle.visibility = this.containerSize == null ? "hidden" : "";
    if (this.containerSize) {
      centerStyle.width = `${this.containerSize.width ?? 0}px`;
      centerStyle.height = `${this.containerSize.height ?? 0}px`;
    } else {
      centerStyle.width = "";
      centerStyle.height = "";
    }
    this.updateContainerClassName();
  }
  setTabGuardIndex(tabIndex) {
    if (!this.tabGuards)
      return;
    this.tabGuards.tabIndex = tabIndex;
  }
  setContainer(newContainer) {
    if (newContainer === this.container)
      return;
    this.pendingContainer = newContainer;
    if (this.mode === "minimal" || this.container == null) {
      this.updateContainer();
    }
  }
  updateContainer() {
    const { pendingContainer } = this;
    if (pendingContainer == null || pendingContainer === this.container)
      return;
    if (this.container) {
      this.container.removeChild(this.element);
      this.sizeMonitor.unobserve(this.container);
    }
    if (this.documentRoot != null) {
      for (const id of this.rootElements["styles"].children.keys()) {
        this.removeChild("styles", id);
      }
    }
    this.container = pendingContainer;
    this.pendingContainer = void 0;
    this.documentRoot = this.getShadowDocumentRoot(pendingContainer);
    this.initiallyConnected = pendingContainer.isConnected;
    for (const [id, styles] of this.styles) {
      this.addStyles(id, styles);
    }
    pendingContainer.appendChild(this.element);
    this.sizeMonitor.observe(pendingContainer, (size) => {
      this.containerSize = size;
      this.updateContainerSize();
      this.eventsHub.emit("dom:resize", null);
    });
    this.eventsHub.emit("dom:container-change", null);
  }
  setThemeClass(themeClassName) {
    const themeClassNamePrefix = "ag-charts-theme-";
    this.element.classList.forEach((className) => {
      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {
        this.element.classList.remove(className);
      }
    });
    this.element.classList.add(themeClassName);
  }
  setThemeParameters(params) {
    for (const [key, value] of entries(params)) {
      let formattedValue = `${value}`;
      if (key.endsWith("Size") || key.endsWith("Radius")) {
        formattedValue = `${value}px`;
      } else if (key.endsWith("Border") && typeof value === "boolean") {
        formattedValue = value ? "var(--ag-charts-border)" : "none";
      }
      this.element.style.setProperty(`--ag-charts-${kebabCase(key)}`, formattedValue);
    }
  }
  updateCanvasLabel(ariaLabel) {
    setAttribute(this.rootElements["canvas-proxy"].element, "aria-label", ariaLabel);
  }
  getEventElement(defaultElem, eventType) {
    const events = ["focus", "blur", "keydown", "keyup"];
    return events.includes(eventType) ? this.rootElements["series-area"].element : defaultElem;
  }
  addEventListener(type, listener, options) {
    const element2 = this.getEventElement(this.element, type);
    return attachListener(element2, type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this.getEventElement(this.element, type).removeEventListener(type, listener, options);
  }
  /** Get the main chart area client bound rect. */
  getBoundingClientRect() {
    return this.rootElements["canvas"].element.getBoundingClientRect();
  }
  /**
   * Get the client bounding rect for overlay elements that might float outside the bounds of the
   * main chart area.
   */
  getOverlayClientRect() {
    const window2 = getWindow();
    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);
    const containerBBox = this.getRawOverlayClientRect();
    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;
  }
  getRawOverlayClientRect() {
    let element2 = this.element;
    const fullScreenElement = this.element.getRootNode()?.fullscreenElement;
    while (element2 != null) {
      let isContainer;
      if (fullScreenElement != null && element2 === fullScreenElement) {
        isContainer = true;
      } else {
        const styleMap = element2.computedStyleMap?.();
        const overflowY = styleMap?.get("overflow-y")?.toString();
        isContainer = overflowY === "auto" || overflowY === "scroll";
      }
      if (isContainer) {
        return BBox.fromDOMRect(element2.getBoundingClientRect());
      }
      element2 = element2.parentElement;
    }
    if (this.documentRoot != null)
      return BBox.fromDOMRect(this.documentRoot.getBoundingClientRect());
    const { innerWidth, innerHeight } = getWindow();
    return new BBox(0, 0, innerWidth, innerHeight);
  }
  getShadowDocumentRoot(current = this.container) {
    const docRoot = current?.ownerDocument?.body ?? getDocument("body");
    while (current != null) {
      if (current === docRoot) {
        return void 0;
      }
      if (current.parentNode instanceof DocumentFragment) {
        return current;
      }
      current = current.parentNode;
    }
  }
  getParent(domElementClass) {
    return this.rootElements[domElementClass].element;
  }
  getChildBoundingClientRect(type) {
    const { children } = this.rootElements[type];
    const childRects = [];
    for (const child of children.values()) {
      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));
    }
    return BBox.merge(childRects);
  }
  isManagedChildDOMElement(el, domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    const search = children?.get(id);
    return search != null && el.contains(search);
  }
  contains(element2, domElementClass) {
    if (domElementClass == null)
      return this.element.contains(element2);
    return this.rootElements[domElementClass].element.contains(element2);
  }
  addStyles(id, styles) {
    const dataAttribute = "data-ag-charts";
    this.styles.set(id, styles);
    if (this.container == null)
      return;
    const checkId = (el) => {
      return el.getAttribute(dataAttribute) === id;
    };
    const addStyleElement = (el) => {
      const metaElements = /* @__PURE__ */ new Set(["TITLE", "META"]);
      let skippingMetaElements = true;
      let insertAfterEl;
      for (const child of el.children) {
        if (skippingMetaElements && metaElements.has(child.tagName)) {
          insertAfterEl = child;
          continue;
        }
        skippingMetaElements = false;
        if (checkId(child))
          return;
        if (child.hasAttribute(dataAttribute)) {
          insertAfterEl = child;
        }
      }
      const styleEl = createElement("style");
      if (this.chart.styleNonce != null) {
        styleEl.nonce = this.chart.styleNonce;
      }
      if (insertAfterEl == null) {
        el.prepend(styleEl);
      } else {
        el.insertBefore(styleEl, insertAfterEl.nextSibling);
      }
      return styleEl;
    };
    let styleElement;
    if (this.styleContainer) {
      styleElement = addStyleElement(this.styleContainer);
    } else if (this.initiallyConnected === false) {
      styleElement = this.addChild("styles", id);
    } else if (this.documentRoot == null && !_DOMManager.headStyles.has(id)) {
      styleElement = addStyleElement(getDocument("head"));
      _DOMManager.headStyles.add(id);
    } else if (this.documentRoot != null) {
      styleElement = this.addChild("styles", id);
    }
    if (styleElement == null || checkId(styleElement))
      return;
    styleElement.setAttribute(dataAttribute, id);
    styleElement.innerHTML = styles;
  }
  removeStyles(id) {
    this.removeChild("styles", id);
  }
  updateCursor(callerId, style2) {
    this.cursorState.set(callerId, style2);
    this.element.style.cursor = this.cursorState.stateValue();
  }
  getCursor() {
    return this.element.style.cursor;
  }
  addChild(domElementClass, id, child, insert) {
    const { element: element2, children, listeners } = this.rootElements[domElementClass];
    if (!children) {
      throw new Error("AG Charts - unable to create DOM elements after destroy()");
    }
    if (children.has(id)) {
      return children.get(id);
    }
    const { childElementType = "div" } = domElementConfig.get(domElementClass) ?? {};
    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {
      throw new Error("AG Charts - mismatching DOM element type");
    }
    const newChild = child ?? createElement(childElementType);
    for (const [type, fn, opts] of listeners) {
      newChild.addEventListener(type, fn, opts);
    }
    children.set(id, newChild);
    if (childElementType === "style" && this.chart.styleNonce != null) {
      newChild.nonce = this.chart.styleNonce;
    }
    if (insert) {
      const queryResult = element2.querySelector(insert.query);
      if (queryResult == null) {
        throw new Error(`AG Charts - addChild query failed ${insert.query}`);
      }
      queryResult.insertAdjacentElement(insert.where, newChild);
    } else {
      element2?.appendChild(newChild);
    }
    return newChild;
  }
  removeChild(domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    if (!children)
      return;
    children.get(id)?.remove();
    children.delete(id);
  }
  incrementDataCounter(name) {
    const { dataset } = this.element;
    dataset[name] ?? (dataset[name] = "0");
    dataset[name] = String(Number(dataset[name]) + 1);
  }
  setDataBoolean(name, value) {
    this.element.dataset[name] = String(value);
  }
  updateContainerClassName() {
    const { element: element2, containerSize, minWidth, minHeight } = this;
    element2.classList.toggle(CONTAINER_MODIFIERS.safeHorizontal, minWidth >= (containerSize?.width ?? Infinity));
    element2.classList.toggle(CONTAINER_MODIFIERS.safeVertical, minHeight >= (containerSize?.height ?? Infinity));
  }
};
_DOMManager.batchedUpdateContainer = [];
_DOMManager.headStyles = /* @__PURE__ */ new Set();
var DOMManager = _DOMManager;

// packages/ag-charts-community/src/widget/boundedTextWidget.ts
var BoundedTextWidget = class extends Widget {
  constructor() {
    super(createElement("div"));
    this.textElement = createSvgElement("text");
    this.textElement.role = "presentation";
    this.svgElement = createSvgElement("svg");
    this.svgElement.appendChild(this.textElement);
    this.svgElement.style.width = "100%";
    this.svgElement.style.opacity = "0";
    this.svgElement.role = "presentation";
    this.elem.appendChild(this.svgElement);
    this.elem.role = "presentation";
  }
  set textContent(text2) {
    this.textElement.textContent = text2;
    const bboxCalculator = this.textElement;
    const bbox = bboxCalculator.getBBox?.();
    if (bbox) {
      this.svgElement.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
    }
  }
  get textContent() {
    return this.textElement.textContent;
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/abstractButtonWidget.ts
var AbstractButtonWidget = class extends Widget {
  constructor(element2, role) {
    super(element2);
    setAttribute(this.elem, "role", role);
    this.setEnabled(true);
    this.addListener("keydown", ({ sourceEvent }) => {
      if (isButtonClickEvent(sourceEvent)) {
        sourceEvent.preventDefault();
        this.htmlListener?.dispatch("click", this, { type: "click", device: "keyboard", sourceEvent });
      }
    });
  }
  destructor() {
  }
  setEnabled(enabled) {
    setAttribute(this.elem, "aria-disabled", !enabled);
  }
  addListener(type, listener) {
    return super.addListener(type, (ev, current) => {
      if ((type === "click" || type === "dblclick") && this.isDisabled())
        return;
      listener(ev, current);
    });
  }
};

// packages/ag-charts-community/src/widget/buttonWidget.ts
var ButtonWidget = class extends AbstractButtonWidget {
  constructor() {
    super(createElement("button"));
  }
};

// packages/ag-charts-community/src/widget/groupWidget.ts
var GroupWidget = class extends Widget {
  constructor() {
    super(createElement("div"));
    setAttribute(this.elem, "role", "group");
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/rovingTabContainerWidget.ts
var RovingTabContainerWidget = class extends Widget {
  constructor(initialOrientation, role) {
    super(createElement("div"));
    this.focusedChildIndex = 0;
    this.onChildFocus = (_event, child) => {
      const oldFocus = this.children[this.focusedChildIndex];
      this.focusedChildIndex = child.index;
      oldFocus?.setTabIndex(-1);
      child.setTabIndex(0);
    };
    this.onChildKeyDown = (event, child) => {
      const rovingOrientation = this.orientation;
      const [primaryKeys, secondaryKeys] = rovingOrientation === "both" ? [PREV_NEXT_KEYS["horizontal"], PREV_NEXT_KEYS["vertical"]] : [PREV_NEXT_KEYS[rovingOrientation], void 0];
      let targetIndex = -1;
      if (hasNoModifiers(event.sourceEvent)) {
        const key = event.sourceEvent.key;
        if (key === primaryKeys.nextKey || key === secondaryKeys?.nextKey) {
          targetIndex = child.index + 1;
        } else if (key === primaryKeys.prevKey || key === secondaryKeys?.prevKey) {
          targetIndex = child.index - 1;
        }
      }
      this.children[targetIndex]?.focus();
    };
    setAttribute(this.elem, "role", role);
    this.orientation = initialOrientation;
  }
  get orientation() {
    return getAttribute(this.elem, "aria-orientation") ?? "both";
  }
  set orientation(orientation) {
    setAttribute(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
  }
  focus() {
    this.children[this.focusedChildIndex]?.focus();
  }
  clear() {
    this.focusedChildIndex = 0;
    for (const child of this.children) {
      this.removeChildListeners(child);
      child.parent = void 0;
    }
    this.elem.textContent = "";
    this.children.length = 0;
  }
  addChildListeners(child) {
    child.addListener("focus", this.onChildFocus);
    child.addListener("keydown", this.onChildKeyDown);
  }
  removeChildListeners(child) {
    child.removeListener("focus", this.onChildFocus);
    child.removeListener("keydown", this.onChildKeyDown);
  }
  onChildAdded(child) {
    this.addChildListeners(child);
    child.setTabIndex(this.children.length === 1 ? 0 : -1);
  }
  onChildRemoved(removedChild) {
    this.removeChildListeners(removedChild);
    const { focusedChildIndex, children } = this;
    const removedFocusedChild = focusedChildIndex === removedChild.index;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.index === focusedChildIndex) {
        this.focusedChildIndex = i;
      }
      child.index = i;
    }
    if (removedFocusedChild) {
      const newFocusChild = children[focusedChildIndex] ?? children[focusedChildIndex - 1];
      if (newFocusChild) {
        this.focusedChildIndex = newFocusChild.index;
        newFocusChild.setTabIndex(0);
      } else {
        this.focusedChildIndex = 0;
      }
    }
  }
};

// packages/ag-charts-community/src/widget/listWidget.ts
var ListWidget = class extends RovingTabContainerWidget {
  constructor() {
    super("both", "list");
    this.setHidden(true);
  }
  destructor() {
    this.children.forEach((c) => c.getElement().parentElement.remove());
  }
  addChildToDOM(child, before) {
    const listItem = createElement("div");
    setAttribute(listItem, "role", "listitem");
    setElementStyle(listItem, "position", "absolute");
    Widget.setElementContainer(child, listItem);
    this.appendOrInsert(listItem, before);
    this.setHidden(false);
  }
  removeChildFromDOM(child) {
    child.getElement().parentElement.remove();
    this.setHidden(this.children.length === 0);
  }
  setHidden(hidden) {
    if (this.children.length === 0) {
      hidden = true;
    }
    super.setHidden(hidden);
  }
};

// packages/ag-charts-community/src/widget/nativeWidget.ts
var NativeWidget = class extends Widget {
  constructor(elem) {
    super(elem);
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/util/format.util.ts
var percentFormatter = new Intl.NumberFormat("en-US", { style: "percent" });
function formatValue(value, maximumFractionDigits = 2) {
  if (typeof value === "number") {
    return formatNumber(value, maximumFractionDigits);
  }
  return typeof value === "string" ? value : String(value ?? "");
}
function formatPercent(value) {
  return percentFormatter.format(value);
}
var numberFormatters = (/* @__PURE__ */ new Map()).set(
  2,
  new Intl.NumberFormat("en-US", { maximumFractionDigits: 2, useGrouping: false })
);
function formatNumber(value, maximumFractionDigits) {
  let formatter2 = numberFormatters.get(maximumFractionDigits);
  if (!formatter2) {
    formatter2 = new Intl.NumberFormat("en-US", { maximumFractionDigits, useGrouping: false });
    numberFormatters.set(maximumFractionDigits, formatter2);
  }
  return formatter2.format(value);
}

// packages/ag-charts-community/src/widget/sliderWidget.ts
var _SliderWidget = class _SliderWidget extends Widget {
  constructor() {
    super(createElement("input"));
    this._step = _SliderWidget.STEP_ONE;
    this.orientation = "both";
  }
  get step() {
    return this._step;
  }
  set step(step) {
    this._step = step;
    this.getElement().step = step.attributeValue;
  }
  get keyboardStep() {
    return this._keyboardStep?.step ?? this._step;
  }
  set keyboardStep(step) {
    if (step === this._keyboardStep?.step)
      return;
    if (this._keyboardStep !== void 0) {
      this.removeListener("keydown", this._keyboardStep.onKeyDown);
      this.removeListener("keyup", this._keyboardStep.onKeyUp);
      this.removeListener("blur", this._keyboardStep.onBlur);
      this._keyboardStep = void 0;
    }
    if (step !== void 0) {
      const onKeyDown = () => this.getElement().step = step.attributeValue;
      const resetStep = () => this.getElement().step = this._step.attributeValue;
      this._keyboardStep = { step, onKeyDown, onKeyUp: resetStep, onBlur: resetStep };
      this.addListener("keydown", this._keyboardStep.onKeyDown);
      this.addListener("keyup", this._keyboardStep.onKeyUp);
      this.addListener("blur", this._keyboardStep.onBlur);
    }
  }
  get orientation() {
    return getAttribute(this.elem, "aria-orientation") ?? "both";
  }
  set orientation(orientation) {
    setAttribute(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
    _SliderWidget.registerDefaultPreventers(this, orientation);
  }
  destructor() {
  }
  clampValueRatio(clampMin, clampMax) {
    const ratio2 = this.getValueRatio();
    const clampedRatio = clamp(clampMin, ratio2, clampMax);
    if (clampedRatio !== ratio2) {
      this.setValueRatio(clampedRatio);
    }
    return clampedRatio;
  }
  setValueRatio(ratio2, opts) {
    const { divider } = this.step;
    const value = Math.round(ratio2 * 1e4) / divider;
    const { ariaValueText = formatPercent(value / divider) } = opts ?? {};
    const elem = this.getElement();
    elem.value = `${value}`;
    elem.ariaValueText = ariaValueText;
  }
  getValueRatio() {
    return this.getElement().valueAsNumber / this.step.divider;
  }
  static registerDefaultPreventers(target, orientation) {
    if (orientation === "both") {
      target.removeListener("keydown", _SliderWidget.onKeyDown);
    } else {
      target.addListener("keydown", _SliderWidget.onKeyDown);
    }
  }
  static onKeyDown(ev, current) {
    let ignoredKeys = [];
    const { orientation } = current;
    if (orientation === "horizontal") {
      ignoredKeys = ["ArrowUp", "ArrowDown"];
    } else if (orientation === "vertical") {
      ignoredKeys = ["ArrowLeft", "ArrowRight"];
    }
    if (ignoredKeys.includes(ev.sourceEvent.code)) {
      ev.sourceEvent.preventDefault();
    }
  }
};
_SliderWidget.STEP_ONE = { attributeValue: "1", divider: 1 };
_SliderWidget.STEP_HUNDRETH = { attributeValue: "0.01", divider: 100 };
var SliderWidget = _SliderWidget;

// packages/ag-charts-community/src/widget/switchWidget.ts
var SwitchWidget = class extends ButtonWidget {
  constructor() {
    super();
    setAttribute(this.elem, "role", "switch");
    this.setChecked(false);
  }
  setChecked(checked) {
    setAttribute(this.elem, "aria-checked", checked);
  }
};

// packages/ag-charts-community/src/widget/toolbarWidget.ts
var ToolbarWidget = class extends RovingTabContainerWidget {
  constructor(orientation = "horizontal") {
    super(orientation, "toolbar");
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/dom/proxyInteractionService.ts
function checkType(type, meta) {
  return meta.params?.type === type;
}
function allocateResult(type) {
  if ("button" === type) {
    return new ButtonWidget();
  } else if ("slider" === type) {
    return new SliderWidget();
  } else if ("toolbar" === type) {
    return new ToolbarWidget();
  } else if ("group" === type) {
    return new GroupWidget();
  } else if ("list" === type) {
    return new ListWidget();
  } else if ("region" === type) {
    return new NativeWidget(createElement("div"));
  } else if ("text" === type) {
    return new BoundedTextWidget();
  } else if ("listswitch" === type) {
    return new SwitchWidget();
  } else {
    throw Error("AG Charts - error allocating meta");
  }
}
function allocateMeta(params) {
  const meta = { params, result: void 0 };
  meta.result = allocateResult(meta.params.type);
  return meta;
}
var ProxyInteractionService = class {
  constructor(eventsHub, localeManager, domManager) {
    this.eventsHub = eventsHub;
    this.localeManager = localeManager;
    this.domManager = domManager;
    this.cleanup = new CleanupRegistry();
  }
  destroy() {
    this.cleanup.flush();
  }
  addLocalisation(fn) {
    fn();
    this.cleanup.register(this.eventsHub.on("locale:change", fn));
  }
  createProxyContainer(args) {
    const meta = allocateMeta(args);
    const { params, result } = meta;
    const div = result.getElement();
    this.domManager.addChild("canvas-proxy", params.domManagerId, div);
    div.classList.add(...params.classList, "ag-charts-proxy-container");
    div.role = params.type;
    if (checkType("toolbar", meta)) {
      meta.result.orientation = meta.params.orientation;
    }
    this.addLocalisation(() => {
      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
    });
    return result;
  }
  createProxyElement(args) {
    const meta = allocateMeta(args);
    if (checkType("button", meta)) {
      const { params, result } = meta;
      const button = result.getElement();
      this.initInteract(params, result);
      if (typeof params.textContent === "string") {
        button.textContent = params.textContent;
      } else {
        const { textContent } = params;
        this.addLocalisation(() => {
          button.textContent = this.localeManager.t(textContent.id, textContent.params);
        });
      }
      this.setParent(meta.params, meta.result);
    }
    if (checkType("slider", meta)) {
      const { params, result } = meta;
      const slider = result.getElement();
      this.initInteract(params, result);
      slider.type = "range";
      slider.role = "presentation";
      slider.style.margin = "0px";
      this.addLocalisation(() => {
        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
      });
      this.setParent(meta.params, meta.result);
    }
    if (checkType("text", meta)) {
      const { params, result } = meta;
      this.initElement(params, result);
      this.setParent(meta.params, meta.result);
    }
    if (checkType("listswitch", meta)) {
      const { params, result: button } = meta;
      this.initInteract(params, button);
      button.setTextContent(params.textContent);
      button.setChecked(params.ariaChecked);
      button.setAriaDescribedBy(params.ariaDescribedBy);
      this.setParent(meta.params, meta.result);
    }
    if (checkType("region", meta)) {
      const { params, result } = meta;
      const region = result.getElement();
      this.initInteract(params, result);
      region.role = "region";
      this.setParent(meta.params, meta.result);
    }
    return meta.result;
  }
  initElement(params, widget) {
    const element2 = widget.getElement();
    setElementStyle(element2, "cursor", params.cursor);
    element2.classList.toggle("ag-charts-proxy-elem", true);
    return element2;
  }
  initInteract(params, widget) {
    const { tabIndex, domIndex } = params;
    const element2 = this.initElement(params, widget);
    if (tabIndex !== void 0) {
      element2.tabIndex = tabIndex;
    }
    if (domIndex !== void 0) {
      widget.domIndex = domIndex;
    }
  }
  setParent(params, element2) {
    if ("parent" in params) {
      params.parent?.addChild(element2);
    } else {
      const insert = { where: params.where, query: ".ag-charts-series-area" };
      this.domManager.addChild("canvas-proxy", params.domManagerId, element2.getElement(), insert);
      element2.destroyListener = () => {
        this.domManager.removeChild("canvas-proxy", params.domManagerId);
      };
    }
  }
};

// packages/ag-charts-locale/src/en-US.ts
var AG_CHARTS_LOCALE_EN_US = {
  // Initial screen reader alt-text of the series area
  ariaInitSeriesArea: "interactive chart",
  // Screen reader announcement when focusing an item in the chart
  ariaAnnounceHoverDatum: "${datum}",
  // Screen reader announcement when focusing a chart
  ariaAnnounceChart: "chart, ${seriesCount}[number] series",
  // Screen reader announcement when focusing a standalone chart (gauges, pyramid)
  ariaAnnounceStandaloneChart: "chart, ${caption}",
  // Screen reader announcement when focusing a hierarchy chart
  ariaAnnounceHierarchyChart: "hierarchy chart, ${caption}",
  // Screen reader announcement when focusing a gauge chart
  ariaAnnounceGaugeChart: "gauge chart, ${caption}",
  // Screen reader announcement when focusing an item in a treemap or sunburst chart
  ariaAnnounceHierarchyDatum: "level ${level}[number], ${count}[number] children, ${description}",
  // Screen reader announcement when focusing a link in a Sankey or chord chart
  ariaAnnounceFlowProportionLink: "link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}",
  // Screen reader announcement when focusing a node in a Sankey or chord chart
  ariaAnnounceFlowProportionNode: "node ${index} of ${count}, ${description}",
  // Screen reader description for legend items
  ariaDescriptionLegendItem: "Press Space or Enter to toggle visibility",
  // Screen reader for the '+' horizontal line button on the Y-axis
  ariaLabelAddHorizontalLine: "Add Horizontal Line",
  // Screen reader text for annotations toolbar
  ariaLabelAnnotationsToolbar: "Annotations",
  // Screen reader text for annotation-options toolbar
  ariaLabelAnnotationOptionsToolbar: "Annotation Options",
  // Screen reader text for annotation-settings dialog
  ariaLabelAnnotationSettingsDialog: "Annotation Settings",
  // Screen reader text for the color-code label in the picker dialog
  ariaLabelColor: "Color",
  // Screen reader text for the color picker dialog
  ariaLabelColorPicker: "Color picker",
  // Screen reader text for the alpha-channel slider label
  ariaLabelColorPickerAlpha: "Transparency",
  // Screen reader text for the hue slider label
  ariaLabelColorPickerHue: "Hue",
  // Screen reader text for when the color-code is multi-colored
  ariaLabelColorPickerMultiColor: "Multi Color",
  // Screen reader text for the 2D palette slider label
  ariaLabelColorPickerPalette: "Palette",
  // Screen reader text for the financial charts toolbar
  ariaLabelFinancialCharts: "Financial Charts",
  // Screen reader text for the legend toolbar
  ariaLabelLegend: "Legend",
  // Screen reader text for the legend pagination button
  ariaLabelLegendPagination: "Legend Pagination",
  // Screen reader text for the previous legend page button
  ariaLabelLegendPagePrevious: "Previous Legend Page",
  // Screen reader text for the next legend page button
  ariaLabelLegendPageNext: "Next Legend Page",
  // Screen reader text for the an item in the legend
  ariaLabelLegendItem: "${label}, Legend item ${index}[number] of ${count}[number]",
  // Screen reader text for the an unknown item in the legend
  ariaLabelLegendItemUnknown: "Unknown legend item",
  // Screen reader text for the navigator element
  ariaLabelNavigator: "Navigator",
  // Screen reader text for an accessibility control that changes the position of the navigator's range
  ariaLabelNavigatorRange: "Range",
  // Screen reader text for an accessibility control that changes the start of the navigator's range
  ariaLabelNavigatorMinimum: "Minimum",
  // Screen reader text for an accessibility control that changes the end of the navigator's range
  ariaLabelNavigatorMaximum: "Maximum",
  // Screen reader text for ranges toolbar
  ariaLabelRangesToolbar: "Ranges",
  // Screen reader text for the settings dialog tab-bar
  ariaLabelSettingsTabBar: "Settings",
  // Screen reader text for zoom toolbar
  ariaLabelZoomToolbar: "Zoom",
  // Aria role description for a 2D role="slider"
  ariaRoleDescription2DSlider: "2D slider",
  // Screen reader text for color picker's 2D slider palette
  ariaValueColorPalette: "s ${s}[percent0to2dp], v ${v}[percent0to2dp]",
  // Screen reader text for color picker's 2D slider palette (when arrowing up or down)
  ariaValueColorPaletteFirstV: "v ${v}[percent0to2dp], s ${s}[percent0to2dp]",
  // Screen reader text for the value of the navigator's range
  ariaValuePanRange: "${min}[percent0to2dp] to ${max}[percent0to2dp]",
  // Alt-text for the solid line dash style menu item icon
  iconAltTextLineStyleSolid: "Solid",
  // Alt-text for the long-dashed line dash style menu item icon
  iconAltTextLineStyleDashed: "Long-dashed",
  // Alt-text for the short-dashed line dash style menu item icon
  iconAltTextLineStyleDotted: "Short-dashed",
  // Alt-text for the 'position-top' icon
  iconAltTextPositionTop: "Top",
  // Alt-text for the 'position-center' icon
  iconAltTextPositionCenter: "Center",
  // Alt-text for the 'position-bottom' icon
  iconAltTextPositionBottom: "Bottom",
  // Alt-text for the 'position-left' icon
  iconAltTextAlignLeft: "Left",
  // Alt-text for the 'align-center' icon
  iconAltTextAlignCenter: "Center",
  // Alt-text for the 'position-right' icon
  iconAltTextAlignRight: "Right",
  // Alt-text for the 'close' icon
  iconAltTextClose: "Close",
  // Default text for the 'loading data' overlay
  overlayLoadingData: "Loading data...",
  // Default text for the 'no data' overlay
  overlayNoData: "No data to display",
  // Default text for the 'no visible series' overlay
  overlayNoVisibleSeries: "No visible series",
  // Default text for the 'unsupported browser' overlay
  overlayUnsupportedBrowser: "Incompatible browser version. Please upgrade your browser.",
  // Text for frequency label in Histogram Series tooltip
  seriesHistogramTooltipFrequency: "Frequency",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipSum: "${yName} (sum)",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipCount: "${yName} (count)",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipMean: "${yName} (mean)",
  // Text for the series type toolbar's chart type button
  toolbarSeriesTypeDropdown: "Chart Type",
  // Text for the series type toolbar's OHLC chart type button
  toolbarSeriesTypeOHLC: "OHLC",
  // Text for the series type toolbar's HLC chart type button
  toolbarSeriesTypeHLC: "HLC",
  // Text for the series type toolbar's high low chart type button
  toolbarSeriesTypeHighLow: "High Low",
  // Text for the series type toolbar's candles chart type button
  toolbarSeriesTypeCandles: "Candles",
  // Text for the series type toolbar's hollow candles chart type button
  toolbarSeriesTypeHollowCandles: "Hollow Candles",
  // Text for the series type toolbar's line chart type button
  toolbarSeriesTypeLine: "Line",
  // Text for the series type toolbar's line with markers chart type button
  toolbarSeriesTypeLineWithMarkers: "Line with Markers",
  // Text for the series type toolbar's line with step line chart type button
  toolbarSeriesTypeStepLine: "Step Line",
  // Text for the annotation toolbar's trend line button
  toolbarAnnotationsTrendLine: "Trend Line",
  // Text for the annotation toolbar's Fibonacci Retracement button
  toolbarAnnotationsFibonacciRetracement: "Fib Retracement",
  // Text for the annotation toolbar's Fibonacci Retracement Trend Based button
  toolbarAnnotationsFibonacciRetracementTrendBased: "Fib Trend Based",
  // Text for the annotation toolbar's horizontal line button
  toolbarAnnotationsHorizontalLine: "Horizontal Line",
  // Text for the annotation toolbar's vertical line button
  toolbarAnnotationsVerticalLine: "Vertical Line",
  // Text for the annotation toolbar's parallel channel button
  toolbarAnnotationsParallelChannel: "Parallel Channel",
  // Text for the annotation toolbar's disjoint channel button
  toolbarAnnotationsDisjointChannel: "Disjoint Channel",
  // Text for the annotation toolbar's clear all button
  toolbarAnnotationsClearAll: "Clear All",
  // Text for the annotation toolbar's fill color picker annotation button
  toolbarAnnotationsFillColor: "Fill Color",
  // Text for the annotation toolbar's line color picker annotation button
  toolbarAnnotationsLineColor: "Line Color",
  // Text for the annotation toolbar's line style type button
  toolbarAnnotationsLineStyle: "Line Style",
  // Text for the annotation toolbar's line stroke width button
  toolbarAnnotationsLineStrokeWidth: "Line Stroke Width",
  // Text for the annotation toolbar's settings annotation button
  toolbarAnnotationsSettings: "Settings",
  // Text for the annotation toolbar's text color picker annotation button
  toolbarAnnotationsTextColor: "Text Color",
  // Text for the annotation toolbar's text size picker annotation button
  toolbarAnnotationsTextSize: "Text Size",
  // Text for the annotation toolbar's lock annotation button
  toolbarAnnotationsLock: "Lock",
  // Text for the annotation toolbar's unlock annotation button
  toolbarAnnotationsUnlock: "Unlock",
  // Text for the annotation toolbar's delete annotation button
  toolbarAnnotationsDelete: "Delete",
  // Text for the annotation toolbar's drag handle
  toolbarAnnotationsDragHandle: "Drag Toolbar",
  // Text for the annotation toolbar's line drawings menu button
  toolbarAnnotationsLineAnnotations: "Trend Lines",
  // Text for the annotation toolbar's Fibonacci drawings menu button
  toolbarAnnotationsFibonacciAnnotations: "Fibonacci",
  // Text for the annotation toolbar's text annotations menu button
  toolbarAnnotationsTextAnnotations: "Text Annotations",
  // Text for the annotation toolbar's shapes menu button
  toolbarAnnotationsShapeAnnotations: "Arrows",
  // Text for the annotation toolbar's measurers menu button
  toolbarAnnotationsMeasurerAnnotations: "Measurers",
  // Text for the annotation toolbar's callout button
  toolbarAnnotationsCallout: "Callout",
  // Text for the annotation toolbar's comment button
  toolbarAnnotationsComment: "Comment",
  // Text for the annotation toolbar's note button
  toolbarAnnotationsNote: "Note",
  // Text for the annotation toolbar's text button
  toolbarAnnotationsText: "Text",
  // Text for the annotation toolbar's arrow button
  toolbarAnnotationsArrow: "Arrow",
  // Text for the annotation toolbar's arrow up button
  toolbarAnnotationsArrowUp: "Arrow Up",
  // Text for the annotation toolbar's arrow down button
  toolbarAnnotationsArrowDown: "Arrow Down",
  // Text for the annotation toolbar's date range button
  toolbarAnnotationsDateRange: "Date Range",
  // Text for the annotation toolbar's price range button
  toolbarAnnotationsPriceRange: "Price Range",
  // Text for the annotation toolbar's date and price range button
  toolbarAnnotationsDatePriceRange: "Date and Price",
  // Text for the annotation toolbar's quick date and price range button
  toolbarAnnotationsQuickDatePriceRange: "Measure",
  // Text for the range toolbar's 1 month button
  toolbarRange1Month: "1M",
  // Aria label for the range toolbar's 1 month button
  toolbarRange1MonthAria: "1 month",
  // Text for the range toolbar's 3 month button
  toolbarRange3Months: "3M",
  // Aria label for the range toolbar's 3 month button
  toolbarRange3MonthsAria: "3 months",
  // Text for the range toolbar's 6 month button
  toolbarRange6Months: "6M",
  // Aria label for the range toolbar's 6 month button
  toolbarRange6MonthsAria: "6 months",
  // Text for the range toolbar's year to date button
  toolbarRangeYearToDate: "YTD",
  // Aria label for the range toolbar's year to date month button
  toolbarRangeYearToDateAria: "Year to date",
  // Text for the range toolbar's 1 year button
  toolbarRange1Year: "1Y",
  // Aria label for the range toolbar's 1 year button
  toolbarRange1YearAria: "1 year",
  // Text for the range toolbar's full range button
  toolbarRangeAll: "All",
  // Aria label for the range toolbar's full range button
  toolbarRangeAllAria: "All",
  // Text for the zoom toolbar's zoom out button
  toolbarZoomZoomOut: "Zoom out",
  // Text for the zoom toolbar's zoom in button
  toolbarZoomZoomIn: "Zoom in",
  // Text for the zoom toolbar's pan left button
  toolbarZoomPanLeft: "Pan left",
  // Text for the zoom toolbar's pan right button
  toolbarZoomPanRight: "Pan right",
  // Text for the zoom toolbar's pan to the start button
  toolbarZoomPanStart: "Pan to the start",
  // Text for the zoom toolbar's pan to the end button
  toolbarZoomPanEnd: "Pan to the end",
  // Text for the zoom toolbar's pan reset button
  toolbarZoomReset: "Reset the zoom",
  // Text for the context menu's download button
  contextMenuDownload: "Download",
  // Text for the context menu's toggle series visibility button
  contextMenuToggleSeriesVisibility: "Toggle Visibility",
  // Text for the context menu's toggle other series visibility button
  contextMenuToggleOtherSeries: "Toggle Other Series",
  // Text for the context menu's zoom to point button
  contextMenuZoomToCursor: "Zoom to here",
  // Text for the context menu's pan to point button
  contextMenuPanToCursor: "Pan to here",
  // Text for the context menu's reset zoom button
  contextMenuResetZoom: "Reset zoom",
  // Text for the annotation dialog's header channel tab label
  dialogHeaderChannel: "Channel",
  // Text for the annotation dialog's header line tab label
  dialogHeaderLine: "Line",
  // Text for the annotation dialog's header fibonacci retracement line tab label
  dialogHeaderFibonacciRange: "Fib Retracement",
  // Text for the annotation dialog's header date range tab label
  dialogHeaderDateRange: "Date Range",
  // Text for the annotation dialog's header price range tab label
  dialogHeaderPriceRange: "Price Range",
  // Text for the annotation dialog's header date and price range tab label
  dialogHeaderDatePriceRange: "Date and Price",
  // Text for the annotation dialog's header text tab label
  dialogHeaderText: "Text",
  // Text for the annotation dialog's text alignment radio label
  dialogInputAlign: "Align",
  // Text for the annotation dialog's color picker label
  dialogInputColorPicker: "Color",
  // Text for the annotation dialog's color picker alt text
  dialogInputColorPickerAltText: "Text Color",
  // Text for the annotation dialog's fill color picker label
  dialogInputFillColorPicker: "Fill",
  // Text for the annotation dialog's fill color picker alt text
  dialogInputFillColorPickerAltText: "Fill Color",
  // Text for the annotation dialog's extend channel start checkbox
  dialogInputExtendChannelStart: "Extend channel start",
  // Text for the annotation dialog's extend channel end checkbox
  dialogInputExtendChannelEnd: "Extend channel end",
  // Text for the annotation dialog's extend line start checkbox
  dialogInputExtendLineStart: "Extend line start",
  // Text for the annotation dialog's extend line end checkbox
  dialogInputExtendLineEnd: "Extend line end",
  // Text for the annotation dialog's extend above checkbox
  dialogInputExtendAbove: "Extend above",
  // Text for the annotation dialog's extend below checkbox
  dialogInputExtendBelow: "Extend below",
  // Text for the annotation dialog's extend left checkbox
  dialogInputExtendLeft: "Extend left",
  // Text for the annotation dialog's extend right checkbox
  dialogInputExtendRight: "Extend right",
  // Text for the annotation dialog's reverse checkbox
  dialogInputReverse: "Reverse",
  // Text for the annotation dialog's show fill checkbox
  dialogInputShowFill: "Show Fill",
  // Text for the annotation dialog's font size select box label
  dialogInputFontSize: "Size",
  // Text for the annotation dialog's font size select box alt text
  dialogInputFontSizeAltText: "Font Size",
  // Text for the annotation dialog's line style radio label
  dialogInputLineStyle: "Dash",
  // Text for the annotation dialog's text position radio label
  dialogInputPosition: "Position",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidth: "Weight",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidthAltText: "Line Weight",
  // Text for the annotation dialog's Fibonacci bands label
  dialogInputFibonacciBands: "Bands",
  // Text for the annotation dialog's Fibonacci bands label
  dialogInputFibonacciBandsAltText: "Fibonacci Bands",
  // Text for text area input placeholders
  inputTextareaPlaceholder: "Add Text",
  // Text for the measurer statistics date range bars value
  measurerDateRangeBars: "${value}[number] bars",
  // Text for the measurer statistics price range value
  measurerPriceRangeValue: "${value}[number]",
  // Text for the measurer statistics price range percentage
  measurerPriceRangePercent: "${value}[percent]",
  // Text for the measurer statistics volume value
  measurerVolume: "Vol ${value}",
  // Status when multiple data are under the cursor, and the user can click to cycle through which one appears in the tooltip
  tooltipPaginationStatus: "${index}[number] of ${count}[number]"
};

// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts
var messageRegExp = /\$\{(\w+)}(?:\[(\w+)])?/gi;
var formatters = {
  number: new Intl.NumberFormat("en-US"),
  percent: new Intl.NumberFormat("en-US", { style: "percent", minimumFractionDigits: 2, maximumFractionDigits: 2 }),
  percent0to2dp: new Intl.NumberFormat("en-US", {
    style: "percent",
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  }),
  date: new Intl.DateTimeFormat("en-US", { dateStyle: "full" }),
  time: new Intl.DateTimeFormat("en-US", { timeStyle: "full" }),
  datetime: new Intl.DateTimeFormat("en-US", { dateStyle: "full", timeStyle: "full" })
};
var defaultMessageFormatter = ({ defaultValue, variables }) => {
  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {
    const value = variables[match];
    const formatter2 = format != null ? formatters[format] : null;
    if (format != null && formatter2 == null) {
      logger_exports.warnOnce(`Format style [${format}] is not supported`);
    }
    if (formatter2 != null) {
      return formatter2.format(value);
    } else if (typeof value === "number") {
      return formatters.number.format(value);
    } else if (value instanceof Date) {
      return formatters.datetime.format(value);
    }
    return String(value);
  });
};

// packages/ag-charts-community/src/locale/localeManager.ts
var LocaleManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.localeText = void 0;
    this.getLocaleText = void 0;
  }
  setLocaleText(localeText) {
    if (this.localeText !== localeText) {
      this.localeText = localeText;
      this.eventsHub.emit("locale:change", null);
    }
  }
  setLocaleTextFormatter(getLocaleText) {
    this.getLocaleText = getLocaleText;
    if (this.getLocaleText !== getLocaleText) {
      this.getLocaleText = getLocaleText;
      this.eventsHub.emit("locale:change", null);
    }
  }
  t(key, variables = {}) {
    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;
    const defaultValue = localeText[key];
    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;
  }
};

// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts
var HdpiCanvas = class {
  constructor(options) {
    this.enabled = true;
    this.width = 600;
    this.height = 300;
    const { width: width2, height: height2, canvasElement, willReadFrequently = false } = options;
    this.pixelRatio = options.pixelRatio ?? getWindow("devicePixelRatio") ?? 1;
    this.element = canvasElement ?? createElement("canvas");
    this.element.style.display = "block";
    this.element.style.width = (width2 ?? this.width) + "px";
    this.element.style.height = (height2 ?? this.height) + "px";
    this.element.width = Math.round((width2 ?? this.width) * this.pixelRatio);
    this.element.height = Math.round((height2 ?? this.height) * this.pixelRatio);
    this.context = this.element.getContext("2d", { willReadFrequently });
    this.onEnabledChange();
    this.resize(width2 ?? 0, height2 ?? 0, this.pixelRatio);
    debugContext(this.context);
  }
  drawImage(context, dx2 = 0, dy2 = 0) {
    return context.drawImage(this.context.canvas, dx2, dy2);
  }
  toDataURL(type) {
    return this.element.toDataURL(type);
  }
  resize(width2, height2, pixelRatio) {
    if (!(width2 > 0 && height2 > 0))
      return;
    const { element: element2, context } = this;
    element2.width = Math.round(width2 * pixelRatio);
    element2.height = Math.round(height2 * pixelRatio);
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    element2.style.width = width2 + "px";
    element2.style.height = height2 + "px";
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
  }
  clear() {
    clearContext(this);
  }
  destroy() {
    this.element.remove();
    this.element.width = 0;
    this.element.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    Object.freeze(this);
  }
  reset() {
    this.context.reset();
    this.context.verifyDepthZero?.();
  }
  onEnabledChange() {
    if (this.element) {
      this.element.style.display = this.enabled ? "" : "none";
    }
  }
};
__decorateClass([
  ObserveChanges((target) => target.onEnabledChange())
], HdpiCanvas.prototype, "enabled", 2);

// packages/ag-charts-community/src/scene/image/imageLoader.ts
var ImageLoader = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.cache = /* @__PURE__ */ new Map();
    this.imageLoadingCount = 0;
  }
  loadImage(uri, affectedNode) {
    const entry = this.cache.get(uri);
    if (entry?.image) {
      return entry.image;
    } else if (entry != null && affectedNode) {
      entry.nodes.add(affectedNode);
      return;
    }
    if (!affectedNode) {
      return;
    }
    const nextEntry = { image: void 0, nodes: /* @__PURE__ */ new Set([affectedNode]) };
    const image = new Image();
    this.imageLoadingCount++;
    image.onload = () => {
      nextEntry.image = image;
      for (const node of nextEntry.nodes) {
        node.markDirty();
      }
      nextEntry.nodes.clear();
      this.imageLoadingCount--;
      this.emit("image-loaded", { uri });
    };
    image.onerror = () => {
      this.imageLoadingCount--;
      nextEntry.nodes.clear();
      this.emit("image-error", { uri });
    };
    image.src = uri;
    this.cache.set(uri, nextEntry);
    return nextEntry.image;
  }
  waitingToLoad() {
    return this.imageLoadingCount > 0;
  }
  destroy() {
    this.cache.forEach((entry) => {
      entry.nodes.clear();
    });
    this.cache.clear();
  }
};

// packages/ag-charts-community/src/scene/layersManager.ts
var LayersManager = class {
  constructor(canvas) {
    this.canvas = canvas;
    this.debug = Debug.create(true, "scene");
    this.layersMap = /* @__PURE__ */ new Map();
    this.nextLayerId = 0;
  }
  get size() {
    return this.layersMap.size;
  }
  resize(width2, height2, pixelRatio) {
    this.canvas.resize(width2, height2, pixelRatio);
    this.layersMap.forEach(({ canvas }) => canvas.resize(width2, height2, pixelRatio));
  }
  addLayer(opts) {
    const { width: width2, height: height2, pixelRatio } = this.canvas;
    const { name } = opts;
    const canvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });
    this.layersMap.set(canvas, {
      id: this.nextLayerId++,
      name,
      canvas
    });
    this.debug("Scene.addLayer() - layers", this.layersMap);
    return canvas;
  }
  removeLayer(canvas) {
    if (this.layersMap.has(canvas)) {
      this.layersMap.delete(canvas);
      canvas.destroy();
      this.debug("Scene.removeLayer() -  layers", this.layersMap);
    }
  }
  clear() {
    for (const layer of this.layersMap.values()) {
      layer.canvas.destroy();
    }
    this.layersMap.clear();
  }
};

// packages/ag-charts-community/src/scene/scene.ts
var Scene = class extends EventEmitter {
  constructor(canvasOptions) {
    super();
    this.debug = Debug.create(true, "scene" /* SCENE */);
    this.id = createId(this);
    this.imageLoader = new ImageLoader();
    this.root = null;
    this.pendingSize = null;
    this.isDirty = false;
    this.cleanup = new CleanupRegistry();
    this.updateDebugFlags();
    this.canvas = new HdpiCanvas(canvasOptions);
    this.layersManager = new LayersManager(this.canvas);
    this.cleanup.register(
      this.imageLoader.on("image-loaded", () => {
        this.emit("scene-changed", {});
      }),
      this.imageLoader.on("image-error", ({ uri }) => {
        logger_exports.warnOnce(`Unable to load image ${uri}`);
      })
    );
  }
  waitingForUpdate() {
    return this.imageLoader?.waitingToLoad() ?? false;
  }
  get width() {
    return this.pendingSize?.[0] ?? this.canvas.width;
  }
  get height() {
    return this.pendingSize?.[1] ?? this.canvas.height;
  }
  get pixelRatio() {
    return this.pendingSize?.[2] ?? this.canvas.pixelRatio;
  }
  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */
  setContainer(value) {
    const { element: element2 } = this.canvas;
    element2.parentElement?.removeChild(element2);
    value.appendChild(element2);
    return this;
  }
  setRoot(node) {
    if (this.root === node) {
      return this;
    }
    this.isDirty = true;
    this.root?.setScene();
    this.root = node;
    if (node) {
      node.visible = true;
      node.setScene(this);
    }
    return this;
  }
  updateDebugFlags() {
    Debug.inDevelopmentMode(() => Node2._debugEnabled = true);
  }
  clearCanvas() {
    this.canvas.clear();
  }
  attachNode(node) {
    this.appendChild(node);
    return () => this.removeChild(node);
  }
  appendChild(node) {
    this.root?.appendChild(node);
    return this;
  }
  removeChild(node) {
    this.root?.removeChild(node);
    return this;
  }
  download(fileName, fileFormat) {
    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? "image");
  }
  /** NOTE: Integrated Charts undocumented image download method. */
  getDataURL(fileFormat) {
    return this.canvas.toDataURL(fileFormat);
  }
  resize(width2, height2, pixelRatio) {
    width2 = Math.round(width2);
    height2 = Math.round(height2);
    pixelRatio ?? (pixelRatio = this.pixelRatio);
    if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio)) {
      this.pendingSize = [width2, height2, pixelRatio];
      this.isDirty = true;
      return true;
    }
    return false;
  }
  render(opts) {
    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};
    const {
      canvas,
      canvas: { context: ctx } = {},
      root,
      pendingSize,
      width: width2,
      height: height2,
      pixelRatio: devicePixelRatio
    } = this;
    if (!ctx) {
      return;
    }
    const renderStartTime = performance.now();
    let resized = false;
    if (pendingSize) {
      resized = true;
      this.layersManager.resize(...pendingSize);
      this.pendingSize = null;
    }
    if (root && !root.visible) {
      this.isDirty = false;
      return;
    }
    let rootDirty;
    if (root instanceof Group) {
      rootDirty = root.dirty;
    }
    if (root != null && rootDirty === false && !this.isDirty) {
      if (this.debug.check()) {
        this.debug("Scene.render() - no-op", {
          tree: buildTree(root, "console")
        });
      }
      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);
      return;
    }
    const renderCtx = {
      ctx,
      width: width2,
      height: height2,
      devicePixelRatio,
      debugNodes: {}
    };
    if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
      renderCtx.stats = {
        layersRendered: 0,
        layersSkipped: 0,
        nodesRendered: 0,
        nodesSkipped: 0,
        opsPerformed: 0,
        opsSkipped: 0
      };
    }
    prepareSceneNodeHighlight(renderCtx);
    let canvasCleared = false;
    if (rootDirty !== false || resized) {
      canvasCleared = true;
      canvas.clear();
    }
    if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */)) {
      const { dirtyTree, paths } = buildDirtyTree(root);
      Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */)("Scene.render() - dirtyTree", { dirtyTree, paths });
    }
    if (root && canvasCleared) {
      if (root.visible) {
        root.preRender(renderCtx);
      }
      if (this.debug.check()) {
        const tree = buildTree(root, "console");
        this.debug("Scene.render() - before", {
          canvasCleared,
          tree
        });
      }
      if (root.visible) {
        try {
          ctx.save();
          root.render(renderCtx);
          ctx.restore();
        } catch (e) {
          this.canvas.reset();
          throw e;
        }
      }
    }
    debugSplitTimes["\u270D\uFE0F"] = performance.now() - renderStartTime;
    ctx.verifyDepthZero?.();
    this.isDirty = false;
    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);
    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
    if (root && this.debug.check()) {
      this.debug("Scene.render() - after", {
        tree: buildTree(root, "console"),
        canvasCleared
      });
    }
  }
  toSVG() {
    const { root, width: width2, height: height2 } = this;
    if (root == null)
      return;
    return Node2.toSVG(root, width2, height2);
  }
  /** Alternative to destroy() that preserves re-usable resources. */
  strip() {
    const { context, pixelRatio } = this.canvas;
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.layersManager.clear();
    this.setRoot(null);
    this.isDirty = false;
    this.clear();
  }
  destroy() {
    this.strip();
    this.canvas.destroy();
    this.imageLoader.destroy();
    this.cleanup.flush();
    Object.assign(this, { canvas: void 0 });
  }
};
Scene.className = "Scene";

// packages/ag-charts-community/src/chart/annotation/annotationManager.ts
var AnnotationManager = class {
  constructor(eventsHub, annotationRoot, fireChartEvent) {
    this.eventsHub = eventsHub;
    this.annotationRoot = annotationRoot;
    this.fireChartEvent = fireChartEvent;
    this.mementoOriginatorKey = "annotations";
    this.annotations = [];
  }
  createMemento() {
    return this.annotations;
  }
  guardMemento(blob) {
    return blob == null || isArray(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    this.annotations = this.cleanData(memento ?? []).map((annotation) => {
      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);
      return mergeDefaults(annotation, annotationTheme);
    });
    this.eventsHub.emit("annotations:restore", { annotations: this.annotations });
  }
  updateData(annotations) {
    this.annotations = this.cleanData(annotations ?? []);
  }
  fireChangedEvent() {
    this.fireChartEvent({ type: "annotations", annotations: deepClone([...this.annotations]) });
  }
  attachNode(node) {
    this.annotationRoot.append(node);
    return () => {
      this.annotationRoot?.removeChild(node);
      return this;
    };
  }
  setAnnotationStyles(styles) {
    this.styles = styles;
  }
  getAnnotationTypeStyles(type) {
    return this.styles?.[type];
  }
  cleanData(annotations) {
    for (const annotation of annotations) {
      if ("textAlign" in annotation)
        delete annotation.textAlign;
    }
    return annotations;
  }
};

// packages/ag-charts-community/src/chart/zIndexMap.ts
var ZIndexMap = /* @__PURE__ */ ((ZIndexMap11) => {
  ZIndexMap11[ZIndexMap11["CHART_BACKGROUND"] = 0] = "CHART_BACKGROUND";
  ZIndexMap11[ZIndexMap11["AXIS_BAND_HIGHLIGHT"] = 1] = "AXIS_BAND_HIGHLIGHT";
  ZIndexMap11[ZIndexMap11["AXIS_GRID"] = 2] = "AXIS_GRID";
  ZIndexMap11[ZIndexMap11["AXIS"] = 3] = "AXIS";
  ZIndexMap11[ZIndexMap11["SERIES_AREA_CONTAINER"] = 4] = "SERIES_AREA_CONTAINER";
  ZIndexMap11[ZIndexMap11["ZOOM_SELECTION"] = 5] = "ZOOM_SELECTION";
  ZIndexMap11[ZIndexMap11["SERIES_CROSSLINE_RANGE"] = 6] = "SERIES_CROSSLINE_RANGE";
  ZIndexMap11[ZIndexMap11["SERIES_LAYER"] = 7] = "SERIES_LAYER";
  ZIndexMap11[ZIndexMap11["AXIS_FOREGROUND"] = 8] = "AXIS_FOREGROUND";
  ZIndexMap11[ZIndexMap11["SERIES_CROSSHAIR"] = 9] = "SERIES_CROSSHAIR";
  ZIndexMap11[ZIndexMap11["SERIES_CROSSLINE_LINE"] = 10] = "SERIES_CROSSLINE_LINE";
  ZIndexMap11[ZIndexMap11["SERIES_ANNOTATION"] = 11] = "SERIES_ANNOTATION";
  ZIndexMap11[ZIndexMap11["CHART_ANNOTATION"] = 12] = "CHART_ANNOTATION";
  ZIndexMap11[ZIndexMap11["CHART_ANNOTATION_FOCUSED"] = 13] = "CHART_ANNOTATION_FOCUSED";
  ZIndexMap11[ZIndexMap11["STATUS_BAR"] = 14] = "STATUS_BAR";
  ZIndexMap11[ZIndexMap11["SERIES_LABEL"] = 15] = "SERIES_LABEL";
  ZIndexMap11[ZIndexMap11["LEGEND"] = 16] = "LEGEND";
  ZIndexMap11[ZIndexMap11["NAVIGATOR"] = 17] = "NAVIGATOR";
  ZIndexMap11[ZIndexMap11["FOREGROUND"] = 18] = "FOREGROUND";
  return ZIndexMap11;
})(ZIndexMap || {});

// packages/ag-charts-community/src/chart/axis/axisManager.ts
var AxisManager = class {
  constructor(eventsHub, sceneRoot) {
    this.eventsHub = eventsHub;
    this.sceneRoot = sceneRoot;
    this.axes = /* @__PURE__ */ new Map();
    this.axisGridGroup = new Group({ name: "Axes-Grids", zIndex: 2 /* AXIS_GRID */ });
    this.axisGroup = new Group({ name: "Axes", zIndex: 3 /* AXIS */ });
    this.axisLabelGroup = new Group({ name: "Axes-Labels", zIndex: 15 /* SERIES_LABEL */ });
    this.axisCrosslineRangeGroup = new Group({
      name: "Axes-Crosslines-Range",
      zIndex: 6 /* SERIES_CROSSLINE_RANGE */
    });
    this.axisCrosslineLineGroup = new Group({
      name: "Axes-Crosslines-Line",
      zIndex: 10 /* SERIES_CROSSLINE_LINE */
    });
    this.axisCrosslineLabelGroup = new Group({
      name: "Axes-Crosslines-Label",
      zIndex: 15 /* SERIES_LABEL */
    });
    this.sceneRoot.appendChild(this.axisGroup);
    this.sceneRoot.appendChild(this.axisGridGroup);
    this.sceneRoot.appendChild(this.axisLabelGroup);
    this.sceneRoot.appendChild(this.axisCrosslineRangeGroup);
    this.sceneRoot.appendChild(this.axisCrosslineLineGroup);
    this.sceneRoot.appendChild(this.axisCrosslineLabelGroup);
  }
  updateAxes(oldAxes, newAxes) {
    const axisNodes = {
      axisNode: this.axisGroup,
      gridNode: this.axisGridGroup,
      labelNode: this.axisLabelGroup,
      crossLineRangeNode: this.axisCrosslineRangeGroup,
      crossLineLineNode: this.axisCrosslineLineGroup,
      crossLineLabelNode: this.axisCrosslineLabelGroup
    };
    for (const axis of oldAxes) {
      if (newAxes.includes(axis))
        continue;
      axis.detachAxis(axisNodes);
      axis.destroy();
    }
    for (const axis of newAxes) {
      if (oldAxes?.includes(axis))
        continue;
      axis.attachAxis(axisNodes);
    }
    this.axes.clear();
    for (const axis of newAxes) {
      const ctx = axis.createAxisContext();
      if (this.axes.has(ctx.direction)) {
        this.axes.get(ctx.direction)?.push(ctx);
      } else {
        this.axes.set(ctx.direction, [ctx]);
      }
    }
    this.eventsHub.emit("axis:change", null);
  }
  getAxisContext(direction) {
    return this.axes.get(direction) ?? [];
  }
  destroy() {
    this.axes.clear();
    this.sceneRoot.removeChild(this.axisGroup);
    this.sceneRoot.removeChild(this.axisGridGroup);
  }
};

// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType4) => {
  ChartUpdateType4[ChartUpdateType4["FULL"] = 0] = "FULL";
  ChartUpdateType4[ChartUpdateType4["UPDATE_DATA"] = 1] = "UPDATE_DATA";
  ChartUpdateType4[ChartUpdateType4["PROCESS_DATA"] = 2] = "PROCESS_DATA";
  ChartUpdateType4[ChartUpdateType4["PROCESS_DOMAIN"] = 3] = "PROCESS_DOMAIN";
  ChartUpdateType4[ChartUpdateType4["PERFORM_LAYOUT"] = 4] = "PERFORM_LAYOUT";
  ChartUpdateType4[ChartUpdateType4["SERIES_UPDATE"] = 5] = "SERIES_UPDATE";
  ChartUpdateType4[ChartUpdateType4["PRE_SCENE_RENDER"] = 6] = "PRE_SCENE_RENDER";
  ChartUpdateType4[ChartUpdateType4["SCENE_RENDER"] = 7] = "SCENE_RENDER";
  ChartUpdateType4[ChartUpdateType4["NONE"] = 8] = "NONE";
  return ChartUpdateType4;
})(ChartUpdateType || {});

// packages/ag-charts-community/src/chart/data/dataService.ts
var DataService = class {
  constructor(eventsHub, caller, animationManager) {
    this.eventsHub = eventsHub;
    this.caller = caller;
    this.animationManager = animationManager;
    this.dispatchOnlyLatest = true;
    this.dispatchThrottle = 0;
    this.requestThrottle = 300;
    this.isLoadingInitialData = false;
    this.isLoadingData = false;
    this.freshRequests = [];
    this.requestCounter = 0;
    this.pendingData = void 0;
    this.debug = Debug.create(true, "data-model", "data-source");
    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
  }
  updateCallback(dataSourceCallback) {
    if (typeof dataSourceCallback !== "function")
      return;
    this.debug("DataService - updated data source callback");
    this.dataSourceCallback = dataSourceCallback;
    this.isLoadingInitialData = true;
    this.animationManager.skip();
    this.eventsHub.emit("data:source-change", null);
  }
  clearCallback() {
    this.dataSourceCallback = void 0;
  }
  load(params) {
    const { pendingData } = this;
    if (pendingData != null && pendingData.params.windowStart?.valueOf() === params.windowStart?.valueOf() && pendingData.params.windowEnd?.valueOf() === params.windowEnd?.valueOf()) {
      const id = this.requestCounter++;
      this.isLoadingInitialData = false;
      this.dispatch(id, pendingData.data);
      return;
    }
    this.isLoadingData = true;
    this.throttledFetch(params);
  }
  isLazy() {
    return this.dataSourceCallback != null;
  }
  isLoading() {
    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);
  }
  async getData() {
    const { latestRequest } = this;
    if (!latestRequest)
      return;
    const { params, fetchRequest } = latestRequest;
    const data = await fetchRequest;
    return { params, data };
  }
  restoreData(data) {
    this.pendingData = data;
  }
  createThrottledFetch(requestThrottle) {
    return throttle(
      (params) => this.fetch(params).catch((e) => logger_exports.error("callback failed", e)),
      requestThrottle,
      { leading: false, trailing: true }
    );
  }
  createThrottledDispatch(dispatchThrottle) {
    return throttle((id, data) => this.dispatch(id, data), dispatchThrottle, {
      leading: true,
      trailing: true
    });
  }
  dispatch(id, data) {
    this.debug(`DataService - dispatching 'data-load' | ${id}`);
    this.eventsHub.emit("data:load", { data });
  }
  async fetch(params) {
    if ("context" in this.caller) {
      params.context = this.caller.context;
    }
    const fetchRequest = Promise.resolve().then(async () => {
      if (!this.dataSourceCallback) {
        throw new Error("DataService - [dataSource.getData] callback not initialised");
      }
      const start2 = performance.now();
      const id = this.requestCounter++;
      this.debug(`DataService - requesting | ${id}`);
      let response;
      try {
        response = await this.dataSourceCallback(params);
        this.debug(`DataService - response | ${performance.now() - start2}ms | ${id}`);
      } catch (error2) {
        this.debug(`DataService - request failed | ${id}`);
        logger_exports.errorOnce(`DataService - request failed | [${error2}]`);
      }
      this.isLoadingInitialData = false;
      const requestIndex = this.freshRequests.indexOf(fetchRequest);
      if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
        this.debug(`DataService - discarding stale request | ${id}`);
        return response;
      }
      this.freshRequests = this.freshRequests.slice(requestIndex + 1);
      if (this.freshRequests.length === 0) {
        this.isLoadingData = false;
      }
      if (Array.isArray(response)) {
        this.throttledDispatch(id, response);
      } else {
        this.eventsHub.emit("data:error", null);
      }
      return response;
    });
    this.latestRequest = { params, fetchRequest };
    this.freshRequests.push(fetchRequest);
    await fetchRequest;
  }
};
__decorateClass([
  ActionOnSet({
    newValue(dispatchThrottle) {
      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
    }
  })
], DataService.prototype, "dispatchThrottle", 2);
__decorateClass([
  ActionOnSet({
    newValue(requestThrottle) {
      this.throttledFetch = this.createThrottledFetch(requestThrottle);
    }
  })
], DataService.prototype, "requestThrottle", 2);

// packages/ag-charts-community/src/chart/fonts/fontManager.ts
var FontManager = class {
  constructor(domManager, updateService) {
    this.domManager = domManager;
    this.updateService = updateService;
    this.observers = [];
  }
  updateFonts(fonts) {
    if (!fonts || fonts.size === 0)
      return;
    this.loadFonts(fonts);
    fonts.forEach((font3) => {
      this.observeFontStatus(font3);
    });
  }
  destroy() {
    for (const observer of this.observers) {
      observer.disconnect();
    }
    this.observers = [];
  }
  loadFonts(fonts) {
    const fontStrings = Array.from(fonts).map((font3) => encodeURIComponent(font3));
    const fontStyle = ":wght@100;200;300;400;500;600;700;800;900";
    const joinString = `${fontStyle}&family=`;
    const css = `@import url('https://fonts.googleapis.com/css2?family=${fontStrings.join(joinString)}${fontStyle}&display=swap');
`;
    this.domManager.addStyles(`google-font-${fontStrings.join("-")}`, css);
  }
  observeFontStatus(font3) {
    const fontCheckElement = window.document.createElement("div");
    fontCheckElement.style.setProperty("position", "absolute");
    fontCheckElement.style.setProperty("top", "0");
    fontCheckElement.style.setProperty("margin", "0");
    fontCheckElement.style.setProperty("padding", "0");
    fontCheckElement.style.setProperty("overflow", "hidden");
    fontCheckElement.style.setProperty("visibility", "hidden");
    fontCheckElement.style.setProperty("width", "auto");
    fontCheckElement.style.setProperty("max-width", "none");
    fontCheckElement.style.setProperty("font-synthesis", "none");
    fontCheckElement.style.setProperty("font-family", font3);
    fontCheckElement.style.setProperty("font-size", "16px");
    fontCheckElement.style.setProperty("white-space", "nowrap");
    fontCheckElement.textContent = "UVWxyz";
    this.domManager.addChild("canvas-container", `font-check-${encodeURIComponent(font3)}`, fontCheckElement);
    const fontCheckObserver = new ResizeObserver((entries2) => {
      const width2 = entries2?.at(0)?.contentBoxSize.at(0)?.inlineSize;
      if (width2 != null && width2 > 0) {
        CachedTextMeasurerPool.clear();
        this.updateService.update(4 /* PERFORM_LAYOUT */);
      }
    });
    fontCheckObserver.observe(fontCheckElement);
    this.observers.push(fontCheckObserver);
  }
};

// packages/ag-charts-types/src/chart/errorBarOptions.ts
var AgErrorBarSupportedSeriesTypes = ["bar", "line", "scatter"];

// packages/ag-charts-types/src/chart/navigatorOptions.ts
var __MINI_CHART_SERIES_OPTIONS = void 0;
var __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;
__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;

// packages/ag-charts-types/src/chart/themeOptions.ts
var __THEME_OVERRIDES = void 0;
var __VERIFY_THEME_OVERRIDES = void 0;
__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;

// packages/ag-charts-types/src/chart/tooltipOptions.ts
var AgTooltipAnchorToType = /* @__PURE__ */ ((AgTooltipAnchorToType2) => {
  AgTooltipAnchorToType2["POINTER"] = "pointer";
  AgTooltipAnchorToType2["NODE"] = "node";
  AgTooltipAnchorToType2["CHART"] = "chart";
  return AgTooltipAnchorToType2;
})(AgTooltipAnchorToType || {});
var AgTooltipPlacementType = /* @__PURE__ */ ((AgTooltipPlacementType2) => {
  AgTooltipPlacementType2["TOP"] = "top";
  AgTooltipPlacementType2["RIGHT"] = "right";
  AgTooltipPlacementType2["BOTTOM"] = "bottom";
  AgTooltipPlacementType2["LEFT"] = "left";
  AgTooltipPlacementType2["TOP_RIGHT"] = "top-right";
  AgTooltipPlacementType2["BOTTOM_RIGHT"] = "bottom-right";
  AgTooltipPlacementType2["BOTTOM_LEFT"] = "bottom-left";
  AgTooltipPlacementType2["TOP_LEFT"] = "top-left";
  AgTooltipPlacementType2["CENTER"] = "center";
  return AgTooltipPlacementType2;
})(AgTooltipPlacementType || {});

// packages/ag-charts-types/src/presets/gauge/commonOptions.ts
var __THEMEABLE_OPTIONS = void 0;
var __VERIFY_THEMEABLE_OPTIONS = void 0;
__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;
var __AXIS_LABEL_OPTIONS = void 0;
var __VERIFY_AXIS_LABEL_OPTIONS = void 0;
__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;

// packages/ag-charts-community/src/util/listeners.ts
var Listeners = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Map();
  }
  addListener(eventType, handler) {
    const record = { symbol: Symbol(eventType), handler };
    if (this.registeredListeners.has(eventType)) {
      this.registeredListeners.get(eventType).push(record);
    } else {
      this.registeredListeners.set(eventType, [record]);
    }
    return () => this.removeListener(record.symbol);
  }
  removeListener(eventSymbol) {
    for (const [type, listeners] of this.registeredListeners.entries()) {
      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);
      if (matchIndex >= 0) {
        listeners.splice(matchIndex, 1);
        if (listeners.length === 0) {
          this.registeredListeners.delete(type);
        }
        break;
      }
    }
  }
  dispatch(eventType, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        listener.handler(...params);
      } catch (e) {
        logger_exports.errorOnce(e);
      }
    }
  }
  getListenersByType(eventType) {
    return this.registeredListeners.get(eventType) ?? [];
  }
  destroy() {
    this.registeredListeners.clear();
  }
};

// packages/ag-charts-community/src/util/memo.ts
var memorizedFns = /* @__PURE__ */ new WeakMap();
function memo(params, fnGenerator) {
  const serialisedParams = JSON.stringify(params, null, 0);
  if (!memorizedFns.has(fnGenerator)) {
    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
  }
  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {
    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));
  }
  return memorizedFns.get(fnGenerator)?.get(serialisedParams);
}
var MemoizeNode = class {
  constructor() {
    this.weak = /* @__PURE__ */ new WeakMap();
    this.strong = /* @__PURE__ */ new Map();
    this.set = false;
    this.value = void 0;
  }
};
function simpleMemorize2(fn, cacheCallback2) {
  let root = new MemoizeNode();
  const memoised = (...p) => {
    let current = root;
    for (const param of p) {
      const target = typeof param === "object" || typeof param === "symbol" ? current.weak : current.strong;
      let next = target.get(param);
      if (next == null) {
        next = new MemoizeNode();
        target.set(param, next);
      }
      current = next;
    }
    if (current.set) {
      cacheCallback2?.("hit", fn, p);
      return current.value;
    } else {
      const out = fn(...p);
      current.set = true;
      current.value = out;
      cacheCallback2?.("miss", fn, p);
      return out;
    }
  };
  memoised.reset = () => {
    root = new MemoizeNode();
  };
  return memoised;
}
function simpleMemorize(fn, cacheCallback2) {
  const primitiveCache = /* @__PURE__ */ new Map();
  const paramsToKeys = (...params) => {
    return params.map((v) => {
      if (typeof v === "object")
        return v;
      if (typeof v === "symbol")
        return v;
      if (!primitiveCache.has(v)) {
        primitiveCache.set(v, { v });
      }
      return primitiveCache.get(v);
    });
  };
  const empty = {};
  const cache = /* @__PURE__ */ new WeakMap();
  return (...p) => {
    const keys = p.length === 0 ? [empty] : paramsToKeys(...p);
    let currentCache = cache;
    for (const key of keys.slice(0, -1)) {
      if (!currentCache.has(key)) {
        currentCache.set(key, /* @__PURE__ */ new WeakMap());
      }
      currentCache = currentCache.get(key);
    }
    const finalKey = keys.at(-1);
    let cachedValue = currentCache.get(finalKey);
    if (cachedValue) {
      cacheCallback2?.("hit", fn, p);
    } else {
      cachedValue = fn(...p);
      currentCache.set(finalKey, cachedValue);
      cacheCallback2?.("miss", fn, p);
    }
    return cachedValue;
  };
}

// packages/ag-charts-community/src/util/timeFormat.ts
var CONSTANTS = {
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
function dayOfYear(date2, startOfYear = new Date(date2.getFullYear(), 0, 1)) {
  const startOffset = date2.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date2.getTime() - startOfYear.getTime() + startOffset * 6e4;
  const timeOneDay = 36e5 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date2, startDay) {
  const startOfYear = new Date(date2.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date2.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date2) {
    return Math.floor(dayOfYear(date2, startOffset) / 7) + 1;
  }
  return 0;
}
var SUNDAY = 0;
var MONDAY = 1;
var THURSDAY = 4;
function isoWeekOfYear(date2, year = date2.getFullYear()) {
  const firstOfYear = new Date(year, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date2) {
    return Math.floor(dayOfYear(date2, startOffset) / 7) + 1;
  }
  return isoWeekOfYear(date2, year - 1);
}
function timezone(date2) {
  const offset = date2.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset);
  const sign = offset > 0 ? "-" : "+";
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, "0")}${pad(Math.floor(unsignedOffset % 60), 2, "0")}`;
}
var FORMATTERS = {
  a: (d) => CONSTANTS.shortDays[d.getDay()],
  A: (d) => CONSTANTS.days[d.getDay()],
  b: (d) => CONSTANTS.shortMonths[d.getMonth()],
  B: (d) => CONSTANTS.months[d.getMonth()],
  c: "%x, %X",
  d: (d, p) => pad(d.getDate(), 2, p ?? "0"),
  e: "%_d",
  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? "0"),
  H: (d, p) => pad(d.getHours(), 2, p ?? "0"),
  I: (d, p) => {
    const hours = d.getHours() % 12;
    return hours === 0 ? "12" : pad(hours, 2, p ?? "0");
  },
  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? "0"),
  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? "0"),
  M: (d, p) => pad(d.getMinutes(), 2, p ?? "0"),
  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? "0"),
  p: (d) => d.getHours() < 12 ? "AM" : "PM",
  Q: (d) => String(d.getTime()),
  s: (d) => String(Math.floor(d.getTime() / 1e3)),
  S: (d, p) => pad(d.getSeconds(), 2, p ?? "0"),
  u: (d) => {
    let day = d.getDay();
    if (day < 1)
      day += 7;
    return String(day % 7);
  },
  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? "0"),
  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? "0"),
  w: (d, p) => pad(d.getDay(), 2, p ?? "0"),
  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? "0"),
  x: "%-m/%-d/%Y",
  X: "%-I:%M:%S %p",
  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? "0"),
  Y: (d, p) => pad(d.getFullYear(), 4, p ?? "0"),
  Z: (d) => timezone(d),
  "%": () => "%"
};
var PADS = {
  _: " ",
  "0": "0",
  "-": ""
};
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildDateFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf("%");
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0)
      break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === "function") {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === "string") {
      const formatter2 = buildDateFormatter(maybeFormatter);
      formatParts.push([formatter2, maybePad]);
    } else {
      formatParts.push(`${maybePad ?? ""}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return (dateTime) => {
    const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
    return formatParts.map((c) => typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
  };
}

// packages/ag-charts-community/src/chart/axis/timeFormatUtil.ts
var defaultTimeFormats = {
  millisecond: "%H:%M:%S.%L",
  second: "%H:%M:%S",
  minute: "%H:%M",
  hour: "%H:%M",
  day: "%e",
  month: "%b",
  year: "%Y"
};
var hardCodedTimeFormats = {
  millisecond: "%Y %b %e %H:%M:%S.%L",
  second: "%Y %b %e %H:%M:%S",
  minute: "%Y %b %e %H:%M",
  hour: "%Y %b %e %H:%M",
  day: "%Y %b %e",
  month: "%Y %b",
  year: "%Y"
};
var FORMAT_ORDERS = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5,
  millisecond: 6
};
var MILLISECOND_FORMAT = /%[-_0]?L/;
var SECOND_FORMAT = /%[-_0]?S/;
var MINUTE_FORMAT = /%[-_0]?M/;
var HOUR_FORMAT = /%[-_0]?[HI]/;
var DAY_FORMAT = /^%[-_0]?[de]$/;
var MONTH_FORMAT = /^%[-_0]?[Bbm]$/;
var YEAR_FORMAT = /^%[-_0]?[Yy]$/;
function deriveTimeSpecifier(format, unit, truncateDate) {
  if (typeof format === "string")
    return format;
  format ?? (format = defaultTimeFormats);
  const {
    millisecond = defaultTimeFormats.millisecond,
    second = defaultTimeFormats.second,
    minute = defaultTimeFormats.minute,
    hour = defaultTimeFormats.hour,
    day = defaultTimeFormats.day,
    month = defaultTimeFormats.month,
    year = defaultTimeFormats.year
  } = format;
  const formatOrder = FORMAT_ORDERS[unit];
  const hardcodedTimeFormat = hardCodedTimeFormats[unit];
  const truncationOrder = truncateDate ? FORMAT_ORDERS[truncateDate] : -1;
  if (truncationOrder < FORMAT_ORDERS.year && formatOrder >= FORMAT_ORDERS.year && !YEAR_FORMAT.test(year) || truncationOrder < FORMAT_ORDERS.month && formatOrder >= FORMAT_ORDERS.month && !MONTH_FORMAT.test(month) || truncationOrder < FORMAT_ORDERS.day && formatOrder >= FORMAT_ORDERS.day && !DAY_FORMAT.test(day)) {
    return hardcodedTimeFormat;
  }
  let timeFormat;
  switch (unit) {
    case "year":
      return year;
    case "month":
      return truncationOrder < FORMAT_ORDERS.year ? `${month} ${year}` : month;
    case "day":
      return truncationOrder < FORMAT_ORDERS.year ? `${month} ${day} ${year}` : `${month} ${day}`;
    case "hour":
      timeFormat = hour;
      break;
    case "minute":
      timeFormat = minute;
      break;
    case "second":
      timeFormat = second;
      break;
    case "millisecond":
      timeFormat = millisecond;
      break;
    default:
      return hardcodedTimeFormat;
  }
  if (formatOrder >= FORMAT_ORDERS.hour && !HOUR_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.minute && !MINUTE_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.second && !SECOND_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.millisecond && !MILLISECOND_FORMAT.test(timeFormat)) {
    return hardcodedTimeFormat;
  }
  let dateFormat;
  if (truncationOrder < FORMAT_ORDERS.year) {
    dateFormat = `${month} ${day} ${year}`;
  } else if (truncationOrder < FORMAT_ORDERS.month) {
    dateFormat = `${month} ${day}`;
  }
  return dateFormat ? `${timeFormat} ${dateFormat}` : timeFormat;
}

// packages/ag-charts-community/src/chart/formatter/formatManager.ts
var FormatManager = class _FormatManager extends Listeners {
  constructor() {
    super(...arguments);
    this.formats = /* @__PURE__ */ new Map();
    this.dateFormatter = simpleMemorize2(
      (propertyFormatter, specifier, unit, style2, truncateDate) => {
        const mergedFormatter = _FormatManager.mergeSpecifiers(propertyFormatter, specifier) ?? defaultTimeFormats;
        return _FormatManager.getFormatter("date", mergedFormatter, unit, style2, { truncateDate });
      }
    );
    this.formatter = void 0;
  }
  static mergeSpecifiers(...specifiers) {
    let out;
    for (const specifier of specifiers) {
      if (typeof specifier === "string") {
        out = specifier;
      } else if (isPlainObject(specifier)) {
        out = isPlainObject(out) ? { ...out, ...specifier } : specifier;
      }
    }
    return out;
  }
  static getFormatter(type, specifier, unit, style2 = "long", { truncateDate } = {}) {
    if (isPlainObject(specifier)) {
      if (type !== "date") {
        logger_exports.warn("Date formatter configuration is not supported for non-date types.");
        return;
      }
      unit ?? (unit = "millisecond");
      const fullFormat = style2 === "component" ? specifier?.[unit] ?? defaultTimeFormats[unit] : deriveTimeSpecifier(specifier, unit, truncateDate);
      return buildDateFormatter(fullFormat);
    }
    switch (type) {
      case "number": {
        const options = parseNumberFormat(specifier);
        if (options == null)
          return;
        return createNumberFormatter(options);
      }
      case "date":
        return buildDateFormatter(specifier);
      case "category":
        return (value) => specifier.replace("%s", String(value));
    }
  }
  setFormatter(formatter2) {
    if (this.formatter !== formatter2) {
      this.formatter = formatter2;
      this.formats.clear();
      this.dateFormatter.reset();
      this.dispatch("format-changed");
    }
  }
  format(formatInContext, params, { specifier, truncateDate } = {}) {
    if (params.value == null)
      return;
    const { formatter: formatter2 } = this;
    if (formatter2 == null)
      return;
    if (typeof formatter2 === "function") {
      const value = formatInContext(formatter2, params);
      return value != null ? String(value) : void 0;
    }
    const propertyFormatter = formatter2[params.property];
    if (propertyFormatter == null)
      return;
    if (typeof propertyFormatter === "function") {
      const value = formatInContext(propertyFormatter, params);
      return value != null ? String(value) : void 0;
    } else if (params.type === "date") {
      const { unit, style: style2 } = params;
      const dateFormatter = this.dateFormatter(propertyFormatter, specifier, unit, style2, truncateDate);
      return dateFormatter?.(params.value);
    }
    const valueSpecifier = specifier ?? propertyFormatter;
    if (typeof valueSpecifier !== "string")
      return;
    let valueFormatter = this.formats.get(valueSpecifier);
    if (valueFormatter == null) {
      valueFormatter = _FormatManager.getFormatter(params.type, valueSpecifier);
      this.formats.set(valueSpecifier, valueFormatter);
    }
    return valueFormatter?.(params.value, params.type === "number" ? params.fractionDigits : void 0);
  }
  defaultFormat(params, { specifier, truncateDate } = {}) {
    const { formatter: formatter2 } = this;
    const propertyFormatter = typeof formatter2 === "function" ? void 0 : formatter2?.[params.property];
    switch (params.type) {
      case "date": {
        const { unit, style: style2 } = params;
        const propertySpecifier = propertyFormatter != null && typeof propertyFormatter !== "function" ? propertyFormatter : void 0;
        const dateFormatter = this.dateFormatter(propertySpecifier, specifier, unit, style2, truncateDate);
        return dateFormatter?.(params.value) ?? String(params.value);
      }
      case "number":
        return formatValue(params.value, params.fractionDigits);
      case "category":
        if (Array.isArray(params.value)) {
          return params.value.join(" - ");
        } else if (typeof params.value === "string") {
          return params.value;
        } else if (typeof params.value === "number") {
          return formatValue(params.value);
        } else {
          return String(params.value);
        }
    }
  }
};

// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
  return (d) => Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
  if (typeof a === "string") {
    try {
      a = Color.fromString(a);
    } catch {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === "string") {
    try {
      b = Color.fromString(b);
    } catch {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  return (d) => Color.mix(a, b, d).toRgbaString();
}

// packages/ag-charts-community/src/motion/easing.ts
var easing_exports = {};
__export(easing_exports, {
  easeIn: () => easeIn,
  easeInOut: () => easeInOut,
  easeInOutQuad: () => easeInOutQuad,
  easeInQuad: () => easeInQuad,
  easeOut: () => easeOut,
  easeOutQuad: () => easeOutQuad,
  inverseEaseOut: () => inverseEaseOut,
  linear: () => linear
});
var linear = (n) => n;
var easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);
var easeOut = (n) => Math.sin(n * Math.PI / 2);
var easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;
var easeInQuad = (n) => n * n;
var easeOutQuad = (n) => 1 - (1 - n) ** 2;
var easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;
var inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;

// packages/ag-charts-community/src/motion/animation.ts
var QUICK_TRANSITION = 0.2;
var PHASE_ORDER = ["initial", "remove", "update", "add", "trailing", "end", "none"];
var PHASE_METADATA = {
  initial: {
    animationDuration: 1,
    animationDelay: 0
  },
  add: {
    animationDuration: 0.25,
    animationDelay: 0.75
  },
  remove: {
    animationDuration: 0.25,
    animationDelay: 0
  },
  update: {
    animationDuration: 0.5,
    animationDelay: 0.25
  },
  trailing: {
    animationDuration: QUICK_TRANSITION,
    animationDelay: 1,
    skipIfNoEarlierAnimations: true
  },
  end: {
    animationDelay: 1 + QUICK_TRANSITION,
    animationDuration: 0,
    skipIfNoEarlierAnimations: true
  },
  none: {
    animationDuration: 0,
    animationDelay: 0
  }
};
var RepeatType = /* @__PURE__ */ ((RepeatType2) => {
  RepeatType2["Loop"] = "loop";
  RepeatType2["Reverse"] = "reverse";
  return RepeatType2;
})(RepeatType || {});
function isNodeArray(array2) {
  return array2.every((n) => n instanceof Node2);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };
}
function animationValuesEqual(a, b) {
  if (a === b) {
    return true;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));
  } else if (isInterpolating(a) && isInterpolating(b)) {
    return a.equals(b);
  } else if (isPlainObject(a) && isPlainObject(b)) {
    return objectsEqualWith(a, b, animationValuesEqual);
  }
  return false;
}
var Animation = class {
  constructor(opts) {
    this.isComplete = false;
    this.elapsed = 0;
    this.iteration = 0;
    this.isPlaying = false;
    this.isReverse = false;
    this.id = opts.id;
    this.groupId = opts.groupId;
    this.autoplay = opts.autoplay ?? true;
    this.ease = opts.ease ?? linear;
    this.phase = opts.phase;
    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;
    this.duration = durationProportion * opts.defaultDuration;
    this.delay = (opts.delay ?? 0) * opts.defaultDuration;
    this.onComplete = opts.onComplete;
    this.onPlay = opts.onPlay;
    this.onStop = opts.onStop;
    this.onUpdate = opts.onUpdate;
    this.interpolate = this.createInterpolator(opts.from, opts.to);
    this.from = opts.from;
    if (opts.skip === true) {
      this.onUpdate?.(opts.to, false, this);
      this.onStop?.(this);
      this.onComplete?.(this);
      this.isComplete = true;
    }
    if (opts.collapsable !== false) {
      this.duration = this.checkCollapse(opts, this.duration);
    }
  }
  checkCollapse(opts, calculatedDuration) {
    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;
  }
  play(initialUpdate = false) {
    if (this.isPlaying || this.isComplete)
      return;
    this.isPlaying = true;
    this.onPlay?.(this);
    if (!this.autoplay)
      return;
    this.autoplay = false;
    if (!initialUpdate)
      return;
    this.onUpdate?.(this.from, true, this);
  }
  stop() {
    this.isPlaying = false;
    if (!this.isComplete) {
      this.isComplete = true;
      this.onStop?.(this);
    }
  }
  update(time3) {
    if (this.isComplete)
      return time3;
    if (!this.isPlaying && this.autoplay) {
      this.play(true);
    }
    const previousElapsed = this.elapsed;
    this.elapsed += time3;
    if (this.delay > this.elapsed)
      return 0;
    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
    this.onUpdate?.(value, false, this);
    const totalDuration = this.delay + this.duration;
    if (this.elapsed >= totalDuration) {
      this.stop();
      this.isComplete = true;
      this.onComplete?.(this);
      return time3 - (totalDuration - previousElapsed);
    }
    return 0;
  }
  get delta() {
    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));
  }
  createInterpolator(from3, to) {
    if (typeof to !== "object" || isInterpolating(to)) {
      return this.interpolateValue(from3, to);
    }
    const interpolatorEntries = [];
    for (const key of Object.keys(to)) {
      const interpolator = this.interpolateValue(from3[key], to[key]);
      if (interpolator != null) {
        interpolatorEntries.push([key, interpolator]);
      }
    }
    return (d) => {
      const result = {};
      for (const [key, interpolator] of interpolatorEntries) {
        result[key] = interpolator(d);
      }
      return result;
    };
  }
  interpolateValue(a, b) {
    if (a == null || b == null) {
      return;
    } else if (isInterpolating(a)) {
      return (d) => a[interpolate](b, d);
    }
    try {
      switch (typeof a) {
        case "number":
          return interpolateNumber(a, b);
        case "string":
          return interpolateColor(a, b);
        case "boolean":
          if (a === b) {
            return () => a;
          }
          break;
        case "object":
          return () => a;
        default:
          throw new Error(`Unable to interpolate values: ${a}, ${b}`);
      }
    } catch {
    }
    throw new Error(`Unable to interpolate values: ${a}, ${b}`);
  }
};

// packages/ag-charts-community/src/chart/interaction/animationBatch.ts
var AnimationBatch = class {
  constructor(maxAnimationTime) {
    this.maxAnimationTime = maxAnimationTime;
    this.debug = Debug.create(true, "animation");
    this.controllers = /* @__PURE__ */ new Map();
    this.stoppedCbs = /* @__PURE__ */ new Set();
    this.currentPhase = 0;
    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));
    this.skipAnimations = false;
    this.animationTimeConsumed = 0;
    /** Guard against premature animation execution. */
    this.isReady = false;
  }
  get size() {
    return this.controllers.size;
  }
  get consumedTimeMs() {
    return this.animationTimeConsumed;
  }
  isActive() {
    return this.controllers.size > 0;
  }
  getActiveControllers() {
    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];
  }
  checkOverlappingId(id) {
    if (id != null && this.controllers.has(id)) {
      this.controllers.get(id).stop();
      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);
      this.skip();
    }
  }
  addAnimation(animation) {
    if (animation.isComplete)
      return;
    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);
    if (animationPhaseIdx < this.currentPhase) {
      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);
      animation.stop();
      return;
    }
    this.controllers.set(animation.id, animation);
    this.phases.get(animation.phase)?.push(animation);
  }
  removeAnimation(animation) {
    this.controllers.delete(animation.id);
    const phase = this.phases.get(animation.phase);
    const index = phase?.indexOf(animation);
    if (index != null && index >= 0) {
      phase?.splice(index, 1);
    }
  }
  progress(deltaTime) {
    if (!this.isReady)
      return;
    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
    const refresh = () => {
      const phase2 = PHASE_ORDER[this.currentPhase];
      return {
        phaseControllers: [...this.getActiveControllers()],
        phase: phase2,
        phaseMeta: PHASE_METADATA[phase2]
      };
    };
    let { phase, phaseControllers, phaseMeta } = refresh();
    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;
    const progressPhase = () => {
      ({ phase, phaseControllers, phaseMeta } = refresh());
      while (!arePhasesComplete() && phaseControllers.length === 0) {
        this.currentPhase++;
        ({ phase, phaseControllers, phaseMeta } = refresh());
        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);
      }
    };
    const total = this.controllers.size;
    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);
    do {
      const phaseDeltaTime = unusedTime;
      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;
      let completeCount = 0;
      for (const controller of phaseControllers) {
        if (skipPhase) {
          controller.stop();
        } else {
          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
        }
        if (controller.isComplete) {
          completeCount++;
          this.removeAnimation(controller);
        }
      }
      this.animationTimeConsumed += phaseDeltaTime - unusedTime;
      this.debug(
        `AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`,
        phaseControllers
      );
      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);
      progressPhase();
    } while (unusedTime > 0 && !arePhasesComplete());
    if (this.animationTimeConsumed > this.maxAnimationTime) {
      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);
      this.stop();
    }
  }
  ready() {
    if (this.isReady)
      return;
    this.isReady = true;
    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);
    let skipAll = true;
    for (const [, controller] of this.controllers) {
      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {
        skipAll = false;
        break;
      }
    }
    if (!skipAll) {
      for (const [, controller] of this.controllers) {
        if (controller.autoplay) {
          controller.play(true);
        }
      }
    }
  }
  skip(skip = true) {
    if (this.skipAnimations === false && skip === true) {
      for (const controller of this.controllers.values()) {
        controller.stop();
      }
      this.controllers.clear();
    }
    this.skipAnimations = skip;
  }
  play() {
    for (const controller of this.controllers.values()) {
      controller.play();
    }
  }
  stop() {
    for (const controller of this.controllers.values()) {
      try {
        controller.stop();
        this.removeAnimation(controller);
      } catch (error2) {
        logger_exports.error("Error during animation stop", error2);
      }
    }
    this.dispatchStopped();
  }
  stopByAnimationId(id) {
    if (id != null && this.controllers.has(id)) {
      const controller = this.controllers.get(id);
      if (controller) {
        controller.stop();
        this.removeAnimation(controller);
      }
    }
  }
  stopByAnimationGroupId(id) {
    for (const controller of this.controllers.values()) {
      if (controller.groupId === id) {
        this.stopByAnimationId(controller.id);
      }
    }
  }
  dispatchStopped() {
    this.stoppedCbs.forEach((cb) => cb());
    this.stoppedCbs.clear();
  }
  isSkipped() {
    return this.skipAnimations;
  }
  getRemainingTime(restrictPhase) {
    if (!this.isActive())
      return 0;
    let total = 0;
    for (const [phase, controllers] of this.phases) {
      if (controllers.length === 0)
        continue;
      if (restrictPhase != null && restrictPhase !== phase)
        continue;
      total += Math.max(...controllers.map((c) => c.isComplete ? 0 : c.delay + c.duration - (c.elapsed ?? 0)));
    }
    return total;
  }
  destroy() {
    this.stop();
    this.controllers.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var InteractionState = /* @__PURE__ */ ((InteractionState6) => {
  InteractionState6[InteractionState6["Default"] = 32] = "Default";
  InteractionState6[InteractionState6["ZoomDrag"] = 16] = "ZoomDrag";
  InteractionState6[InteractionState6["Annotations"] = 8] = "Annotations";
  InteractionState6[InteractionState6["ContextMenu"] = 4] = "ContextMenu";
  InteractionState6[InteractionState6["Animation"] = 2] = "Animation";
  InteractionState6[InteractionState6["AnnotationsSelected"] = 1] = "AnnotationsSelected";
  InteractionState6[InteractionState6["Clickable"] = 41] = "Clickable";
  InteractionState6[InteractionState6["Focusable"] = 34] = "Focusable";
  InteractionState6[InteractionState6["Keyable"] = 43] = "Keyable";
  InteractionState6[InteractionState6["ContextMenuable"] = 36] = "ContextMenuable";
  InteractionState6[InteractionState6["AnnotationsMoveable"] = 9] = "AnnotationsMoveable";
  InteractionState6[InteractionState6["AnnotationsDraggable"] = 57] = "AnnotationsDraggable";
  InteractionState6[InteractionState6["ZoomDraggable"] = 50] = "ZoomDraggable";
  InteractionState6[InteractionState6["ZoomClickable"] = 34] = "ZoomClickable";
  InteractionState6[InteractionState6["ZoomWheelable"] = 59] = "ZoomWheelable";
  InteractionState6[InteractionState6["All"] = 63] = "All";
  return InteractionState6;
})(InteractionState || {});
var InteractionManager = class {
  constructor() {
    this.stateQueue = 32 /* Default */ | 2 /* Animation */;
  }
  pushState(state) {
    this.stateQueue |= state;
  }
  popState(state) {
    this.stateQueue &= ~state;
  }
  isState(allowedStates) {
    return !!(this.stateQueue & -this.stateQueue & allowedStates);
  }
};

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
function validAnimationDuration(testee) {
  if (testee == null)
    return true;
  return !isNaN(testee) && testee >= 0 && testee <= 2;
}
var AnimationManager = class {
  constructor(interactionManager, chartUpdateMutex) {
    this.interactionManager = interactionManager;
    this.chartUpdateMutex = chartUpdateMutex;
    this.defaultDuration = 1e3;
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    this.debug = Debug.create(true, "animation");
    this.events = new EventEmitter();
    this.rafAvailable = typeof requestAnimationFrame !== "undefined";
    this.isPlaying = true;
    this.requestId = null;
    this.skipAnimations = true;
    this.currentAnonymousAnimationId = 0;
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  /**
   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
   * with the same `id`, immediately stop it.
   */
  animate(opts) {
    const batch = this.batch;
    try {
      batch.checkOverlappingId(opts.id);
    } catch (error2) {
      this.failsafeOnError(error2);
      return;
    }
    let { id } = opts;
    if (id == null) {
      id = `__${this.currentAnonymousAnimationId}`;
      this.currentAnonymousAnimationId += 1;
    }
    const skip = this.isSkipped() || opts.phase === "none";
    if (skip) {
      this.debug("AnimationManager - skipping animation");
    }
    const { delay, duration } = opts;
    if (!validAnimationDuration(delay)) {
      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);
    }
    if (!validAnimationDuration(duration)) {
      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);
    }
    const animation = new Animation({
      ...opts,
      id,
      skip,
      autoplay: this.isPlaying ? opts.autoplay : false,
      phase: opts.phase,
      defaultDuration: this.defaultDuration
    });
    if (this.forceTimeJump(animation, this.defaultDuration)) {
      return;
    }
    this.batch.addAnimation(animation);
    return animation;
  }
  play() {
    if (this.isPlaying) {
      return;
    }
    this.isPlaying = true;
    this.debug("AnimationManager.play()");
    try {
      this.batch.play();
    } catch (error2) {
      this.failsafeOnError(error2);
    }
    this.requestAnimation();
  }
  stop() {
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.stop()");
    this.batch.stop();
  }
  stopByAnimationId(id) {
    try {
      this.batch.stopByAnimationId(id);
    } catch (error2) {
      this.failsafeOnError(error2);
    }
  }
  stopByAnimationGroupId(id) {
    try {
      this.batch.stopByAnimationGroupId(id);
    } catch (error2) {
      this.failsafeOnError(error2);
    }
  }
  reset() {
    if (this.isPlaying) {
      this.stop();
      this.play();
    } else {
      this.stop();
    }
  }
  skip(skip = true) {
    this.skipAnimations = skip;
  }
  isSkipped() {
    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
  }
  isActive() {
    return this.isPlaying && this.batch.isActive();
  }
  getRemainingTime(phase) {
    return this.batch.getRemainingTime(phase);
  }
  skipCurrentBatch() {
    if (this.debug.check()) {
      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });
    }
    this.batch.skip();
  }
  /** Mocking point for tests to guarantee that animation updates happen. */
  isSkippingFrames() {
    return true;
  }
  /** Mocking point for tests to capture requestAnimationFrame callbacks. */
  scheduleAnimationFrame(cb) {
    this.requestId = getWindow().requestAnimationFrame((t) => {
      cb(t).catch((e) => logger_exports.error(e));
    });
  }
  /** Mocking point for tests to skip animations to a specific point in time. */
  forceTimeJump(_animation, _defaultDuration) {
    return false;
  }
  requestAnimation() {
    if (!this.rafAvailable)
      return;
    if (!this.batch.isActive() || this.requestId !== null)
      return;
    let prevTime;
    const onAnimationFrame = async (time3) => {
      await this.debug.group("AnimationManager.onAnimationFrame()", async () => {
        const executeAnimationFrame = () => {
          const deltaTime = time3 - (prevTime ?? time3);
          prevTime = time3;
          this.debug("AnimationManager", {
            controllersCount: this.batch.size,
            deltaTime
          });
          this.interactionManager.pushState(2 /* Animation */);
          try {
            this.batch.progress(deltaTime);
          } catch (error2) {
            this.failsafeOnError(error2);
          }
          this.events.emit("animation-frame", {
            type: "animation-frame",
            deltaMs: deltaTime
          });
        };
        if (this.isSkippingFrames()) {
          await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
        } else {
          await this.chartUpdateMutex.acquire(executeAnimationFrame);
        }
        if (this.batch.isActive()) {
          this.scheduleAnimationFrame(onAnimationFrame);
        } else {
          this.batch.stop();
          this.events.emit("animation-stop", {
            type: "animation-stop",
            deltaMs: this.batch.consumedTimeMs
          });
        }
      });
    };
    this.events.emit("animation-start", {
      type: "animation-start",
      deltaMs: 0
    });
    this.scheduleAnimationFrame(onAnimationFrame);
  }
  cancelAnimation() {
    if (this.requestId === null)
      return;
    cancelAnimationFrame(this.requestId);
    this.events.emit("animation-stop", {
      type: "animation-stop",
      deltaMs: this.batch.consumedTimeMs
    });
    this.requestId = null;
    this.startBatch();
  }
  failsafeOnError(error2, cancelAnimation = true) {
    logger_exports.error("Error during animation, skipping animations", error2);
    if (cancelAnimation) {
      this.cancelAnimation();
    }
  }
  startBatch(skipAnimations) {
    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);
    this.reset();
    this.batch.destroy();
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    if (skipAnimations === true) {
      this.batch.skip();
    }
  }
  endBatch() {
    if (this.batch.isActive()) {
      this.batch.ready();
      this.requestAnimation();
    } else {
      this.interactionManager.popState(2 /* Animation */);
      if (this.batch.isSkipped()) {
        this.batch.skip(false);
      }
    }
  }
  onBatchStop(cb) {
    this.batch.stoppedCbs.add(cb);
  }
  destroy() {
    this.stop();
    this.events.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuTypes.ts
var ContextMenuBuiltinItems = class {
  constructor() {
    this.download = {
      type: "action",
      showOn: "always",
      label: "contextMenuDownload",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["zoom-to-cursor"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuZoomToCursor",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["pan-to-cursor"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuPanToCursor",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["reset-zoom"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuResetZoom",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["toggle-series-visibility"] = {
      type: "action",
      showOn: "legend-item",
      label: "contextMenuToggleSeriesVisibility",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["toggle-other-series"] = {
      type: "action",
      showOn: "legend-item",
      label: "contextMenuToggleOtherSeries",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["separator"] = {
      type: "separator",
      showOn: "always",
      label: "separator",
      enabled: true,
      action: void 0,
      items: void 0
    };
  }
};
var ContextMenuBuiltinItemLists = class {
  constructor() {
    this.defaults = [
      "download",
      "zoom-to-cursor",
      "pan-to-cursor",
      "reset-zoom",
      "toggle-series-visibility",
      "toggle-other-series"
    ];
  }
};
var ContextMenuBuiltins = class {
  constructor() {
    this.items = new ContextMenuBuiltinItems();
    this.lists = new ContextMenuBuiltinItemLists();
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.builtins = new ContextMenuBuiltins();
    this.hiddenActions = /* @__PURE__ */ new Set();
    this.setVisible("zoom-to-cursor", false);
    this.setVisible("pan-to-cursor", false);
    this.setVisible("reset-zoom", false);
  }
  static check(showOn, event) {
    return event.showOn == showOn;
  }
  static checkCallback(desiredShowOn, showOn, _callback) {
    return desiredShowOn === showOn;
  }
  dispatchContext(showOn, pointerEvent, context, position) {
    const { widgetEvent } = pointerEvent;
    if (widgetEvent.sourceEvent.defaultPrevented) {
      return;
    }
    const x = position?.x ?? pointerEvent.canvasX;
    const y = position?.y ?? pointerEvent.canvasY;
    const event = { showOn, x, y, context, widgetEvent };
    this.eventsHub.emit("context-menu:setup", event);
    this.eventsHub.emit("context-menu:complete", event);
  }
  isVisible(id) {
    return !this.hiddenActions.has(id);
  }
  setVisible(id, visible) {
    if (visible) {
      this.hiddenActions.delete(id);
    } else {
      this.hiddenActions.add(id);
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.highlightStates = new StateTracker();
  }
  updateHighlight(callerId, highlightedDatum) {
    const previousHighlight = this.getActiveHighlight();
    this.highlightStates.set(callerId, highlightedDatum);
    const currentHighlight = this.getActiveHighlight();
    if (!this.isEqual(currentHighlight, previousHighlight)) {
      this.eventsHub.emit("highlight:change", { callerId, currentHighlight, previousHighlight });
    }
  }
  getActiveHighlight() {
    return this.highlightStates.stateValue();
  }
  isEqual(a, b) {
    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;
  }
};

// packages/ag-charts-community/src/chart/series/util.ts
function datumBoundaryPoints(datum, domain) {
  if (datum == null || domain.length === 0) {
    return [false, false];
  }
  const datumValue = datum.valueOf();
  const d0 = domain[0];
  const d1 = domain[domain.length - 1];
  if (typeof d0 === "string") {
    return [datumValue === d0, datumValue === d1];
  }
  let min = d0.valueOf();
  let max = d1.valueOf();
  if (min > max) {
    [min, max] = [max, min];
  }
  return [datumValue === min, datumValue === max];
}
function datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain) {
  const [min, max] = datumBoundaryPoints(yValue, yDomain);
  const [first2, last] = datumBoundaryPoints(xValue2, xDomain);
  return {
    xKey,
    yKey,
    xValue: xValue2,
    yValue,
    first: first2,
    last,
    min,
    max
  };
}
function visibleRangeIndices(sortOrder, length2, [range0, range1], xRange) {
  let xMinIndex = findMinIndex(0, length2 - 1, (i) => {
    const index = sortOrder === 1 ? i : length2 - i;
    const x1 = xRange(index)?.[1] ?? NaN;
    return !Number.isFinite(x1) || x1 > range0;
  }) ?? 0;
  let xMaxIndex = findMaxIndex(0, length2 - 1, (i) => {
    const index = sortOrder === 1 ? i : length2 - i;
    const x0 = xRange(index)?.[0] ?? NaN;
    return !Number.isFinite(x0) || x0 < range1;
  }) ?? length2 - 1;
  if (sortOrder === -1) {
    [xMinIndex, xMaxIndex] = [length2 - xMaxIndex, length2 - xMinIndex];
  }
  xMinIndex = Math.max(xMinIndex, 0);
  xMaxIndex = Math.min(xMaxIndex + 1, length2);
  return [xMinIndex, xMaxIndex];
}
function getDatumRefPoint(series, datum, movedBounds) {
  if (movedBounds) {
    const { x, y, width: width2, height: height2 } = movedBounds;
    return { canvasX: x + width2 / 2, canvasY: y + height2 / 2 };
  }
  const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? series.datumMidPoint?.(datum);
  if (refPoint) {
    const { x, y } = Transformable.toCanvasPoint(series.contentGroup, refPoint.x, refPoint.y);
    return { canvasX: Math.round(x), canvasY: Math.round(y) };
  }
}
function countExpandingSearch(min, max, start2, countUntil, iteratee) {
  let i = -1;
  let count = 0;
  let shift = 0;
  let reachedAnEnd = false;
  while (count < countUntil && i <= max - min) {
    i += 1;
    const index = start2 + shift;
    if (!reachedAnEnd)
      shift *= -1;
    if (shift >= 0)
      shift += 1;
    if (reachedAnEnd && shift < 0)
      shift -= 1;
    if (index < min || index > max) {
      reachedAnEnd = true;
      continue;
    }
    if (iteratee(index))
      count += 1;
  }
  return count;
}

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var TooltipManager = class {
  constructor(eventsHub, localeManager, domManager, tooltip) {
    this.domManager = domManager;
    this.tooltip = tooltip;
    this.stateTracker = new StateTracker();
    this.suppressState = new StateTracker(false);
    this.appliedState = null;
    this.cleanup = new CleanupRegistry();
    this.cleanup.register(
      tooltip.setup(localeManager, domManager),
      eventsHub.on("dom:hidden", () => this.tooltip.hide())
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  updateTooltip(callerId, meta, content, pagination) {
    content ?? (content = this.stateTracker.get(callerId)?.content);
    this.stateTracker.set(callerId, { meta, content, pagination });
    this.applyStates();
  }
  removeTooltip(callerId) {
    this.stateTracker.delete(callerId);
    this.applyStates();
  }
  suppressTooltip(callerId) {
    this.suppressState.set(callerId, true);
  }
  unsuppressTooltip(callerId) {
    this.suppressState.delete(callerId);
  }
  applyStates() {
    const id = this.stateTracker.stateId();
    const state = id ? this.stateTracker.get(id) : void 0;
    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {
      this.appliedState = null;
      this.tooltip.hide();
      return;
    }
    const canvasRect = this.domManager.getBoundingClientRect();
    const boundingRect = this.tooltip.bounds === "extended" ? this.domManager.getOverlayClientRect() : canvasRect;
    if (objectsEqual(this.appliedState?.content, state?.content) && objectsEqual(this.appliedState?.pagination, state?.pagination)) {
      const renderInstantly = this.tooltip.isVisible();
      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, void 0, renderInstantly);
    } else {
      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content, state?.pagination);
    }
    this.appliedState = state;
  }
  static makeTooltipMeta(event, series, datum, movedBounds) {
    const { canvasX, canvasY } = event;
    const tooltip = series.properties.tooltip;
    const { placement, anchorTo, xOffset, yOffset } = tooltip.position;
    const refPoint = getDatumRefPoint(series, datum, movedBounds);
    const meta = {
      canvasX,
      canvasY,
      nodeCanvasX: refPoint?.canvasX ?? canvasX,
      nodeCanvasY: refPoint?.canvasY ?? canvasY,
      enableInteraction: tooltip.interaction?.enabled ?? false,
      showArrow: tooltip.showArrow,
      position: {
        placement,
        anchorTo,
        xOffset,
        yOffset
      }
    };
    return meta;
  }
};

// packages/ag-charts-community/src/chart/interaction/dragInterpreter.ts
var DRAG_THRESHOLD_PX = 3;
var DOUBLE_TAP_TIMER_MS = 505;
var DOUBLE_TAP_THRESHOLD_PX = 30;
function makeSynthetic(type, event) {
  const { device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent } = event;
  return { type, device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };
}
function checkDragDistance(dx2, dy2) {
  const distanceSquared2 = dx2 * dx2 + dy2 * dy2;
  const thresholdSquared = DRAG_THRESHOLD_PX * DRAG_THRESHOLD_PX;
  return distanceSquared2 >= thresholdSquared;
}
function checkDoubleTapDistance(t1, t2) {
  const dx2 = t1.clientX - t2.clientX;
  const dy2 = t1.clientY - t2.clientY;
  const distanceSquared2 = dx2 * dx2 + dy2 * dy2;
  const thresholdSquared = DOUBLE_TAP_THRESHOLD_PX * DOUBLE_TAP_THRESHOLD_PX;
  return distanceSquared2 < thresholdSquared;
}
var DragInterpreter = class {
  constructor(widget) {
    this.cleanup = new CleanupRegistry();
    this.events = new EventEmitter();
    this.isDragging = false;
    this.touch = { distanceTravelledX: 0, distanceTravelledY: 0, clientX: 0, clientY: 0 };
    this.cleanup.register(
      widget.addListener("touchstart", this.onTouchStart.bind(this)),
      widget.addListener("touchmove", this.onTouchMove.bind(this)),
      widget.addListener("touchend", this.onTouchEnd.bind(this)),
      widget.addListener("mousemove", this.onMouseMove.bind(this)),
      widget.addListener("dblclick", this.onDblClick.bind(this)),
      widget.addListener("drag-start", this.onDragStart.bind(this)),
      widget.addListener("drag-move", this.onDragMove.bind(this)),
      widget.addListener("drag-end", this.onDragEnd.bind(this))
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  onTouchStart(e) {
    const { clientX, clientY } = e.sourceEvent.targetTouches[0] ?? { clientX: Infinity, clientY: Infinity };
    this.touch.distanceTravelledX = 0;
    this.touch.distanceTravelledY = 0;
    this.touch.clientX = clientX;
    this.touch.clientY = clientY;
  }
  onTouchMove(e) {
    const { clientX, clientY } = e.sourceEvent.targetTouches[0] ?? { clientX: Infinity, clientY: Infinity };
    this.touch.distanceTravelledX += Math.abs(this.touch.clientX - clientX);
    this.touch.distanceTravelledY += Math.abs(this.touch.clientY - clientY);
    this.touch.clientX = clientX;
    this.touch.clientY = clientY;
  }
  onTouchEnd(event) {
    event.sourceEvent.preventDefault();
  }
  onMouseMove(event) {
    this.events.emit("mousemove", event);
  }
  onDblClick(event) {
    this.events.emit("dblclick", event);
  }
  onDragStart(event) {
    this.dragStartEvent = event;
  }
  onDragMove(event) {
    if (this.dragStartEvent != null) {
      if (checkDragDistance(event.originDeltaX, event.originDeltaY)) {
        this.events.emit("drag-start", this.dragStartEvent);
        this.events.emit("drag-move", { ...this.dragStartEvent, type: "drag-move" });
        this.dragStartEvent = void 0;
        this.isDragging = true;
      }
    }
    if (this.isDragging) {
      this.events.emit("drag-move", event);
    }
  }
  onDragEnd(event) {
    if (this.isDragging) {
      this.events.emit("drag-end", event);
      this.isDragging = false;
      return;
    }
    if (event.device === "mouse") {
      const click = makeSynthetic("click", event);
      this.events.emit("click", click);
    } else if (event.sourceEvent.type === "touchend") {
      if (checkDragDistance(this.touch.distanceTravelledX, this.touch.distanceTravelledY)) {
        return;
      }
      const click = makeSynthetic("click", event);
      this.events.emit("click", click);
      const now = Date.now();
      if (this.lastClick !== void 0 && now - this.lastClick.time <= DOUBLE_TAP_TIMER_MS && checkDoubleTapDistance(this.lastClick, event)) {
        const dblClick = makeSynthetic("dblclick", event);
        this.events.emit("dblclick", dblClick);
        this.lastClick = void 0;
      } else {
        this.lastClick = { time: now, clientX: event.clientX, clientY: event.clientY };
      }
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/widgetSet.ts
var DOMManagerWidget = class extends NativeWidget {
  constructor(elem) {
    super(elem);
  }
  addChildToDOM() {
  }
  removeChildFromDOM() {
  }
};
var WidgetSet = class {
  constructor(domManager, opts) {
    this.seriesWidget = new DOMManagerWidget(domManager.getParent("series-area"));
    this.chartWidget = new DOMManagerWidget(domManager.getParent("canvas-proxy"));
    this.containerWidget = new DOMManagerWidget(domManager.getParent("canvas-container"));
    this.containerWidget.addChild(this.chartWidget);
    this.chartWidget.addChild(this.seriesWidget);
    if (opts.withDragInterpretation) {
      this.seriesDragInterpreter = new DragInterpreter(this.seriesWidget);
    }
  }
  destroy() {
    this.seriesDragInterpreter?.destroy();
    this.seriesWidget.destroy();
    this.chartWidget.destroy();
    this.containerWidget.destroy();
  }
};

// packages/ag-charts-community/src/util/number.ts
function clampArray(value, array2) {
  const [min, max] = findMinMax(array2);
  return clamp(min, value, max);
}
function findMinMax(array2) {
  if (array2.length === 0)
    return [];
  const result = [Infinity, -Infinity];
  for (const val of array2) {
    if (val < result[0])
      result[0] = val;
    if (val > result[1])
      result[1] = val;
  }
  return result;
}
function findRangeExtent(array2) {
  const [min, max] = findMinMax(array2);
  return max - min;
}
function nextPowerOf2(value) {
  value = value | 0;
  if (value <= 0)
    return 1;
  if (value === 1)
    return 2;
  return 1 << 32 - Math.clz32(value - 1);
}
function previousPowerOf2(value) {
  value = value | 0;
  if (value <= 0)
    return 0;
  if (value === 1)
    return 1;
  return 1 << 31 - Math.clz32(value);
}

// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale = class _ContinuousScale extends AbstractScale {
  constructor(domain = [], range4 = []) {
    super();
    this.domain = domain;
    this.range = range4;
    this.defaultTickCount = _ContinuousScale.defaultTickCount;
    this.defaultClamp = false;
  }
  static is(value) {
    return value instanceof _ContinuousScale;
  }
  normalizeDomains(...domains) {
    return normalizeContinuousDomains(...domains);
  }
  calcBandwidth(smallestInterval = 1, minWidth = 1) {
    const { domain } = this;
    const rangeDistance = this.getPixelRange();
    if (domain.length === 0)
      return rangeDistance;
    const intervals = Math.abs(domain[1].valueOf() - domain[0].valueOf()) / smallestInterval + 1;
    let bands = intervals;
    if (minWidth !== 0) {
      const maxBands = Math.floor(rangeDistance);
      bands = Math.min(bands, maxBands);
    }
    return rangeDistance / Math.max(1, bands);
  }
  convert(value, options) {
    const { domain } = this;
    if (!domain || domain.length < 2 || value == null) {
      return NaN;
    }
    const { range: range4 } = this;
    const clamp2 = options?.clamp ?? this.defaultClamp;
    let d0 = domain[0].valueOf();
    let d1 = domain[1].valueOf();
    let x = value.valueOf();
    if (this.transform) {
      d0 = this.transform(d0);
      d1 = this.transform(d1);
      x = this.transform(x);
    }
    if (clamp2) {
      const [start2, stop] = findMinMax([d0, d1]);
      if (x < start2) {
        return range4[0];
      } else if (x > stop) {
        return range4[1];
      }
    }
    if (d0 === d1) {
      return (range4[0] + range4[1]) / 2;
    } else if (x === d0) {
      return range4[0];
    } else if (x === d1) {
      return range4[1];
    }
    const r0 = range4[0];
    return r0 + (x - d0) / (d1 - d0) * (range4[1] - r0);
  }
  invert(x, _nearest) {
    const { domain } = this;
    if (domain.length < 2)
      return;
    let d0 = domain[0].valueOf();
    let d1 = domain[1].valueOf();
    if (this.transform) {
      d0 = this.transform(d0);
      d1 = this.transform(d1);
    }
    const { range: range4 } = this;
    const [r0, r1] = range4;
    let d;
    if (r0 === r1) {
      d = this.toDomain((d0 + d1) / 2);
    } else {
      d = this.toDomain(d0 + (x - r0) / (r1 - r0) * (d1 - d0));
    }
    return this.transformInvert ? this.transformInvert(d) : d;
  }
  getPixelRange() {
    const [a, b] = this.range;
    return Math.abs(b - a);
  }
};
_ContinuousScale.defaultTickCount = 5;
var ContinuousScale = _ContinuousScale;
function normalizeContinuousDomains(...domains) {
  let min;
  let minValue = Infinity;
  let max;
  let maxValue = -Infinity;
  for (const domain of domains) {
    for (const d of domain) {
      const value = d.valueOf();
      if (value < minValue) {
        minValue = value;
        min = d;
      }
      if (value > maxValue) {
        maxValue = value;
        max = d;
      }
    }
  }
  if (min != null && max != null) {
    const domain = [min, max];
    return { domain, animatable: true };
  } else {
    return { domain: [], animatable: false };
  }
}

// packages/ag-charts-community/src/scale/bandScale.ts
var _BandScale = class _BandScale extends AbstractScale {
  constructor() {
    super(...arguments);
    this.invalid = true;
    this.range = [0, 1];
    this.round = false;
    this._bandwidth = 1;
    this._step = 1;
    this._inset = 1;
    this._rawBandwidth = 1;
    /**
     * The ratio of the range that is reserved for space between bands.
     */
    this._paddingInner = 0;
    /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */
    this._paddingOuter = 0;
  }
  static is(value) {
    return value instanceof _BandScale;
  }
  get bandwidth() {
    this.refresh();
    return this._bandwidth;
  }
  get step() {
    this.refresh();
    return this._step;
  }
  get inset() {
    this.refresh();
    return this._inset;
  }
  get rawBandwidth() {
    this.refresh();
    return this._rawBandwidth;
  }
  set padding(value) {
    value = clamp(0, value, 1);
    this._paddingInner = value;
    this._paddingOuter = value;
  }
  get padding() {
    return this._paddingInner;
  }
  set paddingInner(value) {
    this.invalid = true;
    this._paddingInner = clamp(0, value, 1);
  }
  get paddingInner() {
    return this._paddingInner;
  }
  set paddingOuter(value) {
    this.invalid = true;
    this._paddingOuter = clamp(0, value, 1);
  }
  get paddingOuter() {
    return this._paddingOuter;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      logger_exports.warnOnce("Expected update to not invalidate scale");
    }
  }
  convert(d, options) {
    this.refresh();
    const i = this.findIndex(d, options?.alignment);
    if (i == null || i < 0 || i >= this.bands.length) {
      return NaN;
    }
    return this.ordinalRange(i);
  }
  invertNearestIndex(position) {
    this.refresh();
    const bandCount = this.bands.length;
    if (bandCount === 0)
      return -1;
    let low = 0;
    let high = bandCount - 1;
    let closestDistance = Infinity;
    let closestIndex = 0;
    while (low <= high) {
      const mid = (high + low) / 2 | 0;
      const p = this.ordinalRange(mid);
      const distance2 = Math.abs(p - position);
      if (distance2 === 0)
        return mid;
      if (distance2 < closestDistance) {
        closestDistance = distance2;
        closestIndex = mid;
      }
      if (p < position) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return closestIndex;
  }
  update() {
    const [r0, r1] = this.range;
    let { _paddingInner: paddingInner } = this;
    const { _paddingOuter: paddingOuter, round: round4, bands } = this;
    const bandCount = bands.length;
    if (bandCount === 0)
      return;
    const rangeDistance = r1 - r0;
    let rawStep;
    if (bandCount === 1) {
      paddingInner = 0;
      rawStep = rangeDistance * (1 - paddingOuter * 2);
    } else {
      rawStep = rangeDistance / Math.max(1, bandCount - paddingInner + paddingOuter * 2);
    }
    const step = round4 ? Math.floor(rawStep) : rawStep;
    let inset = r0 + (rangeDistance - step * (bandCount - paddingInner)) / 2;
    let bandwidth = step * (1 - paddingInner);
    if (round4) {
      inset = Math.round(inset);
      bandwidth = Math.round(bandwidth);
    }
    this._step = step;
    this._inset = inset;
    this._bandwidth = bandwidth;
    this._rawBandwidth = rawStep * (1 - paddingInner);
  }
  ordinalRange(i) {
    const { _inset: inset, _step: step, range: range4 } = this;
    const min = Math.min(range4[0], range4[1]);
    const max = Math.max(range4[0], range4[1]);
    return clamp(min, inset + step * i, max);
  }
};
__decorateClass([
  Invalidating
], _BandScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], _BandScale.prototype, "round", 2);
var BandScale = _BandScale;

// packages/ag-charts-community/src/scale/discreteTimeScale.ts
var DiscreteTimeScale = class _DiscreteTimeScale extends BandScale {
  static is(value) {
    return value instanceof _DiscreteTimeScale;
  }
  toDomain(value) {
    return new Date(value);
  }
  convert(value, options) {
    if (!(value instanceof Date))
      value = new Date(value);
    const { domain, bands } = this;
    if (domain.length <= 0)
      return NaN;
    const r0 = this.ordinalRange(0);
    const r1 = this.ordinalRange(bands.length - 1);
    if (bands.length === 0)
      return r0;
    if (options?.clamp === true) {
      const { range: range4 } = this;
      if (value < bands[0])
        return range4[0];
      if (value > bands[bands.length - 1])
        return range4[1];
    }
    const alignment = options?.alignment ?? 0 /* Leading */;
    const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
    if (alignment !== 2 /* Interpolate */) {
      const r2 = super.convert(value, options);
      return reversed ? r1 - (r2 - r0) : r2;
    }
    const v = value.valueOf();
    let bandIndex = this.findIndex(value) ?? 0;
    let dIndex;
    if (reversed) {
      bandIndex = Math.min(Math.max(bandIndex, 1), bands.length - 1);
      dIndex = -1;
    } else {
      bandIndex = Math.min(Math.max(bandIndex, 0), bands.length - 2);
      dIndex = 1;
    }
    const v0 = bands[bandIndex].valueOf();
    const v1 = bands[bandIndex + dIndex].valueOf();
    const vr0 = this.ordinalRange(bandIndex);
    const vr1 = this.ordinalRange(bandIndex + dIndex);
    const ratio2 = (v - v0) / (v1 - v0);
    const r = ratio2 * (vr1 - vr0) + vr0;
    return reversed ? r1 - (r - r0) : r;
  }
  invert(position, nearest = false) {
    this.refresh();
    const { domain, bands } = this;
    if (domain.length <= 0)
      return;
    const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
    let index;
    if (nearest) {
      index = this.invertNearestIndex(position - this.bandwidth / 2);
    } else {
      const closestIndex = findMinIndex(0, bands.length - 1, (i) => {
        const p = this.ordinalRange(i);
        return p >= position;
      });
      index = closestIndex ?? bands.length - 1;
    }
    return bands[reversed ? bands.length - 1 - index : index];
  }
  findIndex(value, alignment = 0 /* Leading */) {
    const { bands } = this;
    const target = value.valueOf();
    if (alignment === 1 /* Trailing */) {
      return findMinIndex(0, bands.length - 1, (index) => bands[index].valueOf() >= target);
    }
    return findMaxIndex(0, bands.length - 1, (index) => bands[index].valueOf() <= target);
  }
};

// packages/ag-charts-community/src/util/vector4.ts
var Vec4 = {
  bottomCenter,
  center,
  clone,
  collides,
  end,
  from,
  height,
  round,
  start,
  topCenter,
  origin,
  width
};
function start(a) {
  return { x: a.x1, y: a.y1 };
}
function end(a) {
  return { x: a.x2, y: a.y2 };
}
function topCenter(a) {
  return { x: (a.x1 + a.x2) / 2, y: Math.min(a.y1, a.y2) };
}
function center(a) {
  return { x: (a.x1 + a.x2) / 2, y: (a.y1 + a.y2) / 2 };
}
function bottomCenter(a) {
  return { x: (a.x1 + a.x2) / 2, y: Math.max(a.y1, a.y2) };
}
function width(a) {
  return Math.abs(a.x2 - a.x1);
}
function height(a) {
  return Math.abs(a.y2 - a.y1);
}
function round(a) {
  return { x1: Math.round(a.x1), y1: Math.round(a.y1), x2: Math.round(a.x2), y2: Math.round(a.y2) };
}
function clone(a) {
  return { x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2 };
}
function collides(a, b) {
  const an = normalise(a);
  const bn = normalise(b);
  return an.x1 <= bn.x2 && an.x2 >= bn.x1 && an.y1 <= bn.y2 && an.y2 >= bn.y1;
}
function normalise(a) {
  return { x1: Math.min(a.x1, a.x2), x2: Math.max(a.x1, a.x2), y1: Math.min(a.y1, a.y2), y2: Math.max(a.y1, a.y2) };
}
function from(a, b, c, d) {
  if (typeof a === "number") {
    return { x1: a, y1: b, x2: c, y2: d };
  }
  if ("width" in a) {
    return normalise({
      x1: a.x,
      y1: a.y,
      x2: a.x + a.width,
      y2: a.y + a.height
    });
  }
  throw new Error(`Values can not be converted into a vector4: [${JSON.stringify(a)}] [${b}] [${c}] [${d}]`);
}
function origin() {
  return { x1: 0, y1: 0, x2: 0, y2: 0 };
}

// packages/ag-charts-community/src/util/panToBBox.ts
function normalize(screenMin, min, screenMax, max, target) {
  return min + (max - min) * ((target - screenMin) / (screenMax - screenMin));
}
function unnormalize(screenMin, min, screenMax, max, ratio2) {
  return screenMin + (ratio2 - min) * ((screenMax - screenMin) / (max - min));
}
function calcWorldAxis(viewportMin, viewportMax, ratio2) {
  return [
    unnormalize(viewportMin, ratio2.min, viewportMax, ratio2.max, 0),
    unnormalize(viewportMin, ratio2.min, viewportMax, ratio2.max, 1)
  ];
}
function calcWorldVec4(viewport, ratioX, ratioY) {
  const [x1, x2] = calcWorldAxis(viewport.x1, viewport.x2, ratioX);
  const [y1, y2] = calcWorldAxis(viewport.y1, viewport.y2, ratioY);
  return { x1, x2, y1, y2 };
}
function panAxesUnnormalized(worldMin, worldMax, viewportMin, viewportMax, targetMin, targetMax) {
  if (viewportMin <= targetMin && targetMax <= viewportMax)
    return viewportMin;
  const minDiff = targetMin - viewportMin;
  const maxDiff = targetMax - viewportMax;
  const diff8 = Math.abs(minDiff) < Math.abs(maxDiff) ? minDiff : maxDiff;
  return clamp(worldMin, viewportMin + diff8, worldMax);
}
function calcPanToBBoxRatios(viewportBBox, ratios, targetBBox) {
  const { x: ratioX = { min: 0, max: 1 }, y: ratioY = { min: 0, max: 1 } } = ratios;
  const target = Vec4.from(targetBBox);
  const viewport = Vec4.from(viewportBBox);
  const world = calcWorldVec4(viewport, ratioX, ratioY);
  const x = panAxesUnnormalized(world.x1, world.x2, viewport.x1, viewport.x2, target.x1, target.x2);
  const y = panAxesUnnormalized(world.y1, world.y2, viewport.y1, viewport.y2, target.y1, target.y2);
  const result = {
    x: {
      min: normalize(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x),
      max: normalize(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x + viewportBBox.width)
    },
    y: {
      min: normalize(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y),
      max: normalize(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y + viewportBBox.height)
    }
  };
  const diffX = result.x.max - result.x.min;
  const diffY = result.y.max - result.y.min;
  result.x.min = clamp(0, result.x.min, 1 - diffX);
  result.x.max = result.x.min + diffX;
  result.y.min = clamp(0, result.y.min, 1 - diffY);
  result.y.max = result.y.min + diffY;
  return result;
}

// packages/ag-charts-community/src/chart/rangeAlignment.ts
function rangeAlignment(start2, end2) {
  const startValue = start2?.valueOf();
  const endValue = end2?.valueOf();
  if (typeof startValue !== "number" || typeof endValue !== "number")
    return [void 0, void 0];
  return startValue < endValue ? [0 /* Leading */, 1 /* Trailing */] : [1 /* Trailing */, 0 /* Leading */];
}

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var ZoomManagerAutoScaleAxis = class {
  constructor() {
    this.enabled = false;
    this.padding = 0;
    this.manuallyAdjusted = false;
  }
};
var rangeValidator = (axis) => attachDescription((value, { options }) => {
  if (!ContinuousScale.is(axis?.scale) && !DiscreteTimeScale.is(axis?.scale))
    return true;
  if (value == null || options.end == null)
    return true;
  return value < options.end;
}, `to be less than end`);
var ZoomManager = class extends BaseManager {
  constructor(eventsHub, fireChartEvent) {
    super();
    this.eventsHub = eventsHub;
    this.fireChartEvent = fireChartEvent;
    this.mementoOriginatorKey = "zoom";
    this.axisZoomManagers = /* @__PURE__ */ new Map();
    this.state = new StateTracker(void 0, "initial");
    this.axes = [];
    this.didLayoutAxes = false;
    this.autoScaleYAxis = new ZoomManagerAutoScaleAxis();
    this.lastRestoredState = void 0;
    this.independentAxes = false;
    this.navigatorModule = false;
    this.zoomModule = false;
    // The initial state memento can not be restored until the chart has performed its first layout. Instead save it as
    // pending and restore then delete it on the first layout.
    this.pendingMemento = void 0;
    this.boundFireOnceChartEvent = this.fireOnceChartEvent.bind(this);
    this.cleanup.register(
      eventsHub.on("layout:complete", () => {
        this.didLayoutAxes = true;
        const { pendingMemento } = this;
        if (pendingMemento) {
          this.restoreMemento(pendingMemento.version, pendingMemento.mementoVersion, pendingMemento.memento);
        }
        this.autoScaleYZoom("zoom-manager");
      })
    );
  }
  createMemento() {
    return this.getMementoRanges();
  }
  guardMemento(blob, messages) {
    if (blob == null)
      return true;
    if (!isObject(blob))
      return false;
    const primaryX = this.getPrimaryAxis("x" /* X */);
    const primaryY = this.getPrimaryAxis("y" /* Y */);
    const zoomMementoDefs = {
      rangeX: { start: rangeValidator(primaryX), end: defined },
      rangeY: { start: rangeValidator(primaryY), end: defined },
      ratioX: { start: defined, end: defined },
      ratioY: { start: defined, end: defined },
      autoScaledAxes: defined
    };
    const { invalid } = validate(blob, zoomMementoDefs);
    if (invalid.length > 0) {
      messages.push(...invalid.map(String));
      return false;
    }
    return true;
  }
  restoreMemento(version, mementoVersion, memento) {
    const { independentAxes } = this;
    if (!this.axes || !this.didLayoutAxes) {
      this.pendingMemento = { version, mementoVersion, memento };
      return;
    }
    this.pendingMemento = void 0;
    const zoom = this.getDefinedZoom();
    if (memento?.rangeX) {
      zoom.x = this.rangeToRatio(memento.rangeX, "x" /* X */) ?? { min: 0, max: 1 };
    } else if (memento?.ratioX) {
      zoom.x = {
        min: memento.ratioX.start ?? 0,
        max: memento.ratioX.end ?? 1
      };
    } else {
      zoom.x = { min: 0, max: 1 };
    }
    if (!this.navigatorModule || this.zoomModule) {
      let yAutoScale = memento?.autoScaledAxes?.includes("y");
      if (memento?.rangeY) {
        yAutoScale ?? (yAutoScale = false);
        zoom.y = this.rangeToRatio(memento.rangeY, "y" /* Y */) ?? { min: 0, max: 1 };
      } else if (memento?.ratioY) {
        yAutoScale ?? (yAutoScale = false);
        zoom.y = {
          min: memento.ratioY.start ?? 0,
          max: memento.ratioY.end ?? 1
        };
      } else {
        yAutoScale ?? (yAutoScale = true);
        const autoZoomY = yAutoScale ? this.getAutoScaleYZoom(zoom.x) : void 0;
        zoom.y = autoZoomY ?? { min: 0, max: 1 };
      }
      zoom.autoScaleYAxis = yAutoScale;
    }
    this.lastRestoredState = zoom;
    if (independentAxes !== true) {
      this.updateZoom("zoom-manager", zoom);
      return;
    }
    const primaryX = this.getPrimaryAxis("x" /* X */);
    const primaryY = this.getPrimaryAxis("y" /* Y */);
    for (const axis of [primaryX, primaryY]) {
      if (!axis)
        continue;
      this.updateAxisZoom("zoom-manager", axis.id, zoom[axis.direction]);
    }
  }
  updateAxes(axes) {
    this.axes = axes;
    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));
    this.axisZoomManagers.clear();
    for (const axis of axes) {
      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));
    }
    if (this.state.size > 0 && axes.length > 0) {
      this.updateZoom(this.state.stateId(), this.state.stateValue());
    }
  }
  setIndependentAxes(independent = true) {
    this.independentAxes = independent;
  }
  setAutoScaleYAxis(enabled, padding2) {
    this.autoScaleYAxis.enabled = enabled;
    this.autoScaleYAxis.padding = padding2;
    if (enabled) {
      this.autoScaleYZoom("toggle-auto-scale");
    }
  }
  setNavigatorEnabled(enabled = true) {
    this.navigatorModule = enabled;
  }
  setZoomModuleEnabled(enabled = true) {
    this.zoomModule = enabled;
  }
  isNavigatorEnabled() {
    return this.navigatorModule;
  }
  isZoomEnabled() {
    return this.zoomModule;
  }
  updateZoom(callerId, newZoom) {
    if (newZoom?.x && (newZoom.x.min < 0 || newZoom.x.max > 1)) {
      logger_exports.warnOnce(
        `Attempted to update x-axis zoom to an invalid ratio of [{ min: ${newZoom.x.min}, max: ${newZoom.x.max} }], expecting a ratio of 0 to 1, ignoring.`
      );
      newZoom.x = void 0;
    }
    if (newZoom?.y && (newZoom.y.min < 0 || newZoom.y.max > 1)) {
      logger_exports.warnOnce(
        `Attempted to update y-axis zoom to an invalid ratio of [{ min: ${newZoom.y.min}, max: ${newZoom.y.max} }], expecting a ratio of 0 to 1, ignoring.`
      );
      newZoom.y = void 0;
    }
    if (this.axisZoomManagers.size === 0) {
      const stateId = this.state.stateId();
      if (stateId === "initial" || stateId === callerId) {
        this.state.set(callerId, newZoom);
      }
      return;
    }
    this.state.set(callerId, newZoom);
    const autoScaleYAxis = newZoom?.autoScaleYAxis;
    if (autoScaleYAxis != null) {
      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
    }
    this.axisZoomManagers.forEach((axis) => {
      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);
    });
    this.applyChanges(callerId);
  }
  updateAxisZoom(callerId, axisId, newZoom) {
    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);
    this.applyChanges(callerId);
  }
  resetZoom(callerId) {
    this.autoScaleYAxis.manuallyAdjusted = false;
    const zoom = this.getRestoredZoom();
    this.updateZoom(callerId, {
      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },
      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 },
      autoScaleYAxis: zoom?.autoScaleYAxis ?? true
    });
  }
  resetAxisZoom(callerId, axisId) {
    const axisZoomManager = this.axisZoomManagers.get(axisId);
    const direction = axisZoomManager?.getDirection();
    if (direction == null)
      return;
    const restoredZoom = this.getRestoredZoom();
    if (direction === "y" /* Y */) {
      const autoScaleYAxis = restoredZoom?.autoScaleYAxis ?? true;
      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
    }
    for (const axis of this.axes) {
      if (axis.direction !== direction)
        continue;
      this.updateAxisZoom(callerId, axis.id, restoredZoom?.[direction] ?? { min: 0, max: 1 });
    }
  }
  setAxisManuallyAdjusted(_callerId, axisId) {
    const direction = this.axisZoomManagers.get(axisId)?.getDirection();
    if (direction !== "y" /* Y */)
      return;
    this.autoScaleYAxis.manuallyAdjusted = true;
  }
  updatePrimaryAxisZoom(callerId, direction, newZoom) {
    const primaryAxis = this.getPrimaryAxis(direction);
    if (!primaryAxis)
      return;
    this.updateAxisZoom(callerId, primaryAxis.id, newZoom);
  }
  panToBBox(callerId, seriesRect, target) {
    if (!this.isZoomEnabled() && !this.isNavigatorEnabled())
      return false;
    const zoom = this.getZoom();
    if (zoom === void 0 || !zoom.x && !zoom.y)
      return false;
    const panIsPossible = seriesRect.width > 0 && seriesRect.height > 0 && Math.abs(target.width) <= Math.abs(seriesRect.width) && Math.abs(target.height) <= Math.abs(seriesRect.height);
    if (!panIsPossible) {
      logger_exports.warnOnce(`cannot pan to target BBox - chart too small?`);
      return false;
    }
    const newZoom = calcPanToBBoxRatios(seriesRect, zoom, target);
    if (this.independentAxes) {
      this.updatePrimaryAxisZoom(callerId, "x" /* X */, newZoom.x);
      this.updatePrimaryAxisZoom(callerId, "y" /* Y */, newZoom.y);
    } else {
      this.updateZoom(callerId, newZoom);
    }
    return true;
  }
  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.
  fireZoomPanStartEvent(callerId) {
    this.eventsHub.emit("zoom:pan-start", { callerId });
  }
  extendToEnd(callerId, direction, extent3) {
    return this.extendWith(callerId, direction, (end2) => Number(end2) - extent3);
  }
  extendWith(callerId, direction, fn) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainExtents(axis);
    if (!extents)
      return;
    const [, end2] = extents;
    const start2 = fn(end2);
    const ratio2 = this.rangeToRatio({ start: start2, end: end2 }, direction);
    if (!ratio2)
      return;
    this.updateZoom(callerId, { [direction]: ratio2 });
  }
  updateWith(callerId, direction, fn) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainExtents(axis);
    if (!extents)
      return;
    let [start2, end2] = extents;
    [start2, end2] = fn(start2, end2);
    const ratio2 = this.rangeToRatio({ start: start2, end: end2 }, direction);
    if (!ratio2)
      return;
    this.updateZoom(callerId, { [direction]: ratio2 });
  }
  getZoom() {
    let x;
    let y;
    this.axisZoomManagers.forEach((axis) => {
      if (axis.getDirection() === "x" /* X */) {
        x ?? (x = axis.getZoom());
      } else if (axis.getDirection() === "y" /* Y */) {
        y ?? (y = axis.getZoom());
      }
    });
    if (x || y) {
      return { x, y };
    }
  }
  getAxisZoom(axisId) {
    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };
  }
  getAxisZooms() {
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = {
        direction: axis.getDirection(),
        zoom: axis.getZoom()
      };
    }
    return axes;
  }
  getRestoredZoom() {
    return this.lastRestoredState;
  }
  getPrimaryAxisId(direction) {
    return this.getPrimaryAxis(direction)?.id;
  }
  isVisibleItemsCountAtLeast(zoom, minVisibleItems) {
    const { autoScaleYAxis } = this;
    const xAxis = this.getPrimaryAxis("x" /* X */);
    const yAxis = this.getPrimaryAxis("y" /* Y */);
    let boundSeries;
    if (this.independentAxes) {
      const xBoundSeries = new Set(xAxis?.boundSeries ?? []);
      const yBoundSeries = new Set(yAxis?.boundSeries ?? []);
      boundSeries = /* @__PURE__ */ new Set();
      for (const series of xBoundSeries) {
        if (yBoundSeries.has(series)) {
          boundSeries.add(series);
        }
      }
    } else {
      boundSeries = /* @__PURE__ */ new Set([...xAxis?.boundSeries ?? [], ...yAxis?.boundSeries ?? []]);
    }
    const xVisibleRange = [zoom.x.min, zoom.x.max];
    const yVisibleRange = autoScaleYAxis.enabled && !autoScaleYAxis.manuallyAdjusted ? void 0 : [zoom.y.min, zoom.y.max];
    let visibleItemsCount = 0;
    for (const series of boundSeries) {
      const remainingItems = minVisibleItems - (visibleItemsCount ?? 0);
      const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);
      visibleItemsCount += seriesVisibleItems;
      if (visibleItemsCount >= minVisibleItems)
        return true;
    }
    return boundSeries.size === 0;
  }
  getMementoRanges() {
    const zoom = this.getDefinedZoom();
    let autoScaledAxes;
    if (this.autoScaleYAxis.enabled) {
      autoScaledAxes = this.autoScaleYAxis.manuallyAdjusted ? [] : ["y"];
    }
    const memento = {
      rangeX: this.getRangeDirection(zoom.x, "x" /* X */),
      rangeY: this.getRangeDirection(zoom.y, "y" /* Y */),
      ratioX: { start: zoom.x.min, end: zoom.x.max },
      ratioY: { start: zoom.y.min, end: zoom.y.max },
      autoScaledAxes
    };
    return memento;
  }
  getAutoScaleYZoom(zoomX) {
    if (!this.isZoomEnabled())
      return;
    const { independentAxes, autoScaleYAxis } = this;
    if (!autoScaleYAxis.enabled || autoScaleYAxis.manuallyAdjusted)
      return;
    const { padding: padding2 } = autoScaleYAxis;
    if (zoomX?.min === 0 && zoomX?.max === 1) {
      return { min: 0, max: 1 };
    } else if (independentAxes) {
      return this.primaryAxisZoom("y" /* Y */, zoomX, { padding: padding2 });
    } else {
      return this.combinedAxisZoom("y" /* Y */, zoomX, { padding: padding2 });
    }
  }
  autoScaleYZoom(callerId, applyChanges = true) {
    const { independentAxes } = this;
    const zoom = this.getZoom();
    if (zoom?.x == null)
      return;
    const zoomY = this.getAutoScaleYZoom(zoom.x);
    if (zoomY == null || objectsEqual(zoom.y, zoomY))
      return;
    if (independentAxes) {
      const primaryAxis = this.getPrimaryAxis("y" /* Y */);
      const primaryAxisManager = primaryAxis == null ? void 0 : this.axisZoomManagers.get(primaryAxis.id);
      primaryAxisManager?.updateZoom("zoom-manager", zoomY);
    } else {
      for (const axisZoomManager of this.axisZoomManagers.values()) {
        if (axisZoomManager.getDirection() === "y" /* Y */) {
          axisZoomManager.updateZoom("zoom-manager", zoomY);
        }
      }
    }
    if (applyChanges) {
      this.applyChanges(callerId);
    }
  }
  applyChanges(callerId) {
    this.autoScaleYZoom(callerId, false);
    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).includes(true);
    if (!changed) {
      return;
    }
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = axis.getZoom();
    }
    this.eventsHub.emit("zoom:change", { ...this.getZoom(), axes, callerId });
    this.eventsHub.on("layout:complete", this.boundFireOnceChartEvent);
  }
  fireOnceChartEvent() {
    this.fireChartEvent({ type: "zoom", ...this.getMementoRanges() });
    this.eventsHub.off("layout:complete", this.boundFireOnceChartEvent);
  }
  getRangeDirection(ratio2, direction) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis || !ContinuousScale.is(axis.scale) && !DiscreteTimeScale.is(axis.scale))
      return;
    const extents = this.getDomainPixelExtents(axis);
    if (!extents)
      return;
    const [d0, d1] = extents;
    let start2;
    let end2;
    if (d0 <= d1) {
      start2 = axis.scale.invert(0);
      end2 = axis.scale.invert(d0 + (d1 - d0) * ratio2.max);
    } else {
      start2 = axis.scale.invert(d0 - (d0 - d1) * ratio2.min);
      end2 = axis.scale.invert(0);
    }
    return { start: start2, end: end2 };
  }
  rangeToRatio(range4, direction) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainPixelExtents(axis);
    if (!extents)
      return;
    const [d0, d1] = extents;
    const { scale: scale2 } = axis;
    const { start: start2, end: end2 } = range4;
    const [startAlignment = 0 /* Leading */, endAlignment = 1 /* Trailing */] = rangeAlignment(
      start2,
      end2
    );
    let r0 = range4.start == null ? d0 : scale2.convert(range4.start, { alignment: startAlignment });
    let r1 = range4.end == null ? d1 : scale2.convert(range4.end, { alignment: endAlignment }) + (scale2.bandwidth ?? 0);
    if (!isFiniteNumber(r0) || !isFiniteNumber(r1))
      return;
    const [dMin, dMax] = [Math.min(d0, d1), Math.max(d0, d1)];
    if (r0 < dMin || r0 > dMax) {
      logger_exports.warnOnce(
        `Invalid range start [${range4.start}], expecting a value between [${scale2.invert(d0)}] and [${scale2.invert?.(d1)}], ignoring.`
      );
      return;
    }
    if (r1 < dMin || r1 > dMax) {
      logger_exports.warnOnce(
        `Invalid range end [${range4.end}], expecting a value between [${scale2.invert(d0)}] and [${scale2.invert?.(d1)}], ignoring.`
      );
      return;
    }
    r0 = Math.min(dMax, Math.max(dMin, r0));
    r1 = Math.min(dMax, Math.max(dMin, r1));
    const diff8 = d1 - d0;
    const min = Math.abs((r0 - d0) / diff8);
    const max = Math.abs((r1 - d0) / diff8);
    return { min, max };
  }
  getPrimaryAxis(direction) {
    return this.axes?.find((a) => a.direction === direction);
  }
  getDomainExtents(axis) {
    const { domain } = axis.scale;
    const d0 = domain.at(0);
    const d1 = domain.at(-1);
    if (d0 == null || d1 == null)
      return;
    return [d0, d1];
  }
  getDomainPixelExtents(axis) {
    const [d0, d1] = axis.scale.range;
    if (!isFiniteNumber(d0) || !isFiniteNumber(d1))
      return;
    return [d0, d1];
  }
  getDefinedZoom() {
    const zoom = this.getZoom();
    return {
      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },
      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 }
    };
  }
  zoomBounds(xAxis, yAxis, zoom, padding2) {
    const xScale = xAxis.scale;
    const xScaleRange = xScale.range;
    xScale.range = [0, 1];
    const yScale = yAxis.scale;
    const yScaleRange = yScale.range;
    yScale.range = [0, 1];
    let min = 1;
    let minPadding = false;
    let max = 0;
    let maxPadding = false;
    for (const series of yAxis.boundSeries) {
      if (!series.visible)
        continue;
      const { connectsToYAxis } = series;
      const yValues = series.getRange("y" /* Y */, [zoom.min, zoom.max]);
      for (const yValue of yValues) {
        const y = yScale.convert(yValue);
        if (!Number.isFinite(y))
          continue;
        if (y < min) {
          min = y;
          minPadding = !connectsToYAxis || yValue < 0;
        }
        if (y > max) {
          max = y;
          maxPadding = !connectsToYAxis || yValue > 0;
        }
      }
    }
    if (isFiniteNumber(yAxis.min)) {
      min = 0;
    }
    if (isFiniteNumber(yAxis.max)) {
      max = 1;
    }
    xScale.range = xScaleRange;
    yScale.range = yScaleRange;
    if (min >= max)
      return;
    const totalPadding = (minPadding ? padding2 : 0) + (maxPadding ? padding2 : 0);
    const paddedDelta = Math.min((max - min) * (1 + totalPadding), 1);
    if (paddedDelta <= 0)
      return;
    if (minPadding && maxPadding) {
      const mid = (max + min) / 2;
      min = mid - paddedDelta / 2;
      max = mid + paddedDelta / 2;
    } else if (!minPadding && maxPadding) {
      max = min + paddedDelta;
    } else if (minPadding && !maxPadding) {
      min = max - paddedDelta;
    }
    if (min < 0) {
      max += -min;
      min = 0;
    } else if (max > 1) {
      min -= max - 1;
      max = 1;
    }
    return { min, max };
  }
  primaryAxisZoom(direction, zoom, { padding: padding2 = 0 } = {}) {
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const xAxis = this.getPrimaryAxis(crossDirection);
    const yAxis = this.getPrimaryAxis(direction);
    if (xAxis == null || yAxis == null)
      return;
    return this.zoomBounds(xAxis, yAxis, zoom, padding2);
  }
  combinedAxisZoom(direction, zoom, { padding: padding2 = 0 } = {}) {
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const seriesXAxes = /* @__PURE__ */ new Map();
    for (const xAxis of this.axes) {
      if (xAxis.direction !== crossDirection)
        continue;
      for (const series of xAxis.boundSeries) {
        seriesXAxes.set(series, xAxis);
      }
    }
    let min = 1;
    let max = 0;
    for (const yAxis of this.axes) {
      if (yAxis.direction !== direction)
        continue;
      for (const series of yAxis.boundSeries) {
        const xAxis = seriesXAxes.get(series);
        if (xAxis == null)
          continue;
        const bounds = this.zoomBounds(xAxis, yAxis, zoom, padding2);
        if (bounds == null)
          return;
        min = Math.min(min, bounds.min);
        max = Math.max(max, bounds.max);
      }
    }
    const delta4 = 1e-6;
    if (min < delta4)
      min = 0;
    if (max > 1 - delta4)
      max = 1;
    if (min > max)
      return;
    return { min, max };
  }
};
var AxisZoomManager = class {
  constructor(axis) {
    this.axis = axis;
    const [min = 0, max = 1] = axis.visibleRange;
    this.state = new StateTracker({ min, max });
    this.currentZoom = this.state.stateValue();
  }
  getDirection() {
    return this.axis.direction;
  }
  updateZoom(callerId, newZoom) {
    this.state.set(callerId, newZoom);
  }
  getZoom() {
    return deepClone(this.state.stateValue());
  }
  hasChanges() {
    const currentZoom = this.currentZoom;
    const pendingZoom = this.state.stateValue();
    return currentZoom.min !== pendingZoom.min || currentZoom.max !== pendingZoom.max;
  }
  applyChanges() {
    const hasChanges = this.hasChanges();
    this.currentZoom = this.state.stateValue();
    return hasChanges;
  }
};

// packages/ag-charts-community/src/chart/layout/layoutManager.ts
var LayoutElement = /* @__PURE__ */ ((LayoutElement6) => {
  LayoutElement6[LayoutElement6["Caption"] = 0] = "Caption";
  LayoutElement6[LayoutElement6["Legend"] = 1] = "Legend";
  LayoutElement6[LayoutElement6["ToolbarLeft"] = 2] = "ToolbarLeft";
  LayoutElement6[LayoutElement6["ToolbarBottom"] = 3] = "ToolbarBottom";
  LayoutElement6[LayoutElement6["Navigator"] = 4] = "Navigator";
  LayoutElement6[LayoutElement6["Overlay"] = 5] = "Overlay";
  return LayoutElement6;
})(LayoutElement || {});
var LayoutManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.elements = /* @__PURE__ */ new Map();
  }
  registerElement(element2, listener) {
    if (this.elements.has(element2)) {
      this.elements.get(element2).add(listener);
    } else {
      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));
    }
    return () => this.elements.get(element2)?.delete(listener);
  }
  createContext(width2, height2) {
    const context = new LayoutContext(width2, height2);
    for (const element2 of Object.values(LayoutElement)) {
      if (typeof element2 !== "number")
        continue;
      this.elements.get(element2)?.forEach((listener) => listener(context));
    }
    return context;
  }
  emitLayoutComplete(context, options) {
    const { width: width2, height: height2 } = context;
    this.eventsHub.emit("layout:complete", {
      axes: options.axes ?? [],
      chart: { width: width2, height: height2 },
      clipSeries: options.clipSeries ?? false,
      series: options.series
    });
  }
};
var LayoutContext = class {
  constructor(width2, height2) {
    this.width = width2;
    this.height = height2;
    this.layoutBox = new BBox(0, 0, width2, height2);
  }
};

// packages/ag-charts-community/src/scene/util/labelPlacement.ts
function circleRectOverlap({ point: c, anchor: unitCenter }, x, y, w, h) {
  if (c.size === 0) {
    return false;
  }
  let cx = c.x;
  let cy = c.y;
  if (unitCenter != null) {
    cx -= (unitCenter.x - 0.5) * c.size;
    cy -= (unitCenter.y - 0.5) * c.size;
  }
  let edgeX = cx;
  if (cx < x) {
    edgeX = x;
  } else if (cx > x + w) {
    edgeX = x + w;
  }
  let edgeY = cy;
  if (cy < y) {
    edgeY = y;
  } else if (cy > y + h) {
    edgeY = y + h;
  }
  const dx2 = cx - edgeX;
  const dy2 = cy - edgeY;
  const d = Math.sqrt(dx2 * dx2 + dy2 * dy2);
  return d <= c.size * 0.5;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === "object" && typeof x.label === "object";
}
var labelPlacements = {
  top: { x: 0, y: -1 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  "top-left": { x: -1, y: -1 },
  "top-right": { x: 1, y: -1 },
  "bottom-left": { x: -1, y: 1 },
  "bottom-right": { x: 1, y: 1 }
};
function placeLabels(data, bounds, padding2 = 5) {
  const result = /* @__PURE__ */ new Map();
  const previousResults = [];
  const sortedDataClone = new Map(
    [...data.entries()].map(([k, d]) => [k, d.toSorted((a, b) => b.point.size - a.point.size)])
  );
  const dataValues = [...sortedDataClone.values()].flat();
  for (const [seriesId, datums] of sortedDataClone.entries()) {
    const labels = [];
    if (!datums[0]?.label)
      continue;
    for (let index = 0, ln = datums.length; index < ln; index++) {
      const d = datums[index];
      const { point, label, anchor } = d;
      const { text: text2, width: width2, height: height2 } = label;
      const r = point.size * 0.5;
      let dx2 = 0;
      let dy2 = 0;
      if (r > 0 && d.placement != null) {
        const placement = labelPlacements[d.placement];
        dx2 = (width2 * 0.5 + r + padding2) * placement.x;
        dy2 = (height2 * 0.5 + r + padding2) * placement.y;
      }
      const x = point.x - width2 * 0.5 + dx2 - ((anchor?.x ?? 0.5) - 0.5) * point.size;
      const y = point.y - height2 * 0.5 + dy2 - ((anchor?.y ?? 0.5) - 0.5) * point.size;
      const withinBounds = boxContains(bounds, x, y, width2, height2);
      if (!withinBounds)
        continue;
      const overlapPoints = dataValues.some((dataDatum) => circleRectOverlap(dataDatum, x, y, width2, height2));
      if (overlapPoints)
        continue;
      const overlapLabels = previousResults.some((pr) => boxCollides(pr, x, y, width2, height2));
      if (overlapLabels)
        continue;
      const resultDatum = { index, text: text2, x, y, width: width2, height: height2, datum: d };
      labels.push(resultDatum);
      previousResults.push(resultDatum);
    }
    result.set(seriesId, labels);
  }
  return result;
}

// packages/ag-charts-community/src/chart/layout/seriesLabelLayoutManager.ts
var SeriesLabelLayoutManager = class {
  constructor() {
    this.labelData = /* @__PURE__ */ new Map();
  }
  updateLabels(placedLabelSeries, padding2, seriesRect = BBox.zero) {
    const bounds = {
      x: -padding2.left,
      y: -padding2.top,
      width: seriesRect.width + padding2.left + padding2.right,
      height: seriesRect.height + padding2.top + padding2.bottom
    };
    const expectedSeriesId = new Set(placedLabelSeries.map((s) => s.id));
    for (const seriesId of this.labelData.keys()) {
      if (!expectedSeriesId.has(seriesId)) {
        this.labelData.delete(seriesId);
      }
    }
    for (const series of placedLabelSeries) {
      const labelData = series.getLabelData();
      if (labelData.every(isPointLabelDatum)) {
        this.labelData.set(series.id, labelData);
      }
    }
    const placedLabels = placeLabels(this.labelData, bounds, 5);
    for (const series of placedLabelSeries) {
      series.updatePlacedLabelData?.(placedLabels.get(series.id) ?? []);
    }
  }
};

// packages/ag-charts-community/src/chart/legend/legendManager.ts
var LegendManager = class {
  constructor(eventsHub) {
    this.eventsHub = eventsHub;
    this.mementoOriginatorKey = "legend";
    this.legendDataMap = /* @__PURE__ */ new Map();
  }
  createMemento() {
    return this.getData().filter(({ hideInLegend, isFixed }) => !hideInLegend && !isFixed).map(({ enabled, seriesId, itemId, legendItemName }) => ({
      visible: enabled,
      seriesId,
      itemId,
      legendItemName
    }));
  }
  guardMemento(blob) {
    return blob == null || isArray(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    memento?.forEach((datum) => {
      const { seriesId, data } = this.getRestoredData(datum) ?? {};
      if (!seriesId || !data) {
        return;
      }
      this.updateData(seriesId, data);
    });
    this.update();
  }
  getRestoredData(datum) {
    const { seriesId, itemId, legendItemName, visible } = datum;
    if (seriesId) {
      const legendData = this.legendDataMap.get(seriesId) ?? [];
      const data = legendData.map((d) => {
        const match = d.seriesId === seriesId && (!itemId || d.itemId === itemId);
        if (match && d.isFixed) {
          this.warnFixed(d.seriesId, d.itemId);
        }
        return !d.isFixed && match ? { ...d, enabled: visible } : d;
      });
      return { seriesId, data };
    }
    if (itemId == null && legendItemName == null) {
      return;
    }
    for (const legendDatum of this.getData()) {
      if (itemId != null && legendDatum.itemId !== itemId || legendItemName != null && legendDatum.legendItemName !== legendItemName) {
        continue;
      }
      if (legendDatum.isFixed) {
        this.warnFixed(legendDatum.seriesId, itemId);
        return;
      }
      const seriesLegendData = (this.legendDataMap.get(legendDatum.seriesId) ?? []).map(
        (d) => d.itemId === itemId || d.legendItemName === legendItemName ? { ...d, enabled: visible } : d
      );
      return {
        seriesId: legendDatum.seriesId,
        data: seriesLegendData
      };
    }
  }
  warnFixed(seriesId, itemId) {
    logger_exports.warnOnce(
      `The legend item with seriesId [${seriesId}] and itemId [${itemId}] is not configurable, this series item cannot be toggled through the legend.`
    );
  }
  update(data) {
    this.eventsHub.emit("legend:change", {
      legendData: data ?? this.getData()
    });
  }
  updateData(seriesId, data = []) {
    this.legendDataMap.set(seriesId, data);
  }
  clearData() {
    this.legendDataMap.clear();
  }
  toggleItem(enabled, seriesId, itemId, legendItemName) {
    if (legendItemName) {
      this.getData().forEach((datum) => {
        const newData = (this.legendDataMap.get(datum.seriesId) ?? []).map(
          (d) => d.legendItemName === legendItemName ? { ...d, enabled } : d
        );
        this.updateData(datum.seriesId, newData);
      });
      return;
    }
    const seriesLegendData = this.getData(seriesId);
    const singleLegendItem = seriesLegendData.length === 1;
    const data = seriesLegendData.map(
      (datum) => itemId == null && singleLegendItem || datum.itemId === itemId ? { ...datum, enabled } : datum
    );
    this.updateData(seriesId, data);
  }
  getData(seriesId) {
    if (seriesId) {
      return this.legendDataMap.get(seriesId) ?? [];
    }
    return [...this.legendDataMap].reduce(
      (data, [_, legendData]) => data.concat(legendData),
      []
    );
  }
  getDatum({ seriesId, itemId } = {}) {
    return this.getData(seriesId).find((datum) => datum.itemId === itemId);
  }
  getSeriesEnabled(seriesId) {
    const data = this.getData(seriesId);
    if (data.length > 0) {
      return data.some((d) => d.enabled);
    }
  }
  getItemEnabled({ seriesId, itemId } = {}) {
    return this.getDatum({ seriesId, itemId })?.enabled ?? true;
  }
};

// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager = class {
  constructor() {
    this.groups = /* @__PURE__ */ new Map();
  }
  registerSeries({ internalId, seriesGrouping, visible, type }) {
    if (!seriesGrouping)
      return;
    let group = this.groups.get(type);
    if (group == null) {
      group = /* @__PURE__ */ new Map();
      this.groups.set(type, group);
    }
    group.set(internalId, { grouping: seriesGrouping, visible });
  }
  updateSeries({ internalId, seriesGrouping, visible, type }) {
    if (!seriesGrouping)
      return;
    const entry = this.groups.get(type)?.get(internalId);
    if (entry) {
      entry.grouping = seriesGrouping;
      entry.visible = visible;
    }
  }
  deregisterSeries({ internalId, type }) {
    const group = this.groups.get(type);
    if (group == null)
      return;
    group.delete(internalId);
    if (group.size === 0) {
      this.groups.delete(type);
    }
  }
  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {
    if (!seriesGrouping) {
      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };
    }
    const visibleGroupsSet = /* @__PURE__ */ new Set();
    const visibleSameStackSet = /* @__PURE__ */ new Set();
    const group = this.groups.get(type);
    for (const entry of group?.values() ?? []) {
      if (!entry.visible)
        continue;
      visibleGroupsSet.add(entry.grouping.groupIndex);
      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
        visibleSameStackSet.add(entry.grouping.stackIndex);
      }
    }
    const visibleGroups = Array.from(visibleGroupsSet);
    visibleGroups.sort((a, b) => a - b);
    return {
      visibleGroupCount: visibleGroups.length,
      visibleSameStackCount: visibleSameStackSet.size,
      index: visibleGroups.indexOf(seriesGrouping.groupIndex)
    };
  }
};

// packages/ag-charts-community/src/chart/updateService.ts
var UpdateService = class {
  constructor(updateCallback) {
    this.updateCallback = updateCallback;
    this.events = new EventEmitter();
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  destroy() {
    this.events.clear();
  }
  update(type = 0 /* FULL */, options) {
    this.updateCallback(type, options);
  }
  dispatchUpdateComplete(apiUpdate) {
    this.events.emit("update-complete", { type: "update-complete", apiUpdate });
  }
  dispatchPreDomUpdate() {
    this.events.emit("pre-dom-update", { type: "pre-dom-update" });
  }
  dispatchPreSceneRender() {
    this.events.emit("pre-scene-render", { type: "pre-scene-render" });
  }
  dispatchProcessData({ series }) {
    this.events.emit("process-data", { type: "process-data", series });
  }
};

// packages/ag-charts-community/src/chart/chartContext.ts
var ChartContext = class {
  constructor(chart, vars) {
    this.eventsHub = new EventEmitter();
    this.callbackCache = new CallbackCache();
    this.highlightManager = new HighlightManager(this.eventsHub);
    this.formatManager = new FormatManager();
    this.layoutManager = new LayoutManager(this.eventsHub);
    this.localeManager = new LocaleManager(this.eventsHub);
    this.seriesStateManager = new SeriesStateManager();
    this.stateManager = new StateManager();
    this.seriesLabelLayoutManager = new SeriesLabelLayoutManager();
    this.cleanup = new CleanupRegistry();
    this.contextModules = [];
    const {
      scene,
      root,
      syncManager,
      container,
      fireEvent,
      updateCallback,
      updateMutex,
      styleContainer,
      chartType,
      domMode,
      withDragInterpretation
    } = vars;
    this.chartService = chart;
    this.syncManager = syncManager;
    this.domManager = new DOMManager(this.eventsHub, this.chartService, container, styleContainer, domMode);
    this.widgets = new WidgetSet(this.domManager, { withDragInterpretation });
    const canvasElement = this.domManager.addChild(
      "canvas",
      "scene-canvas",
      scene?.canvas.element
    );
    this.scene = scene ?? new Scene({ canvasElement });
    this.scene.setRoot(root);
    this.cleanup.register(
      this.scene.on("scene-changed", () => {
        this.updateService.update(7 /* SCENE_RENDER */);
      })
    );
    this.axisManager = new AxisManager(this.eventsHub, root);
    this.legendManager = new LegendManager(this.eventsHub);
    this.annotationManager = new AnnotationManager(this.eventsHub, chart.annotationRoot, fireEvent);
    this.chartTypeOriginator = new ChartTypeOriginator(chart);
    this.interactionManager = new InteractionManager();
    this.contextMenuRegistry = new ContextMenuRegistry(this.eventsHub);
    this.updateService = new UpdateService(updateCallback);
    this.proxyInteractionService = new ProxyInteractionService(this.eventsHub, this.localeManager, this.domManager);
    this.fontManager = new FontManager(this.domManager, this.updateService);
    this.historyManager = new HistoryManager(this.eventsHub);
    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);
    this.dataService = new DataService(this.eventsHub, chart, this.animationManager);
    this.tooltipManager = new TooltipManager(this.eventsHub, this.localeManager, this.domManager, chart.tooltip);
    this.zoomManager = new ZoomManager(this.eventsHub, fireEvent);
    for (const module2 of moduleRegistry.byType("context")) {
      if (!module2.chartTypes.includes(chartType))
        continue;
      const moduleInstance = module2.moduleFactory(this);
      this.contextModules.push(moduleInstance);
      this[module2.contextKey] = moduleInstance;
    }
  }
  destroy() {
    this.animationManager.destroy();
    this.axisManager.destroy();
    this.callbackCache.invalidateCache();
    this.domManager.destroy();
    this.fontManager.destroy();
    this.proxyInteractionService.destroy();
    this.tooltipManager.destroy();
    this.zoomManager.destroy();
    this.widgets.destroy();
    this.contextModules.forEach((m) => m.destroy());
    this.cleanup.flush();
  }
};

// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.range = "tooltip";
  }
};
__decorateClass([
  Property
], ChartHighlight.prototype, "range", 2);

// packages/ag-charts-community/src/chart/data/caching.ts
function setsEqual(a, b) {
  if (a.size !== b.size)
    return false;
  for (const value of a) {
    if (!b.has(value))
      return false;
  }
  return true;
}
function idsMapEqual(a, b) {
  if (a == null || b == null)
    return a === b;
  if (a.size !== b.size)
    return false;
  for (const [key, aValue] of a) {
    const bValue = b.get(key);
    if (bValue == null)
      return false;
    if (!setsEqual(aValue, bValue))
      return false;
  }
  return true;
}
function propsEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i += 1) {
    const { type: typeA, idsMap: idsMapA, scopes: scopesA, data: dataA, ...propA } = a[i];
    const { type: typeB, idsMap: idsMapB, scopes: scopesB, data: dataB, ...propB } = b[i];
    if (typeA !== typeB)
      return false;
    if (scopesA && scopesB && !arraysEqual(scopesA, scopesB))
      return false;
    if (dataA && dataB && dataA !== dataB)
      return false;
    if (!objectsEqual(propA, propB) || !idsMapEqual(idsMapA, idsMapB))
      return false;
  }
  return true;
}
function optsEqual(a, b) {
  const { props: propsA, ...restA } = a;
  const { props: propsB, ...restB } = b;
  return objectsEqual(restA, restB) && propsEqual(propsA, propsB);
}
function canReuseCachedData(cachedDataItem, data, ids, opts) {
  return data === cachedDataItem.data && arraysEqual(ids, cachedDataItem.ids) && optsEqual(opts, cachedDataItem.opts);
}

// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DiscreteDomain = class _DiscreteDomain {
  constructor() {
    this.domain = /* @__PURE__ */ new Set();
  }
  static is(value) {
    return value instanceof _DiscreteDomain;
  }
  extend(val) {
    this.domain.add(val);
  }
  getDomain() {
    return Array.from(this.domain);
  }
};
var ContinuousDomain = class _ContinuousDomain {
  constructor() {
    this.domain = [Infinity, -Infinity];
  }
  static is(value) {
    return value instanceof _ContinuousDomain;
  }
  static extendDomain(values, domain = [Infinity, -Infinity]) {
    for (const value of values) {
      if (typeof value !== "number") {
        continue;
      }
      if (domain[0] > value) {
        domain[0] = value;
      }
      if (domain[1] < value) {
        domain[1] = value;
      }
    }
    return domain;
  }
  extend(value) {
    if (this.domain[0] > value) {
      this.domain[0] = value;
    }
    if (this.domain[1] < value) {
      this.domain[1] = value;
    }
  }
  getDomain() {
    return [...this.domain];
  }
};

// packages/ag-charts-community/src/chart/data/rangeLookup.ts
var MIN = 0;
var MAX = 1;
var SPAN = 2;
var RangeLookup = class {
  constructor(allValues) {
    const dataLength = allValues.reduce((acc, v) => Math.max(acc, v.length), 0);
    const sizePower = 32 - Math.clz32(dataLength);
    let maxLevelSize = 1 << sizePower;
    if (dataLength === maxLevelSize / 2) {
      maxLevelSize = maxLevelSize >>> 1;
    }
    this.maxLevelSize = maxLevelSize;
    const buffer = new Float64Array((maxLevelSize * 2 - 1) * 2).fill(NaN);
    for (const values of allValues) {
      for (let i = 0; i < values.length; i += 1) {
        const value = Number(values[i]);
        const bufferIndex = maxLevelSize + i - 1;
        const bufferMinIndex = (bufferIndex * SPAN | 0) + MIN;
        const bufferMaxIndex = (bufferIndex * SPAN | 0) + MAX;
        const prevMinValue = buffer[bufferMinIndex];
        const prevMaxValue = buffer[bufferMaxIndex];
        if (!Number.isFinite(prevMinValue) || value < prevMinValue) {
          buffer[bufferMinIndex] = value;
        }
        if (!Number.isFinite(prevMaxValue) || value > prevMaxValue) {
          buffer[bufferMaxIndex] = value;
        }
      }
    }
    for (let size = maxLevelSize / 2 | 0; size >= 1; size = size / 2 | 0) {
      const start2 = size - 1 | 0;
      const end2 = start2 + size | 0;
      for (let i = 0; i < size; i += 1) {
        const nodeIndex = start2 + i;
        const leftIndex = end2 + i * 2;
        const rightIndex = leftIndex + 1;
        const aMin = buffer[(leftIndex * SPAN | 0) + MIN];
        const bMin = buffer[(rightIndex * SPAN | 0) + MIN];
        buffer[(nodeIndex * SPAN | 0) + MIN] = !Number.isFinite(bMin) || aMin < bMin ? aMin : bMin;
        const aMax = buffer[(leftIndex * SPAN | 0) + MAX];
        const bMax = buffer[(rightIndex * SPAN | 0) + MAX];
        buffer[(nodeIndex * SPAN | 0) + MAX] = !Number.isFinite(bMax) || aMax > bMax ? aMax : bMax;
      }
    }
    this.buffer = buffer;
  }
  computeRangeInto(buffer, start2, end2, bufferIndex, currentStart, step, into) {
    const currentEnd = currentStart + step - 1;
    if (currentEnd < start2 || currentStart >= end2)
      return into;
    if (currentStart >= start2 && currentEnd < end2) {
      const min = buffer[(bufferIndex * SPAN | 0) + MIN];
      const max = buffer[(bufferIndex * SPAN | 0) + MAX];
      if (Number.isFinite(min))
        into[0] = Math.min(into[0], min);
      if (Number.isFinite(max))
        into[1] = Math.max(into[1], max);
    } else if (step > 1) {
      bufferIndex = bufferIndex * 2 | 0;
      step = step / 2 | 0;
      this.computeRangeInto(buffer, start2, end2, bufferIndex + 1 | 0, currentStart, step, into);
      this.computeRangeInto(buffer, start2, end2, bufferIndex + 2 | 0, currentStart + step, step, into);
    }
    return into;
  }
  rangeBetween(start2, end2) {
    if (start2 > end2)
      return [NaN, NaN];
    const { maxLevelSize, buffer } = this;
    const range4 = [Infinity, -Infinity];
    this.computeRangeInto(buffer, start2, end2, 0, 0, maxLevelSize, range4);
    return range4;
  }
  get range() {
    const { buffer } = this;
    return [buffer[MIN], buffer[MAX]];
  }
};

// packages/ag-charts-community/src/chart/data/sortOrder.ts
function valuesSortOrder(values) {
  if (values.length <= 1)
    return 1;
  let order = 0;
  let v0 = values[0];
  for (let i = 1; i < values.length; i++) {
    const v1 = values[i];
    if (v1 == null)
      continue;
    const primitive = v1.valueOf();
    if (typeof primitive !== "number")
      return;
    const diff8 = Math.sign(v1 - v0);
    if (diff8 !== 0) {
      if (order !== 0 && order !== diff8)
        return;
      order = diff8;
    }
    v0 = v1;
  }
  return order === 0 ? 1 : order;
}

// packages/ag-charts-community/src/chart/data/dataModel.ts
var KEY_SORT_ORDERS = Symbol("key-sort-orders");
var COLUMN_SORT_ORDERS = Symbol("column-sort-orders");
var DOMAIN_RANGES = Symbol("domain-ranges");
function toKeyString(keys) {
  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join("-");
}
function fixNumericExtent(extent3) {
  const numberExtent = extent3?.map(Number);
  return numberExtent?.every(Number.isFinite) ? numberExtent : [];
}
function getMissCount(scopeProvider, missMap) {
  return missMap?.get(scopeProvider.id) ?? 0;
}
function isScoped(obj) {
  return "scopes" in obj && Array.isArray(obj.scopes);
}
function createArray(length2, value) {
  const out = [];
  for (let i = 0; i < length2; i += 1) {
    out[i] = value;
  }
  return out;
}
function datumKeys(keys, columnScope, datumIndex) {
  const out = [];
  for (const k of keys) {
    const key = k.get(columnScope)?.[datumIndex];
    if (key == null)
      return;
    out.push(key);
  }
  return out;
}
function getPathComponents(path) {
  const components = [];
  let matchIndex = 0;
  let matchGroup;
  const regExp = /((?:(?:^|\.)\s*\w+|\[\s*(?:'(?:[^']|(?<!\\)\\')*'|"(?:[^"]|(?<!\\)\\")*"|-?\d+)\s*\])\s*)/g;
  while (matchGroup = regExp.exec(path)) {
    if (matchGroup.index !== matchIndex) {
      return;
    }
    matchIndex = matchGroup.index + matchGroup[0].length;
    const match = matchGroup[1].trim();
    if (match.startsWith(".")) {
      components.push(match.slice(1).trim());
    } else if (match.startsWith("[")) {
      const accessor = match.slice(1, -1).trim();
      if (accessor.startsWith(`'`)) {
        components.push(accessor.slice(1, -1).replace(/(?<!\\)\\'/g, `'`));
      } else if (accessor.startsWith(`"`)) {
        components.push(accessor.slice(1, -1).replace(/(?<!\\)\\"/g, `"`));
      } else {
        components.push(accessor);
      }
    } else {
      components.push(match);
    }
  }
  if (matchIndex !== path.length)
    return;
  return components;
}
function createPathAccessor(components) {
  return (datum) => {
    let current = datum;
    for (const component of components) {
      current = current[component];
    }
    return current;
  };
}
var DataModel = class {
  constructor(opts, mode = "standalone", suppressFieldDotNotation = false) {
    this.opts = opts;
    this.mode = mode;
    this.suppressFieldDotNotation = suppressFieldDotNotation;
    this.debug = Debug.create(true, "data-model");
    this.scopeCache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.values = [];
    this.aggregates = [];
    this.groupProcessors = [];
    this.propertyProcessors = [];
    this.reducers = [];
    this.processors = [];
    this.markScopeDatumInvalid = function(scopes, data, datumIndex, invalidData) {
      for (const scope of scopes) {
        if (!invalidData.has(scope)) {
          invalidData.set(scope, createArray(data.length, false));
        }
        invalidData.get(scope)[datumIndex] = true;
      }
    };
    let keys = true;
    for (const next of opts.props) {
      if (next.type === "key" && !keys) {
        throw new Error("AG Charts - internal config error: keys must come before values.");
      }
      if (next.type === "value" && keys) {
        keys = false;
      }
    }
    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {
      for (const matchGroupId of matchGroupIds) {
        if (this.values.every((def) => def.groupId !== matchGroupId)) {
          throw new Error(
            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`
          );
        }
      }
    };
    const keyScopes = /* @__PURE__ */ new Set();
    const valueScopes = /* @__PURE__ */ new Set();
    for (const def of opts.props) {
      const scopes = def.type === "key" ? keyScopes : valueScopes;
      if (isScoped(def)) {
        def.scopes?.forEach((s) => scopes.add(s));
      }
      switch (def.type) {
        case "key":
          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "value":
          if (def.property == null) {
            throw new Error(
              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(
                def
              )}`
            );
          }
          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "aggregate":
          verifyMatchGroupId(def);
          this.aggregates.push({ ...def, index: this.aggregates.length });
          break;
        case "group-value-processor":
          verifyMatchGroupId(def);
          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });
          break;
        case "property-value-processor":
          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });
          break;
        case "reducer":
          this.reducers.push({ ...def, index: this.reducers.length });
          break;
        case "processor":
          this.processors.push({ ...def, index: this.processors.length });
          break;
      }
    }
    if (!!this.opts.groupByKeys || this.opts.groupByFn != null) {
      const ungroupedScopes = new Set(valueScopes.values());
      keyScopes.forEach((s) => ungroupedScopes.delete(s));
      if (ungroupedScopes.size > 0) {
        throw new Error(
          `AG Charts - scopes missing key for grouping, illegal configuration: ${[...ungroupedScopes.values()]}`
        );
      }
    }
  }
  resolveProcessedDataDefById(scope, searchId) {
    const def = this.scopeCache.get(scope.id)?.get(searchId);
    if (!def) {
      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);
    }
    return { index: def.index, def };
  }
  resolveProcessedDataIndexById(scope, searchId) {
    return this.resolveProcessedDataDefById(scope, searchId).index;
  }
  resolveKeysById(scope, searchId, processedData) {
    const index = this.resolveProcessedDataIndexById(scope, searchId);
    const keys = processedData.keys[index];
    if (keys == null) {
      throw new Error(`AG Charts - didn't find keys for [${searchId}, ${scope.id}]`);
    }
    return keys.get(scope.id);
  }
  hasColumnById(scope, searchId) {
    return this.scopeCache.get(scope.id)?.get(searchId) != null;
  }
  resolveColumnById(scope, searchId, processedData) {
    const index = this.resolveProcessedDataIndexById(scope, searchId);
    const column = processedData.columns?.[index];
    if (column == null) {
      throw new Error(`AG Charts - didn't find column for [${searchId}, ${scope.id}]`);
    }
    return column;
  }
  /**
   * Provides a convenience iterator to iterate over all of the extract datum values in a
   * specific DataGroup.
   *
   * @param scope to which datums should belong
   * @param group containing the datums
   * @param processedData containing the group
   */
  *forEachDatum(scope, processedData, group) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    for (const datumIndex of group.datumIndices[columnIndex] ?? []) {
      yield processedData.columns[columnIndex][datumIndex];
    }
  }
  /**
   * Provides a convenience iterator to iterate over all of the extracted datum values in a
   * GroupedData.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */
  *forEachGroupDatum(scope, processedData) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    const output = {
      groupIndex: 0,
      columnIndex
    };
    const empty = [];
    for (const group of processedData.groups) {
      output.group = group;
      for (const datumIndex of group.datumIndices[columnIndex] ?? empty) {
        output.datumIndex = datumIndex;
        yield output;
      }
      output.groupIndex++;
    }
  }
  /**
   * Provides a window-based convenience iterator to iterate over all of the extracted datum
   * values in a GroupedData, including the previous and next entries relative to each datum.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */
  *forEachGroupDatumTuple(scope, processedData) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    const output = { columnIndex, datumIndexes: [void 0, void 0, void 0] };
    for (const next of this.forEachGroupDatum(scope, processedData)) {
      output.group = output.nextGroup;
      output.groupIndex = output.nextGroupIndex;
      output.nextGroup = next.group;
      output.nextGroupIndex = next.groupIndex;
      output.datumIndexes[0] = output.datumIndexes[1];
      output.datumIndexes[1] = output.datumIndexes[2];
      output.datumIndexes[2] = next.datumIndex;
      if (output.group != null && output.datumIndexes[1] != null) {
        yield output;
      }
    }
    output.group = output.nextGroup;
    output.groupIndex = output.nextGroupIndex;
    output.nextGroup = void 0;
    output.nextGroupIndex = void 0;
    output.datumIndexes[0] = output.datumIndexes[1];
    output.datumIndexes[1] = output.datumIndexes[2];
    output.datumIndexes[2] = void 0;
    if (output.group != null && output.datumIndexes[1] != null) {
      yield output;
    }
  }
  getDomain(scope, searchId, type, processedData) {
    const domains = this.getDomainsByType(type ?? "value", processedData);
    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];
  }
  getDomainBetweenRange(scope, searchIds, [i0, i1], processedData) {
    const columnIndices = searchIds.map((searchId) => this.resolveProcessedDataIndexById(scope, searchId));
    const cacheKey = columnIndices.join(":");
    const domainRanges = processedData[DOMAIN_RANGES];
    let rangeLookup = domainRanges.get(cacheKey);
    if (rangeLookup == null) {
      const values = columnIndices.map((columnIndex) => processedData.columns[columnIndex]);
      rangeLookup = new RangeLookup(values);
      domainRanges.set(cacheKey, rangeLookup);
    }
    return rangeLookup.rangeBetween(i0, i1);
  }
  getSortOrder(values, index, sortOrders) {
    let sortOrder = sortOrders.get(index);
    if (sortOrder == null) {
      sortOrder = { sortOrder: valuesSortOrder(values) };
      sortOrders.set(index, sortOrder);
    }
    return sortOrder.sortOrder;
  }
  getKeySortOrder(scope, searchId, processedData) {
    const columnIndex = this.resolveProcessedDataIndexById(scope, searchId);
    const keys = processedData.keys[columnIndex]?.get(scope.id);
    return keys ? this.getSortOrder(keys, columnIndex, processedData[KEY_SORT_ORDERS]) : void 0;
  }
  getColumnSortOrder(scope, searchId, processedData) {
    const columnIndex = this.resolveProcessedDataIndexById(scope, searchId);
    return this.getSortOrder(processedData.columns[columnIndex], columnIndex, processedData[COLUMN_SORT_ORDERS]);
  }
  getDomainsByType(type, processedData) {
    switch (type) {
      case "key":
        return processedData.domain.keys;
      case "value":
        return processedData.domain.values;
      case "aggregate":
        return processedData.domain.aggValues;
      case "group-value-processor":
        return processedData.domain.groups;
      default:
        return null;
    }
  }
  processData(sources) {
    const {
      opts: { groupByKeys, groupByFn },
      aggregates,
      groupProcessors,
      reducers,
      processors,
      propertyProcessors
    } = this;
    const start2 = performance.now();
    if (groupByKeys && this.keys.length === 0) {
      return;
    }
    let processedData = this.extractData(sources);
    if (groupByKeys) {
      processedData = this.groupData(processedData);
    } else if (groupByFn) {
      processedData = this.groupData(processedData, groupByFn(processedData));
    }
    if (groupProcessors.length > 0 && processedData.type === "grouped") {
      this.postProcessGroups(processedData);
    }
    if (aggregates.length > 0 && processedData.type === "ungrouped") {
      this.aggregateUngroupedData(processedData);
    } else if (aggregates.length > 0 && processedData.type === "grouped") {
      this.aggregateGroupedData(processedData);
    }
    if (propertyProcessors.length > 0) {
      this.postProcessProperties(processedData);
    }
    if (reducers.length > 0) {
      this.reduceData(processedData);
    }
    if (processors.length > 0) {
      this.postProcessData(processedData);
    }
    this.warnDataMissingProperties(sources);
    const end2 = performance.now();
    processedData.time = end2 - start2;
    if (this.debug.check()) {
      logProcessedData(processedData);
    }
    this.processScopeCache();
    return processedData;
  }
  warnDataMissingProperties(sources) {
    if (sources.size === 0)
      return;
    for (const def of iterate(this.keys, this.values)) {
      for (const [scope, missCount] of def.missing) {
        if (missCount < (sources.get(scope)?.length ?? Infinity))
          continue;
        const scopeHint = scope == null ? "" : ` for ${scope}`;
        logger_exports.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);
      }
    }
  }
  processScopeCache() {
    this.scopeCache.clear();
    for (const def of iterate(this.keys, this.values, this.aggregates)) {
      if (!def.idsMap)
        continue;
      for (const [scope, ids] of def.idsMap) {
        for (const id of ids) {
          if (!this.scopeCache.has(scope)) {
            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));
          } else if (this.scopeCache.get(scope)?.has(id)) {
            throw new Error("duplicate definition ids on the same scope are not allowed.");
          } else {
            this.scopeCache.get(scope).set(id, def);
          }
        }
      }
    }
  }
  valueGroupIdxLookup({ matchGroupIds }) {
    const result = [];
    for (const [index, def] of this.values.entries()) {
      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {
        result.push(index);
      }
    }
    return result;
  }
  valueIdxLookup(scopes, prop) {
    const noScopesToMatch = scopes == null || scopes.length === 0;
    const propId = typeof prop === "string" ? prop : prop.id;
    const hasMatchingScopeId = (def) => {
      if (def.idsMap) {
        for (const [scope, ids] of def.idsMap) {
          if (scopes?.includes(scope) && ids.has(propId)) {
            return true;
          }
        }
      }
      return false;
    };
    const result = this.values.reduce((res, def, index) => {
      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));
      if (validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def))) {
        res.push(index);
      }
      return res;
    }, []);
    if (result.length === 0) {
      throw new Error(
        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(
          scopes
        )}`
      );
    }
    return result;
  }
  extractData(sources) {
    const { dataDomain, processValue, allScopesHaveSameDefs } = this.initDataDomainProcessor();
    const { keys: keyDefs, values: valueDefs } = this;
    const { invalidData, invalidKeys, invalidKeyCount, allKeyMappings } = this.extractKeys(
      keyDefs,
      sources,
      processValue
    );
    const { columns, columnScopes, partialValidDataCount, maxDataLength } = this.extractValues(
      invalidData,
      valueDefs,
      sources,
      invalidKeys,
      processValue
    );
    const propertyDomain = (def) => {
      const defDomain = dataDomain.get(def);
      const result = defDomain.getDomain();
      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {
        return [];
      }
      return result;
    };
    return {
      type: "ungrouped",
      input: { count: maxDataLength },
      scopes: new Set(sources.keys()),
      dataSources: sources,
      aggregation: void 0,
      keys: [...allKeyMappings.values()],
      columns,
      columnScopes,
      invalidKeys,
      invalidKeyCount,
      invalidData,
      domain: {
        keys: keyDefs.map(propertyDomain),
        values: valueDefs.map(propertyDomain)
      },
      defs: {
        allScopesHaveSameDefs,
        keys: keyDefs,
        values: valueDefs
      },
      partialValidDataCount,
      time: 0,
      [DOMAIN_RANGES]: /* @__PURE__ */ new Map(),
      [KEY_SORT_ORDERS]: /* @__PURE__ */ new Map(),
      [COLUMN_SORT_ORDERS]: /* @__PURE__ */ new Map()
    };
  }
  extractKeys(keyDefs, sources, processValue) {
    const invalidKeys = /* @__PURE__ */ new Map();
    const invalidData = /* @__PURE__ */ new Map();
    const invalidKeyCount = /* @__PURE__ */ new Map();
    const allKeys = /* @__PURE__ */ new Map();
    let keyDefKeys;
    let scopeDataProcessed;
    const cloneScope = (source, target) => {
      const sourceScope = scopeDataProcessed.get(source);
      keyDefKeys.set(target, keyDefKeys.get(sourceScope));
      if (invalidKeys.has(sourceScope)) {
        invalidKeys.set(target, invalidKeys.get(sourceScope));
        invalidData.set(target, invalidData.get(sourceScope));
      }
    };
    for (const keyDef of keyDefs) {
      const { invalidValue, scopes: keyScopes } = keyDef;
      keyDefKeys = /* @__PURE__ */ new Map();
      scopeDataProcessed = /* @__PURE__ */ new Map();
      allKeys.set(keyDef, keyDefKeys);
      for (const scope of keyScopes ?? []) {
        const data = sources.get(scope) ?? [];
        if (scopeDataProcessed.has(data)) {
          cloneScope(data, scope);
          continue;
        }
        const keys = [];
        keyDefKeys.set(scope, keys);
        scopeDataProcessed.set(data, scope);
        let invalidScopeKeys;
        let invalidScopeData;
        let missingKeys = 0;
        for (let datumIndex = 0; datumIndex < data.length; datumIndex++) {
          if (data[datumIndex] == null || typeof data[datumIndex] !== "object")
            continue;
          const result = processValue(keyDef, data[datumIndex], datumIndex, scope);
          if (result.valid) {
            keys.push(result.value);
            continue;
          }
          keys.push(invalidValue);
          invalidScopeKeys ?? (invalidScopeKeys = createArray(data.length, false));
          invalidScopeData ?? (invalidScopeData = createArray(data.length, false));
          missingKeys += 1;
          invalidScopeKeys[datumIndex] = true;
          invalidScopeData[datumIndex] = true;
        }
        if (invalidScopeKeys && invalidScopeData) {
          invalidKeys.set(scope, invalidScopeKeys);
          invalidData.set(scope, invalidScopeData);
          invalidKeyCount.set(scope, missingKeys);
        }
      }
    }
    return { invalidData, invalidKeys, invalidKeyCount, allKeyMappings: allKeys };
  }
  extractValues(invalidData, valueDefs, sources, scopeInvalidKeys, processValue) {
    let partialValidDataCount = 0;
    const columns = [];
    const allColumnScopes = [];
    let maxDataLength = 0;
    for (const def of valueDefs) {
      const { invalidValue } = def;
      const valueSources = new Set(def.scopes.map((s) => sources.get(s)));
      if (valueSources.size > 1) {
        throw new Error(`AG Charts - more than one data source for: ${JSON.stringify(def)}`);
      }
      const columnScopes = new Set(def.scopes);
      const columnScope = first(def.scopes);
      const columnSource = sources.get(columnScope);
      const column = new Array();
      const invalidKeys = scopeInvalidKeys.get(columnScope);
      for (let datumIndex = 0; datumIndex < columnSource.length; datumIndex++) {
        if (columnSource[datumIndex] == null || typeof columnSource[datumIndex] !== "object")
          continue;
        const valueDatum = columnSource[datumIndex];
        const invalidKey = invalidKeys != null ? invalidKeys[datumIndex] : false;
        const result = processValue(def, valueDatum, datumIndex, def.scopes);
        let value = result.value;
        if (invalidKey || !result.valid) {
          this.markScopeDatumInvalid(def.scopes, columnSource, datumIndex, invalidData);
        }
        if (invalidKey) {
          value = invalidValue;
        } else if (!result.valid) {
          partialValidDataCount += 1;
          value = invalidValue;
        }
        column[datumIndex] = value;
      }
      columns.push(column);
      allColumnScopes.push(columnScopes);
      maxDataLength = Math.max(maxDataLength, column.length);
    }
    return { columns, columnScopes: allColumnScopes, partialValidDataCount, maxDataLength };
  }
  groupData(data, groupingFn) {
    var _a;
    const { keys: dataKeys, columns: allColumns, columnScopes, invalidKeys, invalidData } = data;
    const allScopes = data.scopes;
    const resultGroups = [];
    const resultData = [];
    const processedColumnIndexes = /* @__PURE__ */ new Set();
    const groups = allScopes.size !== 1 || groupingFn != null ? /* @__PURE__ */ new Map() : void 0;
    for (const scope of allScopes) {
      const scopeColumnIndexes = allColumns.map((_, idx) => idx).filter((idx) => !processedColumnIndexes.has(idx) && columnScopes[idx].has(scope));
      if (scopeColumnIndexes.length === 0)
        continue;
      for (const idx of scopeColumnIndexes) {
        processedColumnIndexes.add(idx);
      }
      const siblingScopes = /* @__PURE__ */ new Set();
      for (const columnIdx of scopeColumnIndexes) {
        for (const columnScope of columnScopes[columnIdx]) {
          siblingScopes.add(columnScope);
        }
      }
      const scopeKeys = dataKeys.map((k) => k.get(scope)).filter((k) => k != null);
      const firstColumn = allColumns[first(scopeColumnIndexes)];
      const scopeInvalidData = invalidData?.get(scope);
      const scopeInvalidKeys = invalidKeys?.get(scope);
      for (let datumIndex = 0; datumIndex < firstColumn.length; datumIndex++) {
        if (scopeInvalidKeys?.[datumIndex] === true)
          continue;
        const keys = scopeKeys.map((k) => k[datumIndex]);
        if (keys == null || keys.length === 0) {
          throw new Error("AG Charts - no keys found for scope: " + scope);
        }
        const group = groupingFn?.(keys) ?? keys;
        const groupStr = groups != null ? toKeyString(group) : void 0;
        let outputGroup = groups?.get(groupStr);
        if (outputGroup == null) {
          outputGroup = {
            keys: group,
            datumIndices: [],
            aggregation: [],
            validScopes: allScopes
          };
          groups?.set(groupStr, outputGroup);
          resultGroups.push(outputGroup.keys);
          resultData.push(outputGroup);
        }
        if (scopeInvalidData?.[datumIndex] === true) {
          if (outputGroup.validScopes === allScopes) {
            outputGroup.validScopes = new Set(allScopes.values());
          }
          for (const invalidScope of siblingScopes) {
            outputGroup.validScopes.delete(invalidScope);
          }
        }
        for (const columnIdx of scopeColumnIndexes) {
          (_a = outputGroup.datumIndices)[columnIdx] ?? (_a[columnIdx] = []);
          outputGroup.datumIndices[columnIdx].push(datumIndex);
        }
      }
    }
    return {
      ...data,
      type: "grouped",
      domain: {
        ...data.domain,
        groups: resultGroups
      },
      groups: resultData
    };
  }
  aggregateUngroupedData(processedData) {
    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);
    processedData.domain.aggValues = domainAggValues;
    const { keys, columns, dataSources } = processedData;
    const onlyScope = first(dataSources.keys());
    const rawData = dataSources.get(onlyScope);
    processedData.aggregation = rawData?.map((_, datumIndex) => {
      const aggregation = [];
      for (const [index, def] of this.aggregates.entries()) {
        const indices = this.valueGroupIdxLookup(def);
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        const valuesToAgg = indices.map((columnIndex) => columns[columnIndex][datumIndex]);
        const k = datumKeys(keys, onlyScope, datumIndex);
        const valuesAgg = k != null ? def.aggregateFunction(valuesToAgg, k) : void 0;
        if (valuesAgg) {
          groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
        }
        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;
        aggregation[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
      }
      return aggregation;
    });
  }
  aggregateGroupedData(processedData) {
    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);
    processedData.domain.aggValues = domainAggValues;
    const { columns } = processedData;
    for (const [index, def] of this.aggregates.entries()) {
      const indices = this.valueGroupIdxLookup(def);
      for (const group of processedData.groups) {
        group.aggregation ?? (group.aggregation = []);
        const groupKeys = group.keys;
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        const maxDatumIndex = Math.max(
          ...indices.map((columnIndex) => group.datumIndices[columnIndex]?.length ?? 0)
        );
        for (let datumIndex = 0; datumIndex < maxDatumIndex; datumIndex++) {
          const valuesToAgg = indices.map(
            (columnIndex) => columns[columnIndex][group.datumIndices[columnIndex]?.[datumIndex]]
          );
          const valuesAgg = def.aggregateFunction(valuesToAgg, groupKeys);
          if (valuesAgg) {
            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
          }
        }
        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;
        group.aggregation[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
      }
    }
  }
  postProcessGroups(processedData) {
    const { groupProcessors } = this;
    const { columnScopes, columns, invalidData } = processedData;
    for (const processor of groupProcessors) {
      const valueIndexes = this.valueGroupIdxLookup(processor);
      const adjustFn = processor.adjust()();
      for (const dataGroup of processedData.groups) {
        adjustFn(columns, valueIndexes, dataGroup);
      }
      for (const valueIndex of valueIndexes) {
        const valueDef = this.values[valueIndex];
        const isDiscrete = valueDef.valueType === "category";
        const column = columns[valueIndex];
        const columnScope = first(columnScopes[valueIndex]);
        const invalidDatums = invalidData?.get(columnScope);
        const domain = isDiscrete ? new DiscreteDomain() : new ContinuousDomain();
        for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {
          if (invalidDatums?.[datumIndex] === true)
            continue;
          domain.extend(column[datumIndex]);
        }
        processedData.domain.values[valueIndex] = domain.getDomain();
      }
    }
  }
  postProcessProperties(processedData) {
    for (const { adjust, property, scopes } of this.propertyProcessors) {
      for (const idx of this.valueIdxLookup(scopes, property)) {
        adjust()(processedData, idx);
      }
    }
  }
  reduceData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    const { dataSources, keys } = processedData;
    for (const def of this.reducers) {
      const reducer = def.reducer();
      let accValue = def.initialValue;
      if (processedData.type === "grouped") {
        for (const group of processedData.groups) {
          accValue = reducer(accValue, group.keys);
        }
      } else {
        const onlyScope = first(dataSources.keys());
        const keyColumns = keys.map((k) => k.get(onlyScope)).filter((k) => k != null);
        const keysParam = keyColumns.map(() => void 0);
        const rawData = dataSources.get(onlyScope);
        for (let datumIndex = 0; datumIndex < rawData.length; datumIndex += 1) {
          for (let keyIdx = 0; keyIdx < keysParam.length; keyIdx++) {
            keysParam[keyIdx] = keyColumns[keyIdx]?.[datumIndex];
          }
          accValue = reducer(accValue, keysParam);
        }
      }
      processedData.reduced[def.property] = accValue;
    }
  }
  postProcessData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    for (const def of this.processors) {
      processedData.reduced[def.property] = def.calculate(
        processedData,
        processedData.reduced[def.property]
      );
    }
  }
  initDataDomainProcessor() {
    const { keys: keyDefs, values: valueDefs } = this;
    const scopes = /* @__PURE__ */ new Set();
    for (const valueDef of valueDefs) {
      if (!valueDef.scopes)
        continue;
      for (const scope of valueDef.scopes) {
        scopes.add(scope);
      }
    }
    const dataDomain = /* @__PURE__ */ new Map();
    const processorFns = /* @__PURE__ */ new Map();
    let allScopesHaveSameDefs = true;
    const initDataDomain = () => {
      for (const def of iterate(keyDefs, valueDefs)) {
        if (def.valueType === "category") {
          dataDomain.set(def, new DiscreteDomain());
        } else {
          dataDomain.set(def, new ContinuousDomain());
          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes?.length ?? 0) === scopes.size);
        }
      }
    };
    initDataDomain();
    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));
    const reusableResult = {
      value: void 0,
      missing: false,
      valid: false
    };
    const processValue = (def, datum, idx, valueScopes) => {
      let valueInDatum;
      let value;
      if (accessors.has(def.property)) {
        try {
          value = accessors.get(def.property)(datum);
        } catch {
        }
        valueInDatum = value != null;
      } else {
        valueInDatum = def.property in datum;
        value = valueInDatum ? datum[def.property] : def.missingValue;
      }
      if (def.forceValue != null) {
        const valueNegative = valueInDatum && isNegative(value);
        value = valueNegative ? -1 * def.forceValue : def.forceValue;
        valueInDatum = true;
      }
      reusableResult.missing = !valueInDatum;
      const missingValueDef = "missingValue" in def;
      if (!valueInDatum && !missingValueDef) {
        if (typeof valueScopes === "string") {
          const missCount = def.missing.get(valueScopes) ?? 0;
          def.missing.set(valueScopes, missCount + 1);
        } else {
          for (const scope of valueScopes) {
            const missCount = def.missing.get(scope) ?? 0;
            def.missing.set(scope, missCount + 1);
          }
        }
      }
      if (!dataDomain.has(def)) {
        initDataDomain();
      }
      if (valueInDatum && def.validation?.(value, datum, idx) === false) {
        reusableResult.valid = false;
        if ("invalidValue" in def) {
          value = def.invalidValue;
        } else {
          if (this.mode !== "integrated") {
            logger_exports.warnOnce(
              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,
              `[${value}]`
            );
          }
          reusableResult.value = void 0;
          return reusableResult;
        }
      } else {
        reusableResult.valid = true;
      }
      if (def.processor) {
        let processor = processorFns.get(def);
        if (processor == null) {
          processor = def.processor();
          processorFns.set(def, processor);
        }
        value = processor(value, idx);
      }
      dataDomain.get(def)?.extend(value);
      reusableResult.value = value;
      return reusableResult;
    };
    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };
  }
  buildAccessors(defs) {
    const result = /* @__PURE__ */ new Map();
    if (this.suppressFieldDotNotation) {
      return result;
    }
    for (const def of defs) {
      const isPath = def.property.includes(".") || def.property.includes("[");
      if (!isPath)
        continue;
      const components = getPathComponents(def.property);
      if (components == null) {
        logger_exports.warnOnce("Invalid property path [%s]", def.property);
        continue;
      }
      const accessor = createPathAccessor(components);
      result.set(def.property, accessor);
    }
    return result;
  }
};
function logProcessedData(processedData) {
  const logValues = (name, data) => {
    if (data.length > 0) {
      logger_exports.log(`DataModel.processData() - ${name}`);
      logger_exports.table(data);
    }
  };
  logger_exports.log("DataModel.processData() - processedData", processedData);
  logValues("Key Domains", processedData.domain.keys);
  logValues("Group Domains", processedData.domain.groups ?? []);
  logValues("Value Domains", processedData.domain.values);
  logValues("Aggregate Domains", processedData.domain.aggValues ?? []);
}

// packages/ag-charts-community/src/chart/data/dataController.ts
var _DataController = class _DataController {
  constructor(mode, suppressFieldDotNotation) {
    this.mode = mode;
    this.suppressFieldDotNotation = suppressFieldDotNotation;
    this.debug = Debug.create(true, "data-model");
    this.requested = [];
    this.status = "setup";
  }
  async request(id, data, opts) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    return new Promise((resolve, reject) => {
      this.requested.push({ id, opts, data, resolve, reject });
    });
  }
  execute(cachedData) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    this.status = "executed";
    this.debug("DataController.execute() - requested", this.requested);
    const valid = this.validateRequests(this.requested);
    this.debug("DataController.execute() - validated", valid);
    const merged = this.mergeRequested(valid);
    this.debug("DataController.execute() - merged", merged);
    if (this.debug.check()) {
      getWindow().processedData = [];
    }
    const nextCachedData = [];
    for (const { data, ids, opts, resolves, rejects } of merged) {
      const reusableCache = cachedData?.find((cacheItem) => canReuseCachedData(cacheItem, data, ids, opts));
      let dataModel;
      let processedData;
      if (reusableCache == null) {
        try {
          dataModel = new DataModel(opts, this.mode, this.suppressFieldDotNotation);
          const sources = new Map(valid.map((v) => [v.id, v.data]));
          processedData = dataModel.processData(sources);
        } catch (error2) {
          rejects.forEach((cb) => cb(error2));
          continue;
        }
      } else {
        ({ dataModel, processedData } = reusableCache);
      }
      nextCachedData.push({ opts, data, ids, dataModel, processedData });
      if (this.debug.check()) {
        getWindow("processedData").push(processedData);
      }
      if (processedData?.partialValidDataCount === 0) {
        resolves.forEach(
          (resolve) => resolve({
            dataModel,
            processedData
          })
        );
      } else if (processedData) {
        this.splitResult(dataModel, processedData, ids, resolves);
      } else {
        rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));
      }
    }
    return nextCachedData;
  }
  validateRequests(requested) {
    const valid = [];
    for (const [index, request] of requested.entries()) {
      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false && request.opts.groupByKeys === false) {
        request.reject(
          new Error("all series[].data arrays must be of the same length and have matching keys.")
        );
      } else {
        valid.push(request);
      }
    }
    return valid;
  }
  mergeRequested(requested) {
    const grouped = [];
    for (const request of requested) {
      const match = grouped.find(_DataController.groupMatch(request));
      if (match) {
        match.push(request);
      } else {
        grouped.push([request]);
      }
    }
    return grouped.map(_DataController.mergeRequests);
  }
  splitResult(dataModel, processedData, scopes, resolves) {
    for (let i = 0; i < scopes.length; i++) {
      const resolve = resolves[i];
      resolve({
        dataModel,
        processedData
      });
    }
  }
  static groupMatch({ data, opts }) {
    function keys(props2) {
      return props2.filter((p) => p.type === "key").map((p) => p.property).join(";");
    }
    const { groupByData, groupByKeys = false, groupByFn, props } = opts;
    const propsKeys = keys(props);
    return ([group]) => (groupByData === false || group.data === data) && (group.opts.groupByKeys ?? false) === groupByKeys && group.opts.groupByFn === groupByFn && keys(group.opts.props) === propsKeys;
  }
  static mergeRequests(requests) {
    const result = {
      ids: [],
      rejects: [],
      resolves: [],
      data: requests[0].data,
      opts: { ...requests[0].opts, props: [] }
    };
    const optsByTypeAndDataId = /* @__PURE__ */ new Map();
    const dataIds = /* @__PURE__ */ new Map();
    let nextDataId = 0;
    for (const request of requests) {
      const {
        id,
        data,
        resolve,
        reject,
        opts: { props, ...opts }
      } = request;
      result.ids.push(id);
      result.rejects.push(reject);
      result.resolves.push(resolve);
      result.data ?? (result.data = data);
      result.opts ?? (result.opts = { ...opts, props: [] });
      for (const prop of props) {
        const clone2 = { ...prop, scopes: [id], data };
        _DataController.createIdsMap(id, clone2);
        let dataId;
        if (_DataController.crossScopeMergableTypes.has(clone2.type)) {
          dataId = -1;
        } else if (dataIds.has(data)) {
          dataId = dataIds.get(data);
        } else {
          dataId = nextDataId++;
          dataIds.set(data, dataId);
        }
        const matchKey = `${clone2.type}-${dataId}-${clone2.groupId}`;
        const matches = optsByTypeAndDataId.get(matchKey);
        const match = matches?.find((existing) => _DataController.deepEqual(existing, clone2));
        if (matches == null) {
          result.opts.props.push(clone2);
          optsByTypeAndDataId.set(matchKey, [clone2]);
          continue;
        } else if (match == null) {
          result.opts.props.push(clone2);
          matches.push(clone2);
          continue;
        }
        if (clone2.scopes != null) {
          match.scopes ?? (match.scopes = []);
          match.scopes.push(...clone2.scopes);
        }
        if ((match.type === "key" || match.type === "value") && clone2.idsMap?.size) {
          match.idsMap ?? (match.idsMap = /* @__PURE__ */ new Map());
          _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);
        }
      }
    }
    return result;
  }
  static mergeIdsMap(fromMap, toMap) {
    for (const [scope, ids] of fromMap) {
      const toMapValue = toMap.get(scope);
      if (toMapValue == null) {
        toMap.set(scope, new Set(ids));
      } else {
        for (const id of ids) {
          toMapValue.add(id);
        }
      }
    }
  }
  static createIdsMap(scope, prop) {
    if (prop.id == null)
      return;
    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());
    if (prop.idsMap.has(scope)) {
      prop.idsMap.get(scope).add(prop.id);
    } else {
      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));
    }
  }
  static deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) {
        return false;
      }
      let i, length2;
      if (Array.isArray(a)) {
        length2 = a.length;
        if (length2 !== b.length) {
          return false;
        }
        for (i = length2 - 1; i >= 0; i--) {
          if (!_DataController.deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      const keys = Object.keys(a);
      length2 = keys.length;
      if (length2 !== Object.keys(b).length) {
        return false;
      }
      for (i = length2 - 1; i >= 0; i--) {
        const key = keys[i];
        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
};
_DataController.crossScopeMergableTypes = /* @__PURE__ */ new Set(["key", "group-value-processor"]);
// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times
_DataController.skipKeys = /* @__PURE__ */ new Set(["id", "idsMap", "type", "scopes", "data"]);
var DataController = _DataController;

// packages/ag-charts-community/src/chart/factory/axisRegistry.ts
var AxisRegistry = class {
  constructor() {
    this.axesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(axisType, module2) {
    this.axesMap.set(axisType, module2.moduleFactory);
    if (module2.themeTemplate) {
      this.setThemeTemplate(axisType, module2.themeTemplate);
    }
  }
  create(axisType, moduleContext) {
    const axisFactory = this.axesMap.get(axisType);
    if (axisFactory) {
      return axisFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown axis type: ${axisType}`);
  }
  has(axisType) {
    return this.axesMap.has(axisType);
  }
  keys() {
    return this.axesMap.keys();
  }
  setThemeTemplate(axisType, themeTemplate) {
    this.themeTemplates.set(axisType, themeTemplate);
    return this;
  }
  getThemeTemplate(axisType) {
    return this.themeTemplates.get(axisType);
  }
};
var axisRegistry = new AxisRegistry();

// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
var EXPECTED_ENTERPRISE_MODULES = [
  {
    type: "root",
    optionsKey: "animation",
    chartTypes: ["cartesian", "polar", "topology", "standalone"]
  },
  { type: "root", optionsKey: "annotations", chartTypes: ["cartesian"] },
  {
    type: "root",
    optionsKey: "background",
    chartTypes: ["cartesian", "polar", "topology", "standalone"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "foreground",
    chartTypes: ["cartesian", "polar", "topology", "standalone"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "chartToolbar",
    chartTypes: ["cartesian"]
  },
  {
    type: "root",
    optionsKey: "contextMenu",
    chartTypes: ["cartesian", "polar", "topology", "standalone"]
  },
  { type: "root", optionsKey: "statusBar", chartTypes: ["cartesian"], identifier: "status-bar" },
  {
    type: "root",
    optionsKey: "dataSource",
    chartTypes: ["cartesian", "polar", "topology", "standalone"]
  },
  { type: "root", optionsKey: "sync", chartTypes: ["cartesian"] },
  { type: "root", optionsKey: "zoom", chartTypes: ["cartesian", "topology"] },
  { type: "root", optionsKey: "ranges", chartTypes: ["cartesian"] },
  {
    type: "legend",
    optionsKey: "gradientLegend",
    chartTypes: ["cartesian", "polar", "topology", "standalone"],
    identifier: "gradient"
  },
  { type: "root", optionsKey: "navigator", chartTypes: ["cartesian"] },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["cartesian"], identifier: "ordinal-time" },
  { type: "axis-option", optionsKey: "crosshair", chartTypes: ["cartesian"] },
  { type: "axis-option", optionsKey: "bandHighlight", chartTypes: ["cartesian"] },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "box-plot" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "candlestick" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "cone-funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "ohlc" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "heatmap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "waterfall" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "nightingale" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-column" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-marker" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "pyramid" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "linear-gauge" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "radial-gauge" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "sunburst" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "treemap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "chord" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "sankey" },
  { type: "series-option", optionsKey: "errorBar", chartTypes: ["cartesian"], identifier: "error-bars" },
  { type: "context", contextKey: "sharedToolbar", chartTypes: ["cartesian"] }
];
function getEnterpriseSeriesChartTypes(type) {
  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)?.chartTypes;
}
function isEnterpriseCartesian(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "cartesian");
  return type === "cartesian";
}
function isEnterprisePolar(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "polar");
  return type === "polar";
}
function isEnterpriseTopology(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "topology");
  return type === "topology";
}
function isEnterpriseStandalone(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "standalone");
  return type === "standalone";
}
function isEnterpriseModule(module2) {
  return module2.packageType === "enterprise";
}
function verifyIfModuleExpected(module2) {
  if (!isEnterpriseModule(module2)) {
    throw new Error("AG Charts - internal configuration error, only enterprise modules need verification.");
  }
  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {
    return s.type === module2.type && ("optionsKey" in s && "optionsKey" in module2 ? s.optionsKey === module2.optionsKey : true) && ("contextKey" in s && "contextKey" in module2 ? s.contextKey === module2.contextKey : true) && s.identifier === module2.identifier && module2.chartTypes.every((t) => s.chartTypes.includes(t));
  });
  if (stub) {
    stub.useCount ?? (stub.useCount = 0);
    stub.useCount++;
  }
  return stub != null;
}
function getUnusedExpectedModules() {
  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);
}

// packages/ag-charts-community/src/chart/factory/legendRegistry.ts
var LegendRegistry = class {
  constructor() {
    this.legendMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {
    this.legendMap.set(legendType, { optionsKey, moduleFactory });
    this.themeTemplates.set(optionsKey, themeTemplate);
  }
  create(legendType, moduleContext) {
    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;
    if (legendFactory) {
      return legendFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown legend type: ${legendType}`);
  }
  getThemeTemplates() {
    return Object.fromEntries(this.themeTemplates);
  }
  getKeys() {
    return Array.from(this.legendMap.entries()).reduce(
      (result, [legendType, record]) => {
        result[legendType] = record.optionsKey;
        return result;
      },
      {}
    );
  }
};
var legendRegistry = new LegendRegistry();

// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var ChartTypes = class extends Map {
  get(seriesType) {
    return super.get(seriesType) ?? "unknown";
  }
  isCartesian(seriesType) {
    return this.get(seriesType) === "cartesian";
  }
  isPolar(seriesType) {
    return this.get(seriesType) === "polar";
  }
  isTopology(seriesType) {
    return this.get(seriesType) === "topology";
  }
  isStandalone(seriesType) {
    return this.get(seriesType) === "standalone";
  }
  get seriesTypes() {
    return Array.from(this.keys());
  }
  get cartesianTypes() {
    return this.seriesTypes.filter((t) => this.isCartesian(t));
  }
  get polarTypes() {
    return this.seriesTypes.filter((t) => this.isPolar(t));
  }
  get topologyTypes() {
    return this.seriesTypes.filter((t) => this.isTopology(t));
  }
  get standaloneTypes() {
    return this.seriesTypes.filter((t) => this.isStandalone(t));
  }
};
var ChartDefaults = class extends Map {
  set(chartType, defaults) {
    return super.set(chartType, mergeDefaults(defaults, this.get(chartType)));
  }
};
var chartTypes2 = new ChartTypes();
var publicChartTypes = new ChartTypes();
var chartDefaults = new ChartDefaults();

// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts
var SeriesRegistry = class {
  constructor() {
    this.seriesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(seriesType, {
    chartTypes: [chartType],
    moduleFactory,
    defaultAxes,
    themeTemplate,
    solo,
    stackable,
    groupable,
    stackedByDefault,
    hidden
  }) {
    this.setThemeTemplate(seriesType, themeTemplate);
    this.seriesMap.set(seriesType, {
      moduleFactory,
      defaultAxes,
      solo,
      stackable,
      groupable,
      stackedByDefault
    });
    chartTypes2.set(seriesType, chartType);
    if (!hidden) {
      publicChartTypes.set(seriesType, chartType);
    }
  }
  create(seriesType, moduleContext) {
    const seriesFactory = this.seriesMap.get(seriesType)?.moduleFactory;
    if (seriesFactory) {
      return seriesFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown series type: ${seriesType}`);
  }
  cloneDefaultAxes(seriesType) {
    const defaultAxes = this.seriesMap.get(seriesType)?.defaultAxes;
    if (defaultAxes == null)
      return null;
    return { axes: deepClone(defaultAxes) };
  }
  setThemeTemplate(seriesType, themeTemplate) {
    const currentTemplate = this.themeTemplates.get(seriesType);
    this.themeTemplates.set(seriesType, mergeDefaults(themeTemplate, currentTemplate));
  }
  getThemeTemplate(seriesType) {
    return this.themeTemplates.get(seriesType);
  }
  isSolo(seriesType) {
    return this.seriesMap.get(seriesType)?.solo ?? false;
  }
  isGroupable(seriesType) {
    return this.seriesMap.get(seriesType)?.groupable ?? false;
  }
  isStackable(seriesType) {
    return this.seriesMap.get(seriesType)?.stackable ?? false;
  }
  isStackedByDefault(seriesType) {
    return this.seriesMap.get(seriesType)?.stackedByDefault ?? false;
  }
};
var seriesRegistry = new SeriesRegistry();

// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager = class _SyncManager {
  constructor(chart) {
    this.chart = chart;
  }
  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    let syncGroup = this.get(groupId);
    if (!syncGroup) {
      syncGroup = { members: /* @__PURE__ */ new Set() };
      _SyncManager.chartsGroups.set(groupId, syncGroup);
    }
    syncGroup.members.add(this.chart);
    return this;
  }
  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    const groupState = this.get(groupId);
    groupState?.members.delete(this.chart);
    delete groupState?.domains?.x?.sources?.[this.chart.id];
    delete groupState?.domains?.y?.sources?.[this.chart.id];
    return this;
  }
  getChart() {
    return this.chart;
  }
  getGroupState(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.get(groupId);
  }
  getGroupMembers(groupId = _SyncManager.DEFAULT_GROUP) {
    const syncGroup = this.get(groupId);
    return syncGroup ? Array.from(syncGroup.members) : [];
  }
  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.getGroupMembers(groupId).filter((chart) => chart !== this.chart);
  }
  getGroupSyncMode(groupId = _SyncManager.DEFAULT_GROUP) {
    if (this.getGroupMembers(groupId).some((c) => c.series.length > 1)) {
      return "multi-series";
    }
    return "single-series";
  }
  get(groupId) {
    return _SyncManager.chartsGroups.get(groupId);
  }
};
_SyncManager.chartsGroups = /* @__PURE__ */ new Map();
_SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
var SyncManager = _SyncManager;

// packages/ag-charts-community/src/chart/keyboard.ts
var Keyboard = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Property
], Keyboard.prototype, "enabled", 2);
__decorateClass([
  Property
], Keyboard.prototype, "tabIndex", 2);

// packages/ag-charts-community/src/motion/fromToMotion.ts
var fromToMotion_exports = {};
__export(fromToMotion_exports, {
  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,
  fromToMotion: () => fromToMotion,
  staticFromToMotion: () => staticFromToMotion
});
var NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
  added: "add",
  updated: "update",
  removed: "remove",
  unknown: "initial",
  "no-op": "none"
};
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff8) {
  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const processNodes = (liveNodes, subNodes) => {
    let prevFromProps;
    let liveNodeIndex = 0;
    let nodeIndex = 0;
    for (const node of subNodes) {
      const isLive = liveNodes[liveNodeIndex] === node;
      const ctx = {
        last: nodeIndex >= subNodes.length - 1,
        lastLive: liveNodeIndex >= liveNodes.length - 1,
        prev: subNodes[nodeIndex - 1],
        prevFromProps,
        prevLive: liveNodes[liveNodeIndex - 1],
        next: subNodes[nodeIndex + 1],
        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
      };
      const animationId = `${groupId}_${subId}_${node.id}`;
      animationManager.stopByAnimationId(animationId);
      let status = "unknown";
      if (!isLive) {
        status = "removed";
      } else if (getDatumId && diff8) {
        status = calculateStatus(node, node.datum, getDatumId, diff8);
      }
      node.transitionOut = status === "removed";
      const { phase, start: start2, finish, delay, duration, ...from3 } = fromFn(node, node.datum, status, ctx);
      const {
        phase: toPhase,
        start: toStart,
        finish: toFinish,
        delay: toDelay,
        duration: toDuration,
        ...to
      } = toFn(node, node.datum, status, ctx);
      const collapsable = finish == null;
      animationManager.animate({
        id: animationId,
        groupId,
        phase: phase ?? toPhase ?? "update",
        duration: duration ?? toDuration,
        delay: delay ?? toDelay,
        from: from3,
        to,
        ease: easeOut,
        collapsable,
        onPlay: () => {
          const startProps = { ...start2, ...toStart, ...from3 };
          applyFn(node, startProps, "start");
        },
        onUpdate(props) {
          applyFn(node, props, "update");
        },
        onStop: () => {
          const endProps = {
            ...start2,
            ...toStart,
            ...from3,
            ...to,
            ...finish,
            ...toFinish
          };
          applyFn(node, endProps, "end");
        }
      });
      if (isLive) {
        liveNodeIndex++;
      }
      nodeIndex++;
      prevFromProps = from3;
    }
  };
  let selectionIndex = 0;
  for (const selection of selections) {
    const selectionNodes = selection.nodes();
    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));
    processNodes(liveNodes, selectionNodes);
    animationManager.animate({
      id: `${groupId}_${subId}_selection_${selectionIndex}`,
      groupId,
      phase: "end",
      from: 0,
      to: 1,
      ease: easeOut,
      onStop() {
        selection.cleanup();
      }
    });
    selectionIndex++;
  }
  processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from3, to, extraOpts) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const { start: start2, finish, phase } = extraOpts;
  animationManager.animate({
    id: `${groupId}_${subId}`,
    groupId,
    phase: phase ?? "update",
    from: from3,
    to,
    ease: easeOut,
    onPlay: () => {
      if (!start2)
        return;
      for (const node of nodes) {
        node.setProperties(start2);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(start2);
        }
      }
    },
    onUpdate(props) {
      for (const node of nodes) {
        node.setProperties(props);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(props);
        }
      }
    },
    onStop: () => {
      for (const node of nodes) {
        node.setProperties({ ...to, ...finish });
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties({ ...to, ...finish });
        }
        selection.cleanup();
      }
    }
  });
}
function calculateStatus(node, datum, getDatumId, diff8) {
  const id = getDatumId(node, datum);
  if (diff8.added.has(id)) {
    return "added";
  }
  if (diff8.removed.has(id)) {
    return "removed";
  }
  if (node.previousDatum == null && node.datum != null) {
    return "added";
  }
  if (node.previousDatum != null && node.datum == null) {
    return "removed";
  }
  return "updated";
}

// packages/ag-charts-community/src/motion/resetMotion.ts
var resetMotion_exports = {};
__export(resetMotion_exports, {
  resetMotion: () => resetMotion
});
function resetMotion(selectionsOrNodes, propsFn) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  for (const selection of selections) {
    for (const node of selection.nodes()) {
      const from3 = propsFn(node, node.datum);
      node.setProperties(from3);
    }
    selection.cleanup();
  }
  for (const node of nodes) {
    const from3 = propsFn(node, node.datum);
    node.setProperties(from3);
  }
}

// packages/ag-charts-community/src/scene/selection.ts
var Selection = class _Selection {
  constructor(parentNode, classOrFactory, autoCleanup = true) {
    this.parentNode = parentNode;
    this.autoCleanup = autoCleanup;
    this.garbageBin = /* @__PURE__ */ new Set();
    this._nodesMap = /* @__PURE__ */ new Map();
    this._nodes = [];
    this.data = [];
    this.debug = Debug.create(true, "scene", "scene:selections");
    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node2, classOrFactory) ? () => new classOrFactory() : classOrFactory;
  }
  static select(parent, classOrFactory, garbageCollection = true) {
    return new _Selection(parent, classOrFactory, garbageCollection);
  }
  static selectAll(parent, predicate) {
    const results = [];
    const traverse = (node) => {
      if (predicate(node)) {
        results.push(node);
      }
      if (node instanceof Group) {
        for (const child of node.children()) {
          traverse(child);
        }
      }
    };
    traverse(parent);
    return results;
  }
  static selectByClass(node, ...Classes) {
    return _Selection.selectAll(node, (n) => Classes.some((C2) => n instanceof C2));
  }
  static selectByTag(node, tag) {
    return _Selection.selectAll(node, (n) => n.tag === tag);
  }
  createNode(datum, initializer, idx) {
    const node = this.nodeFactory(datum);
    node.datum = datum;
    initializer?.(node);
    if (idx == null) {
      this._nodes.push(node);
    } else {
      this._nodes.splice(idx, 0, node);
    }
    this.parentNode.appendChild(node);
    return node;
  }
  /**
   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
   * of the array.
   */
  update(data, initializer, getDatumId) {
    if (this.garbageBin.size > 0) {
      this.debug(`Selection - update() called with pending garbage`, data);
    }
    if (getDatumId) {
      const dataMap = /* @__PURE__ */ new Map();
      const duplicateMap = /* @__PURE__ */ new Map();
      for (let idx = 0; idx < data.length; idx++) {
        const datum = data[idx];
        let id = getDatumId(datum);
        if (dataMap.has(id)) {
          const index = (duplicateMap.get(id) ?? 0) + 1;
          duplicateMap.set(id, index);
          id = `${id}:${index}`;
        }
        dataMap.set(id, idx);
      }
      for (const [node, datumId] of this._nodesMap.entries()) {
        const idx = dataMap.get(datumId);
        if (idx == null) {
          this.garbageBin.add(node);
        } else {
          node.datum = data[idx];
          this.garbageBin.delete(node);
          dataMap.delete(datumId);
        }
      }
      for (const [datumId, idx] of dataMap.entries()) {
        const datum = data[idx];
        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
      }
    } else {
      const maxLength = Math.max(data.length, this.data.length);
      for (let i = 0; i < maxLength; i++) {
        if (i >= data.length) {
          this.garbageBin.add(this._nodes[i]);
        } else if (i >= this._nodes.length) {
          this.createNode(data[i], initializer);
        } else {
          this._nodes[i].datum = data[i];
          this.garbageBin.delete(this._nodes[i]);
        }
      }
    }
    this.data = data.slice();
    if (this.autoCleanup) {
      this.cleanup();
    }
    return this;
  }
  cleanup() {
    if (this.garbageBin.size === 0) {
      return this;
    }
    this._nodes = this._nodes.filter((node) => {
      if (this.garbageBin.has(node)) {
        this._nodesMap.delete(node);
        this.garbageBin.delete(node);
        node.destroy();
        return false;
      }
      return true;
    });
    return this;
  }
  clear() {
    this.update([]);
    return this;
  }
  isGarbage(node) {
    return this.garbageBin.has(node);
  }
  each(iterate2) {
    for (const entry of this._nodes.entries()) {
      iterate2(entry[1], entry[1].datum, entry[0]);
    }
    return this;
  }
  *[Symbol.iterator]() {
    for (let index = 0; index < this._nodes.length; index++) {
      const node = this._nodes[index];
      yield { node, datum: node.datum, index };
    }
  }
  select(predicate) {
    return _Selection.selectAll(this.parentNode, predicate);
  }
  selectByClass(Class) {
    return _Selection.selectByClass(this.parentNode, Class);
  }
  selectByTag(tag) {
    return _Selection.selectByTag(this.parentNode, tag);
  }
  nodes() {
    return this._nodes;
  }
  at(index) {
    return this._nodes.at(index);
  }
  get length() {
    return this._nodes.length;
  }
};

// packages/ag-charts-community/src/scene/shape/line.ts
var Line = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.fill = void 0;
    this.strokeWidth = 1;
  }
  set x(value) {
    this.x1 = value;
    this.x2 = value;
  }
  set y(value) {
    this.y1 = value;
    this.y2 = value;
  }
  get midPoint() {
    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };
  }
  computeBBox() {
    return new BBox(
      Math.min(this.x1, this.x2),
      Math.min(this.y1, this.y2),
      Math.abs(this.x2 - this.x1),
      Math.abs(this.y2 - this.y1)
    );
  }
  isPointInPath(x, y) {
    if (this.x1 === this.x2 || this.y1 === this.y2) {
      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);
    }
    return false;
  }
  distanceSquared(px, py) {
    const { x1, y1, x2, y2 } = this;
    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);
  }
  render(renderCtx) {
    const { ctx, devicePixelRatio } = renderCtx;
    let { x1, y1, x2, y2 } = this;
    if (x1 === x2) {
      const { strokeWidth } = this;
      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      x1 = x;
      x2 = x;
    } else if (y1 === y2) {
      const { strokeWidth } = this;
      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      y1 = y;
      y2 = y;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    this.fillStroke(ctx);
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = createSvgElement("line");
    element2.setAttribute("x1", String(this.x1));
    element2.setAttribute("y1", String(this.y1));
    element2.setAttribute("x2", String(this.x2));
    element2.setAttribute("y2", String(this.y2));
    this.applySvgStrokeAttributes(element2);
    return {
      elements: [element2]
    };
  }
};
Line.className = "Line";
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "y2", 2);

// packages/ag-charts-community/src/util/stateMachine.ts
var debugColor = "color: green";
var debugQuietColor = "color: grey";
function StateMachineProperty() {
  return addObserverToInstanceProperty(() => {
  });
}
function applyProperties(parentState, childState) {
  const childProperties = listDecoratedProperties(childState);
  if (childProperties.length === 0)
    return;
  const properties = extractDecoratedProperties(parentState);
  for (const property of childProperties) {
    if (property in properties) {
      childState[property] = properties[property];
    }
  }
}
var AbstractStateMachine = class {
  transitionRoot(event, data) {
    if (this.parent) {
      this.parent.transitionRoot(event, data);
    } else {
      this.transition(event, data);
    }
  }
};
var _StateMachine = class _StateMachine extends AbstractStateMachine {
  constructor(defaultState, states, enterEach) {
    super();
    this.defaultState = defaultState;
    this.states = states;
    this.enterEach = enterEach;
    this.debug = Debug.create(true, "animation");
    this.state = defaultState;
    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);
  }
  // TODO: handle events which do not require data without requiring `undefined` to be passed as as parameter, while
  // also still requiring data to be passed to those events which do require it.
  transition(event, data) {
    const shouldTransitionSelf = this.transitionChild(event, data);
    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {
      return;
    }
    const currentState = this.state;
    const currentStateConfig = this.states[this.state];
    let destination = currentStateConfig[event];
    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;
    if (Array.isArray(destination)) {
      destination = destination.find((transition) => {
        if (!transition.guard)
          return true;
        const valid = transition.guard(data);
        if (!valid) {
          this.debug(`${debugPrefix} (guarded)`, transition.target, debugQuietColor);
        }
        return valid;
      });
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {
      this.debug(`${debugPrefix} (guarded)`, destination.target, debugQuietColor);
      return;
    }
    if (!destination) {
      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);
      return;
    }
    const destinationState = this.getDestinationState(destination);
    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;
    this.debug(`${debugPrefix} ${destinationState}`, debugColor);
    this.state = destinationState;
    if (typeof destination === "function") {
      destination(data);
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine)) {
      destination.action?.(data);
    }
    exitFn?.();
    this.enterEach?.(currentState, destinationState);
    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {
      this.states[destinationState].onEnter?.(currentState, data);
    }
  }
  transitionAsync(event, data) {
    setTimeout(() => {
      this.transition(event, data);
    }, 0);
  }
  is(value) {
    if (this.state === _StateMachine.child && this.childState) {
      return this.childState.is(value);
    }
    return this.state === value;
  }
  resetHierarchy() {
    this.debug(
      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,
      "color: green"
    );
    this.state = this.defaultState;
  }
  transitionChild(event, data) {
    if (this.state !== _StateMachine.child || !this.childState)
      return true;
    applyProperties(this, this.childState);
    this.childState.transition(event, data);
    if (!this.childState.is(_StateMachine.parent))
      return true;
    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);
    this.state = this.defaultState;
    this.states[this.state].onEnter?.();
    this.childState.resetHierarchy();
    return false;
  }
  getDestinationState(destination) {
    let state = this.state;
    if (typeof destination === "string") {
      state = destination;
    } else if (destination instanceof _StateMachine) {
      this.childState = destination;
      this.childState.parent = this;
      state = _StateMachine.child;
    } else if (typeof destination === "object") {
      if (destination.target instanceof _StateMachine) {
        this.childState = destination.target;
        this.childState.parent = this;
        state = _StateMachine.child;
      } else if (destination.target != null) {
        state = destination.target;
      }
    }
    return state;
  }
};
_StateMachine.child = "__child";
_StateMachine.parent = "__parent";
var StateMachine = _StateMachine;
var ParallelStateMachine = class extends AbstractStateMachine {
  constructor(...stateMachines) {
    super();
    this.stateMachines = stateMachines;
    for (const stateMachine of stateMachines) {
      stateMachine.parent = this;
    }
  }
  transition(event, data) {
    for (const stateMachine of this.stateMachines) {
      applyProperties(this, stateMachine);
      stateMachine.transition(event, data);
    }
  }
  transitionAsync(event, data) {
    for (const stateMachine of this.stateMachines) {
      applyProperties(this, stateMachine);
      stateMachine.transitionAsync(event, data);
    }
  }
};

// packages/ag-charts-community/src/util/time/duration.ts
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// packages/ag-charts-community/src/util/time/encoding.ts
var tzOffset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
var unitEncoding = {
  millisecond: {
    milliseconds: 1,
    hierarchy: "day",
    encode(date2) {
      return date2.getTime();
    },
    decode(encoded) {
      return new Date(encoded);
    }
  },
  second: {
    milliseconds: durationSecond,
    hierarchy: "day",
    encode(date2, utc) {
      const offset = utc ? 0 : tzOffset;
      return Math.floor((date2.getTime() - offset) / durationSecond);
    },
    decode(encoded, utc) {
      const offset = utc ? 0 : tzOffset;
      return new Date(offset + encoded * durationSecond);
    }
  },
  minute: {
    milliseconds: durationMinute,
    hierarchy: "day",
    encode(date2, utc) {
      const offset = utc ? 0 : tzOffset;
      return Math.floor((date2.getTime() - offset) / durationMinute);
    },
    decode(encoded, utc) {
      const offset = utc ? 0 : tzOffset;
      return new Date(offset + encoded * durationMinute);
    }
  },
  hour: {
    milliseconds: durationHour,
    hierarchy: "day",
    encode(date2, utc) {
      const offset = utc ? 0 : tzOffset;
      return Math.floor((date2.getTime() - offset) / durationHour);
    },
    decode(encoded, utc) {
      const offset = utc ? 0 : tzOffset;
      return new Date(offset + encoded * durationHour);
    }
  },
  day: {
    milliseconds: durationDay,
    hierarchy: "month",
    encode(date2, utc) {
      const tzOffsetMs = utc ? 0 : date2.getTimezoneOffset() * durationMinute;
      return Math.floor((date2.getTime() - tzOffsetMs) / durationDay);
    },
    decode(encoded, utc) {
      let d;
      if (utc) {
        d = /* @__PURE__ */ new Date(0);
        d.setUTCDate(d.getUTCDate() + encoded);
        d.setUTCHours(0, 0, 0, 0);
      } else {
        d = new Date(1970, 0, 1);
        d.setDate(d.getDate() + encoded);
      }
      return d;
    }
  },
  month: {
    milliseconds: durationMonth,
    hierarchy: "year",
    encode(date2, utc) {
      if (utc) {
        return date2.getUTCFullYear() * 12 + date2.getUTCMonth();
      } else {
        return date2.getFullYear() * 12 + date2.getMonth();
      }
    },
    decode(encoded, utc) {
      if (utc) {
        const year = Math.floor(encoded / 12);
        const m = encoded - year * 12;
        return new Date(Date.UTC(year, m, 1));
      } else {
        const y = Math.floor(encoded / 12);
        const month = encoded - y * 12;
        return new Date(y, month, 1);
      }
    }
  },
  year: {
    milliseconds: durationYear,
    hierarchy: void 0,
    encode(date2, utc) {
      if (utc) {
        return date2.getUTCFullYear();
      } else {
        return date2.getFullYear();
      }
    },
    decode(encoded, utc) {
      let d;
      if (utc) {
        d = /* @__PURE__ */ new Date();
        d.setUTCFullYear(encoded);
        d.setUTCMonth(0, 1);
        d.setUTCHours(0, 0, 0, 0);
      } else {
        d = new Date(encoded, 0, 1, 0, 0, 0, 0);
      }
      return d;
    }
  }
};

// packages/ag-charts-community/src/util/time/range.ts
function timeInterval(interval) {
  return typeof interval === "string" ? { unit: interval, step: 1, epoch: void 0, utc: false } : {
    unit: interval.unit,
    step: interval.step ?? 1,
    epoch: interval.epoch,
    utc: interval.utc ?? false
  };
}
function getOffset(unit, step, epoch, utc) {
  if (epoch == null)
    return 0;
  const encoding = unitEncoding[unit];
  return Math.floor(encoding.encode(new Date(epoch), utc)) % step;
}
function encode(d, unit, step, utc, offset) {
  const encoding = unitEncoding[unit];
  return Math.floor((encoding.encode(new Date(d), utc) - offset) / step);
}
function decode(encoded, unit, step, utc, offset) {
  const encoding = unitEncoding[unit];
  return encoding.decode(encoded * step + offset, utc);
}
function encodingFloor(date2, unit, step, utc, offset) {
  const d = new Date(date2);
  const e = encode(d, unit, step, utc, offset);
  return decode(e, unit, step, utc, offset);
}
function encodingCeil(date2, unit, step, utc, offset) {
  const d = new Date(Number(date2) - 1);
  const e = encode(d, unit, step, utc, offset);
  return decode(e + 1, unit, step, utc, offset);
}
function intervalFloor(interval, date2) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return encodingFloor(date2, unit, step, utc, offset);
}
function intervalCeil(interval, date2) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return encodingCeil(date2, unit, step, utc, offset);
}
function intervalPrevious(interval, date2) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return decode(
    encode(encodingCeil(date2, unit, step, utc, offset), unit, step, utc, offset) - 1,
    unit,
    step,
    utc,
    offset
  );
}
function intervalNext(interval, date2) {
  const { unit, step, epoch, utc } = timeInterval(interval);
  const offset = getOffset(unit, step, epoch, utc);
  return decode(
    encode(encodingFloor(date2, unit, step, utc, offset), unit, step, utc, offset) + 1,
    unit,
    step,
    utc,
    offset
  );
}
function intervalExtent(start2, stop, visibleRange) {
  if (start2.valueOf() > stop.valueOf()) {
    [start2, stop] = [stop, start2];
    if (visibleRange != null) {
      visibleRange = [1 - visibleRange[1], 1 - visibleRange[0]];
    }
  }
  if (visibleRange != null) {
    const delta4 = stop.valueOf() - start2.valueOf();
    const t0 = start2.valueOf();
    start2 = new Date(t0 + visibleRange[0] * delta4);
    stop = new Date(t0 + visibleRange[1] * delta4);
  }
  return [new Date(start2), new Date(stop)];
}
function rangeData(interval, start2, stop, { extend = false, visibleRange = [0, 1], limit, defaultAlignment = "start" } = {}) {
  const params = timeInterval(interval);
  const { unit, step, utc } = params;
  let epoch;
  if (params.epoch != null) {
    epoch = params.epoch;
  } else if (defaultAlignment === "interval") {
    epoch = void 0;
  } else if (start2.valueOf() > stop.valueOf()) {
    epoch = stop;
  } else {
    epoch = start2;
  }
  const offset = getOffset(params.unit, params.step, epoch, params.utc);
  let [d0, d1] = intervalExtent(start2, stop, visibleRange);
  d0 = extend ? encodingFloor(d0, unit, step, utc, offset) : encodingCeil(d0, unit, step, utc, offset);
  d1 = extend ? encodingCeil(d1, unit, step, utc, offset) : encodingFloor(d1, unit, step, utc, offset);
  const e0 = encode(d0, unit, step, utc, offset);
  let e1 = encode(d1, unit, step, utc, offset);
  if (limit != null && e1 - e0 > limit) {
    e1 = e0 + limit;
  }
  return {
    range: [e0, e1],
    unit,
    step,
    utc,
    offset
  };
}
function intervalRangeCount(interval, start2, stop, params) {
  const {
    range: [e0, e1]
  } = rangeData(interval, start2, stop, params);
  return Math.abs(e1 - e0);
}
function intervalRange(interval, start2, stop, params) {
  const {
    range: [e0, e1],
    unit,
    step,
    utc,
    offset
  } = rangeData(interval, start2, stop, params);
  const values = [];
  for (let e = e0; e <= e1; e += 1) {
    const d = decode(e, unit, step, utc, offset);
    values.push(d);
  }
  return values;
}
function intervalRangeStartIndex(interval, start2, stop, { extend, visibleRange, limit, defaultAlignment } = {}) {
  const {
    range: [s]
  } = rangeData(interval, start2, stop, { extend, visibleRange, limit, defaultAlignment });
  const {
    range: [s0]
  } = rangeData(interval, start2, stop, { extend, limit, defaultAlignment });
  return s - s0;
}

// packages/ag-charts-community/src/util/time/index.ts
function intervalUnit(interval) {
  return typeof interval === "string" ? interval : interval.unit;
}
function intervalStep(interval) {
  return typeof interval === "string" ? 1 : interval.step ?? 1;
}
function intervalEpoch(interval) {
  return typeof interval === "string" ? void 0 : interval.epoch;
}
function intervalHierarchy(interval) {
  return unitEncoding[intervalUnit(interval)].hierarchy;
}
function intervalMilliseconds(interval) {
  const step = intervalStep(interval);
  return step * unitEncoding[intervalUnit(interval)].milliseconds;
}

// packages/ag-charts-community/src/chart/label.ts
var LabelBorder = class {
  constructor() {
    this.enabled = true;
  }
};
__decorateClass([
  Property
], LabelBorder.prototype, "enabled", 2);
__decorateClass([
  Property
], LabelBorder.prototype, "stroke", 2);
__decorateClass([
  Property
], LabelBorder.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LabelBorder.prototype, "strokeOpacity", 2);
var Label = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.border = new LabelBorder();
    this._cachedFormatter = void 0;
  }
  formatValue(formatWithContext2, type, value, params) {
    const { formatter: formatter2, format } = this;
    let result;
    if (formatter2 != null) {
      result ?? (result = formatWithContext2(formatter2, params));
    }
    if (format != null) {
      let cachedFormatter = this._cachedFormatter;
      if (cachedFormatter == null || cachedFormatter.type !== type || cachedFormatter.format !== format) {
        cachedFormatter = {
          type,
          format,
          formatter: FormatManager.getFormatter(type, format)
        };
        this._cachedFormatter = cachedFormatter;
      }
      result ?? (result = cachedFormatter.formatter?.(value));
    }
    return result != null ? String(result) : void 0;
  }
};
__decorateClass([
  Property
], Label.prototype, "enabled", 2);
__decorateClass([
  Property
], Label.prototype, "border", 2);
__decorateClass([
  Property
], Label.prototype, "color", 2);
__decorateClass([
  Property
], Label.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], Label.prototype, "fill", 2);
__decorateClass([
  Property
], Label.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], Label.prototype, "fontStyle", 2);
__decorateClass([
  Property
], Label.prototype, "fontWeight", 2);
__decorateClass([
  Property
], Label.prototype, "fontSize", 2);
__decorateClass([
  Property
], Label.prototype, "fontFamily", 2);
__decorateClass([
  Property
], Label.prototype, "formatter", 2);
__decorateClass([
  Property
], Label.prototype, "format", 2);
__decorateClass([
  Property
], Label.prototype, "padding", 2);
__decorateClass([
  Property
], Label.prototype, "itemStyler", 2);
function expandLabelPadding(label) {
  const { enabled: borderEnabled = false, stroke: borderStroke } = label?.border ?? {};
  const hasBoxing = label?.fill != null || borderEnabled && borderStroke != null;
  const padding2 = hasBoxing ? label?.padding : null;
  if (padding2 == null) {
    return { bottom: 0, left: 0, right: 0, top: 0 };
  } else if (typeof padding2 === "number") {
    return { bottom: padding2, left: padding2, right: padding2, top: padding2 };
  } else {
    const { bottom = 0, left = 0, right = 0, top = 0 } = padding2;
    return { bottom, left, right, top };
  }
}
function calculateLabelRotation(rotation, parallel, regularFlipRotation = 0, parallelFlipRotation = 0) {
  const configuredRotation = normalizeAngle360FromDegrees(rotation);
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };
}
function getLabelSpacing(minSpacing, rotated) {
  if (minSpacing != null) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
  if (parallel && !labelRotation) {
    return sideFlag * parallelFlipFlag === -1 ? "top" : "bottom";
  }
  return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return "end";
      }
    } else {
      return "center";
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return "end";
  }
  return "start";
}
function labelSpecifier(format, timeInterval3) {
  if (format == null)
    return;
  if (typeof format === "string") {
    return format;
  } else if (isPlainObject(format) && timeInterval3 != null) {
    return format[intervalUnit(timeInterval3)];
  }
}
function timeIntervalMaxLabelSize(label, primaryLabel, domain, timeInterval3, textMeasurer) {
  const specifier = labelSpecifier(label.format, timeInterval3) ?? (typeof label.format === "string" ? label.format : void 0);
  if (specifier == null)
    return { width: 0, height: 0 };
  const labelFormatter = buildDateFormatter(specifier);
  const hierarchy = timeInterval3 ? intervalHierarchy(timeInterval3) : void 0;
  const primarySpecifier = labelSpecifier(primaryLabel?.format, hierarchy);
  const primaryLabelFormatter = primarySpecifier ? buildDateFormatter(primarySpecifier) : labelFormatter;
  const d0 = new Date(domain[0]);
  const d1 = new Date(domain[domain.length - 1]);
  const hierarchyRange = hierarchy ? intervalRange(hierarchy, new Date(domain[0]), new Date(domain[domain.length - 1]), {
    extend: true
  }) : void 0;
  let maxWidth = 0;
  let maxHeight = 0;
  if (labelFormatter != null) {
    const padding2 = expandLabelPadding(label);
    const xPadding = padding2.left + padding2.right;
    const yPadding = padding2.top + padding2.bottom;
    let l0;
    let l1;
    if (hierarchyRange != null && hierarchyRange.length > 1) {
      l0 = hierarchyRange[0];
      l1 = hierarchyRange[1];
    } else {
      l0 = d0;
      l1 = d1;
    }
    const labelRange = intervalRange(timeInterval3, l0, l1, { limit: 50 });
    for (const date2 of labelRange) {
      const text2 = labelFormatter(date2);
      const { width: width2, height: height2 } = textMeasurer.measureLines(text2);
      maxWidth = Math.max(maxWidth, width2 + xPadding);
      maxHeight = Math.max(maxHeight, height2 + yPadding);
    }
  }
  if (primaryLabelFormatter != null && hierarchyRange != null) {
    const padding2 = expandLabelPadding(primaryLabel);
    const xPadding = padding2.left + padding2.right;
    const yPadding = padding2.top + padding2.bottom;
    for (const date2 of hierarchyRange) {
      const text2 = primaryLabelFormatter(date2);
      const { width: width2, height: height2 } = textMeasurer.measureLines(text2);
      maxWidth = Math.max(maxWidth, width2 + xPadding);
      maxHeight = Math.max(maxHeight, height2 + yPadding);
    }
  }
  return {
    width: Math.ceil(maxWidth),
    height: Math.ceil(maxHeight)
  };
}
function createLabelData(tickData, labelX, labelMatrix, textMeasurer, label) {
  const padding2 = expandLabelPadding(label);
  const xPadding = padding2.left + padding2.right;
  const yPadding = padding2.top + padding2.bottom;
  const labelData = [];
  for (const { tickLabel: text2, translation } of tickData) {
    if (!text2)
      continue;
    const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translation, 0, 0));
    const metrics = textMeasurer.measureLines(text2);
    const width2 = metrics.width + xPadding;
    const height2 = metrics.height + yPadding;
    labelData.push({
      point: { x, y },
      label: { text: text2, width: width2, height: height2 }
    });
  }
  return labelData;
}
function createFixedLabelData({ width: width2, height: height2, spacing }, labelX, labelMatrix) {
  const labelData = [];
  for (const translationY of [0, spacing]) {
    const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translationY, 0, 0));
    labelData.push({
      point: { x, y },
      label: { text: void 0, width: width2, height: height2 }
    });
  }
  return labelData;
}

// packages/ag-charts-community/src/module/moduleMap.ts
var ModuleMap = class {
  constructor() {
    this.moduleMap = /* @__PURE__ */ new Map();
  }
  *modules() {
    for (const m of this.moduleMap.values()) {
      yield m.moduleInstance;
    }
  }
  addModule(module2, moduleFactory) {
    if (this.moduleMap.has(module2.optionsKey)) {
      throw new Error(`AG Charts - module already initialised: ${module2.optionsKey}`);
    }
    this.moduleMap.set(module2.optionsKey, { module: module2, moduleInstance: moduleFactory(module2) });
  }
  removeModule(module2) {
    const moduleKey = isString(module2) ? module2 : module2.optionsKey;
    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    this.moduleMap.delete(moduleKey);
  }
  getModule(module2) {
    return this.moduleMap.get(isString(module2) ? module2 : module2.optionsKey)?.moduleInstance;
  }
  isEnabled(module2) {
    return this.moduleMap.has(isString(module2) ? module2 : module2.optionsKey);
  }
  mapModules(callback2) {
    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));
  }
  destroy() {
    for (const moduleKey of this.moduleMap.keys()) {
      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    }
    this.moduleMap.clear();
  }
};

// packages/ag-charts-community/src/scene/shape/range.ts
var Range = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.startLine = false;
    this.endLine = false;
    this.horizontal = false;
    this.strokeWidth = 1;
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    let { x1, y1, x2, y2 } = this;
    x1 = this.align(x1);
    y1 = this.align(y1);
    x2 = this.align(x2);
    y2 = this.align(y2);
    const { fill, horizontal } = this;
    const { globalAlpha } = ctx;
    if (fill != null) {
      this.applyFillAndAlpha(ctx);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x1, y2);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = globalAlpha;
    }
    const { stroke: stroke3, strokeWidth, startLine, endLine } = this;
    const strokeActive = !!((startLine || endLine) && stroke3 && strokeWidth);
    if (strokeActive) {
      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash([...lineDash]);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.beginPath();
      if (startLine) {
        ctx.moveTo(x1, y1);
        if (horizontal) {
          ctx.lineTo(x1, y2);
        } else {
          ctx.lineTo(x2, y1);
        }
      }
      if (endLine) {
        ctx.moveTo(x2, y2);
        if (horizontal) {
          ctx.lineTo(x2, y1);
        } else {
          ctx.lineTo(x1, y2);
        }
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
};
Range.className = "Range";
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "y2", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "startLine", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "endLine", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "horizontal", 2);

// packages/ag-charts-community/src/util/value.ts
function isStringObject(value) {
  return value != null && Object.hasOwn(value, "toString") && isString(value.toString());
}
function isNumberObject(value) {
  return value != null && Object.hasOwn(value, "valueOf") && isFiniteNumber(value.valueOf());
}
function isContinuous(value) {
  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);
}
function checkDatum(value, isContinuousScale) {
  return value != null && (!isContinuousScale || isContinuous(value));
}
function transformIntegratedCategoryValue(value) {
  if (isStringObject(value) && Object.hasOwn(value, "id")) {
    return value.id;
  }
  return value;
}

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
function getCrossLineValue(crossLine) {
  switch (crossLine.type) {
    case "line":
      return crossLine.value;
    case "range":
      return crossLine.range;
  }
}
function validateCrossLineValue(crossLine, scale2) {
  const value = getCrossLineValue(crossLine);
  if (value == null) {
    return false;
  }
  const isContinuous3 = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
  const validValue = (val) => checkDatum(val, isContinuous3) && !isNaN(scale2.convert(val, { clamp: true }));
  if (crossLine.type === "range") {
    const [start2, end2] = value;
    return validValue(start2) && validValue(end2);
  } else {
    return validValue(value);
  }
}

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var horizontalLineAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var verticalLineAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: -1, labelV: -1 },
  "inside-top-right": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var horizontalRangeAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var verticalRangeAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: -1, labelV: -1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var CartesianCrossLineLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fontSize = 14 /* LARGE */;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
  }
};
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "text", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "padding", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "color", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "position", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "rotation", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "parallel", 2);
var CartesianCrossLine = class extends BaseProperties {
  constructor() {
    super();
    this.id = createId(this);
    this.defaultColorRange = [];
    this.fill = "#c16068";
    this.label = new CartesianCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.position = "top";
    this.rangeGroup = new Group({ name: this.id });
    this.lineGroup = new Group({ name: this.id });
    this.labelGroup = new Group({ name: this.id });
    this.crossLineRange = new Range();
    this.crossLineLabel = new TransformableText();
    this.data = void 0;
    this.startLine = false;
    this.endLine = false;
    this._isRange = void 0;
    this.lineGroup.append(this.crossLineRange);
    this.labelGroup.append(this.crossLineLabel);
    this.crossLineRange.pointerEvents = 1 /* None */;
  }
  get defaultLabelPosition() {
    return "top";
  }
  update(visible) {
    const { enabled, type, data, scale: scale2 } = this;
    if (!scale2 || !enabled || !visible || !validateCrossLineValue(this, scale2) || data == null) {
      this.rangeGroup.visible = false;
      this.lineGroup.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.rangeGroup.visible = visible;
    this.lineGroup.visible = visible;
    this.labelGroup.visible = visible;
    this.updateNodes();
    const isRange = type === "range";
    if (isRange !== this._isRange) {
      if (isRange) {
        this.rangeGroup.appendChild(this.crossLineRange);
      } else {
        this.lineGroup.appendChild(this.crossLineRange);
      }
    }
    this._isRange = isRange;
  }
  calculateLayout(visible) {
    this.data = void 0;
    if (!visible)
      return;
    const { type, range: range4, value, scale: scale2, clippedRange, strokeWidth = 0 } = this;
    if (!scale2)
      return;
    const bandwidth = scale2.bandwidth ?? 0;
    const step = scale2.step ?? 0;
    const rangePadding = scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0;
    let [clippedRange0, clippedRange1] = findMinMax(clippedRange);
    clippedRange0 -= bandwidth;
    clippedRange1 += bandwidth;
    let yStart;
    let yEnd;
    let clampedYStart;
    let clampedYEnd;
    if (type === "line") {
      const offset = bandwidth / 2;
      yStart = scale2.convert(value) + offset;
      yEnd = NaN;
      clampedYStart = scale2.convert(value, { clamp: true }) + offset;
      clampedYEnd = NaN;
      if (clampedYStart >= clippedRange1 || clampedYStart <= clippedRange0) {
        return;
      }
    } else if (range4) {
      const [r0, r1] = range4;
      const [startAlignment, endAlignment] = rangeAlignment(r0, r1);
      yStart = scale2.convert(r0, { alignment: startAlignment });
      yEnd = scale2.convert(r1, { alignment: endAlignment });
      clampedYStart = scale2.convert(r0, { clamp: true, alignment: startAlignment });
      clampedYEnd = scale2.convert(r1, { clamp: true, alignment: endAlignment });
      if (clampedYStart > clampedYEnd) {
        [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];
        [yStart, yEnd] = [yEnd, yStart];
      }
      if (clampedYStart >= clippedRange1 || clampedYEnd <= clippedRange0) {
        return;
      }
      if (Number.isFinite(yStart)) {
        clampedYStart -= rangePadding;
      }
      if (Number.isFinite(yEnd)) {
        yEnd += bandwidth;
        clampedYEnd += bandwidth + rangePadding;
      }
    } else {
      return;
    }
    clampedYStart = clampArray(clampedYStart, clippedRange);
    clampedYEnd = clampArray(clampedYEnd, clippedRange);
    if (yStart - rangePadding >= clampedYStart)
      yStart -= rangePadding;
    if (yEnd + rangePadding <= clampedYEnd)
      yEnd += rangePadding;
    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + rangePadding;
    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - rangePadding && yEnd <= clampedYEnd;
    this.data = [clampedYStart, clampedYEnd];
    if (this.label.enabled === false || !this.label.text)
      return;
  }
  updateNodes() {
    const { position, data: [r0, r1] = [0, 0], gridLength } = this;
    const dr = Number.isFinite(r1) ? r1 - r0 : 0;
    let bounds;
    switch (position) {
      case "top":
      case "bottom":
        bounds = new BBox(r0, position === "top" ? 0 : -gridLength, dr, gridLength);
        break;
      case "left":
      case "right":
        bounds = new BBox(position === "left" ? 0 : -gridLength, r0, gridLength, dr);
    }
    this.updateRangeNode(bounds);
    const { label } = this;
    if (label.enabled !== false && label.text) {
      this.updateLabel();
      this.positionLabel(bounds);
    }
  }
  updateRangeNode(bounds) {
    const {
      type,
      position,
      crossLineRange,
      startLine,
      endLine,
      fill,
      fillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      lineDash
    } = this;
    crossLineRange.x1 = bounds.x;
    crossLineRange.x2 = bounds.x + bounds.width;
    crossLineRange.y1 = bounds.y;
    crossLineRange.y2 = bounds.y + bounds.height;
    crossLineRange.horizontal = position === "top" || position === "bottom";
    crossLineRange.startLine = startLine;
    crossLineRange.endLine = endLine;
    crossLineRange.fill = type === "range" ? fill : void 0;
    crossLineRange.fillOpacity = fillOpacity ?? 1;
    crossLineRange.stroke = stroke3;
    crossLineRange.strokeWidth = strokeWidth ?? 1;
    crossLineRange.strokeOpacity = strokeOpacity ?? 1;
    crossLineRange.lineDash = lineDash;
  }
  updateLabel() {
    const { crossLineLabel, label } = this;
    if (!label.text)
      return;
    crossLineLabel.fontStyle = label.fontStyle;
    crossLineLabel.fontWeight = label.fontWeight;
    crossLineLabel.fontSize = label.fontSize;
    crossLineLabel.fontFamily = label.fontFamily;
    crossLineLabel.fill = label.color;
    crossLineLabel.text = label.text;
  }
  get anchor() {
    const horizontal = this.position === "left" || this.position === "right";
    const range4 = this.type === "range";
    const { position = this.defaultLabelPosition } = this.label;
    if (range4) {
      const anchors = horizontal ? horizontalRangeAnchors : verticalRangeAnchors;
      return anchors[position];
    } else {
      const anchors = horizontal ? horizontalLineAnchors : verticalLineAnchors;
      return anchors[position];
    }
  }
  positionLabel(bounds) {
    const { crossLineLabel, label, anchor } = this;
    crossLineLabel.rotation = toRadians(label.rotation ?? 0);
    crossLineLabel.textBaseline = "middle";
    crossLineLabel.textAlign = "center";
    const bbox = crossLineLabel.getBBox();
    if (!bbox)
      return;
    const { width: width2, height: height2 } = bbox;
    const xOffset = label.padding + width2 / 2;
    const yOffset = label.padding + height2 / 2;
    const x = bounds.x + bounds.width * (anchor.rangeH + 1) / 2 - xOffset * anchor.labelH;
    const y = bounds.y + bounds.height * (anchor.rangeV + 1) / 2 - yOffset * anchor.labelV;
    crossLineLabel.x = x;
    crossLineLabel.y = y;
    crossLineLabel.rotationCenterX = x;
    crossLineLabel.rotationCenterY = y;
  }
  computeLabelSize() {
    const { label } = this;
    if (label.enabled === false || !label.text)
      return;
    const tempText2 = new TransformableText();
    tempText2.fontFamily = label.fontFamily;
    tempText2.fontSize = label.fontSize;
    tempText2.fontStyle = label.fontStyle;
    tempText2.fontWeight = label.fontWeight;
    tempText2.text = label.text;
    tempText2.rotation = toRadians(label.rotation ?? 0);
    tempText2.textBaseline = "middle";
    tempText2.textAlign = "center";
    const bbox = tempText2.getBBox();
    if (!bbox)
      return;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  calculatePadding(into) {
    const { label, anchor } = this;
    const size = this.computeLabelSize();
    if (!size)
      return;
    const { width: width2, height: height2 } = size;
    const xOffset = label.padding + width2;
    const yOffset = label.padding + height2;
    const horizontal = this.position === "left" || this.position === "right";
    if (horizontal) {
      if (anchor.rangeH === -1 && anchor.labelH === 1) {
        into.left = Math.max(into.left ?? 0, xOffset);
      } else if (anchor.rangeH === 1 && anchor.labelH === -1) {
        into.right = Math.max(into.right ?? 0, xOffset);
      }
    }
    if (!horizontal) {
      if (anchor.rangeV === -1 && anchor.labelV === 1) {
        into.top = Math.max(into.top ?? 0, yOffset);
      } else if (anchor.rangeV === 1 && anchor.labelV === -1) {
        into.bottom = Math.max(into.bottom ?? 0, yOffset);
      }
    }
  }
};
CartesianCrossLine.className = "CrossLine";
__decorateClass([
  Property
], CartesianCrossLine.prototype, "enabled", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "type", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "range", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "value", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "fill", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "stroke", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "lineDash", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "label", 2);

// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var AxisGridLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.style = [
      {
        fill: void 0,
        fillOpacity: 1,
        stroke: void 0,
        strokeWidth: void 0,
        lineDash: []
      }
    ];
  }
};
__decorateClass([
  Property
], AxisGridLine.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisGridLine.prototype, "width", 2);
__decorateClass([
  Property
], AxisGridLine.prototype, "style", 2);

// packages/ag-charts-community/src/chart/axis/axisInterval.ts
var AxisInterval = class extends BaseProperties {
};
__decorateClass([
  Property
], AxisInterval.prototype, "placement", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "step", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "values", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "minSpacing", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "maxSpacing", 2);

// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.border = new LabelBorder();
    this.wrapping = "never";
    this.truncate = false;
    this.spacing = 5;
    this.color = "#575757";
    this.avoidCollisions = true;
    this.mirrored = false;
    this.parallel = false;
    this._formatters = {
      "component:year": void 0,
      "component:month": void 0,
      "component:day": void 0,
      "component:none": void 0,
      "long:year": void 0,
      "long:month": void 0,
      "long:day": void 0,
      "long:none": void 0
    };
  }
  /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */
  getSideFlag() {
    return this.mirrored ? 1 : -1;
  }
  formatValue(callWithContext3, params, index, options = {
    dateStyle: "long",
    truncateDate: void 0
  }) {
    const { formatter: formatter2, format } = this;
    const { type, value, domain, boundSeries } = params;
    const fractionDigits = params.type === "number" ? params.fractionDigits : void 0;
    const unit = params.type === "date" ? params.unit : void 0;
    let result;
    if (formatter2 != null) {
      const step = params.type === "date" ? params.step : void 0;
      result = callWithContext3(formatter2, { value, index, domain, fractionDigits, unit, step, boundSeries });
    }
    if (format != null && result == null) {
      const { specifier, dateStyle, truncateDate } = options;
      const cacheKey = `${dateStyle}:${truncateDate ?? "none"}`;
      let valueFormatter = this._formatters[cacheKey];
      const mergedFormat = FormatManager.mergeSpecifiers(specifier, format);
      if (valueFormatter == null || valueFormatter.type !== type || valueFormatter.unit !== unit || !objectsEqual(valueFormatter.mergedFormat, mergedFormat)) {
        valueFormatter = {
          type,
          mergedFormat,
          unit,
          formatter: FormatManager.getFormatter(type, mergedFormat, unit, dateStyle, options)
        };
        this._formatters[cacheKey] = valueFormatter;
      }
      result = valueFormatter.formatter?.(value, fractionDigits);
    }
    return result != null ? String(result) : void 0;
  }
};
__decorateClass([
  Property
], AxisLabel.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "border", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fill", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "wrapping", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "truncate", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "spacing", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "color", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "rotation", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "avoidCollisions", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "mirrored", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "padding", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "parallel", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "itemStyler", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "formatter", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "format", 2);

// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.stroke = void 0;
  }
};
__decorateClass([
  Property
], AxisLine.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisLine.prototype, "width", 2);
__decorateClass([
  Property
], AxisLine.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTick.ts
var AxisTick = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.width = 1;
    this.size = 6;
  }
};
__decorateClass([
  Property
], AxisTick.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisTick.prototype, "width", 2);
__decorateClass([
  Property
], AxisTick.prototype, "size", 2);
__decorateClass([
  Property
], AxisTick.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.caption = new Caption();
    this.enabled = false;
    this.spacing = Caption.SMALL_PADDING;
    this.fontSize = 10 /* SMALLER */;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
  }
};
__decorateClass([
  Property
], AxisTitle.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "text", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "spacing", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontStyle", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontWeight", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontSize", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontFamily", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "color", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "wrapping", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "formatter", 2);

// packages/ag-charts-community/src/chart/axis/axisUtil.ts
var NiceMode = /* @__PURE__ */ ((NiceMode3) => {
  NiceMode3[NiceMode3["TickAndDomain"] = 0] = "TickAndDomain";
  NiceMode3[NiceMode3["TicksOnly"] = 1] = "TicksOnly";
  NiceMode3[NiceMode3["Off"] = 2] = "Off";
  return NiceMode3;
})(NiceMode || {});
function prepareAxisAnimationContext(axis) {
  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
  const min = Math.floor(requestedRangeMin);
  const max = Math.ceil(requestedRangeMax);
  return { min, max, visible: min !== max };
}
var fullCircle = Math.PI * 2;
var halfCircle = fullCircle / 2;
function normaliseEndRotation(start2, end2) {
  const directDistance = Math.abs(end2 - start2);
  if (directDistance < halfCircle) {
    return end2;
  } else if (start2 > end2) {
    return end2 + fullCircle;
  }
  return end2 - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
  const { min, max } = ctx;
  const outOfBounds = (y) => {
    return y < min || y > max;
  };
  const tick = {
    fromFn(node, datum, status) {
      let { x1, x2, y1, y2 } = node;
      let opacity = node.opacity;
      if (status === "added" || outOfBounds(datum.offset)) {
        ({ x1, x2, y1, y2 } = datum);
        opacity = 0;
      }
      return {
        x1,
        x2,
        y1,
        y2,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(_node, datum, status) {
      const { x1, x2, y1, y2 } = datum;
      let opacity = 1;
      if (status === "removed") {
        opacity = 0;
      }
      return { x1, x2, y1, y2, opacity };
    },
    applyFn(node, props) {
      node.setProperties(props);
      node.visible = !outOfBounds(node.y);
    }
  };
  const label = {
    fromFn(node, newDatum, status) {
      const datum = node.previousDatum ?? newDatum;
      let { x, y, rotationCenterX, rotationCenterY, rotation } = datum;
      let opacity = node.opacity;
      if (status === "removed" || outOfBounds(datum.y)) {
        rotation = newDatum.rotation;
      } else if (status === "added" || outOfBounds(node.datum.y)) {
        ({ x, y, rotationCenterX, rotationCenterY, rotation } = newDatum);
        opacity = 0;
      }
      return {
        x,
        y,
        rotationCenterX,
        rotationCenterY,
        rotation,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(node, datum, status) {
      const { x, y, rotationCenterX, rotationCenterY } = datum;
      let rotation = 0;
      let opacity = 1;
      if (status === "added") {
        rotation = datum.rotation;
      } else if (status === "removed") {
        opacity = 0;
        rotation = datum.rotation;
      } else {
        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);
      }
      return {
        x,
        y,
        rotationCenterX,
        rotationCenterY,
        rotation,
        opacity,
        finish: { rotation: datum.rotation }
      };
    }
  };
  const line = {
    fromFn(node, datum) {
      const { x1, x2, y1, y2 } = node.previousDatum ?? datum;
      return {
        x1,
        x2,
        y1,
        y2,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { x1, x2, y1, y2 } = datum;
      return { x1, x2, y1, y2 };
    }
  };
  const group = {
    fromFn(node, _datum) {
      const { translationX, translationY } = node;
      return {
        translationX,
        translationY,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { translationX, translationY } = datum;
      return { translationX, translationY };
    }
  };
  return { tick, line, label, group };
}
function resetAxisGroupFn() {
  return (_node, datum) => {
    return {
      translationX: datum.translationX,
      translationY: datum.translationY
    };
  };
}
function resetAxisLabelSelectionFn() {
  return (_node, datum) => {
    return {
      x: datum.x,
      y: datum.y,
      rotationCenterX: datum.rotationCenterX,
      rotationCenterY: datum.rotationCenterY,
      rotation: datum.rotation
    };
  };
}
function resetAxisLineSelectionFn() {
  return (_node, datum) => {
    const { x1, x2, y1, y2 } = datum;
    return { x1, x2, y1, y2 };
  };
}
function resetAxisFillSelectionFn() {
  return (_node, datum) => {
    const { x1, x2, y1, y2 } = datum;
    return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
  };
}

// packages/ag-charts-community/src/chart/axis/axis.ts
var AxisGroupZIndexMap = /* @__PURE__ */ ((AxisGroupZIndexMap3) => {
  AxisGroupZIndexMap3[AxisGroupZIndexMap3["TickLines"] = 0] = "TickLines";
  AxisGroupZIndexMap3[AxisGroupZIndexMap3["AxisLine"] = 1] = "AxisLine";
  AxisGroupZIndexMap3[AxisGroupZIndexMap3["TickLabels"] = 2] = "TickLabels";
  return AxisGroupZIndexMap3;
})(AxisGroupZIndexMap || {});
function tickLayoutCacheValid(a, b) {
  return a.domain === b.domain && a.rangeExtent === b.rangeExtent && a.nice === b.nice && a.gridLength === b.gridLength && a.visibleRange[0] === b.visibleRange[0] && a.visibleRange[1] === b.visibleRange[1] && a.initialPrimaryTickCount?.unzoomed === b.initialPrimaryTickCount?.unzoomed && a.initialPrimaryTickCount?.zoomed === b.initialPrimaryTickCount?.zoomed;
}
var _Axis = class _Axis {
  constructor(moduleCtx, scale2) {
    this.moduleCtx = moduleCtx;
    this.scale = scale2;
    this.id = createId(this);
    this._crossLines = [];
    this.nice = true;
    this.reverse = false;
    this.keys = [];
    this.interval = new AxisInterval();
    this.dataDomain = { domain: [], clipped: false };
    this.title = new AxisTitle();
    this.gridLength = 0;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    this.gridPadding = 0;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    this.seriesAreaPadding = 0;
    this.layoutConstraints = {
      stacked: true,
      align: "start",
      width: 100,
      unit: "percent"
    };
    this.boundSeries = [];
    this.includeInvisibleDomains = false;
    this.interactionEnabled = true;
    this.axisGroup = new Group({ name: `${this.id}-axis` });
    // Order is important to apply the correct z-index.
    this.tickLineGroup = this.axisGroup.appendChild(
      new TransformableGroup({ name: `${this.id}-Axis-tick-lines`, zIndex: 0 /* TickLines */ })
    );
    this.tickLabelGroup = this.axisGroup.appendChild(
      new TransformableGroup({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* TickLabels */ })
    );
    this.labelGroup = new Group({
      name: `${this.id}-Labels`,
      zIndex: 11 /* SERIES_ANNOTATION */
    });
    this.gridGroup = new TranslatableGroup({ name: `${this.id}-Axis-grid`, zIndex: 2 /* AXIS_GRID */ });
    this.gridFillGroup = this.gridGroup.appendChild(new Group({ name: `${this.id}-gridFills` }));
    this.gridLineGroup = this.gridGroup.appendChild(new Group({ name: `${this.id}-gridLines` }));
    this.crossLineRangeGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Range`,
      zIndex: 6 /* SERIES_CROSSLINE_RANGE */
    });
    this.crossLineLineGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Line`,
      zIndex: 10 /* SERIES_CROSSLINE_LINE */
    });
    this.crossLineLabelGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Label`,
      zIndex: 15 /* SERIES_LABEL */
    });
    this.tickLabelGroupSelection = Selection.select(
      this.tickLabelGroup,
      TransformableText,
      false
    );
    this.line = new AxisLine();
    this.tick = new AxisTick();
    this.gridLine = new AxisGridLine();
    this.label = this.createLabel();
    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
    this.translation = { x: 0, y: 0 };
    this.layout = {
      label: {
        fractionDigits: 0,
        spacing: this.label.spacing,
        format: this.label.format
      }
    };
    this.axisContext = void 0;
    this.cleanup = new CleanupRegistry();
    // AG-15360 Avoid calling removeTooltip() if no tooltip is shown. This avoid a laggy tooltips caused by interference
    // with SeriesAreaManager's tooltip updates.
    this.isHovering = false;
    this.range = [0, 1];
    this.visibleRange = [0, 1];
    this.animatable = true;
    this.tickLayout = void 0;
    this.formatterBoundSeries = new WeakCache(() => {
      const { direction, boundSeries } = this;
      return deepFreeze(boundSeries.flatMap((series) => series.getFormatterContext(direction)));
    });
    this.moduleMap = new ModuleMap();
    this.range = this.scale.range.slice();
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
    this.cleanup.register(
      this.moduleCtx.widgets.containerWidget.addListener("mousemove", (e) => this.onMouseMove(e))
    );
  }
  set crossLines(value) {
    const { CrossLineConstructor } = this.constructor;
    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));
    this._crossLines = value.map((crossLine) => {
      const instance = new CrossLineConstructor();
      instance.set(crossLine);
      return instance;
    });
    this._crossLines.forEach((crossLine) => {
      this.attachCrossLine(crossLine);
      this.initCrossLine(crossLine);
    });
  }
  get crossLines() {
    return this._crossLines;
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get primaryLabel() {
    return void 0;
  }
  get primaryTick() {
    return void 0;
  }
  isCategoryLike() {
    return false;
  }
  resetAnimation(_phase) {
  }
  onMouseMove(event) {
    const node = this.tickLabelGroup.pickNode(event.currentX, event.currentY);
    const datum = node?.datum;
    const { textUntruncated: title = void 0 } = datum ?? {};
    if (title != null) {
      this.moduleCtx.tooltipManager.updateTooltip(
        this.id,
        { canvasX: event.currentX, canvasY: event.currentY, showArrow: false },
        [{ type: "structured", title }]
      );
      this.isHovering = true;
    } else if (this.isHovering) {
      this.moduleCtx.tooltipManager.removeTooltip(this.id);
      this.isHovering = false;
    }
  }
  attachCrossLine(crossLine) {
    this.crossLineRangeGroup.appendChild(crossLine.rangeGroup);
    this.crossLineLineGroup.appendChild(crossLine.lineGroup);
    this.crossLineLabelGroup.appendChild(crossLine.labelGroup);
  }
  detachCrossLine(crossLine) {
    this.crossLineRangeGroup.removeChild(crossLine.rangeGroup);
    this.crossLineLineGroup.removeChild(crossLine.lineGroup);
    this.crossLineLabelGroup.removeChild(crossLine.labelGroup);
  }
  destroy() {
    this.moduleMap.destroy();
    this.cleanup.flush();
  }
  setScaleRange(visibleRange) {
    const { range: rr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (visibleRange[1] - visibleRange[0]);
    const shift = span * visibleRange[0];
    const start2 = rr[0] - shift;
    scale2.range = [start2, start2 + span];
  }
  updateScale() {
    const {
      range: [r0, r1]
    } = this;
    this.setScaleRange(this.visibleRange);
    this.crossLines.forEach((crossLine) => {
      crossLine.clippedRange = [r0, r1];
    });
  }
  setCrossLinesVisible(visible) {
    this.crossLineRangeGroup.visible = visible;
    this.crossLineLineGroup.visible = visible;
    this.crossLineLabelGroup.visible = visible;
  }
  attachAxis(groups) {
    groups.gridNode.appendChild(this.gridGroup);
    groups.axisNode.appendChild(this.axisGroup);
    groups.labelNode.appendChild(this.labelGroup);
    groups.crossLineRangeNode.appendChild(this.crossLineRangeGroup);
    groups.crossLineLineNode.appendChild(this.crossLineLineGroup);
    groups.crossLineLabelNode.appendChild(this.crossLineLabelGroup);
  }
  detachAxis(groups) {
    groups.gridNode.removeChild(this.gridGroup);
    groups.axisNode.removeChild(this.axisGroup);
    groups.labelNode.removeChild(this.labelGroup);
    groups.crossLineRangeNode.removeChild(this.crossLineRangeGroup);
    groups.crossLineLineNode.removeChild(this.crossLineLineGroup);
    groups.crossLineLabelNode.removeChild(this.crossLineLabelGroup);
  }
  attachLabel(axisLabelNode) {
    this.labelGroup.append(axisLabelNode);
  }
  /**
   * Checks if a point or an object is in range.
   * @param value A point (or object's starting point).
   * @param tolerance Expands the range on both ends by this amount.
   */
  inRange(value, tolerance = 0) {
    const [min, max] = findMinMax(this.range);
    return value >= min - tolerance && value <= max + tolerance;
  }
  /**
   * Get a point's overflow on the range, expanded to include the non-visible range.
   * @param value Point
   * @returns Overflow
   */
  getRangeOverflow(value) {
    const { range: rr, visibleRange: vr } = this;
    const size = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const [min, max] = findMinMax([rr[0] - size * vr[0], rr[0] - size * vr[0] + size]);
    if (value < min)
      return value - min;
    if (value > max)
      return value - max;
    return 0;
  }
  createDatumFormatter(_domain, _ticks) {
    return;
  }
  onGridLengthChange(value, prevValue) {
    if (prevValue ^ value) {
      this.onGridVisibilityChange();
    }
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
  }
  onGridVisibilityChange() {
  }
  createLabel() {
    return new AxisLabel();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */
  update() {
    this.formatterBoundSeries.clear();
    this.updatePosition();
    this.updateSelections();
    this.tickLineGroup.visible = this.tick.enabled;
    this.gridLineGroup.visible = this.gridLine.enabled;
    this.tickLabelGroup.visible = this.label.enabled;
    this.updateLabels();
    this.updateCrossLines();
  }
  getLabelStyles(params, additionalStyles, label = this.label) {
    const defaultStyle = {
      border: label.border,
      color: label.color,
      cornerRadius: label.cornerRadius,
      fill: label.fill,
      fillOpacity: label.fillOpacity,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight,
      padding: label.padding,
      spacing: label.spacing
    };
    let stylerOutput;
    if (label.itemStyler) {
      stylerOutput = this.cachedCallWithContext(label.itemStyler, {
        ...params,
        ...defaultStyle
      });
    }
    const merged = mergeDefaults(stylerOutput, additionalStyles, defaultStyle);
    return {
      border: merged.border,
      color: merged.color,
      cornerRadius: merged.cornerRadius,
      fill: merged.fill,
      fillOpacity: merged.fillOpacity,
      fontFamily: merged.fontFamily,
      fontSize: merged.fontSize,
      fontStyle: merged.fontStyle,
      fontWeight: merged.fontWeight,
      padding: merged.padding,
      spacing: merged.spacing
    };
  }
  getTickSize(tick = this.tick) {
    return tick.enabled ? tick.size : 0;
  }
  processData() {
    this.invalidateLayoutCache();
    const { includeInvisibleDomains, boundSeries, direction } = this;
    const visibleSeries = includeInvisibleDomains ? boundSeries : boundSeries.filter((s) => s.isEnabled());
    const domains = visibleSeries.map((series) => series.getDomain(direction));
    this.setDomains(...domains);
  }
  setDomains(...domains) {
    let domain;
    let animatable;
    if (domains.length > 0) {
      ({ domain, animatable } = this.scale.normalizeDomains(...domains));
    } else {
      domain = [];
      animatable = true;
    }
    this.dataDomain = this.normaliseDataDomain(domain);
    if (this.reverse) {
      this.dataDomain.domain.reverse();
    }
    this.animatable = animatable;
  }
  calculateDomain(initialPrimaryTickCount) {
    const {
      dataDomain: { domain },
      range: range4,
      nice,
      scale: scale2,
      gridLength
    } = this;
    const rangeExtent = findRangeExtent(range4);
    const visibleRange = [0, 1];
    this.updateScale();
    const { unzoomedTickLayoutCache } = this;
    let unzoomedTickLayout;
    if (unzoomedTickLayoutCache == null || !tickLayoutCacheValid(unzoomedTickLayoutCache, {
      domain,
      rangeExtent,
      nice,
      gridLength,
      visibleRange,
      initialPrimaryTickCount
    })) {
      const scaleRange = scale2.range;
      this.setScaleRange([0, 1]);
      const niceMode = nice ? 0 /* TickAndDomain */ : 2 /* Off */;
      unzoomedTickLayout = this.calculateTickLayout(domain, niceMode, [0, 1], initialPrimaryTickCount);
      scale2.range = scaleRange;
      this.unzoomedTickLayoutCache = {
        domain,
        rangeExtent,
        nice,
        gridLength,
        visibleRange,
        initialPrimaryTickCount,
        tickLayout: unzoomedTickLayout
      };
    } else {
      unzoomedTickLayout = unzoomedTickLayoutCache.tickLayout;
    }
    this.updateScale();
    scale2.domain = unzoomedTickLayout.niceDomain;
    return { unzoomedTickLayout, domain: scale2.domain };
  }
  calculateLayout(initialPrimaryTickCount, chartLayout) {
    this.chartLayout = chartLayout;
    const { visibleRange, nice } = this;
    const unzoomed = visibleRange[0] === 0 && visibleRange[1] === 1;
    const { unzoomedTickLayout, domain } = this.calculateDomain(initialPrimaryTickCount);
    let tickLayout;
    if (unzoomed) {
      tickLayout = unzoomedTickLayout;
    } else {
      const { range: range4, gridLength } = this;
      const rangeExtent = findRangeExtent(range4);
      const niceMode = nice ? 1 /* TicksOnly */ : 2 /* Off */;
      const { tickLayoutCache } = this;
      if (tickLayoutCache == null || !tickLayoutCacheValid(tickLayoutCache, {
        domain,
        rangeExtent,
        nice,
        gridLength,
        visibleRange,
        initialPrimaryTickCount
      })) {
        tickLayout = this.calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount);
        this.tickLayoutCache = {
          domain,
          rangeExtent,
          nice,
          gridLength,
          visibleRange,
          initialPrimaryTickCount,
          tickLayout
        };
      } else {
        tickLayout = tickLayoutCache.tickLayout;
      }
    }
    const { rawTickCount: zoomedTickCount = 0, fractionDigits, bbox } = tickLayout;
    const unzoomedTickCount = unzoomedTickLayout.rawTickCount ?? 0;
    const primaryTickCount = zoomedTickCount !== 0 && unzoomedTickCount !== 0 ? { zoomed: zoomedTickCount, unzoomed: unzoomedTickCount } : void 0;
    this.tickLayout = tickLayout.layout;
    this.layout.label = {
      fractionDigits,
      spacing: this.label.spacing,
      format: this.label.format
    };
    this.layoutCrossLines();
    return { primaryTickCount, bbox };
  }
  invalidateLayoutCache() {
    this.unzoomedTickLayoutCache = void 0;
    this.tickLayoutCache = void 0;
    this.tickLayout = void 0;
  }
  updateCrossLines() {
    const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
    this.crossLines.forEach((crossLine) => {
      crossLine.update(crosslinesVisible);
    });
  }
  updatePosition() {
    const { crossLineRangeGroup, crossLineLineGroup, crossLineLabelGroup, gridGroup, translation } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    gridGroup.setProperties({ translationX, translationY });
    crossLineRangeGroup.setProperties({ translationX, translationY });
    crossLineLineGroup.setProperties({ translationX, translationY });
    crossLineLabelGroup.setProperties({ translationX, translationY });
  }
  // For formatting (nice rounded) tick values.
  tickFormatter(domain, ticks, primary, inputFractionDigits, inputTimeInterval, dateStyle = "long") {
    const { moduleCtx, label } = this;
    const { formatManager } = moduleCtx;
    const primaryLabel = primary ? this.primaryLabel : void 0;
    const tickFormatParams = this.tickFormatParams(domain, ticks, inputFractionDigits, inputTimeInterval);
    const boundSeries = this.formatterBoundSeries.get();
    let fractionDigits;
    let timeInterval3;
    let truncateDate;
    if (tickFormatParams.type === "number") {
      fractionDigits = tickFormatParams.fractionDigits;
    } else if (tickFormatParams.type === "date") {
      const { unit, step, epoch } = tickFormatParams;
      timeInterval3 = { unit, step, epoch };
      truncateDate = tickFormatParams.truncateDate;
    }
    const f = this.uncachedCallWithContext.bind(this);
    const params = {
      datum: void 0,
      seriesId: void 0,
      legendItemName: void 0,
      key: void 0,
      source: "axis-label",
      property: this.direction,
      domain,
      boundSeries
    };
    const currentLabel = primaryLabel ?? label;
    const specifier = primary ? label.format : void 0;
    const options = {
      specifier: FormatManager.mergeSpecifiers(primaryLabel?.format, label.format),
      truncateDate
    };
    return (value, index) => {
      const formatParams = this.datumFormatParams(value, params, fractionDigits, timeInterval3, dateStyle);
      formatParams.value = value;
      return currentLabel.formatValue(f, formatParams, index, { specifier, dateStyle, truncateDate }) ?? formatManager.format(f, formatParams, options) ?? formatManager.defaultFormat(formatParams, options);
    };
  }
  formatDatum(contextProvider, input, source, seriesId, legendItemName, datum, key, domain, label, params) {
    if (input == null)
      return "";
    const { moduleCtx, direction, dataDomain } = this;
    domain ?? (domain = dataDomain.domain);
    const { formatManager } = moduleCtx;
    const boundSeries = this.formatterBoundSeries.get();
    let inputFractionDigits;
    switch (source) {
      case "crosshair":
      case "annotation-label":
        inputFractionDigits = this.layout.label.fractionDigits + 1;
        break;
      case "series-label":
        inputFractionDigits = 2;
        break;
      case "tooltip":
        inputFractionDigits = 3;
        break;
      case "legend-label":
        inputFractionDigits = void 0;
        break;
    }
    const formatParams = this.datumFormatParams(
      input,
      {
        source,
        datum,
        seriesId,
        legendItemName,
        key,
        property: direction,
        domain,
        boundSeries
      },
      inputFractionDigits,
      void 0,
      "long"
    );
    const { type, value } = formatParams;
    const f = this.createCallWithContext(contextProvider);
    const result = label?.formatValue(f, type, value, params ?? formatParams) ?? formatManager.format(f, formatParams) ?? this.label.formatValue(f, formatParams, NaN) ?? formatManager.defaultFormat(formatParams);
    return String(result);
  }
  getBBox() {
    return this.axisGroup.getBBox();
  }
  initCrossLine(crossLine) {
    crossLine.scale = this.scale;
    crossLine.gridLength = this.gridLength;
  }
  hasVisibleSeries() {
    return this.boundSeries.some((s) => s.isEnabled());
  }
  clipTickLines(x, y, width2, height2) {
    this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));
  }
  clipGrid(x, y, width2, height2) {
    this.gridGroup.setClipRect(new BBox(x, y, width2, height2));
  }
  getTitleFormatterParams(domain) {
    const { direction } = this;
    const boundSeries = this.formatterBoundSeries.get();
    return { domain, direction, boundSeries, defaultValue: this.title?.text };
  }
  normaliseDataDomain(d) {
    return { domain: [...d], clipped: false };
  }
  getLayoutState() {
    return {
      id: this.id,
      rect: this.getBBox(),
      gridPadding: this.gridPadding,
      seriesAreaPadding: this.seriesAreaPadding,
      tickSize: this.getTickSize(),
      direction: this.direction,
      domain: this.dataDomain.domain,
      scale: this.scale,
      ...this.layout
    };
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    this.axisContext ?? (this.axisContext = this.createAxisContext());
    return { ...this.moduleCtx, parent: this.axisContext };
  }
  createAxisContext() {
    const { scale: scale2 } = this;
    return {
      axisId: this.id,
      scale: this.scale,
      direction: this.direction,
      continuous: ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2),
      getCanvasBounds: () => {
        return Transformable.toCanvas(this.axisGroup);
      },
      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {
        const seriesKeys = series.getKeyProperties(this.direction);
        seriesKeys.forEach((key) => keys.add(key));
        return keys;
      }, /* @__PURE__ */ new Set()),
      seriesIds: () => this.boundSeries.map((series) => series.id),
      scaleInvert: (val) => scale2.invert(val, true),
      scaleInvertNearest: (val) => scale2.invert(val, true),
      formatScaleValue: (value, source, label) => this.formatDatum(
        void 0,
        value,
        source,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        label
      ),
      attachLabel: (node) => this.attachLabel(node),
      inRange: (value, tolerance) => this.inRange(value, tolerance),
      getRangeOverflow: (value) => this.getRangeOverflow(value),
      pickBand: (point) => this.pickBand(point)
    };
  }
  pickBand(point) {
    if (!BandScale.is(this.scale)) {
      return;
    }
    const { scale: scale2, range: range4 } = this;
    const value = scale2.invert(this.isVertical() ? point.y : point.x, true);
    const bandwidth = scale2.bandwidth ?? 0;
    const step = scale2.step ?? 0;
    const offset = (step - bandwidth) / 2;
    const position = scale2.convert(value);
    const start2 = position - offset;
    const end2 = position + bandwidth + offset;
    return {
      id: this.id,
      value,
      band: [clampArray(start2, range4), clampArray(end2, range4)],
      position
    };
  }
  isVertical() {
    return this.direction === "y" /* Y */;
  }
  isReversed() {
    return this.reverse;
  }
  cachedCallWithContext(fn, ...params) {
    const { callbackCache, chartService } = this.moduleCtx;
    return callbackCache.call([this, chartService], fn, ...params);
  }
  uncachedCallWithContext(fn, ...params) {
    const { chartService } = this.moduleCtx;
    return callWithContext([this, chartService], fn, ...params);
  }
  createCallWithContext(contextProvider) {
    const { chartService } = this.moduleCtx;
    return (fn, ...params) => callWithContext([contextProvider, this, chartService], fn, ...params);
  }
};
_Axis.defaultTickMinSpacing = 50;
_Axis.CrossLineConstructor = CartesianCrossLine;
__decorateClass([
  Property
], _Axis.prototype, "nice", 2);
__decorateClass([
  Property
], _Axis.prototype, "reverse", 2);
__decorateClass([
  Property
], _Axis.prototype, "keys", 2);
__decorateClass([
  Property
], _Axis.prototype, "interval", 2);
__decorateClass([
  Property
], _Axis.prototype, "title", 2);
__decorateClass([
  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))
], _Axis.prototype, "gridLength", 2);
var Axis = _Axis;

// packages/ag-charts-community/src/util/timeFormatDefaults.ts
function dateToNumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
function lowestGranularityForInterval(interval) {
  if (interval < durationSecond) {
    return "millisecond";
  } else if (interval < durationMinute) {
    return "second";
  } else if (interval < durationHour) {
    return "minute";
  } else if (interval < durationHour * 23) {
    return "hour";
  } else if (interval < 28 * durationDay) {
    return "day";
  } else if (interval < durationYear) {
    return "month";
  } else {
    return "year";
  }
}
function lowestGranularityUnitForTicks(ticks) {
  if (ticks.length === 0) {
    return "millisecond";
  } else if (ticks.length === 1) {
    return lowestGranularityUnitForValue(ticks[0]);
  }
  let minInterval = Infinity;
  for (let i = 1; i < ticks.length; i++) {
    minInterval = Math.min(minInterval, Math.abs(ticks[i].valueOf() - ticks[i - 1].valueOf()));
  }
  return lowestGranularityForInterval(minInterval);
}
function lowestGranularityUnitForValue(value) {
  if (intervalFloor("second", value) < value) {
    return "millisecond";
  } else if (intervalFloor("minute", value) < value) {
    return "second";
  } else if (intervalFloor("hour", value) < value) {
    return "minute";
  } else if (intervalFloor("day", value) < value) {
    return "hour";
  } else if (intervalFloor("month", value) < value) {
    return "day";
  } else if (intervalFloor("year", value) < value) {
    return "month";
  }
  return "year";
}
function dateTruncationForDomain(domain) {
  const [d0, d1] = domain.length === 0 ? [0, 0] : findMinMax([domain[0].valueOf(), domain[domain.length - 1].valueOf()]);
  const startYear = new Date(d0).getFullYear();
  const stopYear = new Date(d1).getFullYear();
  if (startYear !== stopYear)
    return;
  const startMonth = new Date(d0).getMonth();
  const stopMonth = new Date(d1).getMonth();
  if (startMonth !== stopMonth)
    return "year";
  const startDate = new Date(d0).getDate();
  const stopDate = new Date(d1).getDate();
  if (startDate !== stopDate)
    return "month";
  return "day";
}

// packages/ag-charts-community/src/scale/scaleUtil.ts
function filterVisibleTicks(ticks, reversed, visibleRange) {
  if (visibleRange == null || visibleRange[0] === 0 && visibleRange[1] === 1) {
    return { ticks, count: ticks.length, firstTickIndex: 0 };
  }
  const vt0 = clamp(0, Math.floor(visibleRange[0] * ticks.length), ticks.length);
  const vt1 = clamp(0, Math.ceil(visibleRange[1] * ticks.length), ticks.length);
  const t0 = reversed ? ticks.length - vt1 : vt0;
  const t1 = reversed ? ticks.length - vt0 : vt1;
  return {
    ticks: ticks.slice(t0, t1),
    count: ticks.length,
    firstTickIndex: t0
  };
}

// packages/ag-charts-community/src/scale/categoryScale.ts
var CategoryScale = class _CategoryScale extends BandScale {
  constructor() {
    super(...arguments);
    this.type = "category";
    this.defaultTickCount = 0;
    /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate data (not allowed).
     */
    this.index = /* @__PURE__ */ new Map();
    this.indexInitialized = false;
    /**
     * Contains unique data only.
     */
    this._domain = [];
  }
  static is(value) {
    return value instanceof _CategoryScale;
  }
  set domain(values) {
    if (this._domain === values)
      return;
    this.invalid = true;
    this._domain = values;
    this.index.clear();
    this.indexInitialized = false;
  }
  get domain() {
    return this._domain;
  }
  get bands() {
    return this._domain;
  }
  normalizeDomains(...domains) {
    let normalizedDomain = void 0;
    const seenDomains = /* @__PURE__ */ new Set();
    let animatable = true;
    for (const domain of domains) {
      if (seenDomains.has(domain))
        continue;
      seenDomains.add(domain);
      if (normalizedDomain == null) {
        normalizedDomain = deduplicateCategories(domain);
      } else {
        animatable && (animatable = domainOrderedToNormalizedDomain(domain, normalizedDomain));
        normalizedDomain = deduplicateCategories([...normalizedDomain, ...domain]);
      }
    }
    normalizedDomain ?? (normalizedDomain = []);
    return { domain: normalizedDomain, animatable };
  }
  toDomain(_value) {
    return void 0;
  }
  invert(position, nearest = false) {
    this.refresh();
    const offset = nearest ? this.bandwidth / 2 : 0;
    const index = this.invertNearestIndex(Math.max(0, position - offset));
    const matches = nearest || position === this.ordinalRange(index);
    return matches ? this.domain[index] : void 0;
  }
  ticks(params, domain = this.domain, visibleRange) {
    const { bands } = this;
    let { tickCount } = params;
    if (tickCount === 0) {
      const firstTickIndex2 = bands.length > 1 ? 1 : 0;
      return { ticks: [bands[firstTickIndex2]], count: void 0, firstTickIndex: firstTickIndex2 };
    }
    let step = tickCount != null && tickCount !== 0 ? bands.length / tickCount | 0 : 1;
    step = previousPowerOf2(step);
    if (step <= 1) {
      return filterVisibleTicks(domain, false, visibleRange);
    }
    tickCount = bands.length / step | 0;
    const span = step * tickCount;
    const inset = previousPowerOf2((bands.length - span) / 2 | 0);
    const vt0 = clamp(0, Math.floor((visibleRange?.[0] ?? 0) * bands.length), bands.length);
    const vt1 = clamp(0, Math.ceil((visibleRange?.[1] ?? 1) * bands.length), bands.length);
    const i0 = Math.floor((vt0 - inset) / step) * step + inset;
    const i1 = Math.ceil((vt1 - inset) / step) * step + inset;
    const ticks = [];
    for (let i = i0; i < i1; i += step) {
      if (i >= 0 && i < bands.length) {
        ticks.push(bands[i]);
      }
    }
    let firstTickIndex = ticks.length > 0 ? this.findIndex(ticks[0]) : void 0;
    if (firstTickIndex != null) {
      firstTickIndex = Math.floor((firstTickIndex - inset) / step);
    }
    return { ticks, count: void 0, firstTickIndex };
  }
  findIndex(value) {
    const { index, indexInitialized } = this;
    if (!indexInitialized) {
      const { domain } = this;
      for (let i = 0; i < domain.length; i++) {
        index.set(dateToNumber(domain[i]), i);
      }
      this.indexInitialized = true;
    }
    return index.get(dateToNumber(value));
  }
};
function deduplicateCategories(d) {
  let domain;
  const uniqueValues = /* @__PURE__ */ new Set();
  for (const value of d) {
    const key = dateToNumber(value);
    const lastSize = uniqueValues.size;
    uniqueValues.add(key);
    const isUniqueValue = uniqueValues.size !== lastSize;
    if (isUniqueValue) {
      domain?.push(value);
    } else {
      domain ?? (domain = d.slice(0, uniqueValues.size));
    }
  }
  return domain ?? d;
}
function domainOrderedToNormalizedDomain(domain, normalizedDomain) {
  let normalizedIndex = -1;
  for (const value of domain) {
    const normalizedNextIndex = normalizedDomain.indexOf(value);
    if (normalizedNextIndex === -1) {
      normalizedIndex = Infinity;
    } else if (normalizedNextIndex <= normalizedIndex) {
      return false;
    } else {
      normalizedIndex = normalizedNextIndex;
    }
  }
  return true;
}

// packages/ag-charts-community/src/util/date.ts
function compareDates(a, b) {
  return a.valueOf() - b.valueOf();
}
function deduplicateSortedArray(values) {
  let v0 = NaN;
  const out = [];
  for (const v of values) {
    const v1 = v.valueOf();
    if (v0 !== v1)
      out.push(v);
    v0 = v1;
  }
  return out;
}
function sortAndUniqueDates(values) {
  const sortedValues = values.slice().sort(compareDates);
  return datesSortOrder(sortedValues) == null ? deduplicateSortedArray(sortedValues) : sortedValues;
}
function datesSortOrder(d) {
  if (d.length === 0)
    return 1;
  const sign = Number(d[d.length - 1]) > Number(d[0]) ? 1 : -1;
  let v0 = -Infinity * sign;
  for (const v of d) {
    const v1 = v.valueOf();
    if (Math.sign(v1 - v0) !== sign)
      return;
    v0 = v1;
  }
  return sign;
}

// packages/ag-charts-community/src/util/ticks.ts
var tInterval = (timeInterval3, step) => ({
  duration: intervalMilliseconds(timeInterval3) * step,
  timeInterval: timeInterval3,
  step
});
var TickIntervals = [
  tInterval({ unit: "second" }, 1),
  tInterval({ unit: "second" }, 5),
  tInterval({ unit: "second" }, 15),
  tInterval({ unit: "second" }, 30),
  tInterval({ unit: "minute" }, 1),
  tInterval({ unit: "minute" }, 5),
  tInterval({ unit: "minute" }, 15),
  tInterval({ unit: "minute" }, 30),
  tInterval({ unit: "hour" }, 1),
  tInterval({ unit: "hour" }, 3),
  tInterval({ unit: "hour" }, 6),
  tInterval({ unit: "hour" }, 12),
  tInterval({ unit: "day" }, 1),
  tInterval({ unit: "day" }, 2),
  tInterval({ unit: "day", step: 7 }, 1),
  tInterval({ unit: "day", step: 7 }, 2),
  tInterval({ unit: "day", step: 7 }, 3),
  tInterval({ unit: "month" }, 1),
  tInterval({ unit: "month" }, 2),
  tInterval({ unit: "month" }, 3),
  tInterval({ unit: "month" }, 4),
  tInterval({ unit: "month" }, 6),
  tInterval({ unit: "year" }, 1)
];
var TickMultipliers = [1, 2, 5, 10];
function isCloseToInteger(n, delta4) {
  return Math.abs(Math.round(n) - n) < delta4;
}
function countTicks(d0, d1, step) {
  const extent3 = Math.abs(d1 - d0);
  return extent3 >= step ? Math.abs(d1 - d0) / step + 1 : 1;
}
function createTicks(start2, stop, count, minCount, maxCount, visibleRange) {
  if (start2 === stop)
    return { ticks: [start2], count: 1, firstTickIndex: 0 };
  if (count < 2)
    return { ticks: [start2, stop], count: 2, firstTickIndex: 0 };
  const step = tickStep(start2, stop, count, minCount, maxCount);
  if (!Number.isFinite(step))
    return { ticks: [], count: 0, firstTickIndex: void 0 };
  let d0 = start2;
  let d1 = stop;
  if (!isCloseToInteger(d0 / step, 1e-12)) {
    d0 = Math.ceil(d0 / step) * step;
  }
  if (!isCloseToInteger(d1 / step, 1e-12)) {
    d1 = Math.floor(d1 / step) * step;
  }
  if (visibleRange != null) {
    const dr = d1 - d0;
    const vr = stop - start2;
    const vd0 = start2 + vr * visibleRange[0];
    const vd1 = start2 + vr * visibleRange[1];
    visibleRange = [(vd0 - d0) / dr, (vd1 - d0) / dr];
  }
  const { ticks } = range(d0, d1, step, visibleRange);
  const firstTick = ticks.at(0);
  return {
    ticks,
    count: countTicks(d0, d1, step),
    firstTickIndex: firstTick == null ? void 0 : Math.round((firstTick - d0) / step)
  };
}
var minPrimaryTickRatio = Math.floor(2 * durationWeek / durationMonth * 10) / 10;
function isPrimaryTickInterval({ timeInterval: timeInterval3, step }) {
  const milliseconds = intervalMilliseconds(timeInterval3) * step;
  const hierarchy = intervalHierarchy(timeInterval3);
  const hierarchyMilliseconds = hierarchy ? intervalMilliseconds(hierarchy) : void 0;
  return milliseconds <= (hierarchyMilliseconds ?? Infinity) * minPrimaryTickRatio;
}
function defaultEpoch(timeInterval3, { weekStart }) {
  if (timeInterval3.unit === "day" && timeInterval3.step === 7) {
    return weekStart;
  }
}
function getTickTimeInterval(start2, stop, count, minCount, maxCount, {
  weekStart,
  primaryOnly = false,
  targetInterval
}) {
  if (count <= 0)
    return;
  const target = targetInterval ?? Math.abs(stop - start2) / Math.max(count, 1);
  const i0 = TickIntervals.findLast((t) => (!primaryOnly || isPrimaryTickInterval(t)) && target > t.duration);
  const i1 = TickIntervals.find((t) => (!primaryOnly || isPrimaryTickInterval(t)) && target <= t.duration);
  if (i0 == null) {
    const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);
    return { unit: "millisecond", step: step2 };
  } else if (i1 == null) {
    const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;
    return { unit: "year", step: step2 };
  }
  const { timeInterval: timeInterval3, step } = target - i0.duration < i1.duration - target ? i0 : i1;
  return {
    unit: timeInterval3.unit,
    step: intervalStep(timeInterval3) * step,
    epoch: defaultEpoch(timeInterval3, { weekStart })
  };
}
function tickStep(start2, end2, count, minCount = 0, maxCount = Infinity) {
  if (start2 === end2) {
    return clamp(1, minCount, maxCount);
  } else if (count < 1) {
    return NaN;
  }
  const extent3 = Math.abs(end2 - start2);
  const step = 10 ** Math.floor(Math.log10(extent3 / count));
  let m = NaN, minDiff = Infinity, isInBounds = false;
  for (const multiplier of TickMultipliers) {
    const c = Math.ceil(extent3 / (multiplier * step));
    const validBounds = c >= minCount && c <= maxCount;
    if (isInBounds && !validBounds)
      continue;
    const diffCount = Math.abs(c - count);
    if (minDiff > diffCount || isInBounds !== validBounds) {
      isInBounds || (isInBounds = validBounds);
      minDiff = diffCount;
      m = multiplier;
    }
  }
  return m * step;
}
function decimalPlaces(decimal) {
  for (let i = decimal.length - 1; i >= 0; i -= 1) {
    if (decimal[i] !== "0") {
      return i + 1;
    }
  }
  return 0;
}
function tickFormat(ticks, format) {
  const options = parseNumberFormat(format ?? ",f");
  if (options == null)
    return;
  if (options.precision == null || isNaN(options.precision)) {
    if (!options.type || "eEFgGnprs".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x))
            return 0;
          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/[.e]/g);
          return (integer !== "1" && integer !== "-1" ? 1 : 0) + decimalPlaces(decimal) + 1;
        })
      );
    } else if ("f%".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x) || x === 0)
            return 0;
          const l = Math.floor(Math.log10(Math.abs(x)));
          const digits = options.type ? 6 : 12;
          const decimal = x.toExponential(digits - 1).split(/[.e]/g)[1];
          const decimalLength = decimalPlaces(decimal);
          return Math.max(0, decimalLength - l);
        })
      );
    }
  }
  const formatter2 = createNumberFormatter(options);
  return (n) => formatter2(Number(n));
}
function range(start2, end2, step, visibleRange) {
  if (!Number.isFinite(step) || step <= 0) {
    return { ticks: [], count: 0, firstTickIndex: void 0 };
  } else if (start2 === end2) {
    return { ticks: [start2], count: 1, firstTickIndex: 0 };
  }
  const f = 10 ** countFractionDigits(step);
  const d0 = Math.min(start2, end2);
  const d1 = Math.max(start2, end2);
  let vd0;
  let vd1;
  if (visibleRange != null && (visibleRange[0] !== 0 || visibleRange[1] !== 1)) {
    const rangeExtent = end2 - start2;
    const adjustedStart = start2 + rangeExtent * visibleRange[0];
    const adjustedEnd = end2 - rangeExtent * (1 - visibleRange[1]);
    vd0 = Math.min(adjustedStart, adjustedEnd);
    vd1 = Math.max(adjustedStart, adjustedEnd);
  } else {
    vd0 = d0;
    vd1 = d1;
  }
  vd0 = Math.floor(vd0 * f) / f;
  vd1 = Math.ceil(vd1 * f) / f;
  const ticks = [];
  for (let i = 0; ; i += 1) {
    const p = Math.round((d0 + step * i) * f) / f;
    if (p > d1)
      break;
    if (p >= vd0 && p <= vd1) {
      ticks.push(p);
    }
  }
  const firstTick = ticks.at(0);
  return {
    ticks,
    count: countTicks(d0, d1, step),
    firstTickIndex: firstTick == null ? void 0 : Math.round((firstTick - d0) / step)
  };
}
function isDenseInterval(count, availableRange) {
  if (count >= availableRange) {
    logger_exports.warnOnce(
      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`
    );
    return true;
  }
  return false;
}
function niceTicksDomain(start2, end2) {
  const extent3 = Math.abs(end2 - start2);
  const step = 10 ** Math.floor(Math.log10(extent3));
  let minError = Infinity, ticks = [start2, end2];
  for (const multiplier of TickMultipliers) {
    const m = multiplier * step;
    const d0 = Math.floor(start2 / m) * m;
    const d1 = Math.ceil(end2 / m) * m;
    const error2 = 1 - extent3 / Math.abs(d1 - d0);
    if (minError > error2) {
      minError = error2;
      ticks = [d0, d1];
    }
  }
  return ticks;
}
function estimateTickCount(rangeExtent, zoomExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {
  if (rangeExtent <= 0) {
    return { minTickCount: 0, maxTickCount: 0, tickCount: 0 };
  }
  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));
  minSpacing ?? (minSpacing = defaultMinSpacing);
  maxSpacing ?? (maxSpacing = rangeExtent);
  if (minSpacing > maxSpacing) {
    if (minSpacing === defaultMinSpacing) {
      minSpacing = maxSpacing;
    } else {
      maxSpacing = minSpacing;
    }
  }
  minSpacing = Math.max(minSpacing, 1);
  const maxTickCount = Math.max(1, Math.floor(rangeExtent / (zoomExtent * minSpacing)));
  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / (zoomExtent * maxSpacing)));
  const tickCount = clamp(minTickCount, Math.floor(defaultTickCount / zoomExtent), maxTickCount);
  return { minTickCount, maxTickCount, tickCount };
}

// packages/ag-charts-community/src/scale/timeScale.ts
var sunday = new Date(1970, 0, 4);
var TimeScale = class _TimeScale extends ContinuousScale {
  constructor() {
    super([], [0, 1]);
    this.type = "time";
  }
  static is(value) {
    return value instanceof _TimeScale;
  }
  toDomain(d) {
    return new Date(d);
  }
  convert(value, options) {
    return super.convert(value?.valueOf() ?? NaN, options);
  }
  invert(value) {
    return new Date(super.invert(value));
  }
  niceDomain(ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    let [d0, d1] = domain;
    const maxAttempts = 4;
    const availableRange = this.getPixelRange();
    for (let i = 0; i < maxAttempts; i++) {
      const [n0, n1] = updateNiceDomainIteration(d0, d1, ticks, availableRange);
      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {
        break;
      }
      d0 = n0;
      d1 = n1;
    }
    return [d0, d1];
  }
  /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */
  ticks(params, domain = this.domain, visibleRange = [0, 1], { extend = false } = {}) {
    const { nice, interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = params;
    if (domain.length < 2)
      return;
    const timestamps = domain.map(dateToNumber);
    const start2 = timestamps[0];
    const stop = timestamps[timestamps.length - 1];
    if (interval != null) {
      const availableRange = this.getPixelRange();
      return {
        ticks: getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange, extend }) ?? getDefaultDateTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange, extend }),
        count: void 0
      };
    } else if (nice && tickCount === 2) {
      return { ticks: domain, count: void 0 };
    } else if (nice && tickCount === 1) {
      return { ticks: domain.slice(0, 1), count: void 0 };
    }
    const timeInterval3 = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, {
      weekStart: sunday
    });
    if (timeInterval3 == null)
      return;
    const ticks = intervalRange(timeInterval3, new Date(start2), new Date(stop), { visibleRange, extend });
    const firstTickIndex = intervalRangeStartIndex(timeInterval3, new Date(start2), new Date(stop), {
      visibleRange,
      extend
    });
    return {
      ticks,
      count: void 0,
      firstTickIndex,
      timeInterval: timeInterval3
    };
  }
};
function getDefaultDateTicks({
  start: start2,
  stop,
  tickCount,
  minTickCount,
  maxTickCount,
  visibleRange,
  extend
}) {
  const t = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, { weekStart: sunday });
  return t ? intervalRange(t, new Date(start2), new Date(stop), { visibleRange, extend }) : [];
}
function getDateTicksForInterval({
  start: start2,
  stop,
  interval,
  availableRange,
  visibleRange,
  extend
}) {
  if (!interval) {
    return [];
  }
  if (isPlainObject(interval) || typeof interval === "string") {
    const ticks2 = intervalRange(interval, new Date(start2), new Date(stop), { visibleRange, extend });
    if (isDenseInterval(ticks2.length, availableRange)) {
      return;
    }
    return ticks2;
  }
  const absInterval = Math.abs(interval);
  if (isDenseInterval(Math.abs(stop - start2) / absInterval, availableRange))
    return;
  const tickInterval = TickIntervals.findLast((t) => absInterval % t.duration === 0);
  if (tickInterval) {
    const { timeInterval: timeInterval3, step, duration } = tickInterval;
    const alignedInterval = {
      ...timeInterval3,
      step: step * intervalStep(timeInterval3) * Math.round(absInterval / duration),
      epoch: defaultEpoch(timeInterval3, { weekStart: sunday })
    };
    return intervalRange(alignedInterval, new Date(start2), new Date(stop), { visibleRange, extend });
  }
  let date2 = new Date(Math.min(start2, stop));
  const stopDate = new Date(Math.max(start2, stop));
  const ticks = [];
  while (date2 <= stopDate) {
    ticks.push(date2);
    date2 = new Date(date2);
    date2.setMilliseconds(date2.getMilliseconds() + absInterval);
  }
  return ticks;
}
function updateNiceDomainIteration(d0, d1, ticks, availableRange) {
  const { interval } = ticks;
  const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));
  const stop = Math.max(dateToNumber(d0), dateToNumber(d1));
  let i;
  if (isPlainObject(interval) || typeof interval === "string") {
    i = interval;
  } else {
    let tickCount;
    if (typeof interval === "number") {
      tickCount = (stop - start2) / Math.max(interval, 1);
      if (isDenseInterval(tickCount, availableRange)) {
        tickCount = void 0;
      }
    }
    tickCount ?? (tickCount = ticks.tickCount ?? ContinuousScale.defaultTickCount);
    i = getTickTimeInterval(start2, stop, tickCount, ticks.minTickCount, ticks.maxTickCount, { weekStart: sunday });
  }
  if (i == null)
    return [d0, d1];
  const domain = intervalRange(i, new Date(start2), new Date(stop), { extend: true });
  if (domain == null || domain.length < 2)
    return [d0, d1];
  const r0 = domain[0];
  const r1 = domain[domain.length - 1];
  return d0 <= d1 ? [r0, r1] : [r1, r0];
}

// packages/ag-charts-community/src/scale/ordinalTimeScale.ts
var OrdinalTimeScale = class _OrdinalTimeScale extends DiscreteTimeScale {
  constructor() {
    super(...arguments);
    this.type = "ordinal-time";
    this.defaultTickCount = ContinuousScale.defaultTickCount;
    this._domain = [];
    this.isReversed = false;
  }
  static is(value) {
    return value instanceof _OrdinalTimeScale;
  }
  set domain(domain) {
    if (domain === this._domain)
      return;
    this.invalid = true;
    this._domain = domain;
    this._bands = void 0;
    this.isReversed = domainReversed(domain);
  }
  get domain() {
    return this._domain;
  }
  get bands() {
    this._bands ?? (this._bands = this.isReversed ? this.domain.slice().reverse() : this.domain);
    return this._bands;
  }
  normalizeDomains(...domains) {
    const sortedDomains = domains.filter((domain) => domain.length > 0);
    if (sortedDomains.length === 0) {
      return { domain: [], animatable: false };
    } else if (sortedDomains.length === 1) {
      let domain = sortedDomains[0];
      const sortOrder = datesSortOrder(domain);
      if (sortOrder === -1) {
        domain = domain.slice().reverse();
      } else if (sortOrder == null) {
        domain = sortAndUniqueDates(domain.slice());
      }
      return { domain, animatable: true };
    }
    return {
      domain: sortAndUniqueDates(sortedDomains.flat()),
      animatable: true
    };
  }
  ticks(params, domain, visibleRange = [0, 1], { extend = false, dropInitial = false } = {}) {
    const { interval, maxTickCount, tickCount = maxTickCount } = params;
    const { bands } = this;
    if (!bands.length)
      return;
    this.refresh();
    if (interval == null) {
      const { ticks: ticks2, tickOffset, tickEvery } = this.getDefaultTicks(domain, tickCount, visibleRange, extend);
      let firstTickIndex = ticks2.length > 0 ? this.findIndex(ticks2[0]) : void 0;
      firstTickIndex = firstTickIndex != null ? Math.floor((firstTickIndex - tickOffset) / tickEvery) : void 0;
      return { ticks: ticks2, count: void 0, firstTickIndex };
    }
    let start2;
    let stop;
    if (domain && domain.length >= 2) {
      start2 = domain[0].valueOf();
      stop = domain[domain.length - 1].valueOf();
    } else {
      start2 = bands[0].valueOf();
      stop = bands[bands.length - 1].valueOf();
    }
    const [r0, r1] = this.range;
    const availableRange = Math.abs(r1 - r0);
    const dateTicks = getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange, extend }) ?? this.getDefaultTicks(domain, tickCount, visibleRange, extend).ticks;
    const ticks = [];
    let lastIndex = -1;
    for (const dateTick of dateTicks) {
      const index = this.findIndex(dateTick, 1 /* Trailing */) ?? -1;
      const duplicated = index === lastIndex;
      lastIndex = index;
      if (!(dropInitial && index === 0) && index !== -1 && !duplicated) {
        ticks.push(bands[index]);
      }
    }
    return { ticks, count: void 0, firstTickIndex: void 0 };
  }
  stepTicks(bandStep, domain, visibleRange = [0, 1], dropLast = true) {
    const bandIndices = domain ? this.bandDomainIndices(domain) : void 0;
    const ticks = this.ticksEvery(bandIndices, visibleRange, bandStep, 0, false);
    const lastTick = ticks.at(-1);
    const lastBandIndex = dropLast && bandStep > 1 ? bandIndices?.[1] : void 0;
    const lastTickIndex = lastBandIndex != null && lastTick != null ? this.findIndex(lastTick) : void 0;
    if (lastTickIndex != null && lastBandIndex != null && lastBandIndex - lastTickIndex < bandStep) {
      ticks.pop();
    }
    return ticks;
  }
  bandCount(visibleRange = [0, 1]) {
    const { domain } = this;
    const startIndex = Math.floor(visibleRange[0] * domain.length);
    const endIndex = Math.ceil(visibleRange[1] * domain.length);
    return endIndex - startIndex;
  }
  getDefaultTicks(domain, maxTickCount, visibleRange, extend) {
    const { bands } = this;
    const tickEvery = Math.ceil(bands.length / maxTickCount);
    const tickOffset = Math.floor(tickEvery / 2);
    const bandIndices = domain ? this.bandDomainIndices(domain) : void 0;
    return {
      ticks: this.ticksEvery(bandIndices, visibleRange, tickEvery, tickOffset, extend),
      tickOffset,
      tickEvery
    };
  }
  bandDomainIndices(domain) {
    const isReversed = domainReversed(domain);
    const i0 = this.findIndex(domain[isReversed ? domain.length - 1 : 0], 1 /* Trailing */) ?? 0;
    const i1 = this.findIndex(domain[isReversed ? 0 : domain.length - 1], 1 /* Trailing */) ?? this.bands.length - 1;
    return [i0, i1];
  }
  ticksEvery([i0, i1] = [0, this.bands.length], visibleRange, tickEvery, tickOffset, extend) {
    const { bands } = this;
    const offset = i0;
    const span = i1 - i0 + 1;
    let startIndex = offset + Math.floor(visibleRange[0] * span);
    let endIndex = offset + Math.ceil(visibleRange[1] * span);
    if (extend) {
      startIndex -= tickEvery;
      endIndex += tickEvery;
    }
    startIndex = Math.max(startIndex, 0);
    endIndex = Math.min(endIndex, bands.length);
    let ticks;
    if (tickEvery <= 1) {
      ticks = bands.slice(startIndex, endIndex);
    } else {
      ticks = [];
      for (let index = startIndex; index < endIndex; index += 1) {
        if ((index - offset + tickOffset) % tickEvery === 0) {
          ticks.push(bands[index]);
        }
      }
    }
    return ticks;
  }
};
function domainReversed(domain) {
  return domain.length > 0 && domain[0] > domain[domain.length - 1];
}

// packages/ag-charts-community/src/scale/unitTimeScale.ts
var MAX_BANDS = 5e7;
var UnitTimeScale = class _UnitTimeScale extends DiscreteTimeScale {
  constructor() {
    super(...arguments);
    this.type = "unit-time";
    this.defaultTickCount = 12;
    this._domain = [];
    /* eslint-enable */
    this._bands = void 0;
  }
  static is(value) {
    return value instanceof _UnitTimeScale;
  }
  static supportsInterval(domain, interval) {
    return supportsInterval(domain, interval);
  }
  set domain(domain) {
    if (domain === this._domain)
      return;
    this._domain = domain;
    this._bands = void 0;
  }
  get domain() {
    return this._domain;
  }
  get interval() {
    return this._interval;
  }
  set interval(interval) {
    if (this._interval === interval)
      return;
    this._interval = interval;
    this._bands = void 0;
  }
  get bands() {
    this._bands ?? (this._bands = this.calculateBands(this._domain, [0, 1]).bands);
    return this._bands;
  }
  normalizeDomains(...domains) {
    return normalizeContinuousDomains(...domains);
  }
  convert(value, options) {
    if (!(value instanceof Date))
      value = new Date(value);
    const { domain, interval } = this;
    if (domain.length < 2)
      return NaN;
    if (options?.clamp !== true && interval != null) {
      const t = value.valueOf();
      const [start2, stop] = calculateBandRange(domain, interval);
      const d0 = Math.min(start2.valueOf(), stop.valueOf());
      const d1 = Math.max(start2.valueOf(), stop.valueOf());
      if (t < d0 || t >= d1 + intervalMilliseconds(interval))
        return NaN;
    }
    return super.convert(value, options);
  }
  calculateBands(domain, visibleRange, extend = false) {
    if (domain === this.domain && visibleRange[0] === 0 && visibleRange[1] === 1 && !extend && this._bands != null) {
      return { bands: this._bands, firstBandIndex: 0 };
    }
    if (domain.length < 2)
      return { bands: [], firstBandIndex: void 0 };
    const { interval } = this;
    if (interval == null)
      return { bands: [], firstBandIndex: void 0 };
    const rangeParams = { visibleRange, extend };
    if (!supportsInterval(domain, interval, rangeParams))
      return { bands: [], firstBandIndex: void 0 };
    const [start2, stop] = calculateBandRange(domain, interval);
    if (intervalRangeCount(interval, start2, stop, rangeParams) > MAX_BANDS) {
      logger_exports.warnOnce(`the configured unit results in too many bands, ignoring. Supply a larger unit.`);
      return { bands: [], firstBandIndex: void 0 };
    }
    const bands = intervalRange(interval, start2, stop, rangeParams);
    const firstBandIndex = intervalRangeStartIndex(interval, start2, stop, rangeParams);
    return { bands, firstBandIndex };
  }
  ticks({ interval }, domain = this.domain, visibleRange = [0, 1], { extend = false } = {}) {
    if (domain.length < 2)
      return;
    const { bands, firstBandIndex } = this.calculateBands(domain, visibleRange, extend);
    const milliseconds = this.interval ? intervalMilliseconds(this.interval) : Infinity;
    if (interval == null)
      return { ticks: bands, count: void 0, firstTickIndex: firstBandIndex };
    const d0 = Math.min(domain[0].valueOf(), domain[1].valueOf());
    const d1 = Math.max(domain[0].valueOf(), domain[1].valueOf());
    let intervalTicks;
    let intervalStartIndex;
    let intervalEndIndex;
    if (isPlainObject(interval) || typeof interval === "string") {
      intervalTicks = intervalRange(interval, domain[0], domain[1], { extend: true, visibleRange });
      intervalStartIndex = 0;
      intervalEndIndex = intervalTicks.length - 1;
    } else {
      intervalTicks = bands;
      intervalStartIndex = findMaxIndex(0, bands.length - 1, (index) => bands[index].valueOf() <= d0) ?? 0;
      intervalEndIndex = findMaxIndex(0, bands.length - 1, (index) => bands[index].valueOf() <= d1) ?? bands.length - 1;
    }
    const ticks = [];
    let lastIndex;
    for (let i = intervalStartIndex; i <= intervalEndIndex; i++) {
      const intervalTickValue = intervalTicks[i].valueOf();
      const bandIndex = findMaxIndex(0, bands.length - 1, (index) => bands[index].valueOf() <= intervalTickValue);
      const tick = bandIndex != null && bandIndex != lastIndex ? bands[bandIndex] : void 0;
      lastIndex = bandIndex;
      if (tick != null && intervalTickValue - tick.getTime() <= milliseconds)
        ticks.push(tick);
    }
    let bandStart;
    let bandEnd;
    if (this.interval) {
      const bandRange = calculateBandRange([new Date(d0), new Date(d1)], this.interval);
      bandStart = bandRange[0].valueOf();
      bandEnd = bandRange[1].valueOf();
    } else {
      bandStart = d0;
      bandEnd = d1;
    }
    let firstTickIndex = findMinIndex(0, ticks.length - 1, (i) => ticks[i].valueOf() >= bandStart) ?? 0;
    let lastTickIndex = findMaxIndex(0, ticks.length - 1, (i) => ticks[i].valueOf() <= bandEnd) ?? ticks.length - 1;
    if (extend) {
      firstTickIndex = Math.max(firstTickIndex - 1, 0);
      lastTickIndex = Math.min(lastTickIndex + 1, ticks.length - 1);
    }
    return {
      ticks: ticks.slice(firstTickIndex, lastTickIndex + 1),
      count: ticks.length,
      firstTickIndex: firstBandIndex
    };
  }
};
function supportsInterval(domain, interval, rangeParams) {
  const [start2, stop] = calculateBandRange(domain, interval);
  return intervalRangeCount(interval, start2, stop, rangeParams) <= MAX_BANDS;
}
function calculateBandRange(domain, interval) {
  const start2 = intervalFloor(interval, domain[0]);
  const stop = intervalFloor(interval, domain[1]);
  return [start2, stop];
}

// packages/ag-charts-community/src/util/secondaryAxisTicks.ts
function calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange) {
  let [d0, d1] = findMinMax(domain.map(Number));
  const unzoomedTickCount = Math.floor(primaryTickCount.unzoomed);
  if (unzoomedTickCount <= 1) {
    const [start3, stop2] = domainWithOddTickCount(d0, d1);
    const tickCount = 5 * Math.pow(2, -Math.ceil(Math.log2(visibleRange[1] - visibleRange[0])));
    const { ticks: ticks2 } = createTicks(start3, stop2, tickCount, void 0, void 0, visibleRange);
    const d2 = [scale2.toDomain(start3), scale2.toDomain(stop2)];
    if (reverse)
      d2.reverse();
    return { domain: d2, ticks: ticks2 };
  }
  if (d0 === d1) {
    const order = Math.floor(Math.log10(d0));
    const magnitude = Math.pow(10, order);
    const rangeOffsetStep = Math.min(magnitude, 1);
    const rangeOffset = unzoomedTickCount - 1;
    d0 -= rangeOffsetStep * Math.floor(rangeOffset / 2);
    d1 = d0 + rangeOffsetStep * rangeOffset;
  }
  let start2 = d0;
  let stop = d1;
  start2 = calculateNiceStart(start2, stop, unzoomedTickCount);
  const baseStep = getTickStep(start2, stop, unzoomedTickCount);
  const segments = unzoomedTickCount - 1;
  stop = start2 + segments * baseStep;
  const stepAlignedStart = Math.floor(start2 / baseStep) * baseStep;
  const stepAlignedStop = Math.floor(stop / baseStep) * baseStep;
  if (stepAlignedStart <= d0 && stepAlignedStop >= d1) {
    start2 = stepAlignedStart;
    stop = stepAlignedStop;
  }
  const d = [scale2.toDomain(start2), scale2.toDomain(stop)];
  if (reverse)
    d.reverse();
  const step = baseStep * ((primaryTickCount.unzoomed - 1) / (primaryTickCount.zoomed - 1));
  const ticks = getTicks(start2, step, Math.floor(primaryTickCount.zoomed));
  return { domain: d, ticks };
}
function domainWithOddTickCount(d0, d1) {
  let start2 = d0;
  let stop = d1;
  let iterations = 0;
  do {
    [start2, stop] = niceTicksDomain(start2, stop);
    const { ticks } = createTicks(start2, stop, 5);
    if (ticks.length % 2 === 1)
      return [start2, stop];
    start2 -= 1;
    stop += 1;
  } while (iterations++ < 10);
  return [d0, d1];
}
function calculateNiceStart(a, b, count) {
  a = Math.floor(a);
  const rawStep = Math.abs(b - a) / (count - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start2, step, count) {
  const fractionDigits = countFractionDigits(step);
  const f = Math.pow(10, fractionDigits);
  const ticks = [];
  for (let i = 0; i < count; i++) {
    const tick = start2 + step * i;
    ticks.push(Math.round(tick * f) / f);
  }
  return ticks;
}
function getTickStep(start2, stop, count) {
  const segments = count - 1;
  const rawStep = (stop - start2) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  const step = rawStep / magnitude;
  if (step > 0 && step <= 1)
    return magnitude;
  if (step > 1 && step <= 2)
    return 2 * magnitude;
  if (step > 2 && step <= 5)
    return 5 * magnitude;
  if (step > 5 && step <= 10)
    return 10 * magnitude;
  return rawStep;
}

// packages/ag-charts-community/src/util/tempUtils.ts
function createIdsGenerator() {
  const idsCounter = /* @__PURE__ */ new Map();
  return (name) => {
    const counter = idsCounter.get(name);
    if (counter) {
      idsCounter.set(name, counter + 1);
      return `${name}_${counter}`;
    }
    idsCounter.set(name, 1);
    return name;
  };
}

// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts
var DENSE_TICK_COUNT = 18;
var TICK_STEP_VALUES = [1, 2, 3, 4, 6, 8, 9, 10, 12];
var sunday2 = new Date(1970, 0, 4);
var AxisTickGenerator = class {
  constructor(axis) {
    this.axis = axis;
  }
  estimateTickCount(domain, range4, visibleRange, defaultTickMinSpacing, minSpacing, maxSpacing) {
    const { scale: scale2, label } = this.axis;
    const { defaultTickCount } = scale2;
    const rangeExtent = findRangeExtent(range4);
    const zoomExtent = findRangeExtent(visibleRange);
    if (CategoryScale.is(scale2)) {
      const maxTickCount = domain.length;
      let estimatedTickCount = Math.ceil(rangeExtent / (zoomExtent * label.fontSize));
      estimatedTickCount = Math.min(estimatedTickCount, maxTickCount);
      return {
        minTickCount: 0,
        maxTickCount,
        tickCount: estimatedTickCount
      };
    }
    return estimateTickCount(
      rangeExtent,
      zoomExtent,
      minSpacing,
      maxSpacing,
      defaultTickCount,
      defaultTickMinSpacing
    );
  }
  generateTicks({
    range: range4,
    domain,
    reverse,
    primaryTickCount,
    defaultTickMinSpacing,
    visibleRange,
    niceMode,
    parallelFlipRotation,
    regularFlipRotation,
    labelX,
    sideFlag,
    removeOverflowLabels,
    removeOverflowThreshold = 0,
    sizeLimit
  }) {
    const {
      label,
      primaryLabel,
      interval: { minSpacing, maxSpacing }
    } = this.axis;
    const { parallel, fontFamily, fontSize, fontStyle, fontWeight } = label;
    const secondaryAxis = primaryTickCount !== void 0;
    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation(
      label.rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    );
    const { maxTickCount } = this.estimateTickCount(
      domain,
      range4,
      visibleRange,
      defaultTickMinSpacing,
      minSpacing,
      maxSpacing
    );
    const maxIterations = Number.isFinite(maxTickCount) ? maxTickCount : 10;
    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
    const font3 = { fontFamily, fontSize, fontStyle, fontWeight };
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font3 });
    const checkLabelOverlap = label.enabled && label.avoidCollisions;
    const initialRotation = configuredRotation + defaultRotation;
    const labelMatrix = new Matrix();
    const updateLabelMatrix = (iterationRotation) => {
      const labelRotation = initialRotation + iterationRotation;
      Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);
    };
    const getLabelData = ({ ticks }, iterationRotation) => {
      updateLabelMatrix(iterationRotation);
      return createLabelData(ticks, labelX, labelMatrix, textMeasurer, label);
    };
    const getTimeLabelData = (tickData2, iterationRotation) => {
      const { niceDomain, ticks, timeInterval: timeInterval3 } = tickData2;
      if (timeInterval3 == null)
        return [];
      updateLabelMatrix(iterationRotation);
      const spacing = ticksSpacing(ticks);
      const { width: width2, height: height2 } = timeIntervalMaxLabelSize(
        label,
        primaryLabel,
        niceDomain ?? domain,
        timeInterval3,
        textMeasurer
      );
      return createFixedLabelData({ width: width2, height: height2, spacing }, labelX, labelMatrix);
    };
    const getLabelOverlap = (tickData2, iterationRotation) => {
      if (!checkLabelOverlap)
        return false;
      const rotated = configuredRotation !== 0 || iterationRotation !== 0;
      const labelSpacing = getLabelSpacing(label.minSpacing, rotated);
      return axisLabelsOverlap(getTimeLabelData(tickData2, iterationRotation), labelSpacing) || axisLabelsOverlap(getLabelData(tickData2, iterationRotation), labelSpacing);
    };
    let tickData = {
      tickDomain: [],
      niceDomain: domain,
      ticks: [],
      rawTicks: [],
      rawTickCount: void 0,
      timeInterval: void 0,
      fractionDigits: 0
    };
    let index = 0;
    let autoRotation = 0;
    let labelOverlap = true;
    let terminate = false;
    while (!terminate && labelOverlap && index <= maxIterations) {
      autoRotation = 0;
      for (const strategy of this.getTickStrategies({
        domain,
        range: range4,
        reverse,
        niceMode,
        secondaryAxis,
        sizeLimit
      })) {
        ({ tickData, index, autoRotation, terminate } = strategy({
          index,
          tickData,
          terminate,
          primaryTickCount,
          defaultTickMinSpacing,
          visibleRange,
          labelsOverlap() {
            return getLabelOverlap(tickData, autoRotation);
          }
        }));
      }
      labelOverlap = getLabelOverlap(tickData, autoRotation);
    }
    const textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
    const rotation = configuredRotation + autoRotation;
    if (removeOverflowLabels && tickData.ticks.length > 2) {
      const labelData = getLabelData(tickData, autoRotation);
      const lastTick = tickData.ticks.at(-1);
      const lastLabel = labelData.at(-1);
      if (lastTick != null && lastLabel != null && lastTick.translation + lastLabel.label.width / 2 > range4[1] + removeOverflowThreshold) {
        lastTick.tickLabel = void 0;
        if (visibleRange[0] === 0 && visibleRange[1] === 1) {
          tickData.ticks[0].tickLabel = void 0;
        }
      }
    }
    return { tickData, rotation, textBaseline, textAlign };
  }
  getTickStrategies({
    domain,
    range: range4,
    reverse,
    niceMode,
    secondaryAxis,
    sizeLimit
  }) {
    const { label, interval } = this.axis;
    const avoidLabelCollisions = label.enabled && label.avoidCollisions;
    const autoRotate = label.autoRotate === true && label.rotation === void 0;
    const strategies = [];
    let tickGenerationType;
    if (interval.values) {
      tickGenerationType = 2 /* VALUES */;
    } else if (secondaryAxis) {
      tickGenerationType = 1 /* CREATE_SECONDARY */;
    } else {
      tickGenerationType = 0 /* CREATE */;
    }
    const tickGenerationStrategy = ({
      index,
      tickData,
      primaryTickCount,
      defaultTickMinSpacing,
      visibleRange,
      terminate
    }) => this.createTickData(
      domain,
      range4,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount,
      defaultTickMinSpacing,
      tickGenerationType,
      index,
      tickData,
      terminate,
      sizeLimit
    );
    strategies.push(tickGenerationStrategy);
    if (avoidLabelCollisions && autoRotate) {
      const autoRotateStrategy = ({ index, tickData, labelsOverlap, terminate }) => ({
        index,
        tickData,
        autoRotation: labelsOverlap() ? normalizeAngle360FromDegrees(label.autoRotateAngle) : 0,
        terminate
      });
      strategies.push(autoRotateStrategy);
    }
    return strategies;
  }
  createTickData(domain, range4, reverse, niceMode, visibleRange, primaryTickCount, defaultTickMinSpacing, tickGenerationType, index, previousTickData, terminate, sizeLimit) {
    const { interval } = this.axis;
    const { step, values, minSpacing, maxSpacing } = interval;
    const { maxTickCount, minTickCount, tickCount } = this.estimateTickCount(
      domain,
      range4,
      visibleRange,
      defaultTickMinSpacing,
      minSpacing,
      maxSpacing
    );
    const maxIterations = tickCount - minTickCount;
    const countTicks2 = (i) => Math.max(tickCount - i, minTickCount);
    const previousTicks = previousTickData.rawTicks;
    const regenerateTicks = step == null && values == null && countTicks2(index) > minTickCount;
    const getTickParams = {
      domain,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount,
      tickGenerationType,
      minTickCount,
      maxTickCount,
      tickCount: 0
    };
    getTickParams.tickCount = countTicks2(index);
    let nextTicks = this.getTicks(getTickParams);
    if (regenerateTicks && ticksEqual(nextTicks.rawTicks, previousTicks)) {
      let lowerBound = index;
      let upperBound = maxIterations;
      while (lowerBound <= upperBound) {
        index = (lowerBound + upperBound) / 2 | 0;
        getTickParams.tickCount = countTicks2(index);
        const nextTicksCandidate = this.getTicks(getTickParams);
        if (ticksEqual(nextTicksCandidate.rawTicks, previousTicks)) {
          lowerBound = index + 1;
        } else {
          nextTicks = nextTicksCandidate;
          upperBound = index - 1;
        }
      }
    }
    const {
      tickDomain,
      niceDomain,
      rawTicks,
      rawTickCount,
      rawFirstTickIndex,
      generatePrimaryTicks,
      primaryTicksIndices,
      alignment,
      fractionDigits,
      timeInterval: timeInterval3
    } = nextTicks;
    const ticks = this.formatTicks({
      range: range4,
      niceDomain,
      rawTicks,
      rawFirstTickIndex,
      generatePrimaryTicks,
      primaryTicksIndices,
      alignment,
      fractionDigits,
      timeInterval: timeInterval3,
      sizeLimit
    });
    const tickData = {
      tickDomain,
      niceDomain,
      rawTicks,
      rawTickCount,
      timeInterval: timeInterval3,
      fractionDigits,
      ticks
    };
    index += 1;
    terminate || (terminate = step != null || values != null);
    return { tickData, index, autoRotation: 0, terminate };
  }
  getTimeIntervalTicks(visibleRange, tickCount, maxTickCount, tickParams, timeInterval3, reverse) {
    const parentInterval = intervalHierarchy(timeInterval3);
    if (parentInterval == null)
      return;
    const { scale: scale2 } = this.axis;
    if (!TimeScale.is(scale2) && !DiscreteTimeScale.is(scale2))
      return;
    if (reverse) {
      visibleRange = [1 - visibleRange[1], 1 - visibleRange[0]];
    }
    const dv0 = Math.min(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
    const dv1 = Math.max(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
    let [dp0, dp1] = intervalExtent(new Date(dv0), new Date(dv1), visibleRange);
    dp0 = intervalFloor(parentInterval, dp0);
    if (dp0.valueOf() >= dv0)
      dp0 = intervalPrevious(parentInterval, dp0);
    dp1 = intervalCeil(parentInterval, dp1);
    if (dp1.valueOf() <= dv1)
      dp1 = intervalNext(parentInterval, dp1);
    const primaryTicks = intervalRange(parentInterval, dp0, dp1);
    const milliseconds = intervalMilliseconds(timeInterval3);
    let primaryTicksIndices = /* @__PURE__ */ new Set();
    const skipFirstPrimaryTick = OrdinalTimeScale.is(scale2);
    const ticks = [];
    const intervalTickParams = {
      ...tickParams,
      interval: timeInterval3
    };
    let parentLevelMode;
    let alignment;
    let ordinalTickStep = 0;
    if (OrdinalTimeScale.is(scale2)) {
      const minimumTimeGranularity = this.axis.minimumTimeGranularity;
      const timeIntervalGranularity = intervalUnit(timeInterval3);
      parentLevelMode = minimumTimeGranularity != null && intervalMilliseconds(minimumTimeGranularity) >= intervalMilliseconds(timeIntervalGranularity) ? 2 /* OrdinalTimeStepTicks */ : 3 /* OrdinalTimeScaleTicks */;
      alignment = 1 /* Trailing */;
      const tickDensity = tickCount / maxTickCount;
      const baseTickStep = scale2.bandCount(visibleRange) / (tickDensity * DENSE_TICK_COUNT);
      ordinalTickStep = TICK_STEP_VALUES.findLast((t) => baseTickStep >= t) ?? 1;
    } else if (UnitTimeScale.is(scale2) && (scale2.interval == null || intervalMilliseconds(scale2.interval) >= milliseconds)) {
      parentLevelMode = 1 /* UnitTimeScaleTicks */;
    } else {
      parentLevelMode = 0 /* ContinuousTimeScaleTicks */;
      alignment = 2 /* Interpolate */;
    }
    for (let i = 0; i < primaryTicks.length - 1; i += 1) {
      const p0 = primaryTicks[i];
      const p1 = primaryTicks[i + 1];
      const first2 = i === 0;
      const last = i === primaryTicks.length - 2;
      const dp = p1.valueOf() - p0.valueOf();
      const pVisibleRange = [
        Math.max((dv0 - p0.valueOf()) / dp, 0),
        Math.min((dv1 - p0.valueOf()) / dp, 1)
      ];
      let intervalTicks;
      switch (parentLevelMode) {
        case 0 /* ContinuousTimeScaleTicks */:
          intervalTicks = createTimeScaleTicks(
            intervalTickParams.interval,
            [p0, p1],
            pVisibleRange,
            true
          ).ticks;
          break;
        case 1 /* UnitTimeScaleTicks */:
        case 3 /* OrdinalTimeScaleTicks */:
          const scaleTicks = scale2.ticks(intervalTickParams, [p0, p1], pVisibleRange, {
            extend: true,
            dropInitial: true
          });
          intervalTicks = scaleTicks?.ticks ?? [];
          break;
        case 2 /* OrdinalTimeStepTicks */:
          intervalTicks = scale2.stepTicks(
            ordinalTickStep,
            [p0, p1],
            void 0,
            !last
          );
          break;
      }
      dropFirstWhile(intervalTicks, (firstTick2) => firstTick2.valueOf() < p0.valueOf());
      if (!last) {
        dropLastWhile(intervalTicks, (lastTick) => {
          switch (parentLevelMode) {
            case 0 /* ContinuousTimeScaleTicks */:
            case 3 /* OrdinalTimeScaleTicks */:
              return lastTick.valueOf() + milliseconds > p1.valueOf();
            case 1 /* UnitTimeScaleTicks */:
            case 2 /* OrdinalTimeStepTicks */:
              return lastTick.valueOf() >= p1.valueOf();
          }
        });
      }
      if (intervalTicks.length === 0)
        continue;
      const firstTick = intervalTicks[0];
      const firstTickDiff = compareDates(firstTick, p0);
      const firstPrimary = parentLevelMode === 0 /* ContinuousTimeScaleTicks */ ? firstTickDiff === 0 : firstTickDiff <= milliseconds;
      if (firstPrimary && (!skipFirstPrimaryTick || !first2)) {
        primaryTicksIndices.add(ticks.length);
      }
      ticks.push(...intervalTicks);
    }
    if (primaryTicksIndices.size === 0 || // If there's only one primary tick and it's the first tick, don't show primary ticks
    primaryTicksIndices.size === 1 && primaryTicksIndices.has(0)) {
      primaryTicksIndices = void 0;
    }
    let firstTickIndex;
    return { ticks, tickCount: void 0, firstTickIndex, primaryTicksIndices, alignment };
  }
  getTicks({
    domain,
    reverse,
    niceMode,
    visibleRange,
    tickGenerationType,
    tickCount,
    minTickCount,
    maxTickCount,
    primaryTickCount
  }) {
    const { axis } = this;
    const { primaryLabel, scale: scale2, interval } = axis;
    const domainParams = {
      nice: niceMode === 0 /* TickAndDomain */,
      interval: interval.step,
      tickCount,
      minTickCount,
      maxTickCount
    };
    const tickParams = {
      ...domainParams,
      nice: niceMode === 0 /* TickAndDomain */ || niceMode === 1 /* TicksOnly */
    };
    let secondaryAxisTicks;
    if (tickGenerationType === 1 /* CREATE_SECONDARY */ && primaryTickCount != null && ContinuousScale.is(scale2)) {
      secondaryAxisTicks = calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange);
    }
    const niceDomain = niceMode === 0 /* TickAndDomain */ ? secondaryAxisTicks?.domain ?? scale2.niceDomain(domainParams, domain) : domain;
    let tickDomain = niceDomain;
    let rawTicks;
    let rawTickCount;
    let rawFirstTickIndex;
    let timeInterval3;
    let primaryTicksIndices;
    let alignment;
    const generatePrimaryTicks = primaryLabel?.enabled === true && tickParams.interval == null;
    const scaleDomain = scale2.domain;
    scale2.domain = niceDomain;
    switch (tickGenerationType) {
      case 2 /* VALUES */:
        tickDomain = interval.values;
        rawTicks = interval.values;
        rawTickCount = rawTicks.length;
        if (OrdinalTimeScale.is(scale2)) {
          alignment = 1 /* Trailing */;
        } else if (UnitTimeScale.is(scale2)) {
          alignment = 2 /* Interpolate */;
        }
        if (ContinuousScale.is(scale2)) {
          const [d0, d1] = findMinMax(niceDomain.map(Number));
          rawTicks = rawTicks.filter((value) => Number(value) >= d0 && Number(value) <= d1).sort((a, b) => Number(a) - Number(b));
        }
        break;
      case 1 /* CREATE_SECONDARY */:
        if (secondaryAxisTicks) {
          rawTicks = secondaryAxisTicks.ticks;
          rawTickCount = secondaryAxisTicks.ticks.length;
        } else {
          const tickGeneration = scale2.ticks(tickParams, niceDomain, visibleRange);
          rawTicks = tickGeneration?.ticks ?? [];
          rawTickCount = tickGeneration?.count;
        }
        break;
      default: {
        if (niceDomain.length > 0 && tickParams.interval == null && (UnitTimeScale.is(scale2) || generatePrimaryTicks && (TimeScale.is(scale2) || OrdinalTimeScale.is(scale2)))) {
          const dates = niceDomain;
          const start2 = Math.min(dates[0].valueOf(), dates[dates.length - 1].valueOf());
          const end2 = Math.max(dates[0].valueOf(), dates[dates.length - 1].valueOf());
          timeInterval3 = getTickTimeInterval(start2, end2, tickCount, minTickCount, maxTickCount, {
            weekStart: primaryLabel == null ? sunday2 : void 0,
            primaryOnly: true
          });
        }
        let minTimeInterval;
        if (OrdinalTimeScale.is(scale2)) {
          minTimeInterval = axis.minimumTimeGranularity;
        } else if (UnitTimeScale.is(scale2)) {
          minTimeInterval = scale2.interval;
        }
        if (minTimeInterval != null && timeInterval3 != null && // Prefer UnitTimeAxis.unit over this interval, because the user may have defined an epoch
        intervalMilliseconds(minTimeInterval) >= intervalMilliseconds(timeInterval3)) {
          timeInterval3 = minTimeInterval;
        }
        const intervalTicks = timeInterval3 ? this.getTimeIntervalTicks(
          visibleRange,
          tickCount,
          maxTickCount,
          tickParams,
          timeInterval3,
          reverse
        ) : void 0;
        if (intervalTicks) {
          ({
            ticks: rawTicks,
            tickCount: rawTickCount,
            firstTickIndex: rawFirstTickIndex,
            primaryTicksIndices,
            alignment
          } = intervalTicks);
        } else {
          const intervalTickParams = UnitTimeScale.is(scale2) && tickParams.interval == null && timeInterval3 != null ? { ...tickParams, interval: timeInterval3 } : tickParams;
          const tickGeneration = scale2.ticks(intervalTickParams, niceDomain, visibleRange);
          rawTicks = tickGeneration?.ticks ?? [];
          rawTickCount = tickGeneration?.count;
          rawFirstTickIndex = tickGeneration?.firstTickIndex;
          if (TimeScale.is(scale2) || DiscreteTimeScale.is(scale2)) {
            const timeTickParams = tickParams;
            const paramsInterval = typeof timeTickParams.interval === "number" ? lowestGranularityForInterval(timeTickParams.interval) : timeTickParams.interval;
            timeInterval3 ?? (timeInterval3 = paramsInterval ?? tickGeneration?.timeInterval);
          }
        }
      }
    }
    const fractionDigits = rawTicks.reduce(
      (max, tick) => Math.max(max, typeof tick === "number" ? countFractionDigits(tick) : 0),
      0
    );
    if (!generatePrimaryTicks) {
      primaryTicksIndices = void 0;
    }
    scale2.domain = scaleDomain;
    return {
      tickDomain,
      niceDomain,
      rawTicks,
      rawTickCount,
      rawFirstTickIndex,
      generatePrimaryTicks,
      primaryTicksIndices,
      alignment,
      fractionDigits,
      timeInterval: timeInterval3
    };
  }
  formatTicks({
    niceDomain,
    range: range4,
    rawTicks,
    rawFirstTickIndex = 0,
    generatePrimaryTicks,
    primaryTicksIndices,
    alignment,
    fractionDigits,
    timeInterval: timeInterval3,
    sizeLimit = Infinity
  }) {
    const { axis } = this;
    const { label, scale: scale2 } = axis;
    const scaleDomain = scale2.domain;
    scale2.domain = niceDomain;
    const dateStyle = generatePrimaryTicks ? "component" : "long";
    const axisTickFormatter = label.enabled ? axis.tickFormatter(niceDomain, rawTicks, false, fractionDigits, timeInterval3, dateStyle) : void 0;
    const parentInterval = timeInterval3 != null ? intervalHierarchy(timeInterval3) : void 0;
    const axisPrimaryTickFormatter = generatePrimaryTicks ? axis.tickFormatter(niceDomain, rawTicks, true, fractionDigits, parentInterval, dateStyle) : void 0;
    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;
    const ticks = [];
    const continuous = TimeScale.is(scale2) || DiscreteTimeScale.is(scale2);
    const idGenerator = createIdsGenerator();
    const isVertical = axis.direction === "y" /* Y */;
    const maxBand = (BandScale.is(scale2) ? scale2.bandwidth : null) ?? Infinity;
    const wrapOptions = {
      font: label,
      maxWidth: isVertical ? sizeLimit : maxBand,
      maxHeight: isVertical ? maxBand : sizeLimit,
      overflow: label.truncate ? "ellipsis" : "hide",
      textWrap: label.wrapping
    };
    for (let i = 0; i < rawTicks.length; i++) {
      const tick = rawTicks[i];
      const translation = scale2.convert(tick, { alignment }) + halfBandwidth;
      if (range4.length > 0 && !axis.inRange(translation, 1e-3))
        continue;
      const primary = primaryTicksIndices?.has(i) ?? false;
      let tickLabel = primary ? axisPrimaryTickFormatter?.(tick, i) : axisTickFormatter?.(tick, i);
      const inputText = tickLabel ?? String(tick);
      if (label.avoidCollisions) {
        tickLabel = TextWrapper.wrapText(inputText, wrapOptions) || tickLabel;
      }
      let tickId;
      const continuousValue = continuous ? tick?.valueOf() : void 0;
      if (Number.isFinite(continuousValue)) {
        tickId = idGenerator(`v:${continuousValue}`);
      } else {
        tickId = idGenerator(`l:${tickLabel}`);
      }
      ticks.push({
        index: i + rawFirstTickIndex,
        tick,
        tickId,
        tickLabel,
        textUntruncated: tickLabel != null && inputText !== tickLabel ? inputText : void 0,
        translation: Math.floor(translation),
        primary
      });
    }
    scale2.domain = scaleDomain;
    return ticks;
  }
};
function axisLabelsOverlap(data, padding2 = 0) {
  const result = [];
  for (const datum of data) {
    const { x, y } = datum.point;
    let { width: width2, height: height2 } = datum.label;
    width2 += padding2;
    height2 += padding2;
    if (result.some((l) => boxCollides(l, x, y, width2, height2))) {
      return true;
    }
    result.push({ x, y, width: width2, height: height2 });
  }
  return false;
}
function createTimeScaleTicks(interval, domain, visibleRange, extend) {
  if (interval == null) {
    return { ticks: domain, firstTickIndex: void 0 };
  }
  const d0 = domain[0].valueOf();
  const d1 = domain[1].valueOf();
  if (typeof interval !== "number") {
    const epoch = domain[0];
    const alignedInterval = typeof interval === "string" ? { unit: interval, epoch } : { ...interval, epoch };
    const ticks2 = intervalRange(alignedInterval, domain[0], domain[1], { visibleRange, extend });
    const firstTickIndex = intervalRangeStartIndex(alignedInterval, domain[0], domain[1], { visibleRange, extend });
    return { ticks: ticks2, firstTickIndex };
  }
  const ticks = [];
  for (let intervalTickTime = d0; intervalTickTime <= d1; intervalTickTime += interval) {
    ticks.push(new Date(intervalTickTime));
  }
  return { ticks, firstTickIndex: void 0 };
}
function ticksEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i += 1) {
    if (a[i]?.valueOf() !== b[i]?.valueOf()) {
      return false;
    }
  }
  return true;
}
function ticksSpacing(ticks) {
  if (ticks.length < 2)
    return Infinity;
  let spacing = 0;
  let y0 = ticks[0].translation;
  for (let i = 1; i < ticks.length; i++) {
    const y1 = ticks[i].translation;
    const delta4 = Math.abs(y1 - y0);
    spacing = Math.max(spacing, delta4);
    y0 = y1;
  }
  return spacing;
}

// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass([
  Property
], CartesianAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
  Property
], CartesianAxisLabel.prototype, "autoRotateAngle", 2);

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis = class _CartesianAxis extends Axis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.maxThicknessRatio = 0.3;
    this.headingLabelGroup = this.axisGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-Axis-heading` })
    );
    this.lineNodeGroup = this.axisGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-Axis-line` })
    );
    this.lineNode = this.lineNodeGroup.appendChild(new Line({ zIndex: 1 /* AxisLine */ }));
    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);
    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);
    this.gridFillGroupSelection = Selection.select(this.gridFillGroup, Rect, false);
    this.tempText = new TransformableText({ debugDirty: false });
    this.tempCaption = new Caption();
    this.tickGenerator = new AxisTickGenerator(this);
    this.animationManager = moduleCtx.animationManager;
    this.animationState = new StateMachine("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.resetSelectionNodes()
        },
        reset: "empty"
      },
      ready: {
        update: (data) => this.animateReadyUpdate(data),
        resize: () => this.resetSelectionNodes(),
        reset: "empty"
      }
    });
    this.headingLabelGroup.appendChild(this.title.caption.node);
    let previousSize = void 0;
    this.cleanup.register(
      moduleCtx.eventsHub.on("layout:complete", (e) => {
        const size = [e.chart.width, e.chart.height];
        if (previousSize != null && !arraysEqual(size, previousSize)) {
          this.animationState.transition("resize");
        }
        previousSize = size;
      }),
      this.title.caption.registerInteraction(this.moduleCtx, "afterend")
    );
  }
  static is(value) {
    return value instanceof _CartesianAxis;
  }
  get horizontal() {
    return this.position === "top" || this.position === "bottom";
  }
  onGridVisibilityChange() {
    this.gridLineGroupSelection.clear();
    this.gridFillGroupSelection.clear();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    }
  }
  get direction() {
    return this.position === "top" || this.position === "bottom" ? "x" /* X */ : "y" /* Y */;
  }
  createAxisContext() {
    return { ...super.createAxisContext(), position: this.position };
  }
  createLabel() {
    return new CartesianAxisLabel();
  }
  updateDirection() {
    switch (this.position) {
      case "top":
        this.label.mirrored = true;
        this.label.parallel = true;
        break;
      case "right":
        this.label.mirrored = true;
        this.label.parallel = false;
        break;
      case "bottom":
        this.label.mirrored = false;
        this.label.parallel = true;
        break;
      case "left":
        this.label.mirrored = false;
        this.label.parallel = false;
        break;
    }
    if (this.axisContext) {
      this.axisContext.position = this.position;
      this.axisContext.direction = this.direction;
    }
  }
  calculateLayout(primaryTickCount, chartLayout) {
    this.updateDirection();
    return super.calculateLayout(primaryTickCount, chartLayout);
  }
  layoutCrossLines() {
    const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
    this.crossLines.forEach((crossLine) => {
      crossLine.calculateLayout?.(crosslinesVisible);
    });
  }
  calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount) {
    const sideFlag = this.label.getSideFlag();
    const rotation = this.horizontal ? -0.5 * Math.PI : 0;
    const parallelFlipRotation = normalizeAngle360(rotation);
    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
    const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);
    if (niceMode === 2 /* Off */ && this.label.enabled === false && this.tick.enabled === false && this.gridLine.enabled === false) {
      const { bbox: bbox2, spacing: spacing2 } = this.tickBBox(domain, [], []);
      const layout2 = {
        ticks: [],
        tickLines: [],
        gridLines: [],
        gridFills: [],
        labels: [],
        spacing: spacing2
      };
      return {
        ticks: [],
        rawTickCount: 0,
        tickDomain: domain,
        niceDomain: domain,
        fractionDigits: 0,
        timeInterval: void 0,
        bbox: bbox2,
        layout: layout2
      };
    }
    const { range: range4, reverse, defaultTickMinSpacing } = this;
    const removeOverflowLabels = this.label.avoidCollisions && this.horizontal && (ContinuousScale.is(this.scale) || DiscreteTimeScale.is(this.scale));
    const tickGenerationResult = this.tickGenerator.generateTicks({
      domain,
      range: range4,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount: initialPrimaryTickCount,
      defaultTickMinSpacing,
      parallelFlipRotation,
      regularFlipRotation,
      labelX,
      sideFlag,
      sizeLimit: this.chartLayout?.sizeLimit,
      removeOverflowLabels,
      removeOverflowThreshold: this.chartLayout?.padding.right
    });
    const { tickData } = tickGenerationResult;
    const { ticks, tickDomain, rawTicks, rawTickCount, fractionDigits, timeInterval: timeInterval3, niceDomain } = tickData;
    const labels = ticks.map((d) => this.getTickLabelProps(d, tickGenerationResult));
    const { position, gridPadding, gridLength } = this;
    const direction = position === "bottom" || position === "right" ? -1 : 1;
    const p1 = direction * gridPadding;
    const p2 = direction * (gridLength + gridPadding);
    const gridLines = this.calculateGridLines(ticks, p1, p2);
    const gridFills = this.calculateGridFills(ticks, p1, p2);
    const tickLines = this.calculateTickLines(ticks, direction);
    const { bbox, spacing } = this.tickBBox(tickDomain, ticks, labels);
    const layout = { ticks, gridLines, gridFills, tickLines, labels, spacing };
    return { ticks: rawTicks, rawTickCount, tickDomain, niceDomain, fractionDigits, timeInterval: timeInterval3, bbox, layout };
  }
  calculateGridLines(ticks, p1, p2) {
    return ticks.map((tick, index) => this.calculateGridLine(tick, index, p1, p2, ticks));
  }
  calculateGridLine({ index: tickIndex, tickId, translation: offset }, _index, p1, p2, _ticks) {
    const { gridLine, horizontal } = this;
    const [x1, y1, x2, y2] = horizontal ? [offset, p1, offset, p2] : [p1, offset, p2, offset];
    const { style: style2 } = gridLine;
    const { stroke: stroke3, strokeWidth = 0, lineDash } = style2[tickIndex % style2.length] ?? {};
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
  }
  calculateGridFills(ticks, p1, p2) {
    const { horizontal, range: range4, type } = this;
    const gridFills = [];
    if (ticks.length == 0)
      return gridFills;
    let gridFillIndexOffset = 0;
    const isVerticalUnitTime = !horizontal && type === "unit-time";
    const firstFillOffCanvas = isVerticalUnitTime && ticks[0].translation < range4[0] || !isVerticalUnitTime && ticks[0].translation > range4[0];
    if (firstFillOffCanvas) {
      const injectedTick = { tickId: `before:${ticks[0].tickId}`, translation: range4[0] };
      gridFills.push(this.calculateGridFill(injectedTick, -1, ticks[0].index, p1, p2, ticks));
      gridFillIndexOffset = 1;
    }
    gridFills.push(
      ...ticks.map(
        (tick, index) => this.calculateGridFill(tick, index, tick.index + gridFillIndexOffset, p1, p2, ticks)
      )
    );
    return gridFills;
  }
  calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks) {
    const { gridLine, horizontal, range: range4 } = this;
    const nextTick = ticks[index + 1];
    const startOffset = translation;
    const endOffset = nextTick ? nextTick.translation : range4[1];
    const [x1, y1, x2, y2] = horizontal ? [startOffset, Math.max(p1, p2), endOffset, Math.min(p1, p2)] : [Math.min(p1, p2), Math.min(startOffset, endOffset), Math.max(p1, p2), Math.max(startOffset, endOffset)];
    const { fill, fillOpacity } = gridLine.style[gridFillIndex % gridLine.style.length] ?? {};
    return { tickId, x1, y1, x2, y2, fill, fillOpacity };
  }
  calculateTickLines(ticks, direction) {
    return ticks.map((tick) => this.calculateTickLine(tick, tick.index, direction, ticks));
  }
  calculateTickLine({ primary, tickId, translation: offset }, _index, direction, _ticks) {
    const { horizontal, tick, primaryTick } = this;
    const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
    const h = -direction * this.getTickSize(datumTick);
    const [x1, y1, x2, y2] = horizontal ? [offset, 0, offset, h] : [0, offset, h, offset];
    const { stroke: stroke3, width: strokeWidth } = datumTick;
    const lineDash = void 0;
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
  }
  update() {
    this.updateDirection();
    const previousTicksIds = Array.from(this.tickLabelGroupSelection.nodes(), (node) => node.datum.tickId);
    super.update();
    this.tickLineGroup.visible = this.tick.enabled || (this.primaryTick?.enabled ?? false);
    this.tickLabelGroup.visible = this.label.enabled || (this.primaryTick?.enabled ?? false);
    const { tickLayout } = this;
    this.updateTitle(this.scale.domain, tickLayout?.spacing ?? 0);
    if (!this.animatable) {
      this.moduleCtx.animationManager.skipCurrentBatch();
    }
    if (tickLayout) {
      const { ticks } = tickLayout;
      if (this.animationManager.isSkipped()) {
        this.resetSelectionNodes();
      } else {
        const tickIds = ticks.map((datum) => datum.tickId);
        const diff8 = diffArrays(previousTicksIds, tickIds);
        this.animationState.transition("update", diff8);
      }
    }
    const { enabled, stroke: stroke3, width: width2 } = this.line;
    this.lineNode.setProperties({ stroke: stroke3, strokeWidth: enabled ? width2 : 0 });
    this.updateTickLines();
    this.updateGridLines();
    this.updateGridFills();
  }
  getAxisTransform() {
    return {
      translationX: Math.floor(this.translation.x),
      translationY: Math.floor(this.translation.y)
    };
  }
  updatePosition() {
    super.updatePosition();
    const axisTransform = this.getAxisTransform();
    this.tickLineGroup.datum = axisTransform;
    this.tickLabelGroup.datum = axisTransform;
    this.lineNodeGroup.datum = axisTransform;
    this.headingLabelGroup.datum = axisTransform;
  }
  getAxisLineCoordinates() {
    const { horizontal } = this;
    const [c1, c2] = findMinMax(this.range);
    return horizontal ? { x1: c1, x2: c2, y1: 0, y2: 0 } : { x1: 0, x2: 0, y1: c1, y2: c2 };
  }
  getTickLineBBox(datum) {
    const { translation } = datum;
    const { position, primaryTick } = this;
    let tickSize = this.getTickSize();
    if (primaryTick?.enabled) {
      tickSize = Math.max(tickSize, this.getTickSize(primaryTick));
    }
    switch (position) {
      case "top":
        return new BBox(translation, -tickSize, translation, tickSize);
      case "bottom":
        return new BBox(translation, 0, translation, tickSize);
      case "left":
        return new BBox(-tickSize, translation, tickSize, translation);
      case "right":
        return new BBox(0, translation, tickSize, translation);
    }
  }
  lineNodeBBox() {
    const { position, seriesAreaPadding } = this;
    const { y1, y2 } = this.getAxisLineCoordinates();
    const dy2 = y2 - y1;
    switch (position) {
      case "top":
        return new BBox(y1, -seriesAreaPadding, dy2, seriesAreaPadding);
      case "bottom":
        return new BBox(y1, 0, dy2, seriesAreaPadding);
      case "left":
        return new BBox(-seriesAreaPadding, y1, seriesAreaPadding, dy2);
      case "right":
        return new BBox(0, y1, seriesAreaPadding, dy2);
    }
  }
  titleBBox(domain, spacing) {
    const { tempCaption } = this;
    tempCaption.node.setProperties(this.titleProps(tempCaption, domain, spacing));
    return tempCaption.node.getBBox();
  }
  tickBBox(domain, ticks, labels) {
    const { tick, primaryTick, label, primaryLabel, title, position, horizontal, seriesAreaPadding } = this;
    const boxes = [];
    boxes.push(this.lineNodeBBox());
    if (tick.enabled || primaryTick?.enabled) {
      for (const datum of ticks) {
        boxes.push(this.getTickLineBBox(datum));
      }
    }
    const { tempText: tempText2 } = this;
    if (label.enabled) {
      for (const datum of labels) {
        if (!datum.visible)
          continue;
        tempText2.setProperties(datum);
        const box = tempText2.getBBox(false);
        if (box) {
          boxes.push(box);
        }
      }
    }
    if (primaryLabel?.enabled && position === "bottom") {
      const inexactMeasurementPadding = 2;
      boxes.push(
        new BBox(
          0,
          TextUtils.getLineHeight(label.fontSize) + inexactMeasurementPadding,
          1,
          this.getTickSize(tick) + label.spacing + seriesAreaPadding
        )
      );
      if (primaryLabel.format != null) {
        const { format } = primaryLabel;
        const formats = isPlainObject(format) ? Object.values(format) : [format];
        const maxLines = formats.reduce((m, f) => Math.max(m, countLines(f)), 0);
        boxes.push(
          new BBox(
            0,
            this.getTickSize(primaryTick ?? tick) + primaryLabel.spacing + seriesAreaPadding,
            1,
            maxLines * TextUtils.getLineHeight(primaryLabel.fontSize) + inexactMeasurementPadding
          )
        );
      }
    }
    let spacing = 0;
    if (title.enabled) {
      const combined = BBox.merge(boxes);
      spacing = horizontal ? combined.height : combined.width;
      boxes.push(this.titleBBox(domain, spacing));
    }
    const bbox = BBox.merge(boxes);
    return { bbox, spacing };
  }
  titleProps(caption, domain, spacing) {
    const { title } = this;
    if (!title.enabled) {
      caption.enabled = false;
      return {
        visible: false,
        text: "",
        textBaseline: "bottom",
        x: 0,
        y: 0,
        rotationCenterX: 0,
        rotationCenterY: 0,
        rotation: 0
      };
    }
    caption.enabled = true;
    caption.color = title.color;
    caption.fontFamily = title.fontFamily;
    caption.fontSize = title.fontSize;
    caption.fontStyle = title.fontStyle;
    caption.fontWeight = title.fontWeight;
    caption.wrapping = title.wrapping;
    const padding2 = (title.spacing ?? 0) + spacing;
    const { range: range4 } = this;
    const midOffset = (range4[0] + range4[1]) / 2;
    let x;
    let y;
    let rotation;
    let textBaseline;
    switch (this.position) {
      case "top":
        x = midOffset;
        y = -padding2;
        rotation = 0;
        textBaseline = "bottom";
        break;
      case "bottom":
        x = midOffset;
        y = padding2;
        rotation = 0;
        textBaseline = "top";
        break;
      case "left":
        x = -padding2;
        y = midOffset;
        rotation = -0.5 * Math.PI;
        textBaseline = "bottom";
        break;
      case "right":
        x = padding2;
        y = midOffset;
        rotation = 0.5 * Math.PI;
        textBaseline = "bottom";
        break;
    }
    const { formatter: formatter2 = (p) => p.defaultValue } = title;
    const text2 = this.cachedCallWithContext(formatter2, this.getTitleFormatterParams(domain));
    caption.text = text2;
    return {
      visible: true,
      text: text2,
      textBaseline,
      x,
      y,
      rotationCenterX: x,
      rotationCenterY: y,
      rotation
    };
  }
  getLabelBorderOffset(label) {
    const padding2 = expandLabelPadding(label);
    function unreachable(a) {
      return a;
    }
    switch (this.position) {
      case "top":
        return padding2.bottom;
      case "right":
        return padding2.left;
      case "bottom":
        return padding2.top;
      case "left":
        return padding2.right;
      default:
        unreachable(this.position);
    }
  }
  getTickLabelProps(datum, tickGenerationResult) {
    const { horizontal, primaryLabel, primaryTick, seriesAreaPadding, scale: scale2 } = this;
    const { tickId, tickLabel: text2 = "", translation, primary, textUntruncated } = datum;
    const label = primary && primaryLabel?.enabled ? primaryLabel : this.label;
    const tick = primary && primaryTick?.enabled ? primaryTick : this.tick;
    const { rotation, textBaseline, textAlign } = tickGenerationResult;
    const { range: range4 } = scale2;
    const sideFlag = this.label.getSideFlag();
    const borderOffset = -this.getLabelBorderOffset(label);
    const labelOffset = sideFlag * (this.getTickSize(tick) + label.spacing + seriesAreaPadding) + borderOffset;
    const visible = text2 !== "";
    const x = horizontal ? translation : labelOffset;
    const y = horizontal ? -labelOffset : translation;
    return {
      ...this.getLabelStyles({ value: text2 }, void 0, label),
      tickId,
      rotation,
      text: text2,
      textAlign,
      textBaseline,
      textUntruncated,
      visible,
      x,
      y,
      rotationCenterX: x,
      rotationCenterY: y,
      range: range4
    };
  }
  updateSelections() {
    if (!this.tickLayout)
      return;
    const lineData = this.getAxisLineCoordinates();
    const { tickLines, gridLines, gridFills, labels } = this.tickLayout;
    const getDatumId = (datum) => datum.tickId;
    this.lineNode.datum = lineData;
    this.gridLineGroupSelection.update(this.gridLine.enabled ? gridLines : [], void 0, getDatumId);
    this.gridFillGroupSelection.update(this.gridLine.enabled ? gridFills : [], void 0, getDatumId);
    this.tickLineGroupSelection.update(tickLines, void 0, getDatumId);
    this.tickLabelGroupSelection.update(labels, void 0, getDatumId);
  }
  updateGridLines() {
    this.gridLineGroupSelection.each((line, datum) => {
      line.stroke = datum.stroke;
      line.strokeWidth = datum.strokeWidth;
      line.lineDash = datum.lineDash;
    });
  }
  updateGridFills() {
    this.gridFillGroupSelection.each((rect, datum) => {
      rect.fill = datum.fill;
      rect.fillOpacity = datum.fillOpacity ?? 1;
    });
  }
  updateTickLines() {
    this.tickLineGroupSelection.each((line, datum) => {
      line.stroke = datum.stroke;
      line.strokeWidth = datum.strokeWidth;
      line.lineDash = datum.lineDash;
    });
  }
  updateTitle(domain, spacing) {
    const { caption } = this.title;
    const titleProps = this.titleProps(caption, domain, spacing);
    caption.node.visible = titleProps.visible;
    caption.node.text = titleProps.text;
    caption.node.textBaseline = titleProps.textBaseline;
    caption.node.datum = titleProps;
  }
  updateLabels() {
    if (!this.label.enabled)
      return;
    this.tickLabelGroupSelection.each((node, datum) => {
      node.fill = datum.color;
      node.text = datum.text;
      node.textBaseline = datum.textBaseline;
      node.textAlign = datum.textAlign ?? "center";
      node.pointerEvents = datum.textUntruncated == null ? 1 /* None */ : 0 /* All */;
      node.setFont(datum);
      node.setBoxing(datum);
    });
  }
  animateReadyUpdate(diff8) {
    const { animationManager } = this.moduleCtx;
    const selectionCtx = prepareAxisAnimationContext(this);
    const fns = prepareAxisAnimationFunctions(selectionCtx);
    fromToMotion(
      this.id,
      "axis-group",
      animationManager,
      [this.lineNodeGroup, this.tickLabelGroup, this.tickLineGroup, this.headingLabelGroup],
      fns.group
    );
    fromToMotion(this.id, "line", animationManager, [this.lineNode], fns.line);
    fromToMotion(
      this.id,
      "line-paths",
      animationManager,
      [this.gridLineGroupSelection, this.tickLineGroupSelection],
      fns.tick,
      (_, d) => d.tickId,
      diff8
    );
    fromToMotion(
      this.id,
      "tick-labels",
      animationManager,
      [this.tickLabelGroupSelection],
      fns.label,
      (_, d) => d.tickId,
      diff8
    );
    fromToMotion(
      this.id,
      "title",
      animationManager,
      [this.title.caption.node],
      fns.label,
      (_, d) => d.tickId,
      diff8
    );
  }
  resetSelectionNodes() {
    resetMotion(
      [this.lineNodeGroup, this.tickLabelGroup, this.tickLineGroup, this.headingLabelGroup],
      resetAxisGroupFn()
    );
    resetMotion([this.gridLineGroupSelection, this.tickLineGroupSelection], resetAxisLineSelectionFn());
    resetMotion([this.gridFillGroupSelection], resetAxisFillSelectionFn());
    resetMotion([this.tickLabelGroupSelection], resetAxisLabelSelectionFn());
    resetMotion([this.title.caption.node], resetAxisLabelSelectionFn());
    resetMotion([this.lineNode], resetAxisLineSelectionFn());
  }
};
__decorateClass([
  Property
], _CartesianAxis.prototype, "thickness", 2);
__decorateClass([
  Property
], _CartesianAxis.prototype, "maxThicknessRatio", 2);
__decorateClass([
  Property
], _CartesianAxis.prototype, "position", 2);
var CartesianAxis = _CartesianAxis;

// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
var CartesianAxisPositions = ["top", "right", "bottom", "left"];
function isAxisPosition(position) {
  return typeof position === "string" && CartesianAxisPositions.includes(position);
}
function guessInvalidPositions(axes) {
  const invalidAxes = [];
  const usedPositions = [];
  const guesses = [...CartesianAxisPositions];
  for (const axis of axes) {
    if (axis instanceof CartesianAxis) {
      if (isAxisPosition(axis.position)) {
        usedPositions.push(axis.position);
      } else {
        invalidAxes.push(axis);
      }
    }
  }
  for (const axis of invalidAxes) {
    let nextGuess;
    do {
      nextGuess = guesses.pop();
    } while (nextGuess && usedPositions.includes(nextGuess));
    if (nextGuess == null)
      break;
    axis.position = nextGuess;
  }
}

// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
var MATCHING_KEYS = ["direction", "xKey", "yKey", "sizeKey", "angleKey", "radiusKey", "normalizedTo"];
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
  const generateKey = (type, i, opts) => {
    const result = [type];
    for (const key of MATCHING_KEYS) {
      if (key in i && i[key] != null)
        result.push(`${key}=${i[key]}`);
    }
    if (opts?.seriesGrouping) {
      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);
    }
    return result.join(";");
  };
  const seriesMap = /* @__PURE__ */ new Map();
  let idx = 0;
  for (const s of series) {
    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);
    if (!seriesMap.has(key)) {
      seriesMap.set(key, []);
    }
    seriesMap.get(key)?.push([s, idx++]);
  }
  const optsMap = /* @__PURE__ */ new Map();
  idx = 0;
  for (const o of optSeries) {
    const key = generateKey(o.type, o, o);
    if (!optsMap.has(key)) {
      optsMap.set(key, []);
    }
    optsMap.get(key)?.push([o, idx++]);
  }
  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));
  if (!overlap) {
    return { status: "no-overlap", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };
  }
  const changes = [];
  for (const [key, optsTuples] of optsMap.entries()) {
    for (const [opts, targetIdx] of optsTuples) {
      const seriesArray = seriesMap.get(key);
      if (seriesArray == null || seriesArray.length < 1) {
        changes.push({ opts, targetIdx, idx: targetIdx, status: "add" });
        seriesMap.delete(key);
        continue;
      }
      const [outputSeries, currentIdx] = seriesArray.shift();
      const previousOpts = oldOptsSeries?.[currentIdx] ?? {};
      const diff8 = jsonDiff(previousOpts, opts ?? {});
      const { groupIndex, stackIndex } = diff8?.seriesGrouping ?? {};
      if (groupIndex != null || stackIndex != null) {
        changes.push({
          opts,
          series: outputSeries,
          diff: diff8,
          targetIdx,
          idx: currentIdx,
          status: "series-grouping"
        });
      } else if (diff8) {
        changes.push({
          opts,
          series: outputSeries,
          diff: diff8,
          targetIdx,
          idx: currentIdx,
          status: "update"
        });
      } else {
        changes.push({ opts, series: outputSeries, targetIdx, idx: currentIdx, status: "no-op" });
      }
      if (seriesArray.length === 0) {
        seriesMap.delete(key);
      }
    }
  }
  for (const seriesArray of seriesMap.values()) {
    for (const [outputSeries, currentIdx] of seriesArray) {
      changes.push({ series: outputSeries, idx: currentIdx, targetIdx: -1, status: "remove" });
    }
  }
  return { status: "overlap", changes };
}

// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
  const { series } = input;
  return series?.[0]?.type ?? "line";
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes2.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes2.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgTopologyChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes2.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);
}
function isAgStandaloneChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes2.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);
}

// packages/ag-charts-community/src/chart/modulesManager.ts
var ModulesManager = class extends ModuleMap {
  applyOptions(options) {
    for (const m of this.moduleMap.values()) {
      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {
        m.moduleInstance.set(options[m.module.optionsKey]);
      }
    }
  }
  *legends() {
    for (const { module: module2, moduleInstance } of this.moduleMap.values()) {
      if (module2.type !== "legend")
        continue;
      yield {
        legendType: module2.identifier,
        legend: moduleInstance
      };
    }
  }
};

// packages/ag-charts-community/src/chart/overlay/overlay.ts
var DEFAULT_OVERLAY_CLASS = "ag-charts-overlay";
var DEFAULT_OVERLAY_DARK_CLASS = "ag-charts-dark-overlay";
var Overlay = class extends BaseProperties {
  constructor(className, defaultMessageId) {
    super();
    this.className = className;
    this.defaultMessageId = defaultMessageId;
    this.enabled = true;
  }
  getText(localeManager) {
    if (isArray(this.text)) {
      return this.text.map((s) => s.text).join("");
    }
    return localeManager.t(this.text ?? this.defaultMessageId);
  }
  getElement(callers, animationManager, localeManager, rect) {
    this.content?.remove();
    this.focusBox = rect;
    if (this.renderer) {
      const params = {};
      const htmlContent = callWithContext(callers, this.renderer, params);
      if (htmlContent instanceof HTMLElement) {
        this.content = htmlContent;
      } else {
        const tempDiv = createElement("div");
        tempDiv.innerHTML = htmlContent;
        const { firstElementChild } = tempDiv;
        if (firstElementChild instanceof HTMLElement && tempDiv.childElementCount === 1) {
          this.content = firstElementChild;
        } else {
          this.content = tempDiv;
        }
      }
    } else {
      const content = createElement("div", {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxSizing: "border-box",
        height: "100%",
        margin: "8px",
        fontFamily: "var(--ag-charts-font-family)",
        fontSize: "var(--ag-charts-font-size)",
        fontWeight: "var(--ag-charts-font-weight)"
      });
      if (isArray(this.text)) {
        const container = createElement("div");
        for (const segment of this.text) {
          const el = createElement("span", {
            color: segment.color,
            fontSize: `${segment.fontSize}px`,
            fontFamily: segment.fontFamily ?? "inherit",
            fontWeight: String(segment.fontWeight),
            fontStyle: segment.fontStyle
          });
          el.innerText = segment.text;
          container.appendChild(el);
        }
        content.appendChild(container);
      } else {
        content.innerText = this.getText(localeManager);
      }
      this.content = content;
      animationManager?.animate({
        from: 0,
        to: 1,
        id: "overlay",
        phase: "add",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          content.style.opacity = "1";
        }
      });
    }
    return this.content;
  }
  removeElement(cleanup = () => this.content?.remove(), animationManager) {
    if (!this.content)
      return;
    if (animationManager) {
      const { content } = this;
      animationManager.animate({
        from: 1,
        to: 0,
        phase: "remove",
        id: "overlay",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          cleanup?.();
        }
      });
    } else {
      cleanup?.();
    }
    this.content = void 0;
    this.focusBox = void 0;
  }
};
__decorateClass([
  Property
], Overlay.prototype, "enabled", 2);
__decorateClass([
  Property
], Overlay.prototype, "text", 2);
__decorateClass([
  Property
], Overlay.prototype, "renderer", 2);

// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var ChartOverlays = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.darkTheme = false;
    this.loading = new Overlay("ag-charts-loading-overlay", "overlayLoadingData");
    this.noData = new Overlay("ag-charts-no-data-overlay", "overlayNoData");
    this.noVisibleSeries = new Overlay("ag-charts-no-visible-series", "overlayNoVisibleSeries");
    this.unsupportedBrowser = new Overlay("ag-charts-unsupported-browser", "overlayUnsupportedBrowser");
  }
  getFocusInfo(localeManager) {
    for (const overlay of [this.loading, this.noData, this.noVisibleSeries, this.unsupportedBrowser]) {
      if (overlay.focusBox !== void 0) {
        return { text: overlay.getText(localeManager), rect: overlay.focusBox };
      }
    }
    return void 0;
  }
  destroy() {
    this.loading.removeElement();
    this.noData.removeElement();
    this.noVisibleSeries.removeElement();
    this.unsupportedBrowser.removeElement();
  }
};
__decorateClass([
  Property
], ChartOverlays.prototype, "darkTheme", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "loading", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "noData", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "noVisibleSeries", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "unsupportedBrowser", 2);

// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts
function getLoadingSpinner(text2, defaultDuration) {
  const { animationDuration } = PHASE_METADATA["add"];
  const duration = animationDuration * defaultDuration;
  const container = createElement("div", `${DEFAULT_OVERLAY_CLASS}--loading`, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    height: "100%",
    boxSizing: "border-box",
    font: "13px Verdana, sans-serif",
    // FONT_SIZE.MEDIUM
    userSelect: "none",
    animation: `ag-charts-loading ${duration}ms linear 50ms both`
  });
  const matrix = createElement("span", {
    width: "45px",
    height: "40px",
    backgroundImage: [
      "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
    ].join(""),
    backgroundSize: "10px 400%",
    backgroundRepeat: "no-repeat",
    animation: "ag-charts-loading-matrix 1s infinite linear"
  });
  const label = createElement("p", { marginTop: "1em" });
  label.innerText = text2;
  const background = createElement("div", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {
    position: "absolute",
    inset: "0",
    opacity: "0.5",
    zIndex: "-1"
  });
  const animationStyles = createElement("style");
  animationStyles.innerText = [
    "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
    "@keyframes ag-charts-loading-matrix {",
    "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
    "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
    "}"
  ].join(" ");
  container.replaceChildren(animationStyles, matrix, label, background);
  return container;
}

// packages/ag-charts-community/src/chart/series/seriesProperties.ts
var HighlightState = /* @__PURE__ */ ((HighlightState2) => {
  HighlightState2[HighlightState2["None"] = 0] = "None";
  HighlightState2[HighlightState2["Item"] = 1] = "Item";
  HighlightState2[HighlightState2["Series"] = 2] = "Series";
  HighlightState2[HighlightState2["OtherSeries"] = 3] = "OtherSeries";
  HighlightState2[HighlightState2["OtherItem"] = 4] = "OtherItem";
  return HighlightState2;
})(HighlightState || {});
var SeriesItemHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "lineDash", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
var HighlightProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.range = "tooltip";
    this.bringToFront = false;
    this.highlightedItem = {};
    this.unhighlightedItem = {};
    this.highlightedSeries = {};
    this.unhighlightedSeries = {};
  }
  getItemHighlightStyle(highlightState) {
    switch (highlightState) {
      case 1 /* Item */:
        return this.highlightedItem;
      case 4 /* OtherItem */:
        return this.unhighlightedItem;
      case 2 /* Series */:
        return this.highlightedSeries;
      case 3 /* OtherSeries */:
        return this.unhighlightedSeries;
    }
  }
  getSeriesHighlightStyle(highlightState) {
    switch (highlightState) {
      case 1 /* Item */:
      case 4 /* OtherItem */:
      case 2 /* Series */:
        return this.highlightedSeries;
      case 3 /* OtherSeries */:
        return this.unhighlightedSeries;
    }
  }
  getStyle(highlightState) {
    return mergeDefaults(
      this.getItemHighlightStyle(highlightState),
      this.getSeriesHighlightStyle(highlightState)
    );
  }
};
__decorateClass([
  Property
], HighlightProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "range", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "bringToFront", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "highlightedItem", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "unhighlightedItem", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "highlightedSeries", 2);
__decorateClass([
  Property
], HighlightProperties.prototype, "unhighlightedSeries", 2);
var SeriesHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "dimOpacity", 2);
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "enabled", 2);
var TextHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Property
], TextHighlightStyle.prototype, "color", 2);
var FillGradientDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "gradient";
    this.colorStops = [];
    this.bounds = "item";
    this.gradient = "linear";
    this.rotation = 0;
    this.reverse = false;
  }
};
__decorateClass([
  Property
], FillGradientDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "colorStops", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "bounds", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "gradient", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "reverse", 2);
var FillPatternDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "pattern";
    this.colorStops = [];
    this.bounds = "item";
    this.gradient = "linear";
    this.rotation = 0;
    this.scale = 1;
    this.reverse = false;
    this.pattern = "forward-slanted-lines";
    this.width = 26;
    this.height = 26;
    this.padding = 6;
    this.fill = "black";
    this.fillOpacity = 1;
    this.backgroundFill = "white";
    this.backgroundFillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
  }
};
__decorateClass([
  Property
], FillPatternDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "colorStops", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "bounds", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "gradient", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "scale", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "reverse", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "path", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "pattern", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "width", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "height", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "padding", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "fill", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "backgroundFill", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "stroke", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "strokeWidth", 2);
var FillImageDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "image";
    this.url = "";
    this.rotation = 0;
    this.scale = 1;
    this.backgroundFill = "black";
    this.backgroundFillOpacity = 1;
    this.repeat = "no-repeat";
    this.fit = "contain";
  }
};
__decorateClass([
  Property
], FillImageDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "url", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "scale", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "backgroundFill", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "repeat", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "fit", 2);
var HighlightStyle = class extends BaseProperties {
  constructor(deprecated = true) {
    super();
    this.deprecated = deprecated;
    this.item = new SeriesItemHighlightStyle();
    this.series = new SeriesHighlightStyle();
    this.text = new TextHighlightStyle();
  }
  set(properties) {
    if (this.deprecated) {
      logger_exports.warnOnce("highlightStyle is deprecated, use highlight instead.");
    }
    return super.set(properties);
  }
};
__decorateClass([
  Property
], HighlightStyle.prototype, "item", 2);
__decorateClass([
  Property
], HighlightStyle.prototype, "series", 2);
__decorateClass([
  Property
], HighlightStyle.prototype, "text", 2);
var SeriesProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.focusPriority = Infinity;
    this.showInLegend = true;
    this.cursor = "default";
    this.nodeClickRange = "exact";
    this.highlight = new HighlightProperties();
    this.highlightStyle = new HighlightStyle();
  }
  handleUnknownProperties(unknownKeys, properties) {
    if ("context" in properties) {
      this.context = properties.context;
      unknownKeys.delete("context");
    }
  }
};
__decorateClass([
  Property
], SeriesProperties.prototype, "id", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "visible", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "focusPriority", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "showInLegend", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "cursor", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "nodeClickRange", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "highlight", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "highlightStyle", 2);

// packages/ag-charts-community/src/chart/series/seriesZIndexMap.ts
var SeriesZIndexMap = /* @__PURE__ */ ((SeriesZIndexMap3) => {
  SeriesZIndexMap3[SeriesZIndexMap3["BACKGROUND"] = 0] = "BACKGROUND";
  SeriesZIndexMap3[SeriesZIndexMap3["ANY_CONTENT"] = 1] = "ANY_CONTENT";
  return SeriesZIndexMap3;
})(SeriesZIndexMap || {});
var SeriesContentZIndexMap = /* @__PURE__ */ ((SeriesContentZIndexMap2) => {
  SeriesContentZIndexMap2[SeriesContentZIndexMap2["FOREGROUND"] = 0] = "FOREGROUND";
  SeriesContentZIndexMap2[SeriesContentZIndexMap2["HIGHLIGHT"] = 1] = "HIGHLIGHT";
  SeriesContentZIndexMap2[SeriesContentZIndexMap2["LABEL"] = 2] = "LABEL";
  return SeriesContentZIndexMap2;
})(SeriesContentZIndexMap || {});

// packages/ag-charts-community/src/chart/series/shapeUtil.ts
function getShapeFill(fill, defaultGradient, defaultPattern, defaultImage) {
  if (isGradientFill(fill)) {
    return {
      type: "gradient",
      gradient: fill.gradient ?? defaultGradient.gradient,
      colorStops: fill.colorStops ?? defaultGradient.colorStops,
      bounds: fill.bounds ?? defaultGradient.bounds,
      rotation: fill.rotation ?? defaultGradient.rotation,
      reverse: fill.reverse ?? defaultGradient.reverse
    };
  }
  if (isPatternFill(fill)) {
    const pattern = fill.pattern ?? defaultPattern.pattern;
    let strokeWidth = fill.strokeWidth;
    if (pattern === "backward-slanted-lines" || pattern === "forward-slanted-lines" || pattern === "horizontal-lines" || pattern === "vertical-lines") {
      strokeWidth ?? (strokeWidth = defaultPattern.strokeWidth);
    } else {
      strokeWidth ?? (strokeWidth = 0);
    }
    const width2 = fill.width ?? fill.height ?? defaultPattern.width;
    const height2 = fill.height ?? fill.width ?? defaultPattern.height;
    return {
      type: "pattern",
      pattern,
      width: width2,
      height: height2,
      path: fill.path,
      padding: fill.padding ?? defaultPattern.padding,
      fill: fill.fill ?? defaultPattern.fill,
      fillOpacity: fill.fillOpacity ?? defaultPattern.fillOpacity,
      backgroundFill: fill.backgroundFill ?? defaultPattern.backgroundFill,
      backgroundFillOpacity: fill.backgroundFillOpacity ?? defaultPattern.backgroundFillOpacity,
      stroke: fill.stroke ?? defaultPattern.stroke,
      strokeOpacity: fill.strokeOpacity ?? defaultPattern.strokeOpacity,
      strokeWidth,
      rotation: fill.rotation ?? defaultPattern.rotation,
      scale: fill.scale ?? defaultPattern.scale
    };
  }
  if (isImageFill(fill)) {
    return {
      type: "image",
      url: fill.url,
      width: fill.width,
      height: fill.height,
      backgroundFill: fill.backgroundFill ?? defaultImage.backgroundFill,
      backgroundFillOpacity: fill.backgroundFillOpacity ?? defaultImage.backgroundFillOpacity,
      rotation: fill.rotation ?? defaultImage.rotation,
      repeat: fill.repeat ?? defaultImage.repeat,
      fit: fill.fit ?? defaultImage.fit
    };
  }
  return fill;
}
function getShapeStyle(style2, defaultGradient, defaultPattern, defaultImage) {
  if (!isGradientFill(style2?.fill) && !isPatternFill(style2?.fill) && !isImageFill(style2?.fill))
    return style2;
  return {
    ...style2,
    fill: getShapeFill(style2.fill, defaultGradient, defaultPattern, defaultImage)
  };
}
function applyShapeFillBBox(shape, fill, fillBBox, fillParams) {
  if (fillBBox == null || !isGradientFill(fill) || fill.bounds == null || fill.bounds === "item") {
    shape.fillBBox = void 0;
  } else {
    shape.fillBBox = fillBBox[fill.bounds];
  }
  shape.fillParams = fillParams;
}
function applyShapeStyle(shape, style2, fillBBox, fillParams) {
  const opacity = style2?.opacity ?? 1;
  shape.fill = style2?.fill;
  applyShapeFillBBox(shape, shape.fill, fillBBox, fillParams);
  shape.fillOpacity = (style2?.fillOpacity ?? 1) * opacity;
  shape.stroke = style2?.stroke;
  shape.strokeOpacity = (style2?.strokeOpacity ?? 1) * opacity;
  shape.strokeWidth = style2?.strokeWidth ?? 0;
  shape.lineDash = style2?.lineDash;
  shape.lineDashOffset = style2?.lineDashOffset ?? 0;
}

// packages/ag-charts-community/src/chart/series/series.ts
var SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode17) => {
  SeriesNodePickMode17[SeriesNodePickMode17["EXACT_SHAPE_MATCH"] = 0] = "EXACT_SHAPE_MATCH";
  SeriesNodePickMode17[SeriesNodePickMode17["NEAREST_NODE"] = 1] = "NEAREST_NODE";
  SeriesNodePickMode17[SeriesNodePickMode17["AXIS_ALIGNED"] = 2] = "AXIS_ALIGNED";
  return SeriesNodePickMode17;
})(SeriesNodePickMode || {});
var CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;
var CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;
var SeriesNodeEvent = class {
  constructor(type, event, nodeDatum, series) {
    this.type = type;
    this.event = event;
    this.defaultPrevented = false;
    this.datum = nodeDatum.datum;
    this.seriesId = series.id;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
};
var SeriesGroupingChangedEvent = class {
  constructor(series, seriesGrouping) {
    this.series = series;
    this.seriesGrouping = seriesGrouping;
    this.type = "groupingChanged";
  }
};
function propertyAxisDirection(property) {
  switch (property) {
    case "x":
      return "x" /* X */;
    case "y":
      return "y" /* Y */;
    case "angle":
      return "angle" /* Angle */;
    case "radius":
      return "radius" /* Radius */;
  }
}
function axisDirectionProperty(direction) {
  switch (direction) {
    case "x" /* X */:
      return "x";
    case "y" /* Y */:
      return "y";
    case "angle" /* Angle */:
      return "angle";
    case "radius" /* Radius */:
      return "radius";
  }
}
var Series = class extends Observable {
  constructor(seriesOpts) {
    super();
    this.cleanup = new CleanupRegistry();
    this.usesPlacedLabels = false;
    this.hasChangesOnHighlight = false;
    this.seriesGrouping = void 0;
    this.NodeEvent = SeriesNodeEvent;
    this.internalId = createId(this);
    // The group node that contains the series rendering in its default (non-highlighted) state.
    this.contentGroup = new TranslatableGroup({
      name: `${this.internalId}-content`,
      zIndex: 1 /* ANY_CONTENT */
    });
    // The group node that contains all highlighted series items. This is a performance optimisation
    // for large-scale data-sets, where the only thing that routinely varies is the currently
    // highlighted node.
    this.highlightGroup = new TranslatableGroup({
      name: `${this.internalId}-highlight`,
      zIndex: 1 /* ANY_CONTENT */
    });
    // Error bars etc.
    this.annotationGroup = new TranslatableGroup({
      name: `${this.internalId}-annotation`
    });
    // Lazily initialised labelGroup for label presentation.
    this.labelGroup = new TranslatableGroup({
      name: `${this.internalId}-series-labels`
    });
    this.axes = {};
    this.directions = ["x" /* X */, "y" /* Y */];
    // Flag to determine if we should recalculate node data.
    this.nodeDataRefresh = true;
    this.moduleMap = new ModuleMap();
    this.datumCallbackCache = /* @__PURE__ */ new Map();
    this.connectsToYAxis = false;
    this.declarationOrder = -1;
    this._broughtToFront = false;
    this.events = new EventEmitter();
    this._pickNodeCache = new LRUCache();
    // Use a wrapper to comply with the @typescript-eslint/unbound-method rule.
    this.fireEventWrapper = (event) => super.fireEvent(event);
    const {
      moduleCtx,
      pickModes,
      propertyKeys = {},
      propertyNames = {},
      canHaveAxes = false,
      usesPlacedLabels = false
    } = seriesOpts;
    this.ctx = moduleCtx;
    this.propertyKeys = propertyKeys;
    this.propertyNames = propertyNames;
    this.canHaveAxes = canHaveAxes;
    this.usesPlacedLabels = usesPlacedLabels;
    this.pickModes = pickModes;
    this.cleanup.register(this.ctx?.eventsHub.on("highlight:change", (event) => this.onChangeHighlight(event)));
  }
  get pickModeAxis() {
    return "main";
  }
  get id() {
    return this.properties?.id ?? this.internalId;
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get focusable() {
    return true;
  }
  get data() {
    return this._data ?? this._chartData;
  }
  set visible(newVisibility) {
    this.properties.visible = newVisibility;
    this.ctx.legendManager.toggleItem(newVisibility, this.id);
    this.ctx.legendManager.update();
    this.visibleMaybeChanged();
  }
  get visible() {
    return this.ctx.legendManager.getSeriesEnabled(this.id) ?? this.properties.visible;
  }
  get hasData() {
    return this.data != null && this.data.length > 0;
  }
  get tooltipEnabled() {
    return this.properties.tooltip?.enabled;
  }
  onDataChange() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
  }
  setOptionsData(input) {
    this._data = input;
    this.onDataChange();
  }
  setChartData(input) {
    this._chartData = input;
    if (this.data === input) {
      this.onDataChange();
    }
  }
  onSeriesGroupingChange(prev, next) {
    const { internalId, type, visible } = this;
    if (prev) {
      this.ctx.seriesStateManager.deregisterSeries(this);
    }
    if (next) {
      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });
    }
    this.fireEvent(new SeriesGroupingChangedEvent(this, next));
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0 };
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    seriesContentNode.appendChild(this.contentGroup);
    seriesNode.appendChild(this.highlightGroup);
    seriesNode.appendChild(this.labelGroup);
    annotationNode?.appendChild(this.annotationGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    seriesContentNode?.removeChild(this.contentGroup);
    seriesNode.removeChild(this.highlightGroup);
    seriesNode.removeChild(this.labelGroup);
    annotationNode?.removeChild(this.annotationGroup);
  }
  setSeriesIndex(index, forceUpdate = false) {
    const bringToFront = this.bringToFront();
    if (!forceUpdate && index === this.declarationOrder && bringToFront === this._broughtToFront)
      return false;
    this.declarationOrder = index;
    this._broughtToFront = bringToFront;
    this.setZIndex(bringToFront ? Number.MAX_VALUE : index);
    this.fireEvent(new SeriesGroupingChangedEvent(this, this.seriesGrouping));
    return true;
  }
  setZIndex(zIndex) {
    this.contentGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */];
    this.highlightGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 1 /* HIGHLIGHT */];
    this.labelGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 2 /* LABEL */];
    this.annotationGroup.zIndex = zIndex;
  }
  renderToOffscreenCanvas() {
    return false;
  }
  addEventListener(type, listener) {
    return super.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    return super.removeEventListener(type, listener);
  }
  hasEventListener(type) {
    return super.hasEventListener(type);
  }
  addChartEventListeners() {
    return;
  }
  updatedDomains() {
  }
  destroy() {
    this.cleanup.flush();
    this.resetDatumCallbackCache();
    this.ctx.seriesStateManager.deregisterSeries(this);
  }
  getPropertyValues(property, properties) {
    const direction = propertyAxisDirection(property);
    const resolvedProperty = direction != null ? axisDirectionProperty(this.resolveKeyDirection(direction)) : property;
    const keys = properties?.[resolvedProperty];
    const values = [];
    if (!keys) {
      return values;
    }
    const addValues = (...items) => {
      for (const value of items) {
        if (Array.isArray(value)) {
          addValues(...value);
        } else if (typeof value === "object") {
          addValues(...Object.values(value));
        } else {
          values.push(value);
        }
      }
    };
    addValues(...keys.map((key) => this.properties[key]));
    return values;
  }
  getKeys(direction) {
    return this.getPropertyValues(axisDirectionProperty(direction), this.propertyKeys);
  }
  getKeyProperties(direction) {
    return this.propertyKeys[this.resolveKeyDirection(direction)] ?? [];
  }
  getNames(direction) {
    return this.getPropertyValues(axisDirectionProperty(direction), this.propertyNames);
  }
  getFormatterContext(property) {
    const { id: seriesId } = this;
    const keys = this.getPropertyValues(property, this.propertyKeys);
    const names = this.getPropertyValues(property, this.propertyNames);
    const out = [];
    for (let idx = 0; idx < keys.length; idx++) {
      out.push({ seriesId, key: keys[idx], name: names[idx] });
    }
    return out;
  }
  resolveKeyDirection(direction) {
    return direction;
  }
  // The union of the series domain ('community') and series-option domains ('enterprise').
  getDomain(direction) {
    const seriesDomain = this.getSeriesDomain(direction);
    const moduleDomains = this.moduleMap.mapModules((module2) => module2.getDomain(direction)).flat();
    return moduleDomains.length !== 0 ? seriesDomain.concat(moduleDomains) : seriesDomain;
  }
  getRange(direction, visibleRange) {
    return this.getSeriesRange(direction, visibleRange);
  }
  getVisibleItems(_xVisibleRange, _yVisibleRange, _minVisibleItems) {
    return Infinity;
  }
  // Indicate that something external changed and we should recalculate nodeData.
  markNodeDataDirty() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    this.visibleMaybeChanged();
  }
  visibleMaybeChanged() {
    this.ctx.seriesStateManager.updateSeries(this);
  }
  getOpacity() {
    const defaultOpacity = 1;
    if (!this.properties.highlight) {
      return defaultOpacity;
    }
    const { opacity = defaultOpacity } = this.getHighlightStyle();
    return opacity;
  }
  getHighlightState(datum, isHighlight, datumIndex, legendItemValues) {
    if (isHighlight) {
      return 1 /* Item */;
    }
    if (datum?.series == null) {
      return 0 /* None */;
    }
    if (this.isSeriesHighlighted(datum, legendItemValues)) {
      const itemHighlighted = this.isItemHighlighted(datum, datumIndex);
      if (itemHighlighted == null) {
        return 2 /* Series */;
      }
      if (itemHighlighted) {
        return 2 /* Series */;
      }
      return 4 /* OtherItem */;
    }
    return 3 /* OtherSeries */;
  }
  getHighlightStateString(datum, isHighlight, datumIndex, legendItemValues) {
    const state = this.getHighlightState(datum, isHighlight, datumIndex, legendItemValues);
    switch (state) {
      case 1 /* Item */:
        return "highlighted-item";
      case 4 /* OtherItem */:
        return "unhighlighted-item";
      case 2 /* Series */:
        return "highlighted-series";
      case 3 /* OtherSeries */:
        return "unhighlighted-series";
      case 0 /* None */:
      default:
        return "none";
    }
  }
  onChangeHighlight(event) {
    const previousHighlightedDatum = event.previousHighlight;
    const currentHighlightedDatum = event.currentHighlight;
    const currentHighlightState = this.getHighlightState(currentHighlightedDatum);
    const previousHighlightState = this.getHighlightState(previousHighlightedDatum);
    this.setSeriesIndex(this.declarationOrder);
    if (currentHighlightState === previousHighlightState) {
      this.hasChangesOnHighlight = false;
      return;
    }
    const { highlightedSeries, unhighlightedItem, unhighlightedSeries } = this.properties.highlight;
    const hasItemStylers = this.hasItemStylers();
    this.hasChangesOnHighlight = hasItemStylers || !isEmptyObject(highlightedSeries) || !isEmptyObject(unhighlightedItem) || !isEmptyObject(unhighlightedSeries);
  }
  bringToFront() {
    return this.properties.highlight.bringToFront && this.isSeriesHighlighted(this.ctx.highlightManager.getActiveHighlight());
  }
  isSeriesHighlighted(highlightedDatum, _legendItemValues) {
    return highlightedDatum?.series === this;
  }
  isItemHighlighted(highlightedDatum, datumIndex) {
    if (highlightedDatum?.datumIndex == null || datumIndex == null)
      return;
    return highlightedDatum.datumIndex === datumIndex;
  }
  getHighlightStyle(isHighlight, datumIndex, legendItemValues) {
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const highlightState = this.getHighlightState(highlightedDatum, isHighlight, datumIndex, legendItemValues);
    return this.properties.highlight.getStyle(highlightState);
  }
  getModuleTooltipParams() {
    return this.moduleMap.mapModules((module2) => module2.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});
  }
  pickNodes(point, intent, exactMatchOnly = false) {
    const { pickModes, pickModeAxis, visible, contentGroup } = this;
    if (!visible || !contentGroup.visible)
      return;
    if (intent === "highlight" && !this.properties.highlight.enabled)
      return;
    if (intent === "highlight-tooltip" && !this.properties.highlight.enabled)
      return;
    let maxDistance = Infinity;
    if (intent === "tooltip" || intent === "highlight-tooltip") {
      const { tooltip } = this.properties;
      maxDistance = typeof tooltip.range === "number" ? tooltip.range : Infinity;
      exactMatchOnly || (exactMatchOnly = tooltip.range === "exact");
    } else if (intent === "event" || intent === "context-menu") {
      const { nodeClickRange } = this.properties;
      maxDistance = typeof nodeClickRange === "number" ? nodeClickRange : Infinity;
      exactMatchOnly || (exactMatchOnly = nodeClickRange === "exact");
    }
    const selectedPickModes = pickModes.filter(
      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */
    );
    const { x, y } = point;
    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });
    if (this._pickNodeCache.has(key)) {
      return this._pickNodeCache.get(key);
    }
    for (const pickMode of selectedPickModes) {
      let result;
      switch (pickMode) {
        case 0 /* EXACT_SHAPE_MATCH */: {
          const exact = this.pickNodesExactShape(point);
          result = exact.length === 0 ? void 0 : { datums: exact, distance: 0 };
          break;
        }
        case 1 /* NEAREST_NODE */: {
          const closest = this.pickNodeClosestDatum(point);
          const exact = closest?.distance === 0 ? this.pickNodesExactShape(point) : void 0;
          if (exact != null && exact.length !== 0) {
            result = { datums: exact, distance: 0 };
          } else if (closest) {
            result = { datums: [closest.datum], distance: closest.distance };
          } else {
            result = void 0;
          }
          break;
        }
        case 2 /* AXIS_ALIGNED */: {
          const closest = pickModeAxis != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === "main-category") : void 0;
          result = closest != null ? { datums: [closest.datum], distance: closest.distance } : void 0;
          break;
        }
      }
      if (result && result.distance <= maxDistance) {
        return this._pickNodeCache.set(key, { pickMode, datums: result.datums, distance: result.distance });
      }
    }
    return this._pickNodeCache.set(key, void 0);
  }
  pickNodesExactShape(point) {
    const datums = [];
    for (const node of this.contentGroup.pickNodes(point.x, point.y)) {
      const datum = node.closestDatum();
      if (datum != null && datum.missing !== true) {
        datums.push(datum);
      }
    }
    return datums;
  }
  pickNodeClosestDatum(_point) {
    throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
  }
  pickNodeNearestDistantObject(point, items) {
    const match = nearestSquared(point.x, point.y, items);
    const datum = match.nearest?.closestDatum();
    if (datum != null && datum.missing !== true) {
      return { datum, distance: Math.sqrt(match.distanceSquared) };
    }
  }
  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
    throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
  }
  getLabelData() {
    return [];
  }
  updatePlacedLabelData(_labels) {
    return;
  }
  fireEvent(event) {
    callWithContext([this.properties, this.ctx.chartService], this.fireEventWrapper, event);
  }
  fireNodeClickEvent(event, datum) {
    const clickEvent = new this.NodeEvent("seriesNodeClick", event, datum, this);
    this.fireEvent(clickEvent);
    return !clickEvent.defaultPrevented;
  }
  fireNodeDoubleClickEvent(event, datum) {
    const clickEvent = new this.NodeEvent("seriesNodeDoubleClick", event, datum, this);
    this.fireEvent(clickEvent);
    return !clickEvent.defaultPrevented;
  }
  createNodeContextMenuActionEvent(event, datum) {
    return new this.NodeEvent("nodeContextMenuAction", event, datum, this);
  }
  onLegendInitialState(legendType, initialState) {
    const { visible = true, itemId, legendItemName } = initialState ?? {};
    this.toggleSeriesItem(visible, legendType, itemId, legendItemName);
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendType } = event;
    const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
    const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
      this.toggleSeriesItem(enabled, legendType, itemId, legendItemName, event);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems, legendType } = event;
    const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
    const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
      this.toggleSeriesItem(true, legendType, itemId, legendItemName, event);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(true, legendType, void 0, legendItemName);
    } else {
      this.toggleSeriesItem(false, legendType, void 0, legendItemName);
    }
  }
  toggleSeriesItem(enabled, legendType, itemId, legendItemName, legendEvent) {
    const seriesId = this.id;
    if (enabled || legendType !== "category") {
      this.visible = enabled;
    }
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    const event = {
      type: "seriesVisibilityChange",
      seriesId,
      itemId,
      legendItemName: legendEvent?.legendItemName ?? legendItemName,
      visible: enabled
    };
    this.fireEvent(event);
    this.ctx.legendManager.toggleItem(enabled, seriesId, itemId, legendItemName);
  }
  isEnabled() {
    return this.visible;
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    return { ...this.ctx, series: this };
  }
  getAxisValueText(axis, source, value, datum, key, legendItemName) {
    const { id: seriesId, properties } = this;
    return axis.formatDatum(properties, value, source, seriesId, legendItemName, datum, key);
  }
  getLabelText(value, datum, key, property, domain, label, baseParams) {
    if (value == null)
      return "";
    const { axes, canHaveAxes, ctx, id: seriesId, properties } = this;
    const source = "series-label";
    const legendItemName = "legendItemName" in properties ? properties.legendItemName : void 0;
    const params = {
      seriesId: this.id,
      ...baseParams
    };
    const direction = canHaveAxes ? propertyAxisDirection(property) : void 0;
    const axis = direction != null ? axes[this.resolveKeyDirection(direction)] : void 0;
    if (axis != null) {
      return axis.formatDatum(
        properties,
        value,
        source,
        seriesId,
        legendItemName,
        datum,
        key,
        domain,
        label,
        params
      );
    }
    const { formatManager } = ctx;
    const formatInContext = this.callWithContext.bind(this);
    const format = (formatParams) => label.formatValue(formatInContext, formatParams.type, formatParams.value, params) ?? formatManager.format(formatInContext, formatParams) ?? String(value);
    const boundSeries = this.getFormatterContext(property);
    switch (property) {
      case "y":
      case "color":
      case "size": {
        const fractionDigits = void 0;
        return format({
          type: "number",
          value,
          datum,
          seriesId,
          legendItemName,
          key,
          source,
          property,
          domain,
          boundSeries,
          fractionDigits
        });
      }
      case "x":
      case "radius":
      case "angle":
      case "label":
      case "secondaryLabel":
      case "calloutLabel":
      case "sectorLabel":
      case "legendItem":
        return format({
          type: "category",
          value,
          datum,
          seriesId,
          legendItemName,
          key,
          source,
          property,
          domain,
          boundSeries
        });
    }
  }
  getMarkerStyle(marker, { datumIndex, datum, point }, params, isHighlight = false, defaultOverrideStyle = { size: point?.size ?? marker.size ?? 0 }, inheritedStyle, checkForHighlight = true) {
    const { itemStyler, fillGradientDefaults: fillGradientDefaults4, fillPatternDefaults: fillPatternDefaults4, fillImageDefaults: fillImageDefaults4 } = marker;
    const highlightStyle = checkForHighlight ? this.getHighlightStyle(isHighlight, datumIndex) : void 0;
    const baseStyle = mergeDefaults(highlightStyle, defaultOverrideStyle, marker.getStyle(), inheritedStyle);
    let markerStyle = getShapeStyle(baseStyle, fillGradientDefaults4, fillPatternDefaults4, fillImageDefaults4);
    if (itemStyler && params) {
      const highlight5 = this.ctx.highlightManager?.getActiveHighlight();
      const highlightState = this.getHighlightStateString(highlight5, isHighlight, datumIndex);
      const style2 = this.cachedCallWithContext(itemStyler, {
        seriesId: this.id,
        ...markerStyle,
        ...params,
        highlighted: isHighlight,
        highlightState,
        datum
      });
      markerStyle = getShapeStyle(
        mergeDefaults(style2, markerStyle),
        fillGradientDefaults4,
        fillPatternDefaults4,
        fillImageDefaults4
      );
    }
    return markerStyle;
  }
  applyMarkerStyle(style2, markerNode, point, fillBBox, { applyTranslation = true, selected = true } = {}) {
    const { shape, size = 0 } = style2;
    const visible = this.visible && size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
    applyShapeStyle(markerNode, style2, fillBBox);
    if (applyTranslation) {
      markerNode.setProperties({
        visible,
        shape,
        size,
        x: point?.x,
        y: point?.y,
        scalingCenterX: point?.x,
        scalingCenterY: point?.y
      });
    } else {
      markerNode.setProperties({ visible, shape, size });
    }
    if (!selected) {
      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;
      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;
    }
    if (typeof shape === "function" && !markerNode.dirtyPath) {
      markerNode.path.clear(true);
      markerNode.updatePath();
      markerNode.checkPathDirty();
      const bb = markerNode.getBBox();
      if (point != null && bb.isFinite()) {
        const center2 = bb.computeCenter();
        const [dx2, dy2] = ["x", "y"].map(
          (key) => (style2.strokeWidth ?? 0) + Math.abs(center2[key] - point[key])
        );
        point.focusSize = Math.max(bb.width + dx2, bb.height + dy2);
      }
    }
  }
  get nodeDataDependencies() {
    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };
  }
  checkResize(newSeriesRect) {
    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };
    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
      this.markNodeDataDirty();
    }
    return resize;
  }
  pickFocus(_opts) {
    return void 0;
  }
  resetDatumCallbackCache() {
    this.datumCallbackCache.clear();
  }
  cachedDatumCallback(id, fn) {
    const { datumCallbackCache } = this;
    const existing = datumCallbackCache.get(id);
    if (existing != null)
      return existing;
    try {
      const value = fn();
      datumCallbackCache.set(id, value);
      return value;
    } catch (error2) {
      logger_exports.error(String(error2));
    }
  }
  cachedCallWithContext(fn, ...params) {
    return this.ctx.callbackCache.call([this.properties, this.ctx.chartService], fn, ...params);
  }
  callWithContext(fn, ...params) {
    return callWithContext([this.properties, this.ctx.chartService], fn, ...params);
  }
  formatTooltipWithContext(tooltip, content, params) {
    return tooltip.formatTooltip([this.properties, this.ctx.chartService], content, params);
  }
  // @todo(AG-13777) - Remove this function (see CartesianSeries.ts)
  minTimeInterval() {
    return;
  }
};
__decorateClass([
  ActionOnSet({
    changeValue: function(newVal, oldVal) {
      this.onSeriesGroupingChange(oldVal, newVal);
    }
  })
], Series.prototype, "seriesGrouping", 2);

// packages/ag-charts-community/src/dom/focusIndicator.ts
var FocusIndicator = class {
  constructor(swapChain) {
    this.swapChain = swapChain;
    this.hasBeenActivated = false;
    this.div = createElement("div");
    this.svg = createSvgElement("svg");
    this.outerPath = createSvgElement("path");
    this.innerPath = createSvgElement("path");
    this.svg.append(this.outerPath);
    this.svg.append(this.innerPath);
    this.outerPath.classList.add("ag-charts-focus-svg-outer-path");
    this.innerPath.classList.add("ag-charts-focus-svg-inner-path");
    this.element = createElement("div", "ag-charts-focus-indicator");
    this.element.ariaHidden = "true";
    this.element.append(this.svg);
    this.swapChain.addListener("swap", (parent) => this.onSwap(parent));
  }
  clear() {
  }
  update(focus, rect, clip) {
    if (rect == null)
      return;
    if (focus instanceof Path) {
      const transform = (localX, localY) => {
        let { x, y } = Transformable.toCanvasPoint(focus, localX, localY);
        x -= rect.x ?? 0;
        y -= rect.y ?? 0;
        return { x, y };
      };
      const d = focus.svgPathData(transform);
      this.outerPath.setAttribute("d", d);
      this.innerPath.setAttribute("d", d);
      this.show(this.svg);
    } else {
      let bbox;
      if (clip) {
        const x0 = Math.max(focus.x - rect.x, 0);
        const y0 = Math.max(focus.y - rect.y, 0);
        const x1 = Math.min(focus.x + focus.width - rect.x, rect.width);
        const y1 = Math.min(focus.y + focus.height - rect.y, rect.height);
        bbox = new BBox(x0, y0, x1 - x0, y1 - y0);
      } else {
        bbox = new BBox(focus.x - rect.x, focus.y - rect.y, focus.width, focus.height);
      }
      setElementBBox(this.div, bbox);
      this.show(this.div);
    }
  }
  onSwap(newParent) {
    if (newParent === this.element.parentElement)
      return;
    this.element.remove();
    newParent.appendChild(this.element);
    this.overrideFocusVisible(this.focusVisible);
  }
  show(child) {
    this.hasBeenActivated = true;
    this.element.innerHTML = "";
    this.element.append(child);
  }
  overrideFocusVisible(focusVisible) {
    this.focusVisible = focusVisible;
    const opacity = { true: "1", false: "0", undefined: "" };
    const parent = this.element.parentElement;
    parent?.style.setProperty("opacity", opacity[`${focusVisible}`]);
  }
  // Get the `:focus-visible` CSS state.
  isFocusVisible(force = false) {
    if (!force && !this.hasBeenActivated)
      return false;
    const parent = this.element.parentElement;
    return parent != null && getWindow().getComputedStyle(parent).opacity === "1";
  }
};

// packages/ag-charts-community/src/dom/focusSwapChain.ts
var FocusSwapChain = class {
  constructor(label1, label2, announcerRole, initialAltText) {
    this.label1 = label1;
    this.label2 = label2;
    this.hasFocus = false;
    this.skipDispatch = false;
    this.listeners = {
      blur: [],
      focus: [],
      swap: []
    };
    this.onBlur = (e) => {
      setElementStyle(e.target, "pointer-events", void 0);
      return !this.skipDispatch && this.dispatch("blur", e);
    };
    this.onFocus = (e) => {
      setElementStyle(e.target, "pointer-events", "auto");
      return !this.skipDispatch && this.dispatch("focus", e);
    };
    setAttribute(this.label1, "id", createElementId());
    setAttribute(this.label2, "id", createElementId());
    setElementStyle(this.label1, "display", "none");
    setElementStyle(this.label2, "display", "none");
    this.label1.textContent = initialAltText;
    this.label2.textContent = initialAltText;
    this.activeAnnouncer = this.createAnnouncer(announcerRole);
    this.inactiveAnnouncer = this.createAnnouncer(announcerRole);
    setAttribute(this.activeAnnouncer, "tabindex", 0);
    this.label2.insertAdjacentElement("afterend", this.activeAnnouncer);
    this.label2.insertAdjacentElement("afterend", this.inactiveAnnouncer);
    this.swap(initialAltText);
  }
  createAnnouncer(role) {
    const announcer = createElement("div");
    announcer.role = role;
    announcer.className = "ag-charts-swapchain";
    announcer.addEventListener("blur", this.onBlur);
    announcer.addEventListener("focus", this.onFocus);
    return announcer;
  }
  destroy() {
    for (const announcer of [this.activeAnnouncer, this.inactiveAnnouncer]) {
      announcer.removeEventListener("blur", this.onBlur);
      announcer.removeEventListener("focus", this.onFocus);
      announcer.remove();
    }
  }
  focus(opts) {
    this.focusOptions = opts;
    this.activeAnnouncer.focus(opts);
    this.focusOptions = void 0;
  }
  update(newLabel) {
    this.skipDispatch = true;
    this.swap(newLabel);
    if (this.hasFocus) {
      this.activeAnnouncer.focus(this.focusOptions);
    }
    this.skipDispatch = false;
  }
  addListener(type, handler) {
    this.listeners[type].push(handler);
    if (type === "swap") {
      const swapHandler = handler;
      swapHandler(this.activeAnnouncer);
    }
  }
  dispatch(type, param) {
    if (type === "focus")
      this.hasFocus = true;
    else if (type === "blur")
      this.hasFocus = false;
    this.listeners[type].forEach((fn) => fn(param));
  }
  swap(newLabel) {
    const userTabIndex = this.activeAnnouncer.tabIndex;
    this.label2.textContent = newLabel;
    [this.inactiveAnnouncer, this.activeAnnouncer] = [this.activeAnnouncer, this.inactiveAnnouncer];
    [this.label1, this.label2] = [this.label2, this.label1];
    setAttributes(this.inactiveAnnouncer, {
      "aria-labelledby": this.label1.id,
      "aria-hidden": true,
      tabindex: void 0
    });
    setAttributes(this.activeAnnouncer, {
      "aria-labelledby": this.label1.id,
      "aria-hidden": false,
      tabindex: userTabIndex
    });
    this.dispatch("swap", this.activeAnnouncer);
  }
};

// packages/ag-charts-community/src/chart/interaction/keyBindings.ts
var KEY_BINDINGS = {
  arrowdown: { bindings: [{ code: "ArrowDown" }] },
  arrowleft: { bindings: [{ code: "ArrowLeft" }] },
  arrowright: { bindings: [{ code: "ArrowRight" }] },
  arrowup: { bindings: [{ code: "ArrowUp" }] },
  delete: { bindings: [{ key: "Backspace" }, { key: "Delete" }], activatesFocusIndicator: false },
  redo: {
    bindings: [
      { key: "y", ctrlOrMeta: true },
      { key: "z", ctrlOrMeta: true, shift: true }
    ],
    activatesFocusIndicator: false
  },
  undo: { bindings: [{ key: "z", ctrlOrMeta: true }], activatesFocusIndicator: false },
  submit: { bindings: [{ key: "Enter" }, { code: "Enter" }, { code: "Space" }] },
  zoomin: { bindings: [{ key: "+" }, { code: "ZoomIn" }, { code: "Add" }], activatesFocusIndicator: false },
  zoomout: { bindings: [{ key: "-" }, { code: "ZoomOut" }, { code: "Substract" }], activatesFocusIndicator: false }
};
function matchesKeyBinding(e, bindings) {
  for (const kb of bindings) {
    if ("code" in kb) {
      if (kb.code === e.code)
        return true;
    } else {
      const matches = kb.key === e.key && (kb.shift === void 0 || kb.shift === e.shiftKey) && (kb.ctrlOrMeta === void 0 || kb.ctrlOrMeta === e.ctrlKey || kb.ctrlOrMeta === e.metaKey);
      if (matches)
        return true;
    }
  }
  return false;
}
function mapKeyboardEventToAction(event) {
  for (const [actionName, { activatesFocusIndicator = true, bindings }] of entries(KEY_BINDINGS)) {
    if (matchesKeyBinding(event, bindings)) {
      return { name: actionName, activatesFocusIndicator };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/keyboardUtil.ts
function computeCenter(series, hoverRect, pick2) {
  const refPoint = getDatumRefPoint(series, pick2.datum, pick2.movedBounds);
  if (refPoint != null)
    return { x: refPoint.canvasX, y: refPoint.canvasY };
  const bboxOrPath = pick2.bounds;
  if (bboxOrPath == null)
    return;
  if (bboxOrPath instanceof BBox) {
    const { x: centerX, y: centerY } = bboxOrPath.computeCenter();
    return {
      x: hoverRect.x + centerX,
      y: hoverRect.y + centerY
    };
  }
  return Transformable.toCanvas(bboxOrPath).computeCenter();
}
function getPickedFocusBBox({ bounds }) {
  if (bounds instanceof BBox)
    return bounds;
  if (bounds != null)
    return Transformable.toCanvas(bounds);
  return BBox.NaN;
}
function makeKeyboardPointerEvent(series, hoverRect, pick2) {
  const { x: canvasX, y: canvasY } = computeCenter(series, hoverRect, pick2) ?? {};
  if (canvasX !== void 0 && canvasY !== void 0) {
    return { type: "keyboard", canvasX, canvasY };
  }
  return void 0;
}

// packages/ag-charts-community/src/util/placement.ts
function calculatePlacement(naturalWidth, naturalHeight, container, bounds) {
  let { top, right, bottom, left, width: width2, height: height2 } = bounds;
  if (left != null) {
    if (width2 != null) {
      right = container.width - left + width2;
    } else if (right != null) {
      width2 = container.width - left - right;
    }
  } else if (right != null && width2 != null) {
    left = container.width - right - width2;
  }
  if (top != null) {
    if (height2 != null) {
      bottom = container.height - top - height2;
    } else if (bottom != null) {
      height2 = container.height - bottom - top;
    }
  } else if (bottom != null && height2 != null) {
    top = container.height - bottom - height2;
  }
  if (width2 == null) {
    if (height2 == null) {
      height2 = naturalHeight;
      width2 = naturalWidth;
    } else {
      width2 = Math.ceil(naturalWidth * height2 / naturalHeight);
    }
  } else {
    height2 ?? (height2 = Math.ceil(naturalHeight * width2 / naturalWidth));
  }
  if (left == null) {
    if (right == null) {
      left = Math.floor((container.width - width2) / 2);
    } else {
      left = container.width - right - width2;
    }
  }
  if (top == null) {
    if (bottom == null) {
      top = Math.floor((container.height - height2) / 2);
    } else {
      top = container.height - height2 - bottom;
    }
  }
  return { x: left, y: top, width: width2, height: height2 };
}

// packages/ag-charts-community/src/chart/tooltip/springAnimation.ts
var M = 0.1;
var K = 200;
var C = 12;
var DELTA = 0.5;
var SpringAnimation = class {
  constructor() {
    this.events = new EventEmitter();
    this.x1 = NaN;
    this.y1 = NaN;
    this.x = NaN;
    this.y = NaN;
    this.vx = 0;
    this.vy = 0;
    this.t0 = NaN;
    this.animationFrameHandle = void 0;
  }
  reset() {
    this.x = NaN;
    this.y = NaN;
    if (this.animationFrameHandle != null) {
      cancelAnimationFrame(this.animationFrameHandle);
      this.animationFrameHandle = void 0;
    }
  }
  update(x, y) {
    if (Number.isNaN(this.x) || Number.isNaN(this.y)) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.emitUpdate();
      if (this.animationFrameHandle != null) {
        cancelAnimationFrame(this.animationFrameHandle);
        this.animationFrameHandle = void 0;
      }
      return;
    }
    this.x1 = x;
    this.y1 = y;
    this.t0 = Date.now();
    this.animationFrameHandle ?? (this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this)));
  }
  onFrame() {
    this.animationFrameHandle = void 0;
    const { x1, y1, t0 } = this;
    const t1 = Date.now();
    const dt = t1 - t0;
    this.t0 = t1;
    const stepT = 1e-3;
    const iterations = Math.ceil(dt / (stepT * 1e3)) | 0;
    let { x, y, vx, vy } = this;
    for (let i = 0; i < iterations; i += 1) {
      const dx2 = x - x1;
      const dy2 = y - y1;
      const ax = -(K * dx2 + C * vx) / M;
      const ay = -(K * dy2 + C * vy) / M;
      vx += ax * stepT;
      vy += ay * stepT;
      x += vx * stepT;
      y += vy * stepT;
    }
    if (Math.hypot(x - x1, y - y1) < DELTA) {
      this.x = this.x1;
      this.y = this.y1;
      this.vx = 0;
      this.vy = 0;
    } else {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));
    }
    this.emitUpdate();
  }
  emitUpdate() {
    this.events.emit("update", { x: this.x, y: this.y });
  }
};

// packages/ag-charts-community/src/util/sanitize.ts
var element = null;
function sanitizeHtml(text2) {
  if (text2 === "") {
    return "";
  }
  element ?? (element = createElement("div"));
  element.textContent = String(text2);
  return element.innerHTML.replace(/\n/g, "<br>");
}

// packages/ag-charts-community/src/chart/marker/shapes.ts
function drawMarkerUnitPolygon(params, moves) {
  const { path, size } = params;
  const { x: x0, y: y0 } = params;
  path.clear();
  let didMove = false;
  for (const [dx2, dy2] of moves) {
    const x = x0 + (dx2 - 0.5) * size;
    const y = y0 + (dy2 - 0.5) * size;
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
    }
    didMove = true;
  }
  path.closePath();
}
var MARKER_SHAPES = {
  circle({ path, x, y, size }) {
    const r = size / 2;
    path.arc(x, y, r, 0, Math.PI * 2);
    path.closePath();
  },
  cross(params) {
    drawMarkerUnitPolygon(params, [
      [0.25, 0],
      [0.5, 0.25],
      [0.75, 0],
      [1, 0.25],
      [0.75, 0.5],
      [1, 0.75],
      [0.75, 1],
      [0.5, 0.75],
      [0.25, 1],
      [0, 0.75],
      [0.25, 0.5],
      [0, 0.25]
    ]);
  },
  diamond(params) {
    drawMarkerUnitPolygon(params, [
      [0.5, 0],
      [1, 0.5],
      [0.5, 1],
      [0, 0.5]
    ]);
  },
  heart({ path, x, y, size }) {
    const r = size / 4;
    y = y + r / 2;
    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
    path.lineTo(x, y + r);
    path.closePath();
  },
  pin({ path, x, y, size: s }) {
    const cx = 0.5;
    const cy = 0.5;
    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
    path.cubicCurveTo(
      x + (0.15625 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.307741 - cx) * s,
      y + (0 - cy) * s,
      x + (0.5 - cx) * s,
      y + (0 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.692259 - cx) * s,
      y + (0 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.84375 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.784625 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.716461 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.699009 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.681271 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.663785 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.611893 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.562228 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.528896 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.524075 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.512663 - cx) * s,
      y + (1 - cy) * s,
      x + (0.5 - cx) * s,
      y + (1 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.437772 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.388107 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.336215 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.318729 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.300991 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.283539 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.215375 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.closePath();
  },
  plus(params) {
    drawMarkerUnitPolygon(params, [
      [1 / 3, 0],
      [2 / 3, 0],
      [2 / 3, 1 / 3],
      [1, 1 / 3],
      [1, 2 / 3],
      [2 / 3, 2 / 3],
      [2 / 3, 1],
      [1 / 3, 1],
      [1 / 3, 2 / 3],
      [0, 2 / 3],
      [0, 1 / 3],
      [1 / 3, 1 / 3]
    ]);
  },
  square({ path, x, y, size, pixelRatio }) {
    const hs = size / 2;
    path.moveTo(align(pixelRatio, x - hs), align(pixelRatio, y - hs));
    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y - hs));
    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y + hs));
    path.lineTo(align(pixelRatio, x - hs), align(pixelRatio, y + hs));
    path.closePath();
  },
  star({ path, x, y, size }) {
    const spikes = 5;
    const outerRadius = size / 2;
    const innerRadius = outerRadius / 2;
    const rotation = Math.PI / 2;
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle2 = i * Math.PI / spikes - rotation;
      const xCoordinate = x + Math.cos(angle2) * radius;
      const yCoordinate = y + Math.sin(angle2) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  },
  triangle(params) {
    drawMarkerUnitPolygon(params, [
      [0.5, 0],
      [1, 0.87],
      [0, 0.87]
    ]);
  }
};

// packages/ag-charts-community/src/chart/marker/marker.ts
var InternalMarker = class extends Path {
  constructor() {
    super(...arguments);
    this.shape = "square";
    this.x = 0;
    this.y = 0;
    this.size = 12;
  }
  isPointInPath(x, y) {
    return this.distanceSquared(x, y) <= 0;
  }
  distanceSquared(x, y) {
    const anchor = Marker.anchor(this.shape);
    return Math.max(
      Math.hypot(x - this.x + (anchor.x - 0.5) * this.size, y - this.y + (anchor.y - 0.5) * this.size) - this.size / 2,
      0
    );
  }
  updatePath() {
    const { path, shape, x, y, size } = this;
    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
    const anchor = Marker.anchor(shape);
    const drawParams = {
      path,
      x: x - (anchor.x - 0.5) * size,
      y: y - (anchor.y - 0.5) * size,
      size,
      pixelRatio
    };
    path.clear();
    if (typeof shape === "string") {
      MARKER_SHAPES[shape](drawParams);
    } else if (typeof shape === "function") {
      shape(drawParams);
    }
  }
  computeBBox() {
    const { x, y, size } = this;
    const anchor = Marker.anchor(this.shape);
    return new BBox(x - size * anchor.x, y - size * anchor.y, size, size);
  }
  executeFill(ctx, path) {
    if (!path)
      return;
    return super.executeFill(ctx, path);
  }
  executeStroke(ctx, path) {
    if (!path)
      return;
    return super.executeStroke(ctx, path);
  }
};
__decorateClass([
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], InternalMarker.prototype, "shape", 2);
__decorateClass([
  SceneChangeDetection()
], InternalMarker.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], InternalMarker.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ convertor: Math.abs })
], InternalMarker.prototype, "size", 2);
var Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {
  static anchor(shape) {
    if (shape === "pin") {
      return { x: 0.5, y: 1 };
    } else if (typeof shape === "function" && "anchor" in shape) {
      return shape.anchor;
    }
    return { x: 0.5, y: 0.5 };
  }
  constructor(options) {
    super(options);
    if (options?.shape != null) {
      this.shape = options.shape;
    }
  }
};

// packages/ag-charts-community/src/chart/legend/legendSymbol.ts
function legendSymbolSvg(symbol, size, lineSize = size * (5 / 3)) {
  const group = new Group();
  const markerStrokeWidth = Math.min(symbol.marker.strokeWidth ?? 1, 2);
  const lineStrokeWidth = Math.min(symbol.line?.strokeWidth ?? 0, 2);
  const width2 = Math.max(symbol.marker.enabled === false ? 0 : size, symbol.line == null ? 0 : lineSize);
  const height2 = Math.max(symbol.marker.enabled === false ? 0 : size, lineStrokeWidth);
  if (symbol.line != null) {
    const { stroke: stroke3, strokeOpacity, lineDash } = symbol.line;
    const line = new Line();
    line.x1 = 0;
    line.y1 = height2 / 2;
    line.x2 = width2;
    line.y2 = height2 / 2;
    line.stroke = stroke3;
    line.strokeOpacity = strokeOpacity;
    line.strokeWidth = lineStrokeWidth;
    line.lineDash = lineDash;
    group.append(line);
  }
  if (symbol.marker.enabled !== false) {
    const { shape, fill, fillOpacity, stroke: stroke3, strokeOpacity, lineDash, lineDashOffset } = symbol.marker;
    const marker = new Marker();
    marker.shape = shape ?? "square";
    marker.size = size;
    marker.fill = fill;
    marker.fillOpacity = fillOpacity ?? 1;
    marker.stroke = stroke3;
    marker.strokeOpacity = strokeOpacity ?? 1;
    marker.strokeWidth = markerStrokeWidth;
    marker.lineDash = lineDash;
    marker.lineDashOffset = lineDashOffset ?? 0;
    const anchor = Marker.anchor(shape);
    const x = width2 / 2 + (anchor.x - 0.5) * size;
    const y = height2 / 2 + (anchor.y - 0.5) * size;
    const scale2 = size / (size + markerStrokeWidth);
    marker.x = x;
    marker.y = y;
    marker.scalingCenterX = x;
    marker.scalingCenterY = y;
    marker.scalingX = scale2;
    marker.scalingY = scale2;
    group.append(marker);
  }
  return Group.toSVG(group, width2, height2);
}

// packages/ag-charts-community/src/chart/tooltip/tooltipContent.ts
var DEFAULT_TOOLTIP_CLASS = "ag-charts-tooltip";
var DEFAULT_TOOLTIP_DARK_CLASS = "ag-charts-tooltip--dark";
function aggregateTooltipContent(content) {
  const out = [];
  const groupedContents = /* @__PURE__ */ new Map();
  for (const item of content) {
    if (item.type === "structured") {
      const { heading } = item;
      const insertionTarget = heading != null ? groupedContents.get(heading) : void 0;
      const groupedItem = { type: "structured", heading, items: [item] };
      if (insertionTarget == null) {
        groupedContents.set(heading, groupedItem);
        out.push(groupedItem);
      } else {
        insertionTarget.items.push(item);
      }
    } else {
      out.push(item);
    }
  }
  return out;
}
function tooltipContentAriaLabel(ungroupedContent) {
  const content = aggregateTooltipContent(ungroupedContent);
  const ariaLabel = [];
  content.forEach((c) => {
    if (c.type === "raw")
      return "";
    if (c.heading != null)
      ariaLabel.push(c.heading);
    c.items.forEach((i) => {
      if (i.title != null)
        ariaLabel.push(i.title);
      i.data?.forEach((datum) => {
        ariaLabel.push(datum.label ?? datum.fallbackLabel, datum.value);
      });
    });
  });
  return ariaLabel.join("; ");
}
function dataHtml(label, value, inline) {
  let rowHtml = "";
  if (label == null) {
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-label">${sanitizeHtml(value)}</span>`;
  } else {
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-label">${sanitizeHtml(label)}</span>`;
    rowHtml += " ";
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-value">${sanitizeHtml(value)}</span>`;
  }
  const rowClassNames = [`${DEFAULT_TOOLTIP_CLASS}-row`];
  if (inline)
    rowClassNames.push(`${DEFAULT_TOOLTIP_CLASS}-row--inline`);
  rowHtml = `<div class="${rowClassNames.join(" ")}">${rowHtml}</div>`;
  return rowHtml;
}
function tooltipRowContentHtml(content) {
  let html = "";
  if (content.data?.length && content.data.every((datum) => datum.value == null || datum.value === "")) {
    return html;
  }
  const dataInline = content.title == null && content.data?.length === 1;
  const symbol = content.symbol == null ? void 0 : legendSymbolSvg(content.symbol, 12);
  if (symbol != null && (content.title != null || content.data?.length)) {
    html += `<span class="${DEFAULT_TOOLTIP_CLASS}-symbol">${symbol}</span>`;
  }
  if (content.title != null) {
    html += `<span class="${DEFAULT_TOOLTIP_CLASS}-title">${sanitizeHtml(content.title)}</span>`;
    html += " ";
  }
  content.data?.forEach((datum) => {
    html += dataHtml(datum.label ?? datum.fallbackLabel, datum.value, dataInline);
    html += " ";
  });
  return html;
}
function tooltipPaginationContentHtml(localeManager, pagination) {
  if (localeManager == null || pagination.length === 1)
    return;
  const text2 = localeManager?.t("tooltipPaginationStatus", {
    index: pagination.index + 1,
    count: pagination.length
  });
  return `<div class="${DEFAULT_TOOLTIP_CLASS}-footer">${text2}</div>`;
}
function tooltipContentHtml(localeManager, content, mode, pagination) {
  const singleItem = content.items.length === 1 ? content.items[0] : void 0;
  let compact;
  let compactTitle;
  let compactFallbackLabel;
  switch (mode) {
    case "compact":
      compact = true;
      compactTitle = singleItem?.title;
      break;
    case "single":
      compact = singleItem != null && (content.heading == null || singleItem.title == null) && singleItem.data?.length === 1 && singleItem.data[0].label == null && singleItem.data[0].value != null;
      compactFallbackLabel = content.heading ?? singleItem?.title;
      break;
    case "shared":
      compact = false;
  }
  let html = "";
  if (compact && singleItem != null) {
    if (compactTitle != null) {
      html += dataHtml(void 0, compactTitle, false);
    }
    singleItem.data?.forEach((datum) => {
      html += dataHtml(datum.label ?? compactFallbackLabel, datum.value, false);
      html += " ";
    });
  } else {
    if (content.heading != null) {
      html += `<span class="${DEFAULT_TOOLTIP_CLASS}-heading">${sanitizeHtml(content.heading)}</span>`;
      html += " ";
    }
    content.items.forEach((item) => {
      html += tooltipRowContentHtml(item);
    });
  }
  if (html.length === 0)
    return;
  const paginationContent = mode !== "compact" && pagination != null ? tooltipPaginationContentHtml(localeManager, pagination) : void 0;
  if (paginationContent + null) {
    html += paginationContent;
  }
  html = `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${html.trimEnd()}</div>`;
  return html;
}
function tooltipPaginationHtml(localeManager, pagination) {
  const paginationContent = pagination == null ? void 0 : tooltipPaginationContentHtml(localeManager, pagination);
  if (paginationContent == null)
    return "";
  return `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${paginationContent}</div>`;
}
function tooltipHtml(localeManager, content, mode, pagination) {
  const aggregatedContent = aggregateTooltipContent(content);
  if (aggregatedContent.length === 0)
    return;
  if (aggregatedContent.length === 1 && aggregatedContent[0].type === "structured") {
    return tooltipContentHtml(localeManager, aggregatedContent[0], mode, pagination);
  } else {
    const htmlRows = aggregatedContent.map((c) => {
      return c.type === "structured" ? tooltipContentHtml(localeManager, c, mode) : c.rawHtmlString;
    });
    if (pagination != null) {
      htmlRows.push(tooltipPaginationHtml(localeManager, pagination) ?? "");
    }
    return htmlRows.join("");
  }
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var horizontalAlignments = {
  left: -1,
  "top-left": -1,
  "bottom-left": -1,
  top: 0,
  center: 0,
  bottom: 0,
  right: 1,
  "top-right": 1,
  "bottom-right": 1
};
var verticalAlignments = {
  "top-left": -1,
  top: -1,
  "top-right": -1,
  left: 0,
  center: 0,
  right: 0,
  "bottom-left": 1,
  bottom: 1,
  "bottom-right": 1
};
var arrowPositions = {
  left: 3 /* Right */,
  "top-left": void 0,
  "bottom-left": void 0,
  top: 2 /* Bottom */,
  center: void 0,
  bottom: 1 /* Top */,
  right: 0 /* Left */,
  "top-right": void 0,
  "bottom-right": void 0
};
var directionChecks = {
  top: 2 /* Vertical */,
  bottom: 2 /* Vertical */,
  left: 1 /* Horizontal */,
  right: 1 /* Horizontal */,
  "top-right": 3 /* Both */,
  "top-left": 3 /* Both */,
  "bottom-right": 3 /* Both */,
  "bottom-left": 3 /* Both */,
  center: 0 /* None */
};
var defaultPlacements = {
  pointer: "top",
  node: "top",
  chart: "top-left"
};
var TooltipPosition = class extends BaseProperties {
  constructor() {
    super(...arguments);
    /** The horizontal offset in pixels for the position of the tooltip. */
    this.xOffset = 0;
    /** The vertical offset in pixels for the position of the tooltip. */
    this.yOffset = 0;
  }
};
__decorateClass([
  Property
], TooltipPosition.prototype, "xOffset", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "yOffset", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "anchorTo", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "placement", 2);
var Tooltip = class extends BaseProperties {
  constructor() {
    super();
    this.enabled = true;
    this.mode = "single";
    this.delay = 0;
    this.range = void 0;
    this.wrapping = "hyphenate";
    this.position = new TooltipPosition();
    this.pagination = false;
    this.darkTheme = false;
    this.bounds = "extended";
    this.cleanup = new CleanupRegistry();
    this.springAnimation = new SpringAnimation();
    this.enableInteraction = false;
    this.wrapTypes = ["always", "hyphenate", "on-space", "never"];
    this.sizeMonitor = new SizeMonitor();
    // Reading the element size is expensive, so cache the result
    this._elementSize = void 0;
    this._showTimeout = void 0;
    this.arrowPosition = void 0;
    this._visible = false;
    this.positionParams = void 0;
    this.localeManager = void 0;
    this.cleanup.register(this.springAnimation.events.on("update", this.updateTooltipPosition.bind(this)));
  }
  get interactive() {
    return this.enableInteraction;
  }
  setup(localeManager, domManager) {
    if ("togglePopover" in getWindow().HTMLElement.prototype) {
      this.element = domManager.addChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
      this.element.setAttribute("popover", "manual");
      this.element.className = DEFAULT_TOOLTIP_CLASS;
      this.element.style.positionAnchor = domManager.anchorName;
      this.sizeMonitor.observe(this.element, (size) => {
        this._elementSize = size;
        this.updateTooltipPosition();
      });
    }
    this.localeManager = localeManager;
    return () => {
      domManager.removeChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
      this.cleanup.flush();
      if (this.element) {
        this.sizeMonitor.unobserve(this.element);
      }
    };
  }
  isVisible() {
    return this._visible;
  }
  contains(node) {
    return this.element?.contains(node) ?? false;
  }
  updateTooltipPosition() {
    const { element: element2, _elementSize: elementSize, positionParams } = this;
    if (element2 == null || elementSize == null || positionParams == null)
      return;
    const { canvasRect, relativeRect, meta } = positionParams;
    const { x: canvasX, y: canvasY } = this.springAnimation;
    const anchorTo = meta.position?.anchorTo ?? "pointer";
    let placements2 = meta.position?.placement ?? defaultPlacements[anchorTo];
    if (!Array.isArray(placements2)) {
      placements2 = [placements2];
    }
    const xOffset = meta.position?.xOffset ?? 0;
    const yOffset = meta.position?.yOffset ?? 0;
    const minX = relativeRect.x;
    const minY = relativeRect.y;
    const maxX = relativeRect.width - elementSize.width - 1 + minX;
    const maxY = relativeRect.height - elementSize.height + minY;
    let i = 0;
    let placement;
    let position;
    let constrained = false;
    do {
      placement = placements2[i];
      i += 1;
      const tooltipBounds = this.getTooltipBounds({
        elementSize,
        placement,
        anchorTo,
        canvasX,
        canvasY,
        yOffset,
        xOffset,
        canvasRect
      });
      position = calculatePlacement(elementSize.width, elementSize.height, relativeRect, tooltipBounds);
      constrained = false;
      if (directionChecks[placement] & 1 /* Horizontal */) {
        constrained || (constrained = position.x < minX || position.x > maxX);
      }
      if (directionChecks[placement] & 2 /* Vertical */) {
        constrained || (constrained = position.y < minY || position.y > maxY);
      }
    } while (i < placements2.length && constrained);
    const left = clamp(minX, position.x, maxX);
    const top = clamp(minY, position.y, maxY);
    constrained || (constrained = left !== position.x || top !== position.y);
    const defaultShowArrow = anchorTo !== "chart" && !constrained && !xOffset && !yOffset;
    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;
    this.arrowPosition = showArrow ? arrowPositions[placement] : void 0;
    this.updateClassModifiers();
    element2.style.translate = `${left}px ${top}px`;
  }
  /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */
  show(boundingRect, canvasRect, meta, content, pagination, instantly = false) {
    const { element: element2 } = this;
    if (element2 != null && content != null && content.length !== 0) {
      const html = tooltipHtml(this.localeManager, content, this.mode, this.pagination ? pagination : void 0);
      if (html == null) {
        this.toggle(false);
        return;
      }
      element2.innerHTML = html;
    } else if (element2 == null || element2.innerHTML === "") {
      this.toggle(false);
      return;
    }
    const relativeRect = {
      x: boundingRect.x - canvasRect.x,
      y: boundingRect.y - canvasRect.y,
      width: boundingRect.width,
      height: boundingRect.height
    };
    this.positionParams = {
      canvasRect,
      relativeRect,
      meta
    };
    const anchorTo = meta.position?.anchorTo ?? "pointer";
    switch (anchorTo) {
      case "node":
        this.springAnimation.update(meta.nodeCanvasX ?? meta.canvasX, meta.nodeCanvasY ?? meta.canvasY);
        break;
      case "pointer":
        this.springAnimation.update(meta.canvasX, meta.canvasY);
        break;
      case "chart":
        this.springAnimation.reset();
    }
    if (meta.enableInteraction) {
      this.enableInteraction = true;
      element2.style.pointerEvents = "auto";
      element2.removeAttribute("aria-hidden");
      element2.tabIndex = -1;
    } else {
      this.enableInteraction = false;
      element2.style.pointerEvents = "none";
      element2.setAttribute("aria-hidden", "true");
      element2.removeAttribute("tabindex");
    }
    element2.style.setProperty("--top", `${canvasRect.top}px`);
    element2.style.setProperty("--left", `${canvasRect.left}px`);
    this.updateClassModifiers();
    this.toggle(true, instantly);
  }
  hide() {
    this.toggle(false);
  }
  maybeEnterInteractiveTooltip({ relatedTarget }, callback2) {
    const { interactive, interactiveLeave, enabled, element: element2 } = this;
    if (element2 == null)
      return false;
    if (interactiveLeave)
      return true;
    const isEntering = interactive && enabled && this.isVisible() && relatedTarget instanceof Node && this.contains(relatedTarget);
    if (isEntering) {
      this.interactiveLeave = {
        callback: callback2,
        listener: (popoverEvent) => {
          const isLeaving = popoverEvent.relatedTarget == null || popoverEvent.relatedTarget instanceof Node && !this.contains(popoverEvent.relatedTarget);
          if (isLeaving) {
            this.popInteractiveLeaveCallback();
          }
        }
      };
      element2.addEventListener("focusout", this.interactiveLeave.listener);
      element2.addEventListener("mouseout", this.interactiveLeave.listener);
    }
    return isEntering;
  }
  popInteractiveLeaveCallback() {
    const { interactiveLeave, element: element2 } = this;
    this.interactiveLeave = void 0;
    if (interactiveLeave) {
      if (element2) {
        element2.removeEventListener("focusout", interactiveLeave.listener);
        element2.removeEventListener("mouseout", interactiveLeave.listener);
      }
      interactiveLeave.callback();
    }
  }
  toggle(visible, instantly = false) {
    const { delay } = this;
    if (visible && delay > 0 && !instantly) {
      this._showTimeout ?? (this._showTimeout = setTimeout(() => {
        this._showTimeout = void 0;
        this.toggleCallback(true);
      }, delay));
    } else {
      clearTimeout(this._showTimeout);
      this._showTimeout = void 0;
      this.toggleCallback(visible);
    }
  }
  toggleCallback(visible) {
    if (!this.element?.isConnected)
      return;
    if (this._visible === visible)
      return;
    this._visible = visible;
    this.element.togglePopover(visible);
    if (visible) {
      this.updateTooltipPosition();
    } else {
      this.springAnimation.reset();
      this.popInteractiveLeaveCallback();
    }
  }
  updateClassModifiers() {
    if (!this.element?.isConnected)
      return;
    const { classList } = this.element;
    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--${name}`, include);
    toggleClass("no-interaction", !this.enableInteraction);
    toggleClass("arrow-top", this.arrowPosition === 1 /* Top */);
    toggleClass("arrow-right", this.arrowPosition === 3 /* Right */);
    toggleClass("arrow-bottom", this.arrowPosition === 2 /* Bottom */);
    toggleClass("arrow-left", this.arrowPosition === 0 /* Left */);
    toggleClass("compact", this.mode === "compact");
    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
    for (const wrapType of this.wrapTypes) {
      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--wrap-${wrapType}`, wrapType === this.wrapping);
    }
  }
  getTooltipBounds(opts) {
    const { elementSize, anchorTo, placement, canvasX, canvasY, yOffset, xOffset, canvasRect } = opts;
    const { width: tooltipWidth, height: tooltipHeight } = elementSize;
    const bounds = { width: tooltipWidth, height: tooltipHeight };
    if (anchorTo === "node" || anchorTo === "pointer") {
      const horizontalAlignment = horizontalAlignments[placement];
      const verticalAlignment = verticalAlignments[placement];
      bounds.top = canvasY + yOffset + tooltipHeight * (verticalAlignment - 1) / 2 + 8 * verticalAlignment;
      bounds.left = canvasX + xOffset + tooltipWidth * (horizontalAlignment - 1) / 2 + 8 * horizontalAlignment;
      return bounds;
    }
    switch (placement) {
      case "top": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "right": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "left": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "bottom": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "top-left": {
        bounds.top = yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "top-right": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-right": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-left": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
    }
    return bounds;
  }
};
__decorateClass([
  Property
], Tooltip.prototype, "enabled", 2);
__decorateClass([
  Property
], Tooltip.prototype, "mode", 2);
__decorateClass([
  Property
], Tooltip.prototype, "showArrow", 2);
__decorateClass([
  Property
], Tooltip.prototype, "delay", 2);
__decorateClass([
  Property
], Tooltip.prototype, "range", 2);
__decorateClass([
  Property
], Tooltip.prototype, "wrapping", 2);
__decorateClass([
  Property
], Tooltip.prototype, "position", 2);
__decorateClass([
  Property
], Tooltip.prototype, "pagination", 2);
__decorateClass([
  Property
], Tooltip.prototype, "darkTheme", 2);
__decorateClass([
  Property
], Tooltip.prototype, "bounds", 2);

// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
function pickedNodesEqual(a, b) {
  return a.series === b.series && objectsEqual(a.datumIndex, b.datumIndex);
}
var PickedNodeState = class {
  constructor() {
    this.candidates = [];
  }
  get current() {
    return this.active;
  }
  reset() {
    this.candidates.length = 0;
    this.active = void 0;
  }
  update(nextCandidates, previousActive) {
    this.candidates = nextCandidates;
    let nextIndex = previousActive != null ? nextCandidates.findIndex((c) => pickedNodesEqual(c, previousActive)) : -1;
    if (nextIndex === -1)
      nextIndex = 0;
    this.active = nextCandidates[nextIndex];
    return { current: this.active, index: nextIndex, length: nextCandidates.length };
  }
  next() {
    const { candidates, active } = this;
    const hoverIndex = active == null ? -1 : candidates.findIndex((c) => pickedNodesEqual(c, active));
    if (hoverIndex === -1)
      return void 0;
    let nextIndex = hoverIndex + 1;
    if (nextIndex >= candidates.length) {
      nextIndex = 0;
    }
    this.active = candidates[nextIndex];
    return { current: this.active, index: nextIndex, length: this.candidates.length };
  }
};
var SeriesAreaManager = class extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
    this.id = createId(this);
    this.series = [];
    this.announceMode = "when-changed";
    this.highlight = {
      /** Last received event that still needs to be applied. */
      pendingHoverEvent: void 0,
      /** Last applied event. */
      appliedHoverEvent: void 0,
      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */
      stashedHoverEvent: void 0
    };
    this.tooltip = {
      lastHover: void 0
    };
    /**
     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):
     *
     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.
     *
     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.
     *       (this is decided by the browser).
     *
     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on
     *       the currently (or newly) focused datum.
     *
     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match
     *       for the mouse event offsets.
     */
    this.hoverDevice = "pointer";
    /**
     * This is the "second last" input event. It can be useful for keydown
     * events that for which don't to set the isFocusVisible state
     * (e.g. Backspace/Delete key on FC annotations, see AG-13041).
     *
     * Use with caution! The focus indicator must ALWAYS be visible for
     * keyboard-only users.
     */
    this.previousInputDevice = "keyboard";
    this.focus = {
      sortedSeries: [],
      series: void 0,
      seriesIndex: 0,
      datumIndex: 0,
      datum: void 0
    };
    this.cachedTooltipContent = void 0;
    this.hoverScheduler = debouncedAnimationFrame(() => {
      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)
        return;
      if (this.chart.getUpdateType() <= 5 /* SERIES_UPDATE */) {
        this.hoverScheduler.schedule();
        return;
      }
      if (this.highlight.pendingHoverEvent) {
        this.handleHoverHighlight(false);
      }
      if (this.tooltip.lastHover) {
        this.handleHoverTooltip(this.tooltip.lastHover, false);
      }
    });
    this.tooltipCandidates = new PickedNodeState();
    const initialAltText = chart.ctx.localeManager.t("ariaInitSeriesArea");
    const label1 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label1");
    const label2 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label2");
    this.swapChain = new FocusSwapChain(label1, label2, "img", initialAltText);
    this.swapChain.addListener("blur", (event) => this.onBlur(event));
    this.swapChain.addListener("focus", () => this.onFocus());
    if (chart.ctx.domManager.mode === "normal") {
      this.focusIndicator = new FocusIndicator(this.swapChain);
      this.focusIndicator.overrideFocusVisible(chart.mode === "integrated" ? false : void 0);
    }
    const { seriesDragInterpreter, seriesWidget, containerWidget } = chart.ctx.widgets;
    seriesWidget.setTabIndex(-1);
    this.cleanup.register(
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label1"),
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label2"),
      seriesWidget.addListener("focus", () => this.swapChain.focus({ preventScroll: true })),
      seriesWidget.addListener("mousemove", (event) => this.onHover(event, seriesWidget)),
      seriesWidget.addListener("wheel", (event) => this.onWheel(event)),
      seriesWidget.addListener("mouseleave", (event) => this.onLeave(event)),
      seriesWidget.addListener("keydown", (event) => this.onKeyDown(event)),
      seriesWidget.addListener("contextmenu", (event, current) => this.onContextMenu(event, current)),
      containerWidget.addListener("contextmenu", (event, current) => this.onContextMenu(event, current)),
      containerWidget.addListener("click", (event, current) => this.onClick(event, current)),
      containerWidget.addListener("dblclick", (event, current) => this.onClick(event, current)),
      chart.ctx.animationManager.addListener("animation-start", () => this.clearAll()),
      chart.ctx.eventsHub.on("dom:resize", () => this.clearAll()),
      chart.ctx.eventsHub.on("highlight:change", (event) => this.changeHighlightDatum(event)),
      chart.ctx.eventsHub.on("layout:complete", (event) => this.layoutComplete(event)),
      chart.ctx.updateService.addListener("pre-scene-render", () => this.preSceneRender()),
      chart.ctx.updateService.addListener("update-complete", () => this.updateComplete()),
      chart.ctx.eventsHub.on("zoom:change", () => this.clearAll()),
      chart.ctx.eventsHub.on("zoom:pan-start", () => this.clearAll())
    );
    if (seriesDragInterpreter) {
      this.cleanup.register(
        seriesDragInterpreter.events.on("drag-move", (event) => this.onDragMove(event, seriesWidget)),
        seriesDragInterpreter.events.on("click", (event) => this.onClick(event, seriesWidget)),
        seriesDragInterpreter.events.on("dblclick", (event) => this.onClick(event, seriesWidget))
      );
    }
  }
  get bbox() {
    return (this.seriesRect ?? BBox.zero).clone();
  }
  isState(allowedStates) {
    return this.chart.ctx.interactionManager.isState(allowedStates);
  }
  isIgnoredTouch(event) {
    if (event.device !== "touch" || event.type === "click")
      return false;
    if (this.chart.ctx.chartService.touch.dragAction === "hover")
      return false;
    if (this.chart.ctx.chartService.touch.dragAction === "drag") {
      if (this.isState(9 /* AnnotationsMoveable */)) {
        return false;
      }
    }
    return true;
  }
  dataChanged() {
    var _a;
    this.cachedTooltipContent = void 0;
    if (this.highlight.appliedHoverEvent) {
      (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);
      this.clearHighlight();
    }
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.focusIndicator?.clear();
  }
  preSceneRender() {
    if (this.highlight.stashedHoverEvent != null) {
      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;
      this.highlight.stashedHoverEvent = void 0;
      this.handleHoverHighlight(true);
    }
    if (this.tooltip.lastHover != null) {
      this.handleHoverTooltip(this.tooltip.lastHover, true);
    }
  }
  updateComplete() {
    if (this.isState(34 /* Focusable */) && this.focusIndicator?.isFocusVisible()) {
      if (this.announceMode !== "always") {
        this.announceMode = "never";
      }
      this.handleFocus(0, 0);
    }
  }
  update(type, opts) {
    this.chart.ctx.updateService.update(type, opts);
  }
  seriesChanged(series) {
    this.focus.sortedSeries = [...series].sort((a, b) => {
      let fpA = a.properties.focusPriority ?? Infinity;
      let fpB = b.properties.focusPriority ?? Infinity;
      if (fpA === fpB) {
        [fpA, fpB] = [a.declarationOrder, b.declarationOrder];
      }
      if (fpA < fpB) {
        return -1;
      } else if (fpA > fpB) {
        return 1;
      }
      return 0;
    });
    this.series = series;
  }
  layoutComplete(event) {
    this.seriesRect = event.series.rect;
    this.hoverRect = event.series.rect;
    this.chart.ctx.widgets.seriesWidget.setBounds(event.series.rect);
    if (this.chart.ctx.domManager.mode === "normal") {
      this.chart.ctx.widgets.chartWidget.setBounds(event.chart);
    }
  }
  onContextMenu(event, current) {
    const { sourceEvent } = event;
    if (sourceEvent.currentTarget != current.getElement())
      return;
    if (sourceEvent.target == this.chart.ctx.widgets.containerWidget.getElement()) {
      if (this.isState(36 /* ContextMenuable */)) {
        const { currentX: canvasX2, currentY: canvasY2 } = event;
        this.chart.ctx.contextMenuRegistry.dispatchContext(
          "always",
          { widgetEvent: event, canvasX: canvasX2, canvasY: canvasY2 },
          void 0
        );
      }
      return;
    }
    let pickedNode;
    let position;
    if (this.focusIndicator?.isFocusVisible()) {
      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();
      if (pickedNode && this.seriesRect && pickedNode.midPoint) {
        position = Transformable.toCanvasPoint(
          pickedNode.series.contentGroup,
          pickedNode.midPoint.x,
          pickedNode.midPoint.y
        );
      }
    } else if (this.isState(36 /* ContextMenuable */)) {
      const pick2 = this.pickNodes({ x: event.currentX, y: event.currentY }, "context-menu");
      if (pick2) {
        this.chart.ctx.highlightManager.updateHighlight(this.id);
        pickedNode = pick2.matches[0].datum;
      }
    }
    const pickedSeries = pickedNode?.series;
    this.clearAll();
    const canvasX = event.currentX + current.cssLeft();
    const canvasY = event.currentY + current.cssTop();
    if (pickedSeries && pickedNode) {
      this.chart.ctx.contextMenuRegistry.dispatchContext(
        "series-node",
        { widgetEvent: event, canvasX, canvasY },
        { pickedSeries, pickedNode },
        position
      );
    } else {
      this.chart.ctx.contextMenuRegistry.dispatchContext(
        "series-area",
        { widgetEvent: event, canvasX, canvasY },
        void 0,
        position
      );
    }
  }
  onLeave(event) {
    if (!this.isState(41 /* Clickable */))
      return;
    const relatedTarget = event.sourceEvent.relatedTarget;
    if (relatedTarget?.className === "ag-charts-text-input__textarea") {
      return;
    }
    if (this.maybeEnterInteractiveTooltip(event.sourceEvent)) {
      return;
    }
    this.chart.ctx.domManager.updateCursor(this.id);
    if (this.hoverDevice !== "keyboard")
      this.clearAll();
  }
  onWheel(_event) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.focusIndicator?.overrideFocusVisible(false);
    this.previousInputDevice = "pointer";
  }
  onDragMove(event, current) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.focusIndicator?.overrideFocusVisible(false);
    this.onHoverLikeEvent(event, current);
  }
  onHover(event, current) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.onHoverLikeEvent(event, current);
  }
  onHoverLikeEvent(event, current) {
    if (this.isIgnoredTouch(event))
      return;
    if (event.device === "touch" && this.chart.ctx.chartService.touch.dragAction === "hover") {
      event.sourceEvent.preventDefault();
    }
    if (current !== this.chart.ctx.widgets.seriesWidget)
      return;
    if (event.device === "touch" || excludesType(event, "drag-move")) {
      this.tooltip.lastHover = event;
    }
    this.hoverDevice = "pointer";
    this.previousInputDevice = "pointer";
    this.highlight.pendingHoverEvent = event;
    this.hoverScheduler.schedule();
    if (this.isState(32 /* Default */)) {
      const { currentX: x, currentY: y } = event;
      const matches = this.pickNodes({ x, y }, "event")?.matches;
      const found = matches?.[0];
      if (found?.series.hasEventListener("seriesNodeClick") || found?.series.hasEventListener("seriesNodeDoubleClick") || matches != null && matches.length > 1 && this.chart.tooltip.pagination) {
        this.chart.ctx.domManager.updateCursor(this.id, "pointer");
      } else {
        this.chart.ctx.domManager.updateCursor(this.id);
      }
    }
  }
  onClick(event, current) {
    if (event.device === "keyboard") {
      return;
    }
    if (current === this.chart.ctx.widgets.seriesWidget && this.chart.ctx.animationManager.isActive()) {
      this.chart.ctx.animationManager.skipCurrentBatch();
    }
    if (event.device === "touch" && current === this.chart.ctx.widgets.seriesWidget) {
      this.swapChain.focus({ preventScroll: true });
    }
    if (!this.isState(41 /* Clickable */))
      return;
    if (current === this.chart.ctx.widgets.seriesWidget) {
      if (!current.getElement().contains(event.sourceEvent.target)) {
        return;
      }
    } else if (event.sourceEvent.target != current.getElement()) {
      return;
    }
    this.focusIndicator?.overrideFocusVisible(false);
    this.onHoverLikeEvent(event, current);
    if (!this.isState(32 /* Default */))
      return;
    if (current == this.chart.ctx.widgets.seriesWidget && this.checkSeriesNodeClick(event)) {
      this.update(5 /* SERIES_UPDATE */);
      event.sourceEvent.preventDefault();
      return;
    }
    const newEvent = { type: event.type === "click" ? "click" : "doubleClick", event: event.sourceEvent };
    this.chart.fireEvent(newEvent);
  }
  onFocus() {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = this.focusIndicator?.isFocusVisible(true) ? "keyboard" : "pointer";
    this.handleFocus(0, 0);
  }
  onBlur(event) {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = "pointer";
    if (!this.maybeEnterInteractiveTooltip(event)) {
      this.clearAll();
    }
    this.focusIndicator?.overrideFocusVisible(void 0);
  }
  onKeyDown(widgetEvent) {
    if (!this.isState(43 /* Keyable */))
      return;
    const action = mapKeyboardEventToAction(widgetEvent.sourceEvent);
    if (action?.activatesFocusIndicator === false) {
      this.focusIndicator?.overrideFocusVisible(this.previousInputDevice === "keyboard");
    }
    switch (action?.name) {
      case "redo":
        return this.chart.ctx.eventsHub.emit("series:redo", null);
      case "undo":
        return this.chart.ctx.eventsHub.emit("series:undo", null);
      case "zoomin":
        return this.chart.ctx.eventsHub.emit("series:keynav-zoom", { delta: 1, widgetEvent });
      case "zoomout":
        return this.chart.ctx.eventsHub.emit("series:keynav-zoom", { delta: -1, widgetEvent });
      case "arrowup":
        return this.onArrow(-1, 0, widgetEvent);
      case "arrowdown":
        return this.onArrow(1, 0, widgetEvent);
      case "arrowleft":
        return this.onArrow(0, -1, widgetEvent);
      case "arrowright":
        return this.onArrow(0, 1, widgetEvent);
      case "submit":
        return this.onSubmit(widgetEvent);
    }
  }
  onArrow(seriesIndexDelta, datumIndexDelta, event) {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = "keyboard";
    this.previousInputDevice = "keyboard";
    this.focusIndicator?.overrideFocusVisible(true);
    this.focus.seriesIndex += seriesIndexDelta;
    this.focus.datumIndex += datumIndexDelta;
    this.handleFocus(seriesIndexDelta, datumIndexDelta);
    event.sourceEvent.preventDefault();
    this.chart.ctx.eventsHub.emit("series:focus-change", null);
  }
  onSubmit(event) {
    if (!this.isState(34 /* Focusable */))
      return;
    const { series, datum } = this.focus;
    const sourceEvent = event.sourceEvent;
    if (series != null && datum != null) {
      series.fireNodeClickEvent(sourceEvent, datum);
    } else {
      this.chart.fireEvent({
        type: "click",
        event: sourceEvent
      });
    }
    sourceEvent.preventDefault();
  }
  checkSeriesNodeClick(event) {
    var _a;
    const result = this.pickNodes({ x: event.currentX, y: event.currentY }, "event");
    if (result == null || result.matches.length === 0)
      return;
    const paginationUpdate = this.chart.tooltip.pagination ? this.tooltipCandidates.update(result.matches, this.tooltipCandidates.current)?.current : void 0;
    const { series, datum } = paginationUpdate ?? result.matches[0];
    const distance2 = paginationUpdate == null ? result.distance : 0;
    if (event.type === "click") {
      const defaultBehavior = series.fireNodeClickEvent(event.sourceEvent, datum);
      const nextTooltipCandidate = defaultBehavior && this.chart.tooltip.pagination ? this.tooltipCandidates.next() : void 0;
      if (nextTooltipCandidate != null) {
        event.sourceEvent.preventDefault();
        const { currentX, currentY } = event;
        const canvasX = currentX + (this.hoverRect?.x ?? 0);
        const canvasY = currentY + (this.hoverRect?.y ?? 0);
        (_a = this.highlight).pendingHoverEvent ?? (_a.pendingHoverEvent = this.highlight.appliedHoverEvent);
        this.handleHoverHighlight(false);
        this.showTooltip(nextTooltipCandidate.current, canvasX, canvasY, {
          index: nextTooltipCandidate.index,
          length: nextTooltipCandidate.length
        });
      }
      return true;
    }
    if (event.type === "dblclick") {
      event.preventZoomDblClick = distance2 === 0;
      series.fireNodeDoubleClickEvent(event.sourceEvent, datum);
      return true;
    }
    return false;
  }
  handleFocus(seriesIndexDelta, datumIndexDelta) {
    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);
    if (overlayFocus == null) {
      if (this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta) === 0 /* SUCCESS */) {
        this.announceMode = "when-changed";
      } else {
        this.announceMode = "always";
      }
    } else {
      this.focusIndicator?.update(overlayFocus.rect, this.seriesRect, false);
      this.swapChain.update(overlayFocus.text);
      this.announceMode = "always";
    }
  }
  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {
    if (this.chart.chartType === "standalone") {
      return this.handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta);
    }
    const { focus } = this;
    const visibleSeries = focus.sortedSeries.filter((s) => s.visible && s.focusable);
    if (visibleSeries.length === 0)
      return 1 /* SERIES_NOT_FOUND */;
    const oldDatumIndex = focus.datumIndex - datumIndexDelta;
    const oldOtherIndex = focus.seriesIndex - otherIndexDelta;
    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);
    focus.series = visibleSeries[focus.seriesIndex];
    const datumIndex = this.focus.datumIndex;
    const otherIndex = this.focus.seriesIndex;
    return this.updatePickedFocus(
      datumIndex,
      datumIndexDelta,
      oldDatumIndex,
      otherIndex,
      otherIndexDelta,
      oldOtherIndex
    );
  }
  handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta) {
    this.focus.series = this.focus.sortedSeries[0];
    const datumIndex = this.focus.datumIndex;
    const otherIndex = this.focus.seriesIndex;
    const oldDatumIndex = this.focus.datumIndex - datumIndexDelta;
    const oldOtherIndex = this.focus.seriesIndex - otherIndexDelta;
    return this.updatePickedFocus(
      datumIndex,
      datumIndexDelta,
      oldDatumIndex,
      otherIndex,
      otherIndexDelta,
      oldOtherIndex
    );
  }
  updatePickedFocus(datumIndex, datumIndexDelta, oldDatumIndex, otherIndex, otherIndexDelta, oldOtherIndex) {
    const { focus, hoverRect, seriesRect } = this;
    if (focus.series == null || hoverRect == null)
      return 1 /* SERIES_NOT_FOUND */;
    const pick2 = focus?.series?.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });
    if (!pick2)
      return 2 /* DATUM_NOT_FOUND */;
    const { datum } = pick2;
    focus.datum = datum;
    focus.datumIndex = pick2.datumIndex;
    if (pick2.otherIndex != null) {
      focus.seriesIndex = pick2.otherIndex;
    }
    if (this.focusIndicator?.isFocusVisible()) {
      this.chart.ctx.animationManager.reset();
      const focusBBox = getPickedFocusBBox(pick2);
      const { x, y } = focusBBox.computeCenter();
      if (!hoverRect.containsPoint(x, y)) {
        const panSuccess = this.chart.ctx.zoomManager.panToBBox(this.id, hoverRect, focusBBox);
        if (panSuccess) {
          return 3 /* PAN_REQUIRED */;
        }
      }
      const { x1, x2, y1, y2 } = Vec4.from(focusBBox);
      const nw = hoverRect.containsPoint(x1, y1);
      const ne = hoverRect.containsPoint(x2, y1);
      const sw = hoverRect.containsPoint(x1, y2);
      const se = hoverRect.containsPoint(x2, y2);
      if (!(nw || ne || sw || se)) {
        const hoverBounds = Vec4.from(hoverRect);
        pick2.movedBounds = focusBBox.clone();
        if (x1 < hoverBounds.x1 && x2 < hoverBounds.x1) {
          pick2.movedBounds.x = hoverBounds.x1 - 2;
          pick2.movedBounds.width = 4;
        } else if (x1 > hoverBounds.x2 && x2 > hoverBounds.x2) {
          pick2.movedBounds.x = hoverBounds.x2 - 2;
          pick2.movedBounds.width = 4;
        }
        if (y1 < hoverBounds.y1 && y2 < hoverBounds.y1) {
          pick2.movedBounds.y = hoverBounds.y1 - 2;
          pick2.movedBounds.height = 4;
        } else if (y1 > hoverBounds.y2 && y2 > hoverBounds.y2) {
          pick2.movedBounds.y = hoverBounds.y2 - 2;
          pick2.movedBounds.height = 4;
        }
      }
    }
    this.focusIndicator?.update(pick2.movedBounds ?? pick2.bounds, this.seriesRect, pick2.clipFocusBox);
    const keyboardEvent = makeKeyboardPointerEvent(focus.series, hoverRect, pick2);
    if (keyboardEvent != null && this.hoverDevice === "keyboard") {
      this.tooltip.lastHover = void 0;
      this.highlight.appliedHoverEvent = void 0;
      this.highlight.pendingHoverEvent = void 0;
      this.highlight.stashedHoverEvent = void 0;
      const tooltipContent = this.getTooltipContent(focus.series, datum.datumIndex, datum, "aria-label");
      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, focus.series, datum, pick2.movedBounds);
      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
      if (this.isTooltipEnabled(focus.series)) {
        this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent);
      }
      this.maybeAnnouncePickedFocus(
        datumIndexDelta,
        oldDatumIndex,
        otherIndexDelta,
        oldOtherIndex,
        pick2,
        tooltipContent
      );
    }
    return 0 /* SUCCESS */;
  }
  maybeAnnouncePickedFocus(datumIndexDelta, oldDatumIndex, otherIndexDelta, oldOtherIndex, pick2, tooltipContent) {
    const { focus } = this;
    let mode;
    if (this.announceMode === "when-changed") {
      const shouldAnnouncePick = datumIndexDelta === 0 && otherIndexDelta === 0 || oldDatumIndex !== pick2.datumIndex || oldOtherIndex !== (pick2.otherIndex ?? focus.seriesIndex);
      if (shouldAnnouncePick) {
        mode = "always";
      } else {
        mode = "never";
      }
    } else {
      mode = this.announceMode;
    }
    if (mode === "always") {
      this.swapChain.update(this.getDatumAriaText(pick2.datum, tooltipContent));
    }
  }
  getDatumAriaText(datum, tooltipContent) {
    const description = tooltipContent == null ? "" : tooltipContentAriaLabel(tooltipContent);
    return this.chart.ctx.localeManager.t("ariaAnnounceHoverDatum", {
      datum: datum.series.getDatumAriaText?.(datum, description) ?? description
    });
  }
  clearHighlight() {
    this.highlight.pendingHoverEvent = void 0;
    this.highlight.appliedHoverEvent = void 0;
    this.chart.ctx.highlightManager.updateHighlight(this.id);
  }
  clearTooltip() {
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.tooltip.lastHover = void 0;
  }
  clearAll() {
    this.clearHighlight();
    this.clearTooltip();
    this.focusIndicator?.clear();
  }
  handleHoverHighlight(redisplay) {
    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;
    this.highlight.pendingHoverEvent = void 0;
    const event = this.highlight.appliedHoverEvent;
    if (!event || !this.isState(41 /* Clickable */))
      return;
    const { currentX, currentY } = event;
    const canvasX = event.currentX + (this.hoverRect?.x ?? 0);
    const canvasY = event.currentY + (this.hoverRect?.y ?? 0);
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {
      this.clearHighlight();
      return;
    }
    const { range: range4 } = this.chart.highlight;
    const intent = range4 === "tooltip" ? "highlight-tooltip" : "highlight";
    const pick2 = this.pickNodes({ x: currentX, y: currentY }, intent);
    if (!pick2 || pick2.matches.length === 0) {
      this.chart.ctx.highlightManager.updateHighlight(this.id);
      return;
    }
    const { current: tooltipPick } = this.tooltipCandidates;
    const tooltipMatch = tooltipPick == null ? void 0 : pick2.matches.find((m) => pickedNodesEqual(m, tooltipPick));
    const datum = tooltipMatch?.datum ?? pick2.matches[0].datum;
    this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
    this.hoverDevice = "pointer";
  }
  handleHoverTooltip(event, redisplay) {
    const { current: previousHover } = this.tooltipCandidates;
    this.tooltipCandidates.reset();
    if (!this.isState(41 /* Clickable */))
      return;
    const { currentX, currentY } = event;
    const canvasX = currentX + (this.hoverRect?.x ?? 0);
    const canvasY = currentY + (this.hoverRect?.y ?? 0);
    const targetElement = event.sourceEvent.target;
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {
      if (this.hoverDevice == "pointer")
        this.clearTooltip();
      return;
    }
    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, "canvas-overlay", DEFAULT_TOOLTIP_CLASS)) {
      return;
    }
    const pick2 = this.pickNodes({ x: event.currentX, y: event.currentY }, "tooltip");
    if (!pick2 || pick2.matches.length === 0) {
      if (this.hoverDevice == "pointer")
        this.clearTooltip();
      return;
    }
    this.hoverDevice = "pointer";
    if (pick2.distance === 0) {
      const { current, index, length: length2 } = this.tooltipCandidates.update(
        pick2.matches,
        this.chart.tooltip.pagination ? previousHover : void 0
      );
      this.showTooltip(current, canvasX, canvasY, { index, length: length2 });
    } else {
      this.showTooltip(pick2.matches[0], canvasX, canvasY);
    }
  }
  showTooltip({ series, datum, datumIndex }, canvasX, canvasY, pagination) {
    const tooltipContent = this.getTooltipContent(series, datumIndex, datum, "tooltip");
    const shouldUpdateTooltip = tooltipContent != null;
    if (shouldUpdateTooltip) {
      const meta = TooltipManager.makeTooltipMeta(
        { type: "pointermove", canvasX, canvasY },
        series,
        datum,
        void 0
      );
      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent, pagination);
    } else {
      this.chart.ctx.tooltipManager.removeTooltip(this.id);
    }
  }
  maybeEnterInteractiveTooltip(event) {
    return this.chart.tooltip.maybeEnterInteractiveTooltip(event, () => {
      this.tooltip.lastHover = void 0;
      this.chart.ctx.tooltipManager.removeTooltip(this.id);
      this.chart.ctx.highlightManager.updateHighlight(this.id);
    });
  }
  changeHighlightDatum(event) {
    const lastSeries = event.previousHighlight?.series;
    const newSeries = event.currentHighlight?.series;
    if (lastSeries?.properties.cursor && event.previousHighlight?.datum) {
      this.chart.ctx.domManager.updateCursor(lastSeries.id);
    }
    if (newSeries?.properties.cursor && newSeries.properties.cursor !== "default" && event.currentHighlight?.datum) {
      this.chart.ctx.domManager.updateCursor(newSeries.id, newSeries.properties.cursor);
    }
    if (newSeries == null || lastSeries == null) {
      this.update(5 /* SERIES_UPDATE */);
    } else {
      this.update(5 /* SERIES_UPDATE */, {
        seriesToUpdate: new Set([lastSeries, newSeries].filter(Boolean))
      });
    }
  }
  pickNodes(point, intent, exactMatchOnly) {
    const reverseSeries = [...this.series].reverse();
    let result;
    for (const series of reverseSeries) {
      if (!series.visible || !series.contentGroup.visible)
        continue;
      const pick2 = series.pickNodes(point, intent, exactMatchOnly);
      if (pick2 == null || pick2.datums.length === 0)
        continue;
      const { datums, distance: distance2 } = pick2;
      if (pick2.datums.length === 0)
        continue;
      if (distance2 === 0) {
        if (result?.distance !== 0) {
          result = { matches: [], distance: 0 };
        }
        for (const datum of datums) {
          const { datumIndex } = datum;
          result.matches.push({ series, datum, datumIndex });
        }
      } else if (result == null || result.distance > distance2) {
        const [datum] = datums;
        const { datumIndex } = datum;
        result = { matches: [{ series, datum, datumIndex }], distance: distance2 };
      }
    }
    return result;
  }
  isTooltipEnabled(series) {
    return series.tooltipEnabled ?? this.chart.tooltip.enabled;
  }
  getTooltipContent(series, datumIndex, datum, purpose) {
    let result;
    if (purpose === "aria-label" || this.isTooltipEnabled(series)) {
      const { cachedTooltipContent } = this;
      if (cachedTooltipContent != null && cachedTooltipContent.series === series && cachedTooltipContent.datumIndex === datumIndex) {
        result = cachedTooltipContent.content;
      } else {
        const content = this.chart.getTooltipContent(series, datumIndex, datum);
        this.cachedTooltipContent = { series, datumIndex, content };
        result = content;
      }
      purpose;
      result;
    } else {
      this.cachedTooltipContent = void 0;
      purpose;
      result;
    }
    return result;
  }
};
function excludesType(obj, excluded) {
  return obj.type !== excluded;
}

// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
var SeriesLayerManager = class {
  constructor(seriesRoot) {
    this.seriesRoot = seriesRoot;
    this.groups = /* @__PURE__ */ new Map();
    this.series = /* @__PURE__ */ new Map();
    this.expectedSeriesCount = 1;
    this.mode = "normal";
  }
  setSeriesCount(count) {
    this.expectedSeriesCount = count;
  }
  getGroupIndex(seriesConfig) {
    const { internalId, seriesGrouping } = seriesConfig;
    return seriesGrouping?.groupIndex ?? internalId;
  }
  getGroupType(seriesConfig, bringToFront) {
    return bringToFront ? "top" : seriesConfig.type;
  }
  requestGroup(seriesConfig) {
    const { internalId, contentGroup: seriesContentGroup } = seriesConfig;
    const bringToFront = seriesConfig.bringToFront();
    const type = this.getGroupType(seriesConfig, bringToFront);
    const groupIndex = this.getGroupIndex(seriesConfig);
    const seriesInfo = this.series.get(internalId);
    if (seriesInfo != null) {
      throw new Error(`AG Charts - series already has an allocated layer: ${JSON.stringify(seriesInfo)}`);
    }
    if (this.series.size === 0) {
      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
    }
    let group = this.groups.get(type);
    if (group == null) {
      group = /* @__PURE__ */ new Map();
      this.groups.set(type, group);
    }
    const lookupIndex = this.lookupIdx(groupIndex);
    let groupInfo = group.get(lookupIndex);
    if (groupInfo == null) {
      groupInfo = {
        type,
        id: lookupIndex,
        seriesIds: [],
        group: this.seriesRoot.appendChild(
          new Group({
            name: `${seriesConfig.contentGroup.name ?? type}-managed-layer`,
            zIndex: seriesConfig.contentGroup.zIndex,
            // Set in updateLayerCompositing
            renderToOffscreenCanvas: false
          })
        )
      };
      group.set(lookupIndex, groupInfo);
    }
    this.series.set(internalId, { layerState: groupInfo, seriesConfig, bringToFront });
    groupInfo.seriesIds.push(internalId);
    groupInfo.group.appendChild(seriesContentGroup);
    return groupInfo.group;
  }
  changeGroup(seriesConfig) {
    const { internalId, contentGroup } = seriesConfig;
    const bringToFront = seriesConfig.bringToFront();
    const type = this.getGroupType(seriesConfig, bringToFront);
    const oldGroup = this.series.get(internalId);
    const oldType = oldGroup ? this.getGroupType(oldGroup.seriesConfig, oldGroup.bringToFront) : void 0;
    const groupIndex = this.getGroupIndex(seriesConfig);
    const lookupIndex = this.lookupIdx(groupIndex);
    const groupInfo = this.groups.get(type)?.get(lookupIndex);
    if (oldType === type && groupInfo?.seriesIds.includes(internalId) === true) {
      return;
    }
    if (this.series.has(internalId)) {
      this._releaseGroup({ internalId, contentGroup, type: oldType });
    }
    return this.requestGroup(seriesConfig);
  }
  releaseGroup(seriesConfig) {
    const { internalId, contentGroup } = seriesConfig;
    const type = this.getGroupType(seriesConfig, seriesConfig.bringToFront());
    this._releaseGroup({ internalId, contentGroup, type });
  }
  _releaseGroup(seriesConfig) {
    const { internalId, contentGroup, type } = seriesConfig;
    if (!this.series.has(internalId)) {
      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);
    }
    const groupInfo = this.series.get(internalId)?.layerState;
    if (groupInfo) {
      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);
      groupInfo.group.removeChild(contentGroup);
    }
    if (groupInfo?.seriesIds.length === 0) {
      this.seriesRoot.removeChild(groupInfo.group);
      this.groups.get(groupInfo.type)?.delete(groupInfo.id);
      this.groups.get(type)?.delete(internalId);
    } else if (groupInfo != null && groupInfo.seriesIds.length > 0) {
      groupInfo.group.zIndex = this.getLowestSeriesZIndex(groupInfo.seriesIds);
    }
    this.series.delete(internalId);
  }
  updateLayerCompositing() {
    this.groups.forEach((groups) => {
      groups.forEach((groupInfo) => {
        const { group, seriesIds } = groupInfo;
        let renderToOffscreenCanvas;
        if (seriesIds.length === 0) {
          renderToOffscreenCanvas = false;
        } else if (seriesIds.length > 1) {
          renderToOffscreenCanvas = true;
        } else {
          const series = this.series.get(seriesIds[0]);
          renderToOffscreenCanvas = series?.seriesConfig.renderToOffscreenCanvas() === true;
        }
        group.renderToOffscreenCanvas = renderToOffscreenCanvas;
        group.zIndex = this.getLowestSeriesZIndex(seriesIds);
      });
    });
  }
  lookupIdx(groupIndex) {
    if (this.mode === "normal") {
      return groupIndex;
    }
    if (typeof groupIndex === "string") {
      groupIndex = Number(groupIndex.split("-").at(-1));
      if (!Number.isFinite(groupIndex)) {
        return 0;
      }
    }
    return Math.floor(
      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION
    );
  }
  destroy() {
    this.groups.forEach((groups) => {
      groups.forEach((groupInfo) => {
        this.seriesRoot.removeChild(groupInfo.group);
      });
    });
    this.groups.clear();
    this.series.clear();
  }
  getLowestSeriesZIndex(seriesIds) {
    let lowestSeriesZIndex = void 0;
    for (const seriesId of seriesIds) {
      const series = this.series.get(seriesId);
      const zIndex = series?.seriesConfig.contentGroup.zIndex ?? 1 /* ANY_CONTENT */;
      if (lowestSeriesZIndex == null || zIndex == null) {
        lowestSeriesZIndex = zIndex;
        continue;
      }
      lowestSeriesZIndex = compareZIndex(lowestSeriesZIndex, zIndex) <= 0 ? lowestSeriesZIndex : zIndex;
    }
    return lowestSeriesZIndex ?? 1 /* ANY_CONTENT */;
  }
};

// packages/ag-charts-community/src/chart/touch.ts
var Touch = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.dragAction = "drag";
  }
};
__decorateClass([
  Property
], Touch.prototype, "dragAction", 2);

// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts
var DataWindowProcessor = class {
  constructor(chart, eventsHub, dataService, updateService, zoomManager, animationManager) {
    this.chart = chart;
    this.eventsHub = eventsHub;
    this.dataService = dataService;
    this.updateService = updateService;
    this.zoomManager = zoomManager;
    this.animationManager = animationManager;
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    this.lastAxisZooms = /* @__PURE__ */ new Map();
    this.cleanup = new CleanupRegistry();
    this.cleanup.register(
      this.eventsHub.on("data:source-change", () => this.onDataSourceChange()),
      this.eventsHub.on("data:load", () => this.onDataLoad()),
      this.eventsHub.on("data:error", () => this.onDataError()),
      this.updateService.addListener("update-complete", (e) => this.onUpdateComplete(e)),
      this.eventsHub.on("zoom:change", () => this.onZoomChange())
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  onDataLoad() {
    this.animationManager.skip();
    this.updateService.update(1 /* UPDATE_DATA */);
  }
  onDataError() {
    this.updateService.update(4 /* PERFORM_LAYOUT */);
  }
  onDataSourceChange() {
    this.dirtyDataSource = true;
  }
  onUpdateComplete(event) {
    if (!event.apiUpdate && !this.dirtyZoom && !this.dirtyDataSource)
      return;
    this.updateWindow(event);
  }
  onZoomChange() {
    this.dirtyZoom = true;
  }
  updateWindow(event) {
    if (!this.dataService.isLazy())
      return;
    const axis = this.getValidAxis();
    let window2;
    let shouldRefresh = true;
    if (axis) {
      const zoom = this.zoomManager.getAxisZoom(axis.id);
      if (zoom.min !== 0 || zoom.max !== 1) {
        window2 = this.getAxisWindow(axis, zoom);
      }
      shouldRefresh = this.shouldRefresh(event, axis, zoom);
    }
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    if (!shouldRefresh)
      return;
    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });
  }
  getValidAxis() {
    return this.chart.axes.find((axis) => axis.type === "time");
  }
  shouldRefresh(event, axis, zoom) {
    if (event.apiUpdate)
      return true;
    if (this.dirtyDataSource)
      return true;
    if (!this.dirtyZoom)
      return false;
    const lastZoom = this.lastAxisZooms.get(axis.id);
    if (lastZoom && zoom.min === lastZoom.min && zoom.max === lastZoom.max) {
      return false;
    }
    this.lastAxisZooms.set(axis.id, zoom);
    return true;
  }
  getAxisWindow(axis, zoom) {
    const { domain } = axis.scale;
    if (!zoom || domain.length === 0 || isNaN(Number(domain[0])))
      return;
    const diff8 = Number(domain[1]) - Number(domain[0]);
    const min = new Date(Number(domain[0]) + diff8 * zoom.min);
    const max = new Date(Number(domain[0]) + diff8 * zoom.max);
    return { min, max };
  }
};

// packages/ag-charts-community/src/util/browser.ts
var isSafariRegexp = /^((?!chrome|android).)*safari/i;
var safariVersionRegexp = /Version\/(\d+(\.\d+)?)/;
var isChromeRegexp = /Chrome/;
var chromeVersionRegexp = /Chrome\/(\d+)/;
var isEdge = /Edg/;
var isOpera = /OPR/;
function isUnsupportedBrowser() {
  const { userAgent } = getWindow("navigator");
  if (isSafariRegexp.test(userAgent)) {
    const versionExec = safariVersionRegexp.exec(userAgent);
    if (versionExec == null)
      return false;
    const version = parseFloat(versionExec[1]);
    const supported = Math.floor(version) > 16;
    if (!supported) {
      logger_exports.warnOnce(`Unsupported Safari version: ${version}; ${userAgent}`);
    }
    return !supported;
  } else if (isChromeRegexp.test(userAgent) && !isEdge.test(userAgent) && !isOpera.test(userAgent)) {
    const versionExec = chromeVersionRegexp.exec(userAgent);
    if (versionExec == null)
      return false;
    const version = parseInt(versionExec[1], 10);
    const supported = version > 126;
    if (!supported) {
      logger_exports.warnOnce(`Unsupported Chrome version: ${version}; ${userAgent}`);
    }
    return !supported;
  }
  return false;
}

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var visibleIgnoredSeries = /* @__PURE__ */ new Set(["map-shape-background", "map-line-background"]);
var OverlaysProcessor = class {
  constructor(chartLike, overlays, eventsHub, dataService, localeManager, animationManager, domManager) {
    this.chartLike = chartLike;
    this.overlays = overlays;
    this.eventsHub = eventsHub;
    this.dataService = dataService;
    this.localeManager = localeManager;
    this.animationManager = animationManager;
    this.domManager = domManager;
    this.cleanup = new CleanupRegistry();
    this.overlayElem = this.domManager.addChild("canvas-overlay", "overlay");
    this.overlayElem.role = "status";
    this.overlayElem.ariaAtomic = "false";
    this.overlayElem.ariaLive = "polite";
    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);
    this.cleanup.register(this.eventsHub.on("layout:complete", (e) => this.onLayoutComplete(e)));
  }
  destroy() {
    this.cleanup.flush();
    this.domManager.removeChild("canvas-overlay", "overlay");
  }
  onLayoutComplete({ series: { rect } }) {
    const isLoading = this.dataService.isLoading();
    const hasData = this.chartLike.series.some((s) => s.hasData);
    const anySeriesVisible = this.chartLike.series.some((s) => s.visible && !visibleIgnoredSeries.has(s.type));
    if (this.overlays.darkTheme) {
      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);
    } else {
      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);
    }
    this.overlayElem.style.left = `${rect.x}px`;
    this.overlayElem.style.top = `${rect.y}px`;
    this.overlayElem.style.width = `${rect.width}px`;
    this.overlayElem.style.height = `${rect.height}px`;
    const loadingShown = isLoading;
    const noDataShown = !isLoading && !hasData;
    const noVisibleSeriesShown = hasData && !anySeriesVisible;
    const unsupportedBrowser = this.overlays.unsupportedBrowser.enabled && isUnsupportedBrowser();
    if (loadingShown) {
      this.showOverlay(this.overlays.loading, rect);
    } else {
      this.hideOverlay(this.overlays.loading);
    }
    if (noDataShown) {
      this.showOverlay(this.overlays.noData, rect);
    } else {
      this.hideOverlay(this.overlays.noData);
    }
    if (noVisibleSeriesShown) {
      this.showOverlay(this.overlays.noVisibleSeries, rect);
    } else {
      this.hideOverlay(this.overlays.noVisibleSeries);
    }
    if (unsupportedBrowser) {
      this.showOverlay(this.overlays.unsupportedBrowser, rect);
    } else {
      this.hideOverlay(this.overlays.unsupportedBrowser);
    }
    const shown = loadingShown || noDataShown || noVisibleSeriesShown || unsupportedBrowser;
    setAttribute(this.overlayElem, "aria-hidden", !shown);
  }
  showOverlay(overlay, seriesRect) {
    if (!overlay.enabled)
      return;
    const element2 = overlay.getElement(this.chartLike, this.animationManager, this.localeManager, seriesRect);
    this.overlayElem.appendChild(element2);
  }
  hideOverlay(overlay) {
    overlay.removeElement(() => {
      this.overlayElem.innerText = "\xA0";
    }, this.animationManager);
  }
};

// packages/ag-charts-community/src/chart/chart.ts
var debug = Debug.create(true, "opts");
var _Chart = class _Chart extends Observable {
  constructor(options, resources) {
    var _a;
    super();
    this.id = createId(this);
    this.seriesRoot = new TranslatableGroup({
      name: `${this.id}-series-root`,
      zIndex: 7 /* SERIES_LAYER */
    });
    this.annotationRoot = new TranslatableGroup({
      name: `${this.id}-annotation-root`,
      zIndex: 11 /* SERIES_ANNOTATION */
    });
    this.titleGroup = new Group({
      name: "titles",
      zIndex: 15 /* SERIES_LABEL */
    });
    this.debug = Debug.create();
    this.extraDebugStats = {};
    this.data = [];
    this._firstAutoSize = true;
    this._autoSizeNotify = new AsyncAwaitQueue();
    this.chartCaptions = new ChartCaptions();
    this.padding = new Padding(20);
    this.keyboard = new Keyboard();
    this.touch = new Touch();
    this.mode = "standalone";
    this.styleNonce = void 0;
    this.formatter = void 0;
    this.suppressFieldDotNotation = false;
    this.loadGoogleFonts = false;
    this.destroyed = false;
    this.cleanup = new CleanupRegistry();
    this.chartAnimationPhase = "initial";
    this.modulesManager = new ModulesManager();
    this.processors = [];
    this.queuedUserOptions = [];
    this.queuedChartOptions = [];
    this.firstApply = true;
    this.syncStatus = "init";
    // Use a wrapper to comply with the @typescript-eslint/unbound-method rule.
    this.fireEventWrapper = (event) => super.fireEvent(event);
    this.apiUpdate = false;
    this._pendingFactoryUpdatesCount = 0;
    this._performUpdateSkipAnimations = false;
    this._performUpdateNotify = new AsyncAwaitQueue();
    this.performUpdateType = 8 /* NONE */;
    this.runningUpdateType = 8 /* NONE */;
    this.updateShortcutCount = 0;
    this.seriesToUpdate = /* @__PURE__ */ new Set();
    this.updateMutex = new Mutex();
    this.updateRequestors = {};
    this.performUpdateTrigger = debouncedCallback(({ count }) => {
      if (this.destroyed)
        return;
      this.updateMutex.acquire(async () => {
        try {
          await this.performUpdate(count);
        } catch (error2) {
          logger_exports.error("update error", error2, error2.stack);
        }
      }).catch((e) => logger_exports.errorOnce(e));
    });
    this._performUpdateSplits = {};
    this.axes = [];
    this.series = [];
    this._cachedData = void 0;
    this.onSeriesNodeClick = (event) => {
      this.fireEvent(event);
    };
    this.onSeriesNodeDoubleClick = (event) => {
      this.fireEvent(event);
    };
    this.onSeriesVisibilityChange = (event) => {
      this.fireEvent(event);
    };
    this.seriesGroupingChanged = (event) => {
      if (!(event instanceof SeriesGroupingChangedEvent))
        return;
      const { series, seriesGrouping } = event;
      if (series.contentGroup.isRoot())
        return;
      const seriesContentNode = this.seriesLayerManager.changeGroup({
        internalId: series.internalId,
        type: series.type,
        contentGroup: series.contentGroup,
        bringToFront: () => series.bringToFront(),
        renderToOffscreenCanvas: () => series.renderToOffscreenCanvas(),
        seriesGrouping
      });
      if (seriesContentNode != null) {
        series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
      }
    };
    this.chartOptions = options;
    const scene = resources?.scene;
    const container = resources?.container ?? options.processedOptions.container ?? void 0;
    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;
    if (scene) {
      this._firstAutoSize = false;
      this._lastAutoSize = [scene.width, scene.height, scene.pixelRatio];
    }
    const root = new Group({ name: "root" });
    root.visible = false;
    root.append(this.seriesRoot);
    root.append(this.annotationRoot);
    root.append(this.titleGroup);
    this.titleGroup.append(this.title.node);
    this.titleGroup.append(this.subtitle.node);
    this.titleGroup.append(this.footnote.node);
    this.tooltip = new Tooltip();
    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);
    this.mode = options.userOptions.mode ?? this.mode;
    this.styleNonce = options.processedOptions.styleNonce;
    const ctx = this.ctx = new ChartContext(this, {
      chartType: this.getChartType(),
      scene,
      root,
      container,
      styleContainer,
      domMode: options.optionMetadata.domMode,
      withDragInterpretation: options.optionMetadata.withDragInterpretation ?? true,
      syncManager: new SyncManager(this),
      fireEvent: (event) => this.fireEvent(event),
      updateCallback: (type, opts) => this.update(type, opts),
      updateMutex: this.updateMutex
    });
    this.cleanup.register(ctx.eventsHub.on("dom:resize", () => this.parentResize(ctx.domManager.containerSize)));
    this.overlays = new ChartOverlays();
    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));
    this.processors = [
      new DataWindowProcessor(
        this,
        ctx.eventsHub,
        ctx.dataService,
        ctx.updateService,
        ctx.zoomManager,
        ctx.animationManager
      ),
      new OverlaysProcessor(
        this,
        this.overlays,
        ctx.eventsHub,
        ctx.dataService,
        ctx.localeManager,
        ctx.animationManager,
        ctx.domManager
      )
    ];
    this.highlight = new ChartHighlight();
    this.container = container;
    const moduleContext = this.getModuleContext();
    ctx.domManager.setDataBoolean("animating", false);
    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());
    this.cleanup.register(
      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {
        e.layoutBox.shrink(this.padding.toJson());
        this.chartCaptions.positionCaptions(e);
      }),
      ctx.eventsHub.on("layout:complete", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),
      ctx.eventsHub.on("data:load", (event) => {
        this.data = event.data;
      }),
      this.title.registerInteraction(moduleContext, "beforebegin"),
      this.subtitle.registerInteraction(moduleContext, "beforebegin"),
      this.footnote.registerInteraction(moduleContext, "afterend"),
      Widget.addWindowEvent("page-left", () => this.destroy()),
      ctx.animationManager.addListener("animation-frame", () => {
        this.update(7 /* SCENE_RENDER */);
      }),
      ctx.animationManager.addListener("animation-start", () => ctx.domManager.setDataBoolean("animating", true)),
      ctx.animationManager.addListener("animation-stop", () => ctx.domManager.setDataBoolean("animating", false)),
      ctx.eventsHub.on("zoom:change", () => {
        this.series.forEach((s) => s.animationState?.transition("updateData"));
        const skipAnimations = this.chartAnimationPhase !== "initial";
        this.update(4 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      })
    );
    this.parentResize(ctx.domManager.containerSize);
  }
  static getInstance(element2) {
    return _Chart.chartsInstances.get(element2);
  }
  /** NOTE: This is exposed for use by Integrated charts only. */
  get canvasElement() {
    return this.ctx.scene.canvas.element;
  }
  download(fileName, fileFormat) {
    this.ctx.scene.download(fileName, fileFormat);
  }
  getCanvasDataURL(fileFormat) {
    return this.ctx.scene.getDataURL(fileFormat);
  }
  toSVG() {
    return this.ctx.scene.toSVG();
  }
  get seriesAreaBoundingBox() {
    return this.seriesAreaManager.bbox;
  }
  getOptions() {
    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;
  }
  getChartOptions() {
    return this.queuedChartOptions.at(-1) ?? this.chartOptions;
  }
  overrideFocusVisible(visible) {
    this.seriesAreaManager.focusIndicator?.overrideFocusVisible(visible);
  }
  fireEvent(event) {
    callWithContext(this, this.fireEventWrapper, event);
  }
  initSeriesAreaDependencies() {
    const { ctx, tooltip, highlight: highlight5, overlays, seriesRoot, mode } = this;
    const chartType = this.getChartType();
    const fireEvent = this.fireEvent.bind(this);
    const getUpdateType = () => this.performUpdateType;
    const getTooltipContent = (series, datumIndex, removeThisDatum) => this.getTooltipContent(series, datumIndex, removeThisDatum);
    return {
      fireEvent,
      getUpdateType,
      getTooltipContent,
      chartType,
      ctx,
      tooltip,
      highlight: highlight5,
      overlays,
      seriesRoot,
      mode
    };
  }
  getModuleContext() {
    return this.ctx;
  }
  getTooltipContent(series, datumIndex, removeMeDatum) {
    const baseTooltipContent = series.properties.tooltip.enabled !== false ? series.getTooltipContent(datumIndex, removeMeDatum) : void 0;
    const tooltipContent = baseTooltipContent == null ? [] : [baseTooltipContent];
    if (this.tooltip.mode !== "shared" || this.series.length === 1) {
      return tooltipContent;
    }
    const categoryValue = series.getCategoryValue(datumIndex);
    if (categoryValue == null)
      return tooltipContent;
    return this.series.flatMap((s) => {
      if (s === series)
        return tooltipContent;
      if (!s.isEnabled() || s.properties.tooltip.enabled === false)
        return [];
      const seriesDatumIndex = s.datumIndexForCategoryValue(categoryValue);
      const seriesTooltipContent = seriesDatumIndex == null ? void 0 : s.getTooltipContent(seriesDatumIndex, void 0);
      return seriesTooltipContent == null ? [] : [seriesTooltipContent];
    });
  }
  getCaptionText() {
    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(". ");
  }
  getAriaLabel() {
    return this.ctx.localeManager.t("ariaAnnounceChart", { seriesCount: this.series.length });
  }
  resetAnimations() {
    this.chartAnimationPhase = "initial";
    for (const series of this.series) {
      series.resetAnimation(this.chartAnimationPhase);
    }
    for (const axis of this.axes) {
      axis.resetAnimation(this.chartAnimationPhase);
    }
    this.animationRect = void 0;
    this.ctx.animationManager.reset();
  }
  skipAnimations() {
    this.ctx.animationManager.skipCurrentBatch();
    this._performUpdateSkipAnimations = true;
  }
  detachAndClear() {
    this.container = void 0;
    this.ctx.scene.clearCanvas();
  }
  destroy(opts) {
    if (this.destroyed) {
      return;
    }
    const keepTransferableResources = opts?.keepTransferableResources;
    let result;
    this.performUpdateType = 8 /* NONE */;
    this.cleanup.flush();
    this.processors.forEach((p) => p.destroy());
    this.overlays.destroy();
    this.modulesManager.destroy();
    if (keepTransferableResources) {
      this.ctx.scene.strip();
      result = {
        container: this.container,
        scene: this.ctx.scene
      };
    } else {
      this.ctx.scene.destroy();
      this.container = void 0;
    }
    this.destroySeries(this.series);
    this.seriesLayerManager.destroy();
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this.animationRect = void 0;
    this.ctx.destroy();
    this.destroyed = true;
    Object.freeze(this);
    return result;
  }
  requestFactoryUpdate(cb) {
    if (this.destroyed)
      return;
    this._pendingFactoryUpdatesCount++;
    this.updateMutex.acquire(async () => {
      if (this.destroyed)
        return;
      try {
        await cb(this);
      } finally {
        if (!this.destroyed) {
          this._pendingFactoryUpdatesCount--;
        }
      }
    }).catch((e) => logger_exports.errorOnce(e));
  }
  clearCallbackCache() {
    this.ctx.callbackCache.invalidateCache();
    for (const series of this.series) {
      series.resetDatumCallbackCache();
    }
  }
  update(type = 0 /* FULL */, opts) {
    if (this.destroyed)
      return;
    const {
      forceNodeDataRefresh = false,
      skipAnimations,
      seriesToUpdate = this.series,
      newAnimationBatch,
      apiUpdate = false
    } = opts ?? {};
    this.apiUpdate = apiUpdate;
    this.ctx.widgets.seriesWidget.setDragTouchEnabled(this.touch.dragAction !== "none");
    if (forceNodeDataRefresh) {
      this.series.forEach((series) => series.markNodeDataDirty());
    }
    for (const series of seriesToUpdate) {
      this.seriesToUpdate.add(series);
    }
    if (skipAnimations) {
      this.ctx.animationManager.skipCurrentBatch();
      this._performUpdateSkipAnimations = true;
    }
    if (newAnimationBatch && this.ctx.animationManager.isActive()) {
      this._performUpdateSkipAnimations = true;
    }
    if (this.debug.check()) {
      let stack = new Error().stack ?? "<unknown>";
      stack = stack.replace(/\([^)]*/g, "");
      this.updateRequestors[stack] = type;
    }
    if (type < this.performUpdateType) {
      this.performUpdateType = type;
      this.ctx.domManager.setDataBoolean("updatePending", true);
      this.performUpdateTrigger.schedule(opts?.backOffMs);
    }
  }
  async performUpdate(count) {
    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;
    const seriesToUpdate = [...this.seriesToUpdate];
    this.clearCallbackCache();
    this.performUpdateType = 8 /* NONE */;
    this.seriesToUpdate.clear();
    this.runningUpdateType = performUpdateType;
    if (this.updateShortcutCount === 0 && performUpdateType < 7 /* SCENE_RENDER */) {
      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);
      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = "ready");
    }
    this.ctx.scene.updateDebugFlags();
    this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
    let previousSplit = performance.now();
    splits.start ?? (splits.start = previousSplit);
    const updateSplits = (splitName) => {
      splits[splitName] ?? (splits[splitName] = 0);
      splits[splitName] += performance.now() - previousSplit;
      previousSplit = performance.now();
    };
    switch (performUpdateType) {
      case 0 /* FULL */:
        if (this.checkUpdateShortcut(0 /* FULL */))
          break;
        this.ctx.updateService.dispatchPreDomUpdate();
        this.updateDOM();
      case 1 /* UPDATE_DATA */:
        if (this.checkUpdateShortcut(1 /* UPDATE_DATA */))
          break;
        await this.updateData();
        updateSplits("\u2B07\uFE0F");
      case 2 /* PROCESS_DATA */:
        if (this.checkUpdateShortcut(2 /* PROCESS_DATA */))
          break;
        await this.processData();
        this.seriesAreaManager.dataChanged();
        updateSplits("\u{1F3ED}");
      case 3 /* PROCESS_DOMAIN */:
        if (this.checkUpdateShortcut(3 /* PROCESS_DOMAIN */))
          break;
        await this.processDomains();
        updateSplits("\u26F0\uFE0F");
      case 4 /* PERFORM_LAYOUT */:
        await this.checkFirstAutoSize();
        if (this.checkUpdateShortcut(4 /* PERFORM_LAYOUT */))
          break;
        await this.processLayout();
        updateSplits("\u2316");
      case 5 /* SERIES_UPDATE */: {
        if (this.checkUpdateShortcut(5 /* SERIES_UPDATE */))
          break;
        await this.updateSeries(seriesToUpdate);
        updateSplits("\u{1F914}");
        this.updateAriaLabels();
        this.seriesLayerManager.updateLayerCompositing();
      }
      case 6 /* PRE_SCENE_RENDER */:
        if (this.checkUpdateShortcut(6 /* PRE_SCENE_RENDER */))
          break;
        ctx.updateService.dispatchPreSceneRender();
        updateSplits("\u2196");
      case 7 /* SCENE_RENDER */:
        if (this.checkUpdateShortcut(7 /* SCENE_RENDER */))
          break;
        ctx.animationManager.endBatch();
        extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
        ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });
        this.extraDebugStats = {};
        for (const key of Object.keys(splits)) {
          delete splits[key];
        }
        this.ctx.domManager.incrementDataCounter("sceneRenders");
        this.ctx.domManager.postRenderUpdate();
      case 8 /* NONE */:
        this.updateShortcutCount = 0;
        this.updateRequestors = {};
        this._performUpdateSkipAnimations = false;
        ctx.animationManager.endBatch();
    }
    if (!this.destroyed) {
      ctx.updateService.dispatchUpdateComplete(this.apiUpdate);
      this.apiUpdate = false;
      this.ctx.domManager.setDataBoolean("updatePending", false);
      this.runningUpdateType = 8 /* NONE */;
      this.syncStatus = "ready";
    }
    this._performUpdateNotify.notify();
    const end2 = performance.now();
    this.debug("Chart.performUpdate() - end", {
      chart: this,
      durationMs: Math.round((end2 - splits["start"]) * 100) / 100,
      count,
      performUpdateType: ChartUpdateType[performUpdateType]
    });
  }
  updateThemeClassName() {
    const themeClassNamePrefix = "ag-charts-theme-";
    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];
    let themeClassName = validThemeClassNames[0];
    let isDark = false;
    let { theme } = this.chartOptions.processedOptions;
    while (typeof theme !== "string" && theme != null) {
      theme = theme.baseTheme;
    }
    if (typeof theme === "string") {
      themeClassName = theme.replace("ag-", themeClassNamePrefix);
      isDark = theme.includes("-dark");
    }
    if (!validThemeClassNames.includes(themeClassName)) {
      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];
    }
    this.ctx.domManager.setThemeClass(themeClassName);
  }
  updateDOM() {
    this.updateThemeClassName();
    const { enabled, tabIndex } = this.keyboard;
    this.ctx.domManager.setTabGuardIndex(enabled ? tabIndex ?? 0 : -1);
    this.ctx.domManager.setThemeParameters(this.chartOptions.themeParameters);
  }
  updateAriaLabels() {
    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());
  }
  checkUpdateShortcut(checkUpdateType) {
    const maxShortcuts = 3;
    if (this.destroyed)
      return true;
    if (this.updateShortcutCount > maxShortcuts) {
      logger_exports.warn(
        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,
        this.updateRequestors
      );
      return false;
    }
    if (this.performUpdateType <= checkUpdateType) {
      this.updateShortcutCount++;
      return true;
    }
    return false;
  }
  async checkFirstAutoSize() {
    if (this.width != null && this.height != null) {
    } else if (!this._lastAutoSize) {
      const success = await this._autoSizeNotify.await(500);
      if (!success) {
        this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
      }
    }
  }
  onAxisChange(newValue, oldValue) {
    if (oldValue == null && newValue.length === 0)
      return;
    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);
  }
  onSeriesChange(newValue, oldValue) {
    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];
    this.destroySeries(seriesToDestroy);
    this.seriesLayerManager?.setSeriesCount(newValue.length);
    for (const series of newValue) {
      if (oldValue?.includes(series))
        continue;
      const seriesContentNode = this.seriesLayerManager.requestGroup(series);
      series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
      const chart = this;
      series.chart = {
        get mode() {
          return chart.mode;
        },
        get isMiniChart() {
          return false;
        },
        get seriesRect() {
          return chart.seriesRect;
        }
      };
      series.resetAnimation(this.chartAnimationPhase);
      this.addSeriesListeners(series);
      series.addChartEventListeners();
    }
    this.seriesAreaManager?.seriesChanged(newValue);
  }
  destroySeries(allSeries) {
    allSeries?.forEach((series) => {
      series.removeEventListener("seriesNodeClick", this.onSeriesNodeClick);
      series.removeEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
      series.removeEventListener("groupingChanged", this.seriesGroupingChanged);
      series.destroy();
      this.seriesLayerManager.releaseGroup(series);
      series.detachSeries(void 0, this.seriesRoot, this.annotationRoot);
      series.chart = void 0;
    });
  }
  addSeriesListeners(series) {
    if (this.hasEventListener("seriesNodeClick")) {
      series.addEventListener("seriesNodeClick", this.onSeriesNodeClick);
    }
    if (this.hasEventListener("seriesNodeDoubleClick")) {
      series.addEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
    }
    if (this.hasEventListener("seriesVisibilityChange")) {
      series.addEventListener("seriesVisibilityChange", this.onSeriesVisibilityChange);
    }
    series.addEventListener("groupingChanged", this.seriesGroupingChanged);
  }
  assignSeriesToAxes() {
    for (const axis of this.axes) {
      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);
    }
  }
  assignAxesToSeries() {
    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);
    for (const series of this.series) {
      for (const direction of series.directions) {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          logger_exports.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = directionAxes.find(
          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))
        );
        if (!newAxis) {
          logger_exports.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      }
    }
  }
  parentResize(size) {
    if (size == null || this.width != null && this.height != null)
      return;
    let { width: width2, height: height2 } = size;
    const { pixelRatio } = size;
    width2 = Math.floor(width2);
    height2 = Math.floor(height2);
    if (width2 === 0 && height2 === 0)
      return;
    const [autoWidth = 0, autoHeight = 0, autoPixelRatio = 1] = this._lastAutoSize ?? [];
    if (autoWidth === width2 && autoHeight === height2 && autoPixelRatio === pixelRatio)
      return;
    this._lastAutoSize = [width2, height2, pixelRatio];
    this.resize("SizeMonitor", {});
  }
  resize(source, opts) {
    const { scene, animationManager } = this.ctx;
    const { inWidth, inHeight, inMinWidth, inMinHeight, inOverrideDevicePixelRatio } = opts;
    this.ctx.domManager.setSizeOptions(
      inMinWidth ?? this.minWidth,
      inMinHeight ?? this.minHeight,
      inWidth ?? this.width,
      inHeight ?? this.height
    );
    const width2 = inWidth ?? this.width ?? this._lastAutoSize?.[0];
    const height2 = inHeight ?? this.height ?? this._lastAutoSize?.[1];
    const pixelRatio = inOverrideDevicePixelRatio ?? this.overrideDevicePixelRatio ?? this._lastAutoSize?.[2];
    this.debug(`Chart.resize() from ${source}`, { width: width2, height: height2, pixelRatio, stack: new Error().stack });
    if (width2 == null || height2 == null || !isFiniteNumber(width2) || !isFiniteNumber(height2))
      return;
    if (scene.resize(width2, height2, pixelRatio)) {
      animationManager.reset();
      let skipAnimations = true;
      if ((this.width == null || this.height == null) && this._firstAutoSize) {
        skipAnimations = false;
        this._firstAutoSize = false;
      }
      this.update(4 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      this._autoSizeNotify.notify();
    }
  }
  async updateData() {
    this.series.forEach((s) => s.setChartData(this.data));
    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));
    await Promise.all(modulePromises);
  }
  async processData() {
    if (this.series.some((s) => s.canHaveAxes)) {
      this.assignAxesToSeries();
      this.assignSeriesToAxes();
    }
    const dataController = new DataController(this.mode, this.suppressFieldDotNotation);
    const seriesPromises = this.series.map((s) => s.processData(dataController));
    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));
    this._cachedData = dataController.execute(this._cachedData);
    await Promise.all([...seriesPromises, ...modulePromises]);
    this.updateLegends();
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async processDomains() {
    for (const axis of this.axes) {
      axis.processData();
    }
    for (const series of this.series) {
      series.updatedDomains();
    }
  }
  updateLegends(initialStateLegend) {
    for (const { legend, legendType } of this.modulesManager.legends()) {
      if (legendType === "category") {
        this.setCategoryLegendData(initialStateLegend);
      } else {
        this.setLegendData(legendType, legend);
      }
    }
  }
  setCategoryLegendData(initialState) {
    var _a;
    const {
      ctx: { legendManager, stateManager }
    } = this;
    if (initialState) {
      this.series.forEach((s) => {
        const seriesState = initialState.find((init) => init.seriesId === s.id);
        s.onLegendInitialState("category", seriesState);
      });
    }
    const legendData = this.series.flatMap((s) => {
      const seriesLegendData = s.getLegendData("category");
      legendManager.updateData(s.id, seriesLegendData);
      return seriesLegendData;
    });
    if (initialState) {
      stateManager.setStateAndRestore(legendManager, initialState);
      return;
    }
    if (this.mode !== "integrated") {
      const seriesMarkerFills = {};
      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));
      for (const {
        seriesId,
        symbol: { marker },
        label
      } of legendData.filter((d) => !d.hideInLegend)) {
        if (marker.fill == null)
          continue;
        const seriesType = seriesTypeMap.get(seriesId);
        const markerFill = seriesMarkerFills[seriesType] ?? (seriesMarkerFills[seriesType] = {});
        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);
        if (markerFill[label.text] !== marker.fill) {
          logger_exports.warnOnce(
            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`
          );
        }
      }
    }
    legendManager.update();
  }
  setLegendData(legendType, legend) {
    legend.data = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));
  }
  async processLayout() {
    const oldRect = this.animationRect;
    const { width: width2, height: height2 } = this.ctx.scene;
    const ctx = this.ctx.layoutManager.createContext(width2, height2);
    await this.performLayout(ctx);
    if (oldRect && !this.animationRect?.equals(oldRect)) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
  }
  async updateSeries(seriesToUpdate) {
    const { seriesRect } = this;
    await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));
    this.ctx.seriesLabelLayoutManager.updateLabels(
      this.series.filter((s) => s.visible && s.usesPlacedLabels),
      this.padding,
      this.seriesRect
    );
  }
  async waitForUpdate(timeoutMs, failOnTimeout) {
    const agChartsDebugTimeout = getWindow("agChartsDebugTimeout");
    if (agChartsDebugTimeout == null) {
      timeoutMs ?? (timeoutMs = 1e5);
      failOnTimeout ?? (failOnTimeout = false);
    } else {
      timeoutMs = agChartsDebugTimeout;
      failOnTimeout ?? (failOnTimeout = true);
    }
    const start2 = performance.now();
    while (this._pendingFactoryUpdatesCount > 0 || this.performUpdateType !== 8 /* NONE */ || this.runningUpdateType !== 8 /* NONE */ || this.ctx.scene.waitingForUpdate()) {
      if (this.destroyed)
        break;
      if (this._pendingFactoryUpdatesCount > 0) {
        await this.updateMutex.waitForClearAcquireQueue();
      }
      if (this.performUpdateType !== 8 /* NONE */ || this.runningUpdateType !== 8 /* NONE */) {
        await this._performUpdateNotify.await();
      }
      if (performance.now() - start2 > timeoutMs) {
        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;
        if (failOnTimeout) {
          throw new Error(message);
        } else {
          logger_exports.warnOnce(message);
        }
      }
      if (isInputPending()) {
        await pause();
      }
      if (this.ctx.scene.waitingForUpdate()) {
        await pause(50);
      }
    }
  }
  filterMiniChartSeries(series) {
    return series?.filter((s) => s.showInMiniChart !== false);
  }
  applyOptions(newChartOptions) {
    const minimumUpdateType = 4 /* PERFORM_LAYOUT */;
    const deltaOptions = this.firstApply ? newChartOptions.processedOptions : newChartOptions.diffOptions(this.chartOptions);
    if (deltaOptions == null || Object.keys(deltaOptions).length === 0) {
      debug("Chart.applyOptions() - no delta, forcing re-layout", deltaOptions);
      this.update(minimumUpdateType, { apiUpdate: true, newAnimationBatch: true });
      return;
    }
    const oldOpts = this.firstApply ? {} : this.chartOptions.processedOptions;
    const newOpts = newChartOptions.processedOptions;
    debug("Chart.applyOptions() - applying delta", deltaOptions);
    const modulesChanged = this.applyModules(newOpts);
    const skip = [
      "type",
      "data",
      "series",
      "listeners",
      "preset",
      "theme",
      "legend.listeners",
      "navigator.miniChart.series",
      "navigator.miniChart.label",
      "locale.localeText",
      "axes",
      "topology",
      "nodes",
      "initialState",
      "styleContainer",
      "formatter"
    ];
    if (deltaOptions.listeners) {
      this.registerListeners(this, deltaOptions.listeners);
    }
    jsonApply(this, deltaOptions, { skip });
    let forceNodeDataRefresh = false;
    let seriesStatus = "no-op";
    if (deltaOptions.series != null) {
      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);
      forceNodeDataRefresh = true;
    }
    if (seriesStatus === "replaced") {
      this.resetAnimations();
    }
    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [])) {
      forceNodeDataRefresh = true;
    }
    if (deltaOptions.data) {
      this.data = deltaOptions.data;
    }
    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled("legend")) {
      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
    }
    if (deltaOptions.locale?.localeText) {
      this.modulesManager.getModule("locale").localeText = deltaOptions.locale?.localeText;
    }
    this.chartOptions = newChartOptions;
    const navigatorModule = this.modulesManager.getModule("navigator");
    const zoomModule = this.modulesManager.getModule("zoom");
    if (!navigatorModule?.enabled && !zoomModule?.enabled) {
      this.ctx.zoomManager.updateZoom("chart");
    }
    const miniChart = navigatorModule?.miniChart;
    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;
    if (miniChart?.enabled === true && miniChartSeries != null) {
      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);
    } else if (miniChart?.enabled === false) {
      miniChart.series = [];
      miniChart.axes = [];
    }
    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);
    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));
    const majorChange = forceNodeDataRefresh || modulesChanged;
    const updateType = majorChange ? 0 /* FULL */ : minimumUpdateType;
    this.maybeResetAnimations(seriesStatus);
    if (this.shouldClearLegendData(newOpts, oldOpts, seriesStatus)) {
      this.ctx.legendManager.clearData();
    }
    this.applyInitialState(newOpts);
    this.ctx.formatManager.setFormatter(newOpts.formatter);
    debug("Chart.applyOptions() - update type", ChartUpdateType[updateType], {
      seriesStatus,
      forceNodeDataRefresh
    });
    if (newChartOptions.optionsProcessingTime !== void 0) {
      this._performUpdateSplits["\u2699\uFE0F"] = newChartOptions.optionsProcessingTime;
      const optionsStartTime = performance.now() - newChartOptions.optionsProcessingTime;
      this._performUpdateSplits.start = optionsStartTime;
    }
    this.update(updateType, { apiUpdate: true, forceNodeDataRefresh, newAnimationBatch: true });
    this.firstApply = false;
  }
  applyInitialState(options) {
    const { annotationManager, chartTypeOriginator, historyManager, stateManager, zoomManager } = this.ctx;
    const { initialState } = options;
    if ("annotations" in options && options.annotations?.enabled && initialState?.annotations != null) {
      const annotations = initialState.annotations.map((annotation) => {
        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);
        return mergeDefaults(annotation, annotationTheme);
      });
      stateManager.setState(annotationManager, annotations);
    }
    if (initialState?.chartType != null) {
      stateManager.setState(chartTypeOriginator, initialState.chartType);
    }
    if ((options.navigator?.enabled || options.zoom?.enabled) && initialState?.zoom != null) {
      stateManager.setState(zoomManager, initialState.zoom);
    }
    if (initialState?.legend != null) {
      this.updateLegends(initialState.legend);
    }
    if (initialState != null) {
      historyManager.clear();
    }
  }
  maybeResetAnimations(seriesStatus) {
    if (this.mode !== "standalone")
      return;
    switch (seriesStatus) {
      case "series-grouping-change":
      case "replaced":
        this.resetAnimations();
        break;
      default:
    }
  }
  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {
    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
    const legendKeys = legendRegistry.getKeys();
    const optionsHaveLegend = Object.values(legendKeys).some(
      (legendKey) => deltaOptions[legendKey] != null
    );
    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null || deltaOptions.formatter != null;
    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
  }
  shouldClearLegendData(options, oldOpts, seriesStatus) {
    const seriesChanged = seriesStatus === "replaced" || seriesStatus === "series-grouping-change" || seriesStatus === "updated" && (options.series?.length !== oldOpts.series?.length || !options.series?.every((s, i) => s.type === oldOpts.series?.[i].type));
    const legendRemoved = oldOpts.legend != null && options.legend == null;
    return seriesChanged || legendRemoved;
  }
  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {
    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;
    const miniChartSeriesStatus = this.applySeries(
      miniChart,
      this.filterMiniChartSeries(miniChartSeries),
      this.filterMiniChartSeries(oldSeries)
    );
    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [
      "axes[].tick",
      "axes[].thickness",
      "axes[].title",
      "axes[].crosshair",
      "axes[].gridLine",
      "axes[].label"
    ]);
    const series = miniChart.series;
    for (const s of series) {
      s.properties.id = void 0;
    }
    const axes = miniChart.axes;
    const horizontalAxis = axes.find((axis) => axis.direction === "x" /* X */);
    for (const axis of axes) {
      axis.nice = false;
      axis.gridLine.enabled = false;
      axis.label.enabled = axis === horizontalAxis;
      axis.tick.enabled = false;
      axis.interactionEnabled = false;
    }
    if (horizontalAxis != null) {
      const miniChartOpts = completeOptions.navigator?.miniChart;
      const labelOptions2 = miniChartOpts?.label;
      const intervalOptions = miniChartOpts?.label?.interval;
      horizontalAxis.line.enabled = false;
      horizontalAxis.label.set(
        without(labelOptions2, [
          "interval",
          "autoRotate",
          "autoRotateAngle",
          "itemStyler",
          "minSpacing",
          "rotation"
        ])
      );
      if (horizontalAxis.type === "grouped-category") {
        horizontalAxis.label.enabled = false;
        horizontalAxis.label.rotation = 0;
        const { depthOptions } = horizontalAxis;
        if (depthOptions.length === 0) {
          depthOptions.set([{ label: { enabled: true } }]);
        } else {
          for (let i = 1; i < depthOptions.length; i++) {
            depthOptions[i].label.enabled = false;
          }
        }
      } else if (horizontalAxis.type === "time" || horizontalAxis.type === "unit-time" || horizontalAxis.type === "ordinal-time") {
        horizontalAxis.parentLevel.enabled = false;
      }
      horizontalAxis.interval.step = intervalOptions?.step;
      horizontalAxis.interval.values = intervalOptions?.values;
      horizontalAxis.interval.minSpacing = intervalOptions?.minSpacing;
      horizontalAxis.interval.maxSpacing = intervalOptions?.maxSpacing;
    }
  }
  applyModules(options) {
    const { type: chartType } = this.constructor;
    let modulesChanged = false;
    for (const module2 of moduleRegistry.byType("root", "legend")) {
      const isConfigured = options[module2.optionsKey] != null;
      const shouldBeEnabled = isConfigured && module2.chartTypes.includes(chartType);
      if (shouldBeEnabled === this.modulesManager.isEnabled(module2))
        continue;
      if (shouldBeEnabled) {
        this.modulesManager.addModule(module2, (m) => m.moduleFactory(this.getModuleContext()));
        if (module2.type === "legend") {
          this.modulesManager.getModule(module2)?.attachLegend(this.ctx.scene);
        }
        this[module2.optionsKey] = this.modulesManager.getModule(module2);
      } else {
        this.modulesManager.removeModule(module2);
        delete this[module2.optionsKey];
      }
      modulesChanged = true;
    }
    return modulesChanged;
  }
  initSeriesDeclarationOrder(series) {
    for (let idx = 0; idx < series.length; idx++) {
      series[idx].setSeriesIndex(idx);
    }
  }
  applySeries(chart, optSeries, oldOptSeries) {
    if (!optSeries) {
      return "no-change";
    }
    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
    if (matchResult.status === "no-overlap") {
      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);
      const chartSeries = optSeries.map((opts) => this.createSeries(opts));
      this.initSeriesDeclarationOrder(chartSeries);
      chart.series = chartSeries;
      return "replaced";
    }
    debug(`Chart.applySeries() - matchResult`, matchResult);
    const seriesInstances = [];
    let dataChanged = false;
    let groupingChanged = false;
    let isUpdated = false;
    const changes = matchResult.changes.toSorted((a, b) => a.targetIdx - b.targetIdx);
    for (const change of changes) {
      groupingChanged || (groupingChanged = change.status === "series-grouping");
      dataChanged || (dataChanged = change.diff?.data != null);
      isUpdated || (isUpdated = change.status !== "no-op");
      switch (change.status) {
        case "add": {
          const newSeries = this.createSeries(change.opts);
          seriesInstances.push(newSeries);
          debug(`Chart.applySeries() - created new series`, newSeries);
          break;
        }
        case "remove":
          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);
          break;
        case "no-op":
          seriesInstances.push(change.series);
          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);
          break;
        case "series-grouping":
        case "update":
        default: {
          const { series, diff: diff8, idx } = change;
          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff8, series);
          this.applySeriesValues(series, diff8);
          series.markNodeDataDirty();
          seriesInstances.push(series);
        }
      }
    }
    this.initSeriesDeclarationOrder(seriesInstances);
    debug(`Chart.applySeries() - final series instances`, seriesInstances);
    chart.series = seriesInstances;
    if (groupingChanged) {
      return "series-grouping-change";
    }
    if (dataChanged) {
      return "data-change";
    }
    return isUpdated ? "updated" : "no-op";
  }
  applyAxes(chart, options, oldOpts, seriesStatus, skip = []) {
    if (!("axes" in options) || !options.axes) {
      return false;
    }
    skip = ["axes[].type", ...skip];
    const axes = options.axes;
    const forceRecreate = seriesStatus === "replaced";
    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);
    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
      chart.axes.forEach((axis, index) => {
        const previousOpts = oldOpts.axes?.[index] ?? {};
        const axisDiff = jsonDiff(previousOpts, axes[index]);
        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);
        const path = `axes[${index}]`;
        jsonApply(axis, axisDiff, { path, skip });
      });
      return true;
    }
    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);
    chart.axes = this.createAxis(axes, skip);
    return true;
  }
  createSeries(seriesOptions) {
    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());
    this.applySeriesOptionModules(seriesInstance, seriesOptions);
    this.applySeriesValues(seriesInstance, seriesOptions);
    return seriesInstance;
  }
  applySeriesOptionModules(series, options) {
    const moduleContext = series.createModuleContext();
    const moduleMap = series.getModuleMap();
    for (const module2 of moduleRegistry.byType("series-option")) {
      if (module2.optionsKey in options && module2.seriesTypes.includes(series.type)) {
        moduleMap.addModule(module2, (m) => m.moduleFactory(moduleContext));
      }
    }
  }
  applySeriesValues(target, options) {
    const moduleMap = target.getModuleMap();
    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;
    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {
      if (moduleDef.type !== "series-option")
        continue;
      if (moduleDef.optionsKey in seriesOptions) {
        const module2 = moduleMap.getModule(moduleDef.optionsKey);
        if (module2) {
          const moduleOptions = seriesOptions[moduleDef.optionsKey];
          delete seriesOptions[moduleDef.optionsKey];
          module2.properties.set(moduleOptions);
        }
      }
    }
    if (seriesOptions.visible != null) {
      target.visible = seriesOptions.visible;
    }
    target.properties.set(seriesOptions);
    if ("data" in options) {
      target.setOptionsData(data);
    }
    if (listeners) {
      this.registerListeners(target, listeners);
    }
    if ("seriesGrouping" in options) {
      if (seriesGrouping == null) {
        target.seriesGrouping = void 0;
      } else {
        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };
      }
    }
  }
  createAxis(options, skip) {
    const newAxes = [];
    const moduleContext = this.getModuleContext();
    for (let index = 0; index < options.length; index++) {
      const axisOptions = options[index];
      const axis = axisRegistry.create(axisOptions.type, moduleContext);
      this.applyAxisModules(axis, axisOptions);
      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });
      newAxes.push(axis);
    }
    guessInvalidPositions(newAxes);
    return newAxes;
  }
  applyAxisModules(axis, options) {
    const moduleContext = axis.createModuleContext();
    const moduleMap = axis.getModuleMap();
    for (const module2 of moduleRegistry.byType("axis-option")) {
      const shouldBeEnabled = options[module2.optionsKey] != null;
      if (shouldBeEnabled === moduleMap.isEnabled(module2))
        continue;
      if (shouldBeEnabled) {
        moduleMap.addModule(module2, (m) => m.moduleFactory(moduleContext));
        axis[module2.optionsKey] = moduleMap.getModule(module2);
      } else {
        moduleMap.removeModule(module2);
        delete axis[module2.optionsKey];
      }
    }
  }
  registerListeners(source, listeners) {
    source.clearEventListeners();
    for (const [property, listener] of entries(listeners)) {
      source.addEventListener(property, listener);
    }
  }
};
_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    newValue(value) {
      if (this.destroyed)
        return;
      this.ctx.domManager.setContainer(value);
      _Chart.chartsInstances.set(value, this);
    },
    oldValue(value) {
      _Chart.chartsInstances.delete(value);
    }
  })
], _Chart.prototype, "container", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("width option", { inWidth: value });
    }
  })
], _Chart.prototype, "width", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("height option", { inHeight: value });
    }
  })
], _Chart.prototype, "height", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minWidth option", { inMinWidth: value });
    }
  })
], _Chart.prototype, "minWidth", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minHeight option", { inMinHeight: value });
    }
  })
], _Chart.prototype, "minHeight", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("overrideDevicePixelRatio option", { inOverrideDevicePixelRatio: value });
    }
  })
], _Chart.prototype, "overrideDevicePixelRatio", 2);
__decorateClass([
  Property
], _Chart.prototype, "padding", 2);
__decorateClass([
  Property
], _Chart.prototype, "keyboard", 2);
__decorateClass([
  Property
], _Chart.prototype, "touch", 2);
__decorateClass([
  Property
], _Chart.prototype, "mode", 2);
__decorateClass([
  Property
], _Chart.prototype, "styleNonce", 2);
__decorateClass([
  ProxyProperty("chartCaptions.title")
], _Chart.prototype, "title", 2);
__decorateClass([
  ProxyProperty("chartCaptions.subtitle")
], _Chart.prototype, "subtitle", 2);
__decorateClass([
  ProxyProperty("chartCaptions.footnote")
], _Chart.prototype, "footnote", 2);
__decorateClass([
  Property
], _Chart.prototype, "formatter", 2);
__decorateClass([
  Property
], _Chart.prototype, "suppressFieldDotNotation", 2);
__decorateClass([
  Property
], _Chart.prototype, "loadGoogleFonts", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onAxisChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "axes", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "series", 2);
var Chart = _Chart;

// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts
function removeUsedEnterpriseOptions(options, silent) {
  let usedOptions = [];
  const optsType = options?.series?.[0]?.type;
  const isGaugeChart = optsType === "linear-gauge" || optsType === "radial-gauge";
  const optionsChartType = optsType ? chartTypes2.get(optsType) : "unknown";
  for (const module2 of EXPECTED_ENTERPRISE_MODULES) {
    if (optionsChartType !== "unknown" && !module2.chartTypes.includes(optionsChartType))
      continue;
    if (module2.type === "root" || module2.type === "legend") {
      const optionValue = options[module2.optionsKey];
      if (optionValue == null)
        continue;
      if (!module2.optionsInnerKey) {
        usedOptions.push(module2.optionsKey);
        delete options[module2.optionsKey];
      } else if (optionValue[module2.optionsInnerKey]) {
        usedOptions.push(`${module2.optionsKey}.${module2.optionsInnerKey}`);
        delete optionValue[module2.optionsInnerKey];
      }
    } else if (module2.type === "axis") {
      if (!("axes" in options) || !isArray(options.axes) || !options.axes?.some((axis) => axis.type === module2.identifier)) {
        continue;
      }
      usedOptions.push(`axis[type=${module2.identifier}]`);
      options.axes = options.axes.filter((axis) => axis.type !== module2.identifier);
    } else if (module2.type === "axis-option") {
      if (!("axes" in options) || !isArray(options.axes) || !options.axes?.some((axis) => axis[module2.optionsKey])) {
        continue;
      }
      usedOptions.push(`axis.${module2.optionsKey}`);
      options.axes.forEach((axis) => {
        if (axis[module2.optionsKey]) {
          delete axis[module2.optionsKey];
        }
      });
    } else if (module2.type === "series") {
      if (module2.community)
        continue;
      if (!isArray(options.series) || !options.series?.some((series) => series.type === module2.identifier)) {
        continue;
      }
      usedOptions.push(`series[type=${module2.identifier}]`);
      options.series = options.series.filter((series) => series.type !== module2.identifier);
    } else if (module2.type === "series-option") {
      if (!isArray(options.series) || !options.series?.some((series) => series[module2.optionsKey])) {
        continue;
      }
      usedOptions.push(`series.${module2.optionsKey}`);
      options.series.forEach((series) => {
        if (series[module2.optionsKey]) {
          delete series[module2.optionsKey];
        }
      });
    }
  }
  if (usedOptions.length && !silent) {
    if (isGaugeChart) {
      usedOptions = ["AgCharts.createGauge"];
    }
    let enterprisePackageName = "ag-charts-enterprise";
    let enterpriseReferenceUrl = "https://www.ag-grid.com/charts/javascript/installation/";
    if (options.mode === "integrated") {
      enterprisePackageName = "ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise";
      enterpriseReferenceUrl = "https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/";
    }
    logger_exports.warnOnce(
      [
        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,
        "",
        ...usedOptions,
        "",
        `See: ${enterpriseReferenceUrl}`
      ].join("\n")
    );
  }
}
function removeUnusedEnterpriseOptions(options) {
  const integratedMode = "mode" in options && options.mode === "integrated";
  for (const module2 of moduleRegistry.byType("root", "legend")) {
    const moduleOptions = options[module2.optionsKey];
    const isPresentAndDisabled = moduleOptions != null && moduleOptions.enabled === false;
    const removable = !("removable" in module2) || module2.removable === true || module2.removable === "standalone-only" && !integratedMode;
    if (isPresentAndDisabled && removable) {
      delete options[module2.optionsKey];
    }
  }
}

// packages/ag-charts-community/src/module/coreModulesTypes.ts
function paletteType(partial) {
  if (partial?.up || partial?.down || partial?.neutral) {
    return "user-full";
  } else if (partial?.fills || partial?.strokes) {
    return "user-indexed";
  }
  return "inbuilt";
}

// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_STROKES = {
  BLUE: "#2b5c95",
  ORANGE: "#cc6f10",
  GREEN: "#1e652e",
  CYAN: "#18859e",
  YELLOW: "#a69400",
  VIOLET: "#603c88",
  GRAY: "#575757",
  MAGENTA: "#7d2f6d",
  BROWN: "#4f3508",
  RED: "#a82529"
};

// packages/ag-charts-community/src/chart/themes/symbols.ts
var symbols_exports = {};
__export(symbols_exports, {
  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,
  DEFAULT_ANNOTATION_STATISTICS_COLOR: () => DEFAULT_ANNOTATION_STATISTICS_COLOR,
  DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
  DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
  DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
  DEFAULT_ANNOTATION_STATISTICS_FILL: () => DEFAULT_ANNOTATION_STATISTICS_FILL,
  DEFAULT_ANNOTATION_STATISTICS_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_STROKE,
  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,
  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,
  DEFAULT_FIBONACCI_STROKES: () => DEFAULT_FIBONACCI_STROKES,
  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,
  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,
  DEFAULT_SEPARATION_LINES_COLOUR: () => DEFAULT_SEPARATION_LINES_COLOUR,
  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,
  DEFAULT_SPARKLINE_CROSSHAIR_STROKE: () => DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,
  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,
  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,
  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,
  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,
  IS_DARK_THEME: () => IS_DARK_THEME,
  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,
  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,
  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,
  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,
  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,
  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,
  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,
  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,
  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,
  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,
  PALETTE_UP_FILL: () => PALETTE_UP_FILL,
  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE
});
var IS_DARK_THEME = Symbol("is-dark-theme");
var DEFAULT_SEPARATION_LINES_COLOUR = Symbol("default-separation-lines-colour");
var DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
var DEFAULT_CAPTION_LAYOUT_STYLE = Symbol("default-caption-layout-style");
var DEFAULT_CAPTION_ALIGNMENT = Symbol("default-caption-alignment");
var PALETTE_UP_STROKE = Symbol("palette-up-stroke");
var PALETTE_DOWN_STROKE = Symbol("palette-down-stroke");
var PALETTE_UP_FILL = Symbol("palette-up-fill");
var PALETTE_DOWN_FILL = Symbol("palette-down-fill");
var PALETTE_NEUTRAL_STROKE = Symbol("palette-neutral-stroke");
var PALETTE_NEUTRAL_FILL = Symbol("palette-neutral-fill");
var PALETTE_ALT_UP_STROKE = Symbol("palette-alt-up-stroke");
var PALETTE_ALT_DOWN_STROKE = Symbol("palette-alt-down-stroke");
var PALETTE_ALT_UP_FILL = Symbol("palette-alt-up-fill");
var PALETTE_ALT_DOWN_FILL = Symbol("palette-alt-down-fill");
var PALETTE_ALT_NEUTRAL_FILL = Symbol("palette-gray-fill");
var PALETTE_ALT_NEUTRAL_STROKE = Symbol("palette-gray-stroke");
var DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
var DEFAULT_SPARKLINE_CROSSHAIR_STROKE = Symbol("default-sparkline-crosshair-stroke");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR = Symbol(
  "default-financial-charts-annotation-stroke"
);
var DEFAULT_FIBONACCI_STROKES = Symbol("default-hierarchy-strokes");
var DEFAULT_TEXT_ANNOTATION_COLOR = Symbol("default-text-annotation-color");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL = Symbol(
  "default-financial-charts-annotation-background-fill"
);
var DEFAULT_ANNOTATION_HANDLE_FILL = Symbol("default-annotation-handle-fill");
var DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol("default-annotation-statistics-fill");
var DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol("default-annotation-statistics-stroke");
var DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol("default-annotation-statistics-color");
var DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(
  "default-annotation-statistics-divider-stroke"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(
  "default-annotation-statistics-fill"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(
  "default-annotation-statistics-stroke"
);
var DEFAULT_TEXTBOX_FILL = Symbol("default-textbox-fill");
var DEFAULT_TEXTBOX_STROKE = Symbol("default-textbox-stroke");
var DEFAULT_TEXTBOX_COLOR = Symbol("default-textbox-color");
var DEFAULT_TOOLBAR_POSITION = Symbol("default-toolbar-position");
var DEFAULT_GRIDLINE_ENABLED = Symbol("default-gridline-enabled");

// packages/ag-charts-community/src/chart/themes/util.ts
var DIRECTION_SWAP_AXES = [
  {
    type: "number" /* NUMBER */,
    position: {
      $if: [
        { $eq: [{ $path: ["/series/0/direction", void 0] }, "horizontal"] },
        "bottom" /* BOTTOM */,
        "left" /* LEFT */
      ]
    }
  },
  {
    type: "category" /* CATEGORY */,
    position: {
      $if: [
        { $eq: [{ $path: ["/series/0/direction", void 0] }, "horizontal"] },
        "left" /* LEFT */,
        "bottom" /* BOTTOM */
      ]
    }
  }
];
var SAFE_FILL_OPERATION = {
  $if: [
    {
      $or: [
        { $isGradient: { $palette: "fill" } },
        { $isPattern: { $palette: "fill" } },
        { $isImage: { $value: "$1" } }
      ]
    },
    { $palette: "fillFallback" },
    { $palette: "fill" }
  ]
};
var SAFE_FILLS_OPERATION = {
  $if: [
    {
      $or: [
        { $isGradient: { $palette: "fill" } },
        { $isPattern: { $palette: "fill" } },
        { $isImage: { $value: "$1" } }
      ]
    },
    { $palette: "fillsFallback" },
    { $palette: "fills" }
  ]
};
var SAFE_STROKE_FILL_OPERATION = {
  $if: [
    { $isGradient: { $palette: "fill" } },
    { $palette: "fillFallback" },
    {
      $if: [
        { $isPattern: { $palette: "fill" } },
        { $path: ["/stroke", { $palette: "fillFallback" }, { $palette: "fill" }] },
        { $palette: "fill" }
      ]
    }
  ]
};
var SAFE_RANGE2_OPERATION = {
  $if: [
    {
      $or: [
        { $isGradient: { $palette: "fill" } },
        { $isPattern: { $palette: "fill" } },
        { $isImage: { $value: "$1" } }
      ]
    },
    [{ $palette: "fillFallback" }, { $palette: "fillFallback" }],
    { $palette: "range2" }
  ]
};
var FILL_GRADIENT_LINEAR_DEFAULTS = {
  type: "gradient",
  gradient: "linear",
  bounds: "item",
  colorStops: { $palette: "gradient" },
  rotation: 0,
  reverse: false
};
var FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS = {
  ...FILL_GRADIENT_LINEAR_DEFAULTS,
  colorStops: [
    {
      $mix: [{ $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] }, "black", 0.15]
    },
    {
      $mix: [{ $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] }, "white", 0.15]
    }
  ]
};
var FILL_GRADIENT_LINEAR_SHADED_DEFAULTS = (key) => ({
  ...FILL_GRADIENT_LINEAR_DEFAULTS,
  colorStops: {
    $if: [
      {
        $or: [
          { $isGradient: { $palette: `${key}.fill` } },
          { $isPattern: { $palette: `${key}.fill` } },
          { $isImage: { $palette: `${key}.fill` } }
        ]
      },
      {
        $map: [
          { $path: ["/color", void 0, { $value: "$1" }] },
          {
            $path: ["/colorStops", void 0, { $palette: `${key}.fill` }]
          }
        ]
      },
      [
        { $mix: [{ $palette: `${key}.fill` }, "black", 0.15] },
        { $mix: [{ $palette: `${key}.fill` }, "white", 0.15] }
      ]
    ]
  }
});
var FILL_GRADIENT_RADIAL_DEFAULTS = {
  type: "gradient",
  gradient: "radial",
  bounds: "item",
  colorStops: { $palette: "gradient" },
  rotation: 0,
  reverse: false
};
var FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS = {
  ...FILL_GRADIENT_RADIAL_DEFAULTS,
  reverse: true
};
var FILL_GRADIENT_RADIAL_SERIES_DEFAULTS = {
  ...FILL_GRADIENT_RADIAL_DEFAULTS,
  bounds: "series"
};
var FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS = {
  ...FILL_GRADIENT_RADIAL_DEFAULTS,
  bounds: "series",
  reverse: true
};
var FILL_GRADIENT_CONIC_DEFAULTS = {
  type: "gradient",
  gradient: "conic",
  bounds: "series",
  colorStops: { $palette: "gradient" },
  rotation: 0,
  reverse: false
};
var FILL_PATTERN_DEFAULTS = {
  type: "pattern",
  pattern: "forward-slanted-lines",
  width: 10,
  height: 10,
  padding: 2,
  fill: {
    $if: [
      { $or: [{ $isGradient: { $palette: "fill" } }, { $isImage: { $palette: "fill" } }] },
      { $palette: "fillFallback" },
      {
        $if: [
          { $isPattern: { $palette: "fill" } },
          { $path: ["/fill", { $palette: "fillFallback" }, { $palette: "fill" }] },
          { $palette: "fill" }
        ]
      }
    ]
  },
  fillOpacity: 1,
  stroke: SAFE_STROKE_FILL_OPERATION,
  strokeOpacity: 1,
  strokeWidth: 4,
  backgroundFill: "none",
  backgroundFillOpacity: 1,
  rotation: 0,
  scale: 1
};
var FILL_PATTERN_HIERARCHY_DEFAULTS = {
  ...FILL_PATTERN_DEFAULTS,
  fill: { $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] },
  stroke: { $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] }
};
var FILL_IMAGE_DEFAULTS = {
  type: "image",
  backgroundFill: { $palette: "fillFallback" },
  backgroundFillOpacity: 1,
  repeat: "no-repeat",
  fit: "contain",
  rotation: 0
};
function getSequentialColors(colors) {
  return mapValues(colors, (value) => {
    const color2 = Color.fromString(value);
    return [Color.darken(color2, 0.15).toString(), value, Color.lighten(color2, 0.15).toString()];
  });
}
var ITEM_HIGHLIGHT_BASE_STYLE = {
  stroke: { $path: ["../../highlightStyle/item/stroke", `rgba(0, 0, 0, 0.4)`] },
  strokeWidth: { $path: ["../../highlightStyle/item/strokeWidth", 2] },
  strokeOpacity: { $path: ["../../highlightStyle/item/strokeOpacity", void 0] },
  opacity: { $path: ["../../highlightStyle/item/opacity", 1] }
};
var ITEM_HIGHLIGHT_STYLE = {
  ...ITEM_HIGHLIGHT_BASE_STYLE,
  fill: { $path: ["../../highlightStyle/item/fill", `rgba(255,255,255, 0.33)`] },
  fillOpacity: { $path: ["../../highlightStyle/item/fillOpacity", void 0] }
};
var LABEL_BOXING_DEFAULTS = {
  padding: 8,
  cornerRadius: 4,
  fill: {
    $if: [
      {
        $and: [
          { $eq: [{ $path: "./fill/type" }, "image"] },
          { $isUserOption: ["./fill/backgroundFill", false, true] }
        ]
      },
      { backgroundFill: "transparent" },
      void 0
    ]
  },
  border: {
    enabled: { $isUserOption: ["../border", true, false] },
    strokeWidth: 1,
    stroke: { $foregroundOpacity: 0.08 }
  }
};
function multiSeriesHighlightStyle(hasFill = true) {
  return {
    enabled: true,
    highlightedItem: hasFill ? ITEM_HIGHLIGHT_STYLE : ITEM_HIGHLIGHT_BASE_STYLE,
    unhighlightedItem: {
      strokeWidth: { $path: ["../../highlightStyle/series/strokeWidth", void 0] }
    },
    highlightedSeries: {
      strokeWidth: { $path: ["../../highlightStyle/series/strokeWidth", void 0] }
    },
    unhighlightedSeries: {
      opacity: { $path: ["../../highlightStyle/series/dimOpacity", void 0] }
    }
  };
}
function singleSeriesHighlightStyle(hasFill = true) {
  return {
    enabled: true,
    highlightedItem: hasFill ? ITEM_HIGHLIGHT_STYLE : ITEM_HIGHLIGHT_BASE_STYLE,
    unhighlightedItem: {
      strokeWidth: { $path: ["../../highlightStyle/series/strokeWidth", void 0] },
      opacity: { $path: ["../../highlightStyle/series/dimOpacity", void 0] }
    }
  };
}
var LEGEND_CONTAINER_THEME = {
  border: {
    enabled: false,
    stroke: { $foregroundBackgroundMix: 0.25 },
    strokeOpacity: 1,
    strokeWidth: 1
  },
  cornerRadius: 4,
  fillOpacity: 1,
  padding: {
    $if: [{ $eq: [{ $path: "./border/enabled" }, true] }, 5, { $isUserOption: ["./fill", 5, 0] }]
  }
};

// packages/ag-charts-community/src/chart/themes/chartTheme.ts
var DEFAULT_BACKGROUND_FILL = "white";
var CHART_TYPE_CONFIG = {
  get cartesian() {
    return { seriesTypes: chartTypes2.cartesianTypes, commonOptions: ["zoom", "navigator"] };
  },
  get polar() {
    return { seriesTypes: chartTypes2.polarTypes, commonOptions: [] };
  },
  get topology() {
    return { seriesTypes: chartTypes2.topologyTypes, commonOptions: [] };
  },
  get standalone() {
    return { seriesTypes: chartTypes2.standaloneTypes, commonOptions: [] };
  }
};
var PRESET_OVERRIDES_TYPES = {
  "radial-gauge": true,
  "linear-gauge": true
};
function isPresetOverridesType(type) {
  return PRESET_OVERRIDES_TYPES[type] === true;
}
var _ChartTheme = class _ChartTheme {
  static getDefaultColors() {
    return {
      fills: DEFAULT_FILLS,
      fillsFallback: Object.values(DEFAULT_FILLS),
      strokes: DEFAULT_STROKES,
      sequentialColors: getSequentialColors(DEFAULT_FILLS),
      divergingColors: [DEFAULT_FILLS.ORANGE, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.GREEN],
      hierarchyColors: ["#fff", "#e0e5ea", "#c1ccd5", "#a3b4c1", "#859cad"],
      secondSequentialColors: Color.interpolate(
        [
          Color.fromHexString(DEFAULT_FILLS.BLUE),
          Color.fromHexString("#cbdef5")
          // TODO: Color.lighten(DEFAULT_FILLS.BLUE, ?)
        ],
        8
      ).map((color2) => color2.toString()),
      secondDivergingColors: [DEFAULT_FILLS.GREEN, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.RED],
      secondHierarchyColors: ["#fff", "#c5cbd1", "#a4b1bd", "#8498a9", "#648096"],
      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },
      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },
      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },
      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },
      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },
      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }
    };
  }
  static getDefaultPublicParameters() {
    return {
      accentColor: "#2196f3",
      axisColor: { $foregroundBackgroundMix: 0.325 },
      backgroundColor: DEFAULT_BACKGROUND_FILL,
      borderColor: { $foregroundOpacity: 0.15 },
      borderRadius: 4,
      chartBackgroundColor: { $ref: "backgroundColor" },
      chartPadding: 20,
      focusShadow: "0 0 0 3px var(--ag-charts-accent-color)",
      foregroundColor: "#181d1f",
      fontFamily: "Verdana, sans-serif",
      fontSize: BASE_FONT_SIZE,
      fontWeight: 400,
      gridLineColor: { $foregroundBackgroundMix: 0.1 },
      popupShadow: "0 0 16px rgba(0, 0, 0, 0.15)",
      subtleTextColor: { $mix: [{ $ref: "textColor" }, { $ref: "chartBackgroundColor" }, 0.38] },
      textColor: { $ref: "foregroundColor" },
      chromeBackgroundColor: { $foregroundBackgroundMix: 0.02 },
      chromeFontFamily: { $ref: "fontFamily" },
      chromeFontSize: { $ref: "fontSize" },
      chromeFontWeight: { $ref: "fontWeight" },
      chromeTextColor: { $ref: "foregroundColor" },
      chromeSubtleTextColor: { $mix: [{ $ref: "chromeTextColor" }, { $ref: "backgroundColor" }, 0.38] },
      buttonBackgroundColor: { $ref: "backgroundColor" },
      buttonBorder: true,
      buttonFontWeight: 400,
      buttonTextColor: { $ref: "textColor" },
      inputBackgroundColor: { $ref: "backgroundColor" },
      inputBorder: true,
      inputTextColor: { $ref: "textColor" },
      menuBackgroundColor: { $ref: "chromeBackgroundColor" },
      menuBorder: true,
      menuTextColor: { $ref: "chromeTextColor" },
      panelBackgroundColor: { $ref: "chromeBackgroundColor" },
      panelSubtleTextColor: { $ref: "chromeSubtleTextColor" },
      tooltipBackgroundColor: { $ref: "chromeBackgroundColor" },
      tooltipBorder: true,
      tooltipTextColor: { $ref: "chromeTextColor" },
      tooltipSubtleTextColor: { $ref: "chromeSubtleTextColor" },
      crosshairLabelBackgroundColor: { $ref: "foregroundColor" },
      crosshairLabelTextColor: { $ref: "chartBackgroundColor" }
    };
  }
  static getAxisDefaults(overrideDefaults, { title, time: time3 }) {
    return mergeDefaults(
      overrideDefaults,
      title && {
        title: {
          enabled: false,
          text: "Axis Title",
          spacing: 25,
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $rem: FONT_SIZE_RATIO.MEDIUM },
          fontFamily: { $ref: "fontFamily" },
          color: { $ref: "textColor" }
        }
      },
      time3 && {
        parentLevel: {
          enabled: false,
          label: {
            // TODO: { $merge: [{ $path: '../../label' }, { fontWeight: 'bold' }]}
            enabled: { $path: "../../label/enabled" },
            border: {
              enabled: {
                $or: [
                  { $isUserOption: ["../border", true, false] },
                  { $path: "../../../label/border/enabled" }
                ]
              },
              strokeWidth: { $path: "../../../label/border/strokeWidth" },
              stroke: { $path: "../../../label/border/stroke" }
            },
            fill: { $path: "../../label/fill" },
            fontSize: { $path: "../../label/fontSize" },
            fontFamily: { $path: "../../label/fontFamily" },
            fontWeight: "bold",
            spacing: { $path: "../../label/spacing" },
            color: { $path: "../../label/color" },
            cornerRadius: { $path: "../../label/cornerRadius" },
            padding: { $path: "../../label/padding" },
            avoidCollisions: { $path: "../../label/avoidCollisions" }
          },
          tick: {
            enabled: { $path: "../../tick/enabled" },
            width: { $path: "../../tick/width" },
            size: { $path: "../../tick/size" },
            stroke: { $path: "../../tick/stroke" }
          }
        }
      },
      {
        label: {
          enabled: true,
          fontSize: { $ref: "fontSize" },
          fontFamily: { $ref: "fontFamily" },
          fontWeight: { $ref: "fontWeight" },
          spacing: 11,
          color: { $ref: "textColor" },
          avoidCollisions: true,
          cornerRadius: 4,
          border: {
            enabled: { $isUserOption: ["../border", true, false] },
            strokeWidth: 1,
            stroke: { $foregroundOpacity: 0.08 }
          },
          padding: {
            $if: [
              { $eq: [{ $path: "./border/enabled" }, true] },
              { left: 12, right: 12, top: 8, bottom: 8 },
              void 0
            ]
          }
        },
        line: {
          enabled: true,
          width: 1,
          stroke: { $ref: "axisColor" }
        },
        tick: {
          enabled: false,
          size: 6,
          width: 1,
          stroke: { $ref: "axisColor" }
        },
        gridLine: {
          enabled: true,
          width: 1,
          style: {
            $apply: [
              {
                fillOpacity: 1,
                stroke: { $ref: "gridLineColor" },
                strokeWidth: { $path: "../../width" },
                lineDash: []
              },
              [
                {
                  fillOpacity: 1,
                  stroke: { $ref: "gridLineColor" },
                  strokeWidth: { $path: "../../width" },
                  lineDash: []
                }
              ]
            ]
          }
        },
        crossLines: {
          $apply: [
            {
              enabled: true,
              fill: { $ref: "foregroundColor" },
              stroke: { $ref: "foregroundColor" },
              fillOpacity: 0.08,
              strokeWidth: 1,
              label: {
                fontSize: { $ref: "fontSize" },
                fontFamily: { $ref: "fontFamily" },
                fontWeight: { $ref: "fontWeight" },
                padding: 5,
                color: { $ref: "textColor" }
              }
            },
            void 0,
            // TODO: can we just infer this common path?
            {
              $pathString: [
                "/common/axes/$axisType/crossLines",
                { axisType: { $path: ["/axes/$index/type"] } }
              ]
            },
            {
              $pathString: [
                "/$seriesType/axes/$axisType/crossLines",
                {
                  seriesType: { $path: ["/series/0/type", "line"] },
                  axisType: { $path: ["/axes/$index/type"] }
                }
              ]
            }
          ]
        }
      }
    );
  }
  getChartDefaults() {
    return {
      minHeight: 300,
      minWidth: 300,
      background: { visible: true, fill: { $ref: "chartBackgroundColor" } },
      padding: {
        top: { $ref: "chartPadding" },
        right: { $ref: "chartPadding" },
        bottom: { $ref: "chartPadding" },
        left: { $ref: "chartPadding" }
      },
      seriesArea: {
        border: {
          enabled: false,
          stroke: { $ref: "foregroundColor" },
          strokeOpacity: 1,
          strokeWidth: 1
        },
        cornerRadius: 4,
        padding: { $if: [{ $eq: [{ $path: "./border/enabled" }, true] }, 5, 0] }
      },
      keyboard: { enabled: true },
      title: {
        enabled: false,
        text: "Title",
        spacing: { $if: [{ $path: "../subtitle/enabled" }, 10, 20] },
        fontWeight: { $ref: "fontWeight" },
        fontSize: { $rem: FONT_SIZE_RATIO.LARGEST },
        fontFamily: { $ref: "fontFamily" },
        color: { $ref: "textColor" },
        wrapping: "hyphenate",
        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
        textAlign: DEFAULT_CAPTION_ALIGNMENT
      },
      subtitle: {
        enabled: false,
        text: "Subtitle",
        spacing: 20,
        fontWeight: { $ref: "fontWeight" },
        fontSize: { $rem: FONT_SIZE_RATIO.MEDIUM },
        fontFamily: { $ref: "fontFamily" },
        color: { $ref: "subtleTextColor" },
        wrapping: "hyphenate",
        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
        textAlign: DEFAULT_CAPTION_ALIGNMENT
      },
      footnote: {
        enabled: false,
        text: "Footnote",
        spacing: 20,
        fontSize: { $rem: FONT_SIZE_RATIO.MEDIUM },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "subtleTextColor" },
        wrapping: "hyphenate",
        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
        textAlign: DEFAULT_CAPTION_ALIGNMENT
      },
      legend: {
        ...LEGEND_CONTAINER_THEME,
        enabled: {
          $and: [
            { $greaterThan: [{ $size: [{ $path: "/series" }] }, 1] },
            {
              $or: [
                { $isChartType: "cartesian" },
                { $isChartType: "standalone" },
                {
                  $and: [
                    { $isChartType: "polar" },
                    { $not: { $isSeriesType: "pie" } },
                    { $not: { $isSeriesType: "donut" } }
                  ]
                }
              ]
            }
          ]
        },
        position: "bottom" /* BOTTOM */,
        orientation: {
          $if: [
            {
              $or: [
                { $eq: [{ $path: "./position" }, "left" /* LEFT */] },
                { $eq: [{ $path: "./position" }, "left-top" /* LEFT_TOP */] },
                { $eq: [{ $path: "./position" }, "left-bottom" /* LEFT_BOTTOM */] },
                { $eq: [{ $path: "./position" }, "right" /* RIGHT */] },
                { $eq: [{ $path: "./position" }, "right-top" /* RIGHT_TOP */] },
                { $eq: [{ $path: "./position" }, "right-bottom" /* RIGHT_BOTTOM */] },
                { $eq: [{ $path: "./position/placement" }, "left" /* LEFT */] },
                { $eq: [{ $path: "./position/placement" }, "left-top" /* LEFT_TOP */] },
                { $eq: [{ $path: "./position/placement" }, "left-bottom" /* LEFT_BOTTOM */] },
                { $eq: [{ $path: "./position/placement" }, "right" /* RIGHT */] },
                { $eq: [{ $path: "./position/placement" }, "right-top" /* RIGHT_TOP */] },
                { $eq: [{ $path: "./position/placement" }, "right-bottom" /* RIGHT_BOTTOM */] }
              ]
            },
            "vertical",
            "horizontal"
          ]
        },
        spacing: 30,
        listeners: {},
        toggleSeries: true,
        item: {
          paddingX: 16,
          paddingY: 8,
          marker: { size: 15, padding: 8 },
          showSeriesStroke: true,
          label: {
            color: { $ref: "textColor" },
            fontSize: { $rem: FONT_SIZE_RATIO.SMALL },
            fontFamily: { $ref: "fontFamily" },
            fontWeight: { $ref: "fontWeight" }
          }
        },
        reverseOrder: false,
        pagination: {
          marker: { size: 12 },
          activeStyle: { fill: { $ref: "foregroundColor" } },
          inactiveStyle: { fill: { $ref: "subtleTextColor" } },
          highlightStyle: { fill: { $ref: "foregroundColor" } },
          label: { color: { $ref: "textColor" } }
        },
        fill: {
          $if: [{ $path: ["./position/floating", false] }, { $ref: "chartBackgroundColor" }, "transparent"]
        }
      },
      tooltip: {
        enabled: true,
        darkTheme: IS_DARK_THEME,
        delay: 0,
        pagination: false,
        mode: {
          $if: [
            {
              $and: [
                { $isChartType: "cartesian" },
                { $not: { $hasSeriesType: "bubble" } },
                { $not: { $hasSeriesType: "scatter" } },
                { $greaterThan: [{ $size: [{ $path: "/series" }] }, 1] },
                { $lessThan: [{ $size: [{ $path: "/series" }] }, 4] }
              ]
            },
            "shared",
            "single"
          ]
        }
      },
      overlays: { darkTheme: IS_DARK_THEME },
      listeners: {},
      series: {
        tooltip: {
          range: { $path: ["/tooltip/range", "exact"] },
          position: {
            anchorTo: { $path: ["/tooltip/position/anchorTo", "pointer"] },
            placement: { $path: ["/tooltip/position/placement", void 0] },
            xOffset: { $path: ["/tooltip/position/xOffset", 0] },
            yOffset: { $path: ["/tooltip/position/yOffset", 0] }
          }
        }
      }
    };
  }
  constructor(options = {}) {
    const { overrides, palette, params } = deepClone(options);
    const defaults = this.createChartConfigPerChartType(this.getDefaults());
    const presets = {};
    if (overrides) {
      this.processOverrides(presets, overrides);
    }
    const { fills, strokes, sequentialColors, ...otherColors } = this.getDefaultColors();
    this.palette = deepFreeze(
      mergeDefaults(palette, {
        fills: Object.values(fills),
        strokes: Object.values(strokes),
        sequentialColors: Object.values(sequentialColors),
        ...otherColors
      })
    );
    this.paletteType = paletteType(palette);
    this.params = mergeDefaults(params, this.getPublicParameters());
    this.config = deepFreeze(deepClone(defaults));
    this.overrides = deepFreeze(overrides);
    this.presets = deepFreeze(presets);
  }
  processOverrides(presets, overrides) {
    chartTypes2.seriesTypes.forEach((s) => {
      const seriesType = s;
      const seriesOverrides = overrides[seriesType];
      if (isPresetOverridesType(seriesType)) {
        presets[seriesType] = seriesOverrides;
        delete overrides[seriesType];
      }
    });
  }
  createChartConfigPerChartType(config) {
    for (const [nextType, { seriesTypes }] of entries(CHART_TYPE_CONFIG)) {
      const typeDefaults = chartDefaults.get(nextType);
      for (const seriesType of seriesTypes) {
        config[seriesType] ?? (config[seriesType] = deepClone(typeDefaults));
      }
    }
    return config;
  }
  getDefaults() {
    const getOverridesByType = (chartType, seriesTypes) => {
      const result = {};
      const chartTypeDefaults = {
        axes: {},
        ...legendRegistry.getThemeTemplates(),
        ...this.getChartDefaults(),
        ...chartDefaults.get(chartType)
      };
      for (const seriesType of seriesTypes) {
        result[seriesType] = mergeDefaults(
          seriesRegistry.getThemeTemplate(seriesType),
          result[seriesType] ?? deepClone(chartTypeDefaults)
        );
        const { axes } = result[seriesType];
        for (const axisType of axisRegistry.keys()) {
          axes[axisType] = mergeDefaults(
            axes[axisType],
            axisRegistry.getThemeTemplate(axisType),
            _ChartTheme.axisDefault[axisType]
          );
        }
        if (seriesType === "map-shape-background" || seriesType === "map-line-background") {
          delete result[seriesType].series.tooltip;
        }
      }
      return result;
    };
    return mergeDefaults(
      getOverridesByType("cartesian", chartTypes2.cartesianTypes),
      getOverridesByType("polar", chartTypes2.polarTypes),
      getOverridesByType("topology", chartTypes2.topologyTypes),
      getOverridesByType("standalone", chartTypes2.standaloneTypes)
    );
  }
  static applyTemplateTheme(node, _other, params) {
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        const symbol = node[i];
        if (typeof symbol === "symbol" && params?.has(symbol)) {
          node[i] = params.get(symbol);
        }
      }
    } else {
      for (const name of Object.keys(node)) {
        const value = node[name];
        if (typeof value === "symbol" && params?.has(value)) {
          node[name] = params.get(value);
        }
      }
    }
  }
  templateTheme(themeTemplate, clone2 = true) {
    const themeInstance = clone2 ? deepClone(themeTemplate) : themeTemplate;
    const params = this.getTemplateParameters();
    jsonWalk(themeInstance, _ChartTheme.applyTemplateTheme, void 0, void 0, params);
    return themeInstance;
  }
  getDefaultColors() {
    return _ChartTheme.getDefaultColors();
  }
  getPublicParameters() {
    return _ChartTheme.getDefaultPublicParameters();
  }
  // Private parameters that are not exposed in the themes API.
  getTemplateParameters() {
    const params = /* @__PURE__ */ new Map();
    params.set(IS_DARK_THEME, false);
    params.set(DEFAULT_SEPARATION_LINES_COLOUR, "#d9d9d9");
    params.set(DEFAULT_SHADOW_COLOUR, "#00000080");
    params.set(DEFAULT_SPARKLINE_CROSSHAIR_STROKE, "#aaa");
    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "block");
    params.set(DEFAULT_CAPTION_ALIGNMENT, "center");
    params.set(DEFAULT_FIBONACCI_STROKES, [
      "#797b86",
      "#e24c4a",
      "#f49d2d",
      "#65ab58",
      "#409682",
      "#4db9d2",
      "#5090dc",
      "#3068f9",
      "#e24c4a",
      "#913aac",
      "#d93e64"
    ]);
    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);
    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);
    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, "#fafafa");
    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, "#ddd");
    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, "#000");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, "#181d1f");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL, "#e35c5c");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE, "#e35c5c");
    params.set(DEFAULT_TEXTBOX_FILL, "#fafafa");
    params.set(DEFAULT_TEXTBOX_STROKE, "#ddd");
    params.set(DEFAULT_TEXTBOX_COLOR, "#000");
    params.set(DEFAULT_TOOLBAR_POSITION, "top");
    params.set(DEFAULT_GRIDLINE_ENABLED, false);
    const defaultColors = this.getDefaultColors();
    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);
    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);
    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);
    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);
    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);
    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);
    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);
    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);
    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);
    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);
    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);
    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);
    return params;
  }
};
_ChartTheme.axisDefault = {
  ["number" /* NUMBER */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      line: { enabled: false },
      crosshair: { enabled: true }
    },
    { title: true, time: false }
  ),
  ["log" /* LOG */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      base: 10,
      line: { enabled: false },
      crosshair: { enabled: true }
    },
    { title: true, time: false }
  ),
  ["category" /* CATEGORY */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      groupPaddingInner: 0.1,
      label: { autoRotate: true, wrapping: "on-space" },
      gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },
      crosshair: { enabled: false }
    },
    { title: true, time: false }
  ),
  ["grouped-category" /* GROUPED_CATEGORY */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      tick: { enabled: true, stroke: DEFAULT_SEPARATION_LINES_COLOUR },
      label: { spacing: 10, rotation: 270, wrapping: "on-space" },
      maxThicknessRatio: 0.5,
      paddingInner: 0.4,
      groupPaddingInner: 0.2,
      crosshair: { enabled: false }
    },
    { title: true, time: false }
  ),
  ["time" /* TIME */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },
      crosshair: { enabled: true }
    },
    { title: true, time: true }
  ),
  ["unit-time" /* UNIT_TIME */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      groupPaddingInner: 0.1,
      label: { autoRotate: false },
      gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },
      crosshair: { enabled: true },
      parentLevel: { enabled: true }
    },
    { title: true, time: true }
  ),
  ["ordinal-time" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults(
    {
      keys: [],
      groupPaddingInner: 0,
      label: { autoRotate: false },
      gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },
      crosshair: { enabled: true }
    },
    { title: true, time: true }
  ),
  ["angle-category" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults(
    {
      label: { spacing: 5 },
      gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },
      shape: { $findFirstSiblingNotOperation: void 0 }
    },
    { title: false, time: false }
  ),
  ["angle-number" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults(
    {
      label: { spacing: 5 },
      gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }
    },
    { title: false, time: false }
  ),
  ["radius-category" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults(
    {
      positionAngle: 0,
      line: { enabled: false }
    },
    { title: true, time: false }
  ),
  ["radius-number" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults(
    {
      positionAngle: 0,
      line: { enabled: false },
      shape: { $findFirstSiblingNotOperation: void 0 }
    },
    { title: true, time: false }
  )
};
var ChartTheme = _ChartTheme;

// packages/ag-charts-community/src/chart/themes/darkTheme.ts
var DEFAULT_DARK_BACKGROUND_FILL = "#192232";
var DEFAULT_DARK_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_DARK_STROKES = {
  BLUE: "#74a8e6",
  ORANGE: "#ffbe70",
  GREEN: "#6cb176",
  CYAN: "#75d4ef",
  YELLOW: "#f6e559",
  VIOLET: "#aa86d8",
  GRAY: "#a1a1a1",
  MAGENTA: "#ce7ab9",
  BROWN: "#997b52",
  RED: "#ff7872"
};
var DarkTheme = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: DEFAULT_DARK_FILLS,
      fillsFallback: Object.values(DEFAULT_DARK_FILLS),
      strokes: DEFAULT_DARK_STROKES,
      sequentialColors: getSequentialColors(DEFAULT_DARK_FILLS),
      divergingColors: [DEFAULT_DARK_FILLS.ORANGE, DEFAULT_DARK_FILLS.YELLOW, DEFAULT_DARK_FILLS.GREEN],
      hierarchyColors: ["#192834", "#253746", "#324859", "#3f596c", "#4d6a80"],
      secondSequentialColors: [
        "#5090dc",
        "#4882c6",
        "#4073b0",
        "#38659a",
        "#305684",
        "#28486e",
        "#203a58",
        "#182b42"
      ],
      secondDivergingColors: [DEFAULT_DARK_FILLS.GREEN, DEFAULT_DARK_FILLS.YELLOW, DEFAULT_DARK_FILLS.RED],
      secondHierarchyColors: ["#192834", "#3b5164", "#496275", "#577287", "#668399"],
      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },
      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },
      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },
      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },
      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },
      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }
    };
  }
  getPublicParameters() {
    return {
      ...super.getPublicParameters(),
      axisColor: { $foregroundBackgroundMix: 0.737 },
      backgroundColor: DEFAULT_DARK_BACKGROUND_FILL,
      borderColor: { $foregroundBackgroundMix: 0.216 },
      chromeBackgroundColor: { $foregroundBackgroundMix: 0.07 },
      foregroundColor: "#fff",
      gridLineColor: { $foregroundBackgroundMix: 0.257 },
      popupShadow: "0 0 16px rgba(0, 0, 0, 0.33)",
      subtleTextColor: { $mix: [{ $ref: "textColor" }, { $ref: "chartBackgroundColor" }, 0.57] },
      crosshairLabelBackgroundColor: { $foregroundBackgroundMix: 0.65 }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(IS_DARK_THEME, true);
    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);
    params.set(DEFAULT_SEPARATION_LINES_COLOUR, "#7f8389");
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);
    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, "#fff");
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);
    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, "#28313e");
    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, "#4b525d");
    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, "#fff");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, "#fff");
    params.set(DEFAULT_TEXTBOX_FILL, "#28313e");
    params.set(DEFAULT_TEXTBOX_STROKE, "#4b525d");
    params.set(DEFAULT_TEXTBOX_COLOR, "#fff");
    return params;
  }
  constructor(options) {
    super(options);
  }
};

// packages/ag-charts-community/src/chart/themes/financialDark.ts
var FINANCIAL_DARK_FILLS = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#A9A9A9"
};
var FINANCIAL_DARK_STROKES = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#909090"
};
var FinancialDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: { ...FINANCIAL_DARK_FILLS },
      fillsFallback: Object.values({ ...FINANCIAL_DARK_FILLS }),
      strokes: { ...FINANCIAL_DARK_STROKES },
      sequentialColors: getSequentialColors(FINANCIAL_DARK_FILLS),
      divergingColors: [FINANCIAL_DARK_FILLS.GREEN, FINANCIAL_DARK_FILLS.BLUE, FINANCIAL_DARK_FILLS.RED],
      // hierarchyColors: [],
      secondSequentialColors: [
        "#5090dc",
        "#4882c6",
        "#4073b0",
        "#38659a",
        "#305684",
        "#28486e",
        "#203a58",
        "#182b42"
      ],
      // secondDivergingColors: [],
      // secondHierarchyColors: [],
      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },
      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },
      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },
      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },
      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },
      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }
    };
  }
  getPublicParameters() {
    return {
      ...super.getPublicParameters(),
      chartPadding: 0,
      gridLineColor: { $foregroundBackgroundMix: 0.12 }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);
    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "overlay");
    params.set(DEFAULT_CAPTION_ALIGNMENT, "left");
    params.set(DEFAULT_TOOLBAR_POSITION, "bottom");
    params.set(DEFAULT_GRIDLINE_ENABLED, true);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/financialLight.ts
var FINANCIAL_LIGHT_FILLS = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#A9A9A9"
};
var FINANCIAL_LIGHT_STROKES = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#909090"
};
var FinancialLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: { ...FINANCIAL_LIGHT_FILLS },
      fillsFallback: Object.values({ ...FINANCIAL_LIGHT_FILLS }),
      strokes: { ...FINANCIAL_LIGHT_STROKES },
      sequentialColors: getSequentialColors(FINANCIAL_LIGHT_FILLS),
      divergingColors: [FINANCIAL_LIGHT_FILLS.GREEN, FINANCIAL_LIGHT_FILLS.BLUE, FINANCIAL_LIGHT_FILLS.RED],
      // hierarchyColors: [],
      // secondSequentialColors: [],
      // secondDivergingColors: [],
      // secondHierarchyColors: [],
      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },
      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },
      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },
      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },
      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },
      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }
    };
  }
  getPublicParameters() {
    return {
      ...super.getPublicParameters(),
      chartPadding: 0,
      gridLineColor: { $foregroundBackgroundMix: 0.06 }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "overlay");
    params.set(DEFAULT_CAPTION_ALIGNMENT, "left");
    params.set(DEFAULT_TOOLBAR_POSITION, "bottom");
    params.set(DEFAULT_GRIDLINE_ENABLED, true);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/materialDark.ts
var MATERIAL_DARK_FILLS = {
  BLUE: "#2196F3",
  ORANGE: "#FF9800",
  GREEN: "#4CAF50",
  CYAN: "#00BCD4",
  YELLOW: "#FFEB3B",
  VIOLET: "#7E57C2",
  GRAY: "#9E9E9E",
  MAGENTA: "#F06292",
  BROWN: "#795548",
  RED: "#F44336"
};
var MATERIAL_DARK_STROKES = {
  BLUE: "#90CAF9",
  ORANGE: "#FFCC80",
  GREEN: "#A5D6A7",
  CYAN: "#80DEEA",
  YELLOW: "#FFF9C4",
  VIOLET: "#B39DDB",
  GRAY: "#E0E0E0",
  MAGENTA: "#F48FB1",
  BROWN: "#A1887F",
  RED: "#EF9A9A"
};
var MaterialDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: MATERIAL_DARK_FILLS,
      fillsFallback: Object.values(MATERIAL_DARK_FILLS),
      strokes: MATERIAL_DARK_STROKES,
      sequentialColors: getSequentialColors(MATERIAL_DARK_FILLS),
      divergingColors: [MATERIAL_DARK_FILLS.ORANGE, MATERIAL_DARK_FILLS.YELLOW, MATERIAL_DARK_FILLS.GREEN],
      // hierarchyColors: [],
      secondSequentialColors: [
        "#2196f3",
        // 500
        "#208FEC",
        // (interpolated)
        "#1E88E5",
        // 600
        "#1C7FDC",
        // (interpolated)
        "#1976d2",
        // 700
        "#176EC9",
        // (interpolated)
        "#1565c0"
        // 800
      ],
      secondDivergingColors: [MATERIAL_DARK_FILLS.GREEN, MATERIAL_DARK_FILLS.YELLOW, MATERIAL_DARK_FILLS.RED],
      // secondHierarchyColors: [],
      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },
      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },
      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },
      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },
      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },
      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/materialLight.ts
var MATERIAL_LIGHT_FILLS = {
  BLUE: "#2196F3",
  ORANGE: "#FF9800",
  GREEN: "#4CAF50",
  CYAN: "#00BCD4",
  YELLOW: "#FFEB3B",
  VIOLET: "#7E57C2",
  GRAY: "#9E9E9E",
  MAGENTA: "#F06292",
  BROWN: "#795548",
  RED: "#F44336"
};
var MATERIAL_LIGHT_STROKES = {
  BLUE: "#1565C0",
  ORANGE: "#E65100",
  GREEN: "#2E7D32",
  CYAN: "#00838F",
  YELLOW: "#F9A825",
  VIOLET: "#4527A0",
  GRAY: "#616161",
  MAGENTA: "#C2185B",
  BROWN: "#4E342E",
  RED: "#B71C1C"
};
var MaterialLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: MATERIAL_LIGHT_FILLS,
      fillsFallback: Object.values(MATERIAL_LIGHT_FILLS),
      strokes: MATERIAL_LIGHT_STROKES,
      sequentialColors: getSequentialColors(MATERIAL_LIGHT_FILLS),
      divergingColors: [MATERIAL_LIGHT_FILLS.ORANGE, MATERIAL_LIGHT_FILLS.YELLOW, MATERIAL_LIGHT_FILLS.GREEN],
      // hierarchyColors: [],
      secondSequentialColors: [
        "#2196f3",
        // 500
        "#329EF4",
        // (interpolated)
        "#42a5f5",
        // 400
        "#53ADF6",
        // (interpolated)
        "#64b5f6",
        // 300
        "#7AC0F8",
        // (interpolated)
        "#90caf9"
        // 200
      ],
      secondDivergingColors: [MATERIAL_LIGHT_FILLS.GREEN, MATERIAL_LIGHT_FILLS.YELLOW, MATERIAL_LIGHT_FILLS.RED],
      // secondHierarchyColors: [],
      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },
      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },
      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },
      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },
      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },
      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/polychromaDark.ts
var POLYCHROMA_DARK_FILLS = {
  BLUE: "#436ff4",
  PURPLE: "#9a7bff",
  MAGENTA: "#d165d2",
  PINK: "#f0598b",
  RED: "#f47348",
  ORANGE: "#f2a602",
  YELLOW: "#e9e201",
  GREEN: "#21b448",
  CYAN: "#00b9a2",
  MODERATE_BLUE: "#00aee4",
  GRAY: "#bbbbbb"
};
var POLYCHROMA_DARK_STROKES = {
  BLUE: "#6698ff",
  PURPLE: "#c0a3ff",
  MAGENTA: "#fc8dfc",
  PINK: "#ff82b1",
  RED: "#ff9b70",
  ORANGE: "#ffcf4e",
  YELLOW: "#ffff58",
  GREEN: "#58dd70",
  CYAN: "#51e2c9",
  MODERATE_BLUE: "#4fd7ff",
  GRAY: "#eeeeee"
};
var PolychromaDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: POLYCHROMA_DARK_FILLS,
      fillsFallback: Object.values(POLYCHROMA_DARK_FILLS),
      strokes: POLYCHROMA_DARK_STROKES,
      sequentialColors: getSequentialColors(POLYCHROMA_DARK_FILLS),
      divergingColors: [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED],
      hierarchyColors: [],
      secondSequentialColors: [
        POLYCHROMA_DARK_FILLS.BLUE,
        POLYCHROMA_DARK_FILLS.PURPLE,
        POLYCHROMA_DARK_FILLS.MAGENTA,
        POLYCHROMA_DARK_FILLS.PINK,
        POLYCHROMA_DARK_FILLS.RED,
        POLYCHROMA_DARK_FILLS.ORANGE,
        POLYCHROMA_DARK_FILLS.YELLOW,
        POLYCHROMA_DARK_FILLS.GREEN
      ],
      secondDivergingColors: [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED],
      secondHierarchyColors: [],
      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },
      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },
      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },
      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },
      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },
      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/polychromaLight.ts
var POLYCHROMA_LIGHT_FILLS = {
  BLUE: "#436ff4",
  PURPLE: "#9a7bff",
  MAGENTA: "#d165d2",
  PINK: "#f0598b",
  RED: "#f47348",
  ORANGE: "#f2a602",
  YELLOW: "#e9e201",
  GREEN: "#21b448",
  CYAN: "#00b9a2",
  MODERATE_BLUE: "#00aee4",
  GRAY: "#bbbbbb"
};
var POLYCHROMA_LIGHT_STROKES = {
  BLUE: "#2346c9",
  PURPLE: "#7653d4",
  MAGENTA: "#a73da9",
  PINK: "#c32d66",
  RED: "#c84b1c",
  ORANGE: "#c87f00",
  YELLOW: "#c1b900",
  GREEN: "#008c1c",
  CYAN: "#00927c",
  MODERATE_BLUE: "#0087bb",
  GRAY: "#888888"
};
var PolychromaLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: POLYCHROMA_LIGHT_FILLS,
      fillsFallback: Object.values(POLYCHROMA_LIGHT_FILLS),
      strokes: POLYCHROMA_LIGHT_STROKES,
      sequentialColors: getSequentialColors(POLYCHROMA_LIGHT_FILLS),
      divergingColors: [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED],
      hierarchyColors: [],
      secondSequentialColors: [
        POLYCHROMA_LIGHT_FILLS.BLUE,
        POLYCHROMA_LIGHT_FILLS.PURPLE,
        POLYCHROMA_LIGHT_FILLS.MAGENTA,
        POLYCHROMA_LIGHT_FILLS.PINK,
        POLYCHROMA_LIGHT_FILLS.RED,
        POLYCHROMA_LIGHT_FILLS.ORANGE,
        POLYCHROMA_LIGHT_FILLS.YELLOW,
        POLYCHROMA_LIGHT_FILLS.GREEN
      ],
      secondDivergingColors: [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED],
      secondHierarchyColors: [],
      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },
      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },
      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },
      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },
      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },
      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/sheetsDark.ts
var SHEETS_DARK_FILLS = {
  BLUE: "#4472C4",
  ORANGE: "#ED7D31",
  GRAY: "#A5A5A5",
  YELLOW: "#FFC000",
  MODERATE_BLUE: "#5B9BD5",
  GREEN: "#70AD47",
  DARK_GRAY: "#7B7B7B",
  DARK_BLUE: "#264478",
  VERY_DARK_GRAY: "#636363",
  DARK_YELLOW: "#997300"
};
var SHEETS_DARK_STROKES = {
  BLUE: "#6899ee",
  ORANGE: "#ffa55d",
  GRAY: "#cdcdcd",
  YELLOW: "#ffea53",
  MODERATE_BLUE: "#82c3ff",
  GREEN: "#96d56f",
  DARK_GRAY: "#a1a1a1",
  DARK_BLUE: "#47689f",
  VERY_DARK_GRAY: "#878787",
  DARK_YELLOW: "#c0993d"
};
var SheetsDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },
      fillsFallback: Object.values({ ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE }),
      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },
      sequentialColors: getSequentialColors({ ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE }),
      divergingColors: [SHEETS_DARK_FILLS.ORANGE, SHEETS_DARK_FILLS.YELLOW, SHEETS_DARK_FILLS.GREEN],
      // hierarchyColors: [],
      secondSequentialColors: [
        "#5090dc",
        "#4882c6",
        "#4073b0",
        "#38659a",
        "#305684",
        "#28486e",
        "#203a58",
        "#182b42"
      ],
      secondDivergingColors: [SHEETS_DARK_FILLS.GREEN, SHEETS_DARK_FILLS.YELLOW, SHEETS_DARK_FILLS.ORANGE],
      // secondHierarchyColors: [],
      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },
      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },
      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },
      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },
      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },
      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/sheetsLight.ts
var SHEETS_LIGHT_FILLS = {
  BLUE: "#5281d5",
  ORANGE: "#ff8d44",
  GRAY: "#b5b5b5",
  YELLOW: "#ffd02f",
  MODERATE_BLUE: "#6aabe6",
  GREEN: "#7fbd57",
  DARK_GRAY: "#8a8a8a",
  DARK_BLUE: "#335287",
  VERY_DARK_GRAY: "#717171",
  DARK_YELLOW: "#a98220"
};
var SHEETS_LIGHT_STROKES = {
  BLUE: "#214d9b",
  ORANGE: "#c25600",
  GRAY: "#7f7f7f",
  YELLOW: "#d59800",
  MODERATE_BLUE: "#3575ac",
  GREEN: "#4b861a",
  DARK_GRAY: "#575757",
  DARK_BLUE: "#062253",
  VERY_DARK_GRAY: "#414141",
  DARK_YELLOW: "#734f00"
};
var SheetsLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },
      fillsFallback: Object.values({ ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE }),
      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },
      sequentialColors: getSequentialColors({ ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE }),
      divergingColors: [SHEETS_LIGHT_FILLS.ORANGE, SHEETS_LIGHT_FILLS.YELLOW, SHEETS_LIGHT_FILLS.GREEN],
      // hierarchyColors: [],
      secondSequentialColors: [
        "#5090dc",
        "#629be0",
        "#73a6e3",
        "#85b1e7",
        "#96bcea",
        "#a8c8ee",
        "#b9d3f1",
        "#cbdef5"
      ],
      secondDivergingColors: [SHEETS_LIGHT_FILLS.GREEN, SHEETS_LIGHT_FILLS.YELLOW, SHEETS_LIGHT_FILLS.ORANGE],
      secondHierarchyColors: [],
      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },
      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },
      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },
      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },
      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },
      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/commonOptionsDefs.ts
var legendPlacementLiterals = [
  "top",
  "top-right",
  "top-left",
  "bottom",
  "bottom-right",
  "bottom-left",
  "right",
  "right-top",
  "right-bottom",
  "left",
  "left-top",
  "left-bottom"
];
var legendPositionOptionsDef = {
  floating: boolean,
  placement: union(...legendPlacementLiterals),
  xOffset: number,
  yOffset: number
};
var legendPositionValidator = attachDescription(
  (value, context) => {
    let result;
    if (typeof value === "string") {
      const allowedValues = legendPlacementLiterals;
      if (allowedValues.includes(value)) {
        result = true;
      } else {
        result = { valid: false, invalid: [], cleared: null };
        result.invalid.push(
          new ValidationError(
            "invalid" /* Invalid */,
            `a legend placement string: ["${legendPlacementLiterals.join('", "')}"]`,
            value,
            context.path
          )
        );
      }
    } else {
      const { cleared, invalid } = validate(value, legendPositionOptionsDef);
      result = { valid: invalid.length === 0, cleared, invalid };
    }
    return result;
  },
  `a legend position object or placement string`
);
var shapeValidator = or(
  union("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle"),
  callback
);
var textWrapValidator = union("never", "always", "hyphenate", "on-space");
var tooltipPlacementValidator = union(
  "top",
  "right",
  "bottom",
  "left",
  "top-right",
  "bottom-right",
  "bottom-left",
  "top-left",
  "center"
);
var rangeValidator2 = or(positiveNumber, union("exact", "nearest"));
var textOrSegments = or(
  string,
  arrayOfDefs(
    {
      text: required(string),
      ...fontOptionsDef
    },
    "text segments array"
  )
);
var zoomAnchorPoint = union("pointer", "start", "middle", "end");
var chartCaptionOptionsDefs = {
  enabled: boolean,
  text: textOrSegments,
  textAlign: union("left", "center", "right"),
  wrapping: union("never", "always", "hyphenate", "on-space"),
  spacing: positiveNumber,
  maxWidth: positiveNumber,
  maxHeight: positiveNumber,
  ...fontOptionsDef
};
chartCaptionOptionsDefs.padding = undocumented(positiveNumber);
var chartOverlayOptionsDefs = {
  enabled: boolean,
  text: textOrSegments,
  renderer: callbackOf(or(string, htmlElement))
};
var contextMenuItemLiterals = [
  "defaults",
  "download",
  "zoom-to-cursor",
  "pan-to-cursor",
  "reset-zoom",
  "toggle-series-visibility",
  "toggle-other-series",
  "separator"
];
var contextMenuItemObjectDef = {
  type: union("action", "separator"),
  showOn: union("always", "series-area", "series-node", "legend-item"),
  label: required(string),
  enabled: boolean,
  action: callback,
  items: (value, context) => contextMenuItemsArray(value, context)
};
contextMenuItemObjectDef.iconUrl = undocumented(string);
var contextMenuItemObjectValidator = optionsDefs(contextMenuItemObjectDef);
var contextMenuItemValidator = attachDescription(
  (value, context) => {
    let result;
    if (typeof value === "string") {
      const allowedValues = contextMenuItemLiterals;
      if (allowedValues.includes(value)) {
        result = true;
      } else {
        result = { valid: false, invalid: [], cleared: null };
        result.invalid.push(
          new ValidationError(
            "invalid" /* Invalid */,
            `a context menu item string alias: ["${contextMenuItemLiterals.join('", "')}"]`,
            value,
            context.path
          )
        );
      }
    } else {
      result = contextMenuItemObjectValidator(value, context);
    }
    return result;
  },
  `a context menu item object or string alias: [${contextMenuItemLiterals.join(", ")}]`
);
var contextMenuItemsArray = arrayOf(contextMenuItemValidator, "a menu items array", false);
var toolbarButtonOptionsDefs = {
  label: string,
  ariaLabel: string,
  tooltip: string,
  icon: union(
    "align-center",
    "align-left",
    "align-right",
    "arrow-drawing",
    "arrow-down-drawing",
    "arrow-up-drawing",
    "callout-annotation",
    "candlestick-series",
    "close",
    "comment-annotation",
    "date-range-drawing",
    "date-price-range-drawing",
    "delete",
    "disjoint-channel-drawing",
    "drag-handle",
    "fill-color",
    "line-style-solid",
    "line-style-dashed",
    "line-style-dotted",
    "high-low-series",
    "hlc-series",
    "hollow-candlestick-series",
    "horizontal-line-drawing",
    "line-color",
    "line-series",
    "line-with-markers-series",
    "locked",
    "measurer-drawing",
    "note-annotation",
    "ohlc-series",
    "pan-end",
    "pan-left",
    "pan-right",
    "pan-start",
    "parallel-channel-drawing",
    "position-bottom",
    "position-center",
    "position-top",
    "price-label-annotation",
    "price-range-drawing",
    "reset",
    "settings",
    "step-line-series",
    "text-annotation",
    "trend-line-drawing",
    "fibonacci-retracement-drawing",
    "fibonacci-retracement-trend-based-drawing",
    "unlocked",
    "vertical-line-drawing",
    "zoom-in",
    "zoom-out"
  )
};
var formatter = or(string, callbackOf(string));
var formatObjectValidator = optionsDefs({
  x: formatter,
  y: formatter,
  angle: formatter,
  radius: formatter,
  size: formatter,
  color: formatter,
  label: formatter,
  secondaryLabel: formatter,
  sectorLabel: formatter,
  calloutLabel: formatter,
  legendItem: formatter
});
var numberFormatValidator = attachDescription(isValidNumberFormat, "a valid number format string");
var commonChartOptionsDefs = {
  width: positiveNumber,
  height: positiveNumber,
  minWidth: positiveNumber,
  minHeight: positiveNumber,
  suppressFieldDotNotation: boolean,
  title: chartCaptionOptionsDefs,
  subtitle: chartCaptionOptionsDefs,
  footnote: chartCaptionOptionsDefs,
  padding: {
    top: positiveNumber,
    right: positiveNumber,
    bottom: positiveNumber,
    left: positiveNumber
  },
  seriesArea: {
    border: borderOptionsDef,
    clip: boolean,
    cornerRadius: number,
    padding
  },
  legend: {
    enabled: boolean,
    position: legendPositionValidator,
    orientation: union("horizontal", "vertical"),
    maxWidth: positiveNumber,
    maxHeight: positiveNumber,
    spacing: positiveNumber,
    border: borderOptionsDef,
    cornerRadius: number,
    padding,
    fill: colorUnion,
    fillOpacity: ratio,
    preventHidingAll: boolean,
    reverseOrder: boolean,
    toggleSeries: boolean,
    item: {
      marker: {
        size: positiveNumber,
        shape: shapeValidator,
        padding: positiveNumber,
        strokeWidth: positiveNumber
      },
      line: {
        length: positiveNumber,
        strokeWidth: positiveNumber
      },
      label: {
        maxLength: positiveNumber,
        formatter: callback,
        ...fontOptionsDef
      },
      maxWidth: positiveNumber,
      paddingX: positiveNumber,
      paddingY: positiveNumber,
      showSeriesStroke: boolean
    },
    pagination: {
      marker: {
        size: positiveNumber,
        shape: shapeValidator,
        padding: positiveNumber
      },
      activeStyle: {
        ...fillOptionsDef,
        ...strokeOptionsDef
      },
      inactiveStyle: {
        ...fillOptionsDef,
        ...strokeOptionsDef
      },
      highlightStyle: {
        ...fillOptionsDef,
        ...strokeOptionsDef
      },
      label: fontOptionsDef
    },
    listeners: {
      legendItemClick: callback,
      legendItemDoubleClick: callback
    }
  },
  gradientLegend: {
    enabled: boolean,
    position: legendPositionValidator,
    spacing: positiveNumber,
    reverseOrder: boolean,
    border: borderOptionsDef,
    cornerRadius: number,
    padding,
    fill: colorUnion,
    fillOpacity: ratio,
    gradient: {
      preferredLength: positiveNumber,
      thickness: positiveNumber
    },
    scale: {
      label: {
        ...fontOptionsDef,
        minSpacing: positiveNumber,
        format: numberFormatValidator,
        formatter: callback
      },
      padding: positiveNumber,
      interval: {
        step: number,
        values: array,
        minSpacing: and(positiveNumber, lessThan("maxSpacing")),
        maxSpacing: and(positiveNumber, greaterThan("minSpacing"))
      }
    }
  },
  listeners: {
    seriesNodeClick: callback,
    seriesNodeDoubleClick: callback,
    seriesVisibilityChange: callback,
    click: callback,
    doubleClick: callback,
    annotations: callback,
    zoom: callback
  },
  loadGoogleFonts: boolean,
  highlight: {
    range: union("tooltip", "node")
  },
  overlays: {
    loading: chartOverlayOptionsDefs,
    noData: chartOverlayOptionsDefs,
    noVisibleSeries: chartOverlayOptionsDefs,
    unsupportedBrowser: chartOverlayOptionsDefs
  },
  tooltip: {
    enabled: boolean,
    showArrow: boolean,
    pagination: boolean,
    delay: positiveNumber,
    range: rangeValidator2,
    wrapping: textWrapValidator,
    mode: union("single", "shared", "compact"),
    position: {
      anchorTo: union("pointer", "node", "chart"),
      placement: or(tooltipPlacementValidator, arrayOf(tooltipPlacementValidator)),
      xOffset: number,
      yOffset: number
    }
  },
  animation: {
    enabled: boolean,
    duration: positiveNumber
  },
  contextMenu: {
    enabled: boolean,
    items: contextMenuItemsArray
  },
  context: () => true,
  dataSource: {
    getData: callback
  },
  keyboard: {
    enabled: boolean,
    tabIndex: number
  },
  touch: {
    dragAction: union("none", "drag", "hover")
  },
  ranges: {
    enabled: boolean,
    buttons: arrayOfDefs(
      {
        ...toolbarButtonOptionsDefs,
        value: or(number, and(arrayOf(or(number, date)), arrayLength(2, 2)), callback)
      },
      "range button options array"
    )
  },
  // modules
  locale: {
    localeText: object,
    getLocaleText: callbackOf(string)
  },
  background: {
    visible: boolean,
    fill: color,
    // enterprise
    image: {
      url: required(string),
      top: number,
      right: number,
      bottom: number,
      left: number,
      width: positiveNumber,
      height: positiveNumber,
      opacity: ratio
    }
  },
  styleNonce: string,
  sync: {
    enabled: boolean,
    groupId: string,
    axes: union("x", "y", "xy"),
    nodeInteraction: boolean,
    zoom: boolean
  },
  zoom: {
    enabled: boolean,
    enableAxisDragging: boolean,
    enableAxisScrolling: boolean,
    enableDoubleClickToReset: boolean,
    enablePanning: boolean,
    enableScrolling: boolean,
    enableSelecting: boolean,
    enableTwoFingerZoom: boolean,
    keepAspectRatio: boolean,
    anchorPointX: zoomAnchorPoint,
    anchorPointY: zoomAnchorPoint,
    axisDraggingMode: union("pan", "zoom"),
    axes: union("x", "y", "xy"),
    deceleration: or(union("off", "short", "long"), ratio),
    minVisibleItems: positiveNumber,
    panKey: union("alt", "ctrl", "meta", "shift"),
    scrollingStep: ratio,
    autoScaling: {
      enabled: boolean,
      padding: ratio
    },
    buttons: {
      enabled: boolean,
      buttons: arrayOfDefs(
        {
          ...toolbarButtonOptionsDefs,
          value: union("reset", "zoom-in", "zoom-out", "pan-left", "pan-right", "pan-start", "pan-end"),
          section: string
        },
        "zoom button options array"
      ),
      visible: union("always", "zoomed", "hover")
    }
  },
  formatter: or(callbackOf(string), formatObjectValidator)
};
commonChartOptionsDefs.dataSource.requestThrottle = undocumented(positiveNumber);
commonChartOptionsDefs.dataSource.updateThrottle = undocumented(positiveNumber);
commonChartOptionsDefs.dataSource.updateDuringInteraction = undocumented(boolean);
commonChartOptionsDefs.zoom.enableIndependentAxes = undocumented(boolean);
commonChartOptionsDefs.statusBar = undocumented(defined);
commonChartOptionsDefs.foreground = undocumented({
  visible: boolean,
  text: string,
  image: {
    url: string,
    top: number,
    right: number,
    bottom: number,
    left: number,
    width: positiveNumber,
    height: positiveNumber,
    opacity: ratio
  },
  ...fillOptionsDef
});
commonChartOptionsDefs.overrideDevicePixelRatio = undocumented(number);
commonChartOptionsDefs.sync.domainMode = undocumented(union("direction", "position", "key"));
var commonSeriesThemeableOptionsDefs = {
  cursor: string,
  context: () => true,
  showInLegend: boolean,
  nodeClickRange: rangeValidator2,
  listeners: {
    seriesNodeClick: callback,
    seriesNodeDoubleClick: callback
  },
  // TODO Remove in next major version
  highlightStyle: {
    item: { ...fillOptionsDef, ...strokeOptionsDef },
    series: {
      enabled: boolean,
      dimOpacity: ratio,
      strokeWidth: positiveNumber
    }
  },
  highlight: highlightOptionsDef(shapeHighlightOptionsDef)
};
var commonSeriesOptionsDefs = {
  ...commonSeriesThemeableOptionsDefs,
  id: string,
  visible: boolean,
  context: () => true,
  data: array
};
commonSeriesOptionsDefs.seriesGrouping = undocumented(defined);
var markerOptionsDefs = {
  enabled: boolean,
  shape: shapeValidator,
  size: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    shape: shapeValidator,
    size: positiveNumber
  }),
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var seriesLabelOptionsDefs = {
  enabled: boolean,
  formatter: callback,
  format: numberFormatValidator,
  itemStyler: undocumented(
    callbackDefs({
      enabled: boolean,
      ...labelBoxOptionsDef,
      ...fontOptionsDef
    })
  ),
  ...labelBoxOptionsDef,
  ...fontOptionsDef
};
var autoSizedLabelOptionsDefs = {
  ...seriesLabelOptionsDefs,
  lineHeight: positiveNumber,
  minimumFontSize: positiveNumber,
  wrapping: textWrapValidator,
  overflowStrategy: union("ellipsis", "hide")
};
var errorBarThemeableOptionsDefs = {
  visible: boolean,
  cap: {
    visible: boolean,
    length: positiveNumber,
    lengthRatio: ratio,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var errorBarOptionsDefs = {
  ...errorBarThemeableOptionsDefs,
  xLowerKey: string,
  xUpperKey: string,
  yLowerKey: string,
  yUpperKey: string,
  xLowerName: string,
  xUpperName: string,
  yLowerName: string,
  yUpperName: string,
  itemStyler: callbackDefs({
    visible: boolean,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cap: {
      visible: boolean,
      length: positiveNumber,
      lengthRatio: ratio,
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }
  })
};
var tooltipOptionsDefs = {
  enabled: boolean,
  showArrow: boolean,
  range: rangeValidator2,
  renderer: callbackOf(
    or(
      string,
      optionsDefs(
        {
          heading: string,
          title: string,
          data: arrayOfDefs({
            label: required(string),
            value: required(string)
          })
        },
        "tooltip renderer result object"
      )
    )
  ),
  position: {
    anchorTo: union("node", "pointer", "chart"),
    placement: or(tooltipPlacementValidator, arrayOf(tooltipPlacementValidator)),
    xOffset: number,
    yOffset: number
  },
  interaction: {
    enabled: boolean
  }
};
var shadowOptionsDefs = {
  enabled: boolean,
  xOffset: number,
  yOffset: number,
  blur: positiveNumber,
  color
};
var interpolationOptionsDefs = typeUnion(
  {
    linear: {},
    smooth: {
      tension: ratio
    },
    step: {
      position: union("start", "middle", "end")
    }
  },
  "interpolation line options"
);

// packages/ag-charts-community/src/api/preset/gaugeOptionsDefs.ts
var fillsOptionsDef = {
  fills: and(
    arrayLength(2),
    arrayOf(optionsDefs({ color, stop: number }, "")),
    colorStopsOrderValidator
  ),
  fillMode: union("continuous", "discrete")
};
var linearGaugeTargetOptionsDef = {
  value: required(number),
  text: string,
  shape: or(
    union("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"),
    callback
  ),
  placement: union("before", "after", "middle"),
  spacing: positiveNumber,
  size: positiveNumber,
  rotation: number,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var radialGaugeTargetOptionsDef = {
  value: required(number),
  text: string,
  shape: or(
    union("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"),
    callback
  ),
  placement: union("inside", "outside", "middle"),
  spacing: positiveNumber,
  size: positiveNumber,
  rotation: number,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: positiveNumber
  },
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var linearGaugeSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  cornerMode: union("container", "item"),
  cornerRadius: positiveNumber,
  thickness: positiveNumber,
  segmentation: {
    enabled: boolean,
    spacing: positiveNumber,
    interval: {
      values: arrayOf(number),
      step: number,
      count: number
    }
  },
  bar: {
    enabled: boolean,
    thickness: positiveNumber,
    thicknessRatio: ratio,
    ...fillsOptionsDef,
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  label: {
    ...autoSizedLabelOptionsDefs,
    text: string,
    spacing: positiveNumber,
    avoidCollisions: boolean,
    placement: union(
      "inside-start",
      "outside-start",
      "inside-end",
      "outside-end",
      "inside-center",
      "bar-inside",
      "bar-inside-end",
      "bar-outside-end",
      "bar-end"
    )
  },
  tooltip: tooltipOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["listeners"])
};
var linearGaugeSeriesOptionsDef = {
  ...linearGaugeSeriesThemeableOptionsDef,
  ...without(commonSeriesOptionsDefs, ["listeners"]),
  type: required(constant("linear-gauge")),
  value: required(number),
  scale: {
    min: and(number, lessThan("max")),
    max: and(number, greaterThan("min")),
    label: {
      enabled: boolean,
      formatter: callback,
      rotation: number,
      spacing: positiveNumber,
      minSpacing: positiveNumber,
      placement: union("before", "after"),
      avoidCollisions: boolean,
      format: numberFormatValidator,
      ...fontOptionsDef
    },
    interval: {
      values: arrayOf(number),
      step: number
    },
    ...fillsOptionsDef,
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  targets: arrayOfDefs(linearGaugeTargetOptionsDef, "target options array")
};
linearGaugeSeriesOptionsDef.margin = undocumented(number);
linearGaugeSeriesOptionsDef.defaultColorRange = undocumented(arrayOf(color));
linearGaugeSeriesOptionsDef.defaultTarget = undocumented({
  ...linearGaugeTargetOptionsDef,
  value: number,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: number
  }
});
linearGaugeSeriesOptionsDef.defaultScale = undocumented(linearGaugeSeriesOptionsDef.scale);
linearGaugeSeriesOptionsDef.scale.defaultFill = undocumented(color);
var radialGaugeSeriesThemeableOptionsDef = {
  outerRadius: positiveNumber,
  innerRadius: positiveNumber,
  outerRadiusRatio: ratio,
  innerRadiusRatio: ratio,
  startAngle: number,
  endAngle: number,
  spacing: positiveNumber,
  cornerMode: union("container", "item"),
  cornerRadius: positiveNumber,
  scale: {
    min: and(number, lessThan("max")),
    max: and(number, greaterThan("min")),
    label: {
      enabled: boolean,
      formatter: callback,
      rotation: number,
      spacing: positiveNumber,
      minSpacing: positiveNumber,
      avoidCollisions: boolean,
      format: numberFormatValidator,
      ...fontOptionsDef
    },
    interval: {
      values: arrayOf(number),
      step: number
    },
    ...fillsOptionsDef,
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  segmentation: {
    enabled: boolean,
    spacing: positiveNumber,
    interval: {
      values: arrayOf(number),
      step: number,
      count: number
    }
  },
  bar: {
    enabled: boolean,
    ...fillsOptionsDef,
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  needle: {
    enabled: boolean,
    spacing: positiveNumber,
    radiusRatio: ratio,
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  label: {
    text: string,
    spacing: positiveNumber,
    ...autoSizedLabelOptionsDefs
  },
  secondaryLabel: {
    text: string,
    ...autoSizedLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs
};
var radialGaugeSeriesOptionsDef = {
  ...radialGaugeSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required(constant("radial-gauge")),
  value: required(number),
  targets: arrayOfDefs(radialGaugeTargetOptionsDef, "target options array")
};
radialGaugeSeriesOptionsDef.defaultColorRange = undocumented(arrayOf(color));
radialGaugeSeriesOptionsDef.defaultTarget = undocumented({
  ...radialGaugeTargetOptionsDef,
  value: number,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: number
  }
});
radialGaugeSeriesOptionsDef.scale.defaultFill = undocumented(color);

// packages/ag-charts-community/src/chart/axesOptionsDefs.ts
var timeIntervalUnit = union("millisecond", "second", "minute", "hour", "day", "month", "year");
var timeIntervalDefs = {
  unit: required(timeIntervalUnit),
  step: positiveNumberNonZero,
  epoch: date,
  utc: boolean
};
timeIntervalDefs.every = callback;
var timeInterval2 = optionsDefs(timeIntervalDefs, "a time interval object");
var commonCrossLineLabelOptionsDefs = {
  enabled: boolean,
  text: string,
  padding: number,
  ...fontOptionsDef
};
var commonCrossLineOptionsDefs = attachDescription(
  {
    enabled: boolean,
    type: required(union("line", "range")),
    range: and(
      attachDescription((_, { options }) => options.type === "range", "crossLine type to be 'range'"),
      arrayOf(defined),
      arrayLength(2, 2)
    ),
    value: and(
      attachDescription((_, { options }) => options.type === "line", "crossLine type to be 'line'"),
      defined
    ),
    label: commonCrossLineLabelOptionsDefs,
    fill: color,
    fillOpacity: ratio,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  "cross-line options"
);
var cartesianCrossLineOptionsDefs = {
  ...commonCrossLineOptionsDefs,
  label: {
    ...commonCrossLineLabelOptionsDefs,
    position: union(
      "top",
      "left",
      "right",
      "bottom",
      "top-left",
      "top-right",
      "bottom-left",
      "bottom-right",
      "inside",
      "inside-left",
      "inside-right",
      "inside-top",
      "inside-bottom",
      "inside-top-left",
      "inside-bottom-left",
      "inside-top-right",
      "inside-bottom-right"
    ),
    rotation: number
  }
};
var commonAxisLabelOptionsDefs = {
  enabled: boolean,
  rotation: number,
  avoidCollisions: boolean,
  minSpacing: positiveNumber,
  spacing: positiveNumber,
  formatter: callback,
  itemStyler: undocumented(
    callbackDefs({
      ...fontOptionsDef,
      ...labelBoxOptionsDef,
      spacing: number
    })
  ),
  ...fontOptionsDef,
  ...labelBoxOptionsDef
};
var cartesianAxisLabelOptionsDefs = {
  autoRotate: boolean,
  autoRotateAngle: number,
  wrapping: union("never", "always", "hyphenate", "on-space"),
  truncate: boolean,
  ...commonAxisLabelOptionsDefs
};
var cartesianNumericAxisLabel = {
  format: numberFormatValidator,
  ...cartesianAxisLabelOptionsDefs
};
var cartesianTimeAxisLabel = {
  format: or(string, object),
  ...cartesianAxisLabelOptionsDefs
};
var cartesianAxisTick = {
  enabled: boolean,
  width: positiveNumber,
  size: positiveNumber,
  stroke: color
};
var cartesianTimeAxisParentLevel = {
  enabled: boolean,
  label: cartesianTimeAxisLabel,
  tick: cartesianAxisTick
};
var commonAxisIntervalOptionsDefs = {
  values: arrayOf(defined),
  minSpacing: positiveNumber
};
var commonAxisOptionsDefs = {
  reverse: boolean,
  gridLine: {
    enabled: boolean,
    width: positiveNumber,
    style: arrayOfDefs(
      {
        fill: color,
        fillOpacity: positiveNumber,
        stroke: or(color, themeOperator),
        strokeWidth: positiveNumber,
        lineDash: arrayOf(positiveNumber)
      },
      "a grid-line style object array"
    )
  },
  interval: commonAxisIntervalOptionsDefs,
  label: commonAxisLabelOptionsDefs,
  line: {
    enabled: boolean,
    width: positiveNumber,
    stroke: color
  },
  tick: cartesianAxisTick,
  context: () => true
};
commonAxisOptionsDefs.layoutConstraints = undocumented({
  stacked: required(boolean),
  align: required(union("start", "end")),
  unit: required(union("percent", "px")),
  width: required(positiveNumber)
});
var cartesianAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  keys: arrayOf(string),
  crossLines: arrayOfDefs(cartesianCrossLineOptionsDefs, "a cross-line options array"),
  position: union("top", "right", "bottom", "left"),
  thickness: positiveNumber,
  maxThicknessRatio: ratio,
  title: {
    enabled: boolean,
    text: string,
    spacing: positiveNumber,
    formatter: callback,
    ...fontOptionsDef
  }
};
cartesianAxisOptionsDefs.title._enabledFromTheme = undocumented(boolean);
var cartesianAxisBandHighlightOptions = {
  enabled: boolean,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
function cartesianAxisCrosshairOptions(canFormat, timeFormat) {
  const baseCrosshairLabel = {
    enabled: boolean,
    xOffset: number,
    yOffset: number,
    formatter: callbackOf(string),
    renderer: callbackOf(
      or(
        string,
        optionsDefs(
          {
            text: string,
            color,
            backgroundColor: color,
            opacity: ratio
          },
          "crosshair label renderer result object"
        )
      )
    )
  };
  let crosshairLabel;
  if (canFormat) {
    crosshairLabel = {
      ...baseCrosshairLabel,
      format: timeFormat ? or(
        string,
        optionsDefs({
          millisecond: string,
          second: string,
          hour: string,
          day: string,
          month: string,
          year: string
        })
      ) : string
    };
  }
  return {
    enabled: boolean,
    snap: boolean,
    label: crosshairLabel ?? baseCrosshairLabel,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  };
}
function continuousAxisOptions(validDatum, supportTimeInterval) {
  return {
    min: and(validDatum, lessThan("max")),
    max: and(validDatum, greaterThan("min")),
    nice: boolean,
    interval: {
      step: supportTimeInterval ? or(positiveNumberNonZero, timeIntervalUnit, timeInterval2) : positiveNumberNonZero,
      values: arrayOf(validDatum),
      minSpacing: and(positiveNumber, lessThan("maxSpacing")),
      maxSpacing: and(positiveNumber, greaterThan("minSpacing"))
    }
  };
}
var discreteTimeAxisIntervalOptionsDefs = {
  step: or(positiveNumberNonZero, timeIntervalUnit, timeInterval2),
  values: arrayOf(or(number, date)),
  minSpacing: and(positiveNumber, lessThan("maxSpacing")),
  maxSpacing: and(positiveNumber, greaterThan("minSpacing")),
  placement: union("on", "between")
};

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
var _CategoryAxis = class _CategoryAxis extends CartesianAxis {
  constructor(moduleCtx, scale2 = new CategoryScale(), includeInvisibleDomains = true) {
    super(moduleCtx, scale2);
    this.groupPaddingInner = 0.1;
    this.includeInvisibleDomains = includeInvisibleDomains;
    this.nice = false;
  }
  static is(value) {
    return value instanceof _CategoryAxis;
  }
  isCategoryLike() {
    return true;
  }
  hasDefinedDomain() {
    return false;
  }
  normaliseDataDomain(domain) {
    return { domain, clipped: false };
  }
  updateScale() {
    super.updateScale();
    let { paddingInner, paddingOuter } = this;
    if (!isFiniteNumber(paddingInner) || !isFiniteNumber(paddingOuter)) {
      const padding2 = this.reduceBandScalePadding();
      paddingInner ?? (paddingInner = padding2.inner);
      paddingOuter ?? (paddingOuter = padding2.outer);
    }
    this.scale.paddingInner = paddingInner ?? 0;
    this.scale.paddingOuter = paddingOuter ?? 0;
  }
  calculateGridLines(ticks, p1, p2) {
    const gridLines = super.calculateGridLines(ticks, p1, p2);
    if (this.interval.placement === "between" && ticks.length > 0) {
      gridLines.push(
        super.calculateGridLine(
          {
            index: ticks.at(-1).index + 1,
            tickId: `after:${ticks.at(-1).tickId}`,
            translation: this.range[1]
          },
          ticks.length,
          p1,
          p2,
          ticks
        )
      );
    }
    return gridLines;
  }
  calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks) {
    const { gridLine, horizontal, interval, scale: scale2 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks);
    }
    const halfStep = translation < scale2.step ? Math.floor(scale2.step / 2) : scale2.step / 2;
    const offset = translation - halfStep;
    const [x1, y1, x2, y2] = horizontal ? [offset, Math.max(p1, p2), offset, Math.min(p1, p2)] : [Math.min(p1, p2), offset, Math.max(p1, p2), offset];
    const { style: style2 } = gridLine;
    const { stroke: stroke3, strokeWidth = 0, lineDash } = style2[tickIndex % style2.length] ?? {};
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
  }
  calculateGridFills(ticks, p1, p2) {
    const { horizontal, range: range4, scale: scale2 } = this;
    if (this.interval.placement !== "between") {
      return super.calculateGridFills(ticks, p1, p2);
    }
    const gridFills = [];
    if (ticks.length == 0)
      return gridFills;
    const firstTick = ticks[0];
    const firstFillOffCanvas = firstTick.translation > range4[0] + scale2.step / 2;
    const lastTick = ticks[ticks.length - 1];
    const lastFillOffCanvas = horizontal && lastTick.translation < range4[1] - scale2.step / 2;
    if (firstFillOffCanvas) {
      const tick = { tickId: `before:${firstTick.tickId}`, translation: firstTick.translation - scale2.step };
      gridFills.push(this.calculateGridFill(tick, -1, firstTick.index - 1, p1, p2, ticks));
    }
    gridFills.push(...ticks.map((tick, index) => this.calculateGridFill(tick, index, tick.index, p1, p2, ticks)));
    if (lastFillOffCanvas) {
      const tick = { tickId: `after:${lastTick.tickId}`, translation: lastTick.translation + scale2.step };
      gridFills.push(this.calculateGridFill(tick, ticks.length, lastTick.index + 1, p1, p2, ticks));
    }
    return gridFills;
  }
  calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks) {
    const { gridLine, horizontal, interval, scale: scale2 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks);
    }
    const startOffset = translation - scale2.step / 2;
    const endOffset = translation + scale2.step / 2;
    const [x1, y1, x2, y2] = horizontal ? [startOffset, Math.max(p1, p2), endOffset, Math.min(p1, p2)] : [Math.min(p1, p2), startOffset, Math.max(p1, p2), endOffset];
    const { fill, fillOpacity } = gridLine.style[gridFillIndex % gridLine.style.length] ?? {};
    return { tickId, x1, y1, x2, y2, fill, fillOpacity };
  }
  calculateTickLines(ticks, direction) {
    const tickLines = super.calculateTickLines(ticks, direction);
    if (this.interval.placement === "between" && ticks.length > 0) {
      tickLines.push(
        super.calculateTickLine(
          { primary: false, tickId: `after:${ticks.at(-1)?.tickId}`, translation: this.range[1] },
          ticks.length,
          direction,
          ticks
        )
      );
    }
    return tickLines;
  }
  calculateTickLine({ primary, tickId, translation }, index, direction, ticks) {
    const { horizontal, interval, primaryTick, scale: scale2, tick } = this;
    if (interval.placement !== "between") {
      return super.calculateTickLine({ primary, tickId, translation }, index, direction, ticks);
    }
    const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
    const h = -direction * this.getTickSize(datumTick);
    const halfStep = translation < scale2.step ? Math.floor(scale2.step / 2) : scale2.step / 2;
    const offset = translation - halfStep;
    const [x1, y1, x2, y2] = horizontal ? [offset, 0, offset, h] : [0, offset, h, offset];
    const { stroke: stroke3, width: strokeWidth } = datumTick;
    const lineDash = void 0;
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
  }
  reduceBandScalePadding() {
    return this.boundSeries.reduce(
      (result, series) => {
        const padding2 = series.getBandScalePadding?.();
        if (padding2) {
          if (result.inner > padding2.inner) {
            result.inner = padding2.inner;
          }
          if (result.outer < padding2.outer) {
            result.outer = padding2.outer;
          }
        }
        return result;
      },
      { inner: Infinity, outer: -Infinity }
    );
  }
  tickFormatParams(_domain, _ticks, _fractionDigits, _timeInterval) {
    return { type: "category" };
  }
  datumFormatParams(value, params, _fractionDigits, _timeInterval, _style) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    if (Array.isArray(value) && value.some((v) => typeof v !== "string")) {
      value = value.map(String);
    } else if (!Array.isArray(value) && typeof value !== "string" && typeof value !== "number" && !(value instanceof Date)) {
      value = String(value);
    }
    return { type: "category", value, datum, seriesId, legendItemName, key, source, property, domain, boundSeries };
  }
};
_CategoryAxis.className = "CategoryAxis";
_CategoryAxis.type = "category";
__decorateClass([
  Property
], _CategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  Property
], _CategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
  Property
], _CategoryAxis.prototype, "paddingOuter", 2);
var CategoryAxis = _CategoryAxis;

// packages/ag-charts-community/src/scale/groupedCategoryScale.ts
var GroupedCategoryScale = class _GroupedCategoryScale extends CategoryScale {
  static is(value) {
    return value instanceof _GroupedCategoryScale;
  }
  normalizeDomains(...domains) {
    const { domain } = super.normalizeDomains(...domains);
    return { domain, animatable: false };
  }
  findIndex(value) {
    return super.findIndex(value) ?? this.getMatchIndex(value);
  }
  getMatchIndex(value) {
    const key = JSON.stringify(value);
    const match = this._domain.find((d) => JSON.stringify(d) === key);
    if (match != null) {
      return super.findIndex(match);
    }
  }
};

// packages/ag-charts-community/src/util/extent.ts
function extent(values) {
  if (values.length === 0) {
    return null;
  }
  let min = Infinity;
  let max = -Infinity;
  for (const n of values) {
    const v = n instanceof Date ? n.getTime() : n;
    if (typeof v !== "number")
      continue;
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
  }
  const result = [min, max];
  return result.every(isFinite) ? result : null;
}
function normalisedExtentWithMetadata(d, min, max) {
  let clipped = false;
  const de = extent(d);
  if (de == null) {
    return { extent: min != null && max != null && min <= max ? [min, max] : [], clipped: false };
  }
  let [d0, d1] = de;
  if (min != null) {
    clipped || (clipped = min > d0);
    d0 = min;
  }
  if (max != null) {
    clipped || (clipped = max < d1);
    d1 = max;
  }
  if (d0 > d1) {
    return { extent: [], clipped: false };
  }
  return { extent: [d0, d1], clipped };
}

// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts
function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function sum(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values)
  };
  return result;
}
function groupSum(id, matchGroupId) {
  return {
    id,
    type: "aggregate",
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function range2(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)
  };
  return result;
}
function groupCount(id) {
  return {
    id,
    type: "aggregate",
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function groupAverage(id, matchGroupId) {
  const def = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result = acc[0] + acc[1];
      if (result >= 0) {
        return [0, result / acc[2]];
      }
      return [result / acc[2], 0];
    }
  };
  return def;
}
function area(id, aggFn, matchGroupId) {
  const result = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue(onlyPositive) {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum)) {
        return datum;
      }
      value += onlyPositive ? Math.max(0, datum) : datum;
      return value;
    };
  };
}
function trailingAccumulatedValue() {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum)) {
        return datum;
      }
      const trailingValue = value;
      value += datum;
      return trailingValue;
    };
  };
}

// packages/ag-charts-community/src/chart/data/processors.ts
var MAX_ANIMATABLE_NODES = 1e3;
function processedDataIsAnimatable(processedData) {
  return processedData.input.count <= MAX_ANIMATABLE_NODES;
}
function basicContinuousCheckDatumValidation(value) {
  return value != null && isContinuous(value);
}
function basicDiscreteCheckDatumValidation(value) {
  return value != null;
}
function getValidationFn(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "unit-time":
    case "ordinal-time":
    case "color":
      return basicContinuousCheckDatumValidation;
    default:
      return basicDiscreteCheckDatumValidation;
  }
}
function getValueType(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "color":
      return "range";
    default:
      return "category";
  }
}
function keyProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "key",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function valueProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function rowCountProperty(propName, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: "range",
    missingValue: 1,
    processor: () => () => 1,
    ...opts
  };
  return result;
}
var noopProcessor = function(v) {
  return v;
};
function processorChain(...chain) {
  const filteredChain = chain.filter((fn) => fn != null);
  if (filteredChain.length === 0) {
    return () => noopProcessor;
  }
  if (filteredChain.length === 1) {
    return filteredChain[0];
  }
  return () => {
    const processorInstances = filteredChain.map((fn) => fn());
    return (value, index) => {
      return processorInstances.reduce((r, p) => p(r, index), value);
    };
  };
}
function rangedValueProperty(propName, opts = {}) {
  const { min = -Infinity, max = Infinity, processor, ...defOpts } = opts;
  return {
    type: "value",
    property: propName,
    valueType: "range",
    validation: basicContinuousCheckDatumValidation,
    processor: processorChain(processor, () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum),
    ...defOpts
  };
}
function accumulativeValueProperty(propName, scaleType, opts = {}) {
  const { onlyPositive, processor, ...defOpts } = opts;
  const result = {
    ...valueProperty(propName, scaleType, defOpts),
    processor: processorChain(processor, accumulatedValue(onlyPositive))
  };
  return result;
}
function trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {
  const result = {
    ...valueProperty(propName, scaleType, opts),
    processor: trailingAccumulatedValue()
  };
  return result;
}
function groupAccumulativeValueProperty(propName, mode, sum2, opts, scaleType) {
  return [
    valueProperty(propName, scaleType, opts),
    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),
    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []
  ];
}
function groupStackValueProperty(propName, scaleType, opts) {
  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];
}
var SMALLEST_KEY_INTERVAL = {
  type: "reducer",
  property: "smallestKeyInterval",
  initialValue: Infinity,
  reducer: () => {
    let prevX = NaN;
    return (smallestSoFar = Infinity, keys) => {
      const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
        return interval;
      }
      return smallestSoFar;
    };
  }
};
var LARGEST_KEY_INTERVAL = {
  type: "reducer",
  property: "largestKeyInterval",
  initialValue: -Infinity,
  reducer: () => {
    let prevX = NaN;
    return (largestSoFar = -Infinity, keys) => {
      const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {
        return interval;
      }
      return largestSoFar;
    };
  }
};
var SORT_DOMAIN_GROUPS = {
  type: "processor",
  property: "sortedGroupDomain",
  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {
    for (let i = 0; i < a.length; i++) {
      const result = a[i] - b[i];
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  })
};
function normaliseFnBuilder({ normaliseTo }) {
  const normalise2 = (val, extent3) => {
    if (extent3 === 0)
      return null;
    const result = (val ?? 0) * normaliseTo / extent3;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return () => () => (columns, valueIndexes, dataGroup) => {
    const extent3 = normaliseFindExtent(columns, valueIndexes, dataGroup);
    for (const valueIdx of valueIndexes) {
      const datumIndices = dataGroup.datumIndices[valueIdx];
      if (datumIndices == null)
        continue;
      for (const datumIndex of datumIndices) {
        const column = columns[valueIdx];
        const value = column[datumIndex];
        if (value == null) {
          column[datumIndex] = void 0;
          continue;
        }
        column[datumIndex] = // eslint-disable-next-line sonarjs/no-nested-functions
        typeof value === "number" ? normalise2(value, extent3) : value.map((v) => normalise2(v, extent3));
      }
    }
  };
}
function normaliseFindExtent(columns, valueIndexes, dataGroup) {
  const valuesExtent = [0, 0];
  for (const valueIdx of valueIndexes) {
    const column = columns[valueIdx];
    const datumIndices = dataGroup.datumIndices[valueIdx];
    if (datumIndices == null)
      continue;
    for (const datumIndex of datumIndices) {
      const value = column[datumIndex];
      if (value == null)
        continue;
      const valueExtent = typeof value === "number" ? value : Math.max(...value.map((v) => v ?? 0));
      const valIdx = valueExtent < 0 ? 0 : 1;
      if (valIdx === 0) {
        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);
      } else {
        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);
      }
    }
  }
  return Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
}
function normaliseGroupTo(matchGroupIds, normaliseTo) {
  return {
    type: "group-value-processor",
    matchGroupIds,
    adjust: memo({ normaliseTo }, normaliseFnBuilder)
  };
}
function normalisePropertyFnBuilder({
  normaliseTo,
  zeroDomain,
  rangeMin,
  rangeMax
}) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise2 = (val, start2, span) => {
    const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;
    if (span === 0) {
      return zeroDomain;
    } else if (result >= normaliseTo[1]) {
      return normaliseTo[1];
    } else if (result < normaliseTo[0]) {
      return normaliseTo[0];
    }
    return result;
  };
  return () => (pData, pIdx) => {
    let [start2, end2] = pData.domain.values[pIdx];
    if (rangeMin != null)
      start2 = rangeMin;
    if (rangeMax != null)
      end2 = rangeMax;
    const span = end2 - start2;
    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
    const column = pData.columns[pIdx];
    for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {
      column[datumIndex] = normalise2(column[datumIndex], start2, span);
    }
  };
}
function normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
  return {
    type: "property-value-processor",
    property,
    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)
  };
}
var ANIMATION_VALIDATION_UNIQUE_KEYS = 1;
var ANIMATION_VALIDATION_ORDERED_KEYS = 2;
function animationValidationProcessKey(count, def, keyValues, column) {
  let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
  if (def.valueType === "category") {
    if (keyValues.length < count)
      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
    return validation;
  }
  let lastValue = column[0]?.valueOf();
  for (let d = 1; validation !== 0 && d < column.length; d++) {
    const keyValue = column[d]?.valueOf();
    if (!Number.isFinite(keyValue) || lastValue > keyValue)
      validation &= ~ANIMATION_VALIDATION_ORDERED_KEYS;
    if (Number.isFinite(keyValue) && lastValue === keyValue)
      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
    lastValue = keyValue;
  }
  return validation;
}
function animationValidation(valueKeyIds) {
  return {
    type: "processor",
    property: "animationValidation",
    calculate(result) {
      if (!processedDataIsAnimatable(result))
        return;
      const { keys: keysDefs, values: valuesDef } = result.defs;
      const {
        input,
        domain: { keys: domainKeys, values: domainValues },
        keys,
        columns,
        invalidKeyCount
      } = result;
      let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
      if (input.count !== 0) {
        for (let i = 0; validation !== 0 && i < keysDefs.length; i++) {
          for (const scope of keysDefs[i].scopes) {
            const column = keys[i].get(scope);
            const missingKeys = invalidKeyCount?.get(scope) ?? 0;
            const count = column.length - missingKeys;
            validation &= animationValidationProcessKey(count, keysDefs[i], domainKeys[i], column);
          }
        }
        for (let i = 0; validation !== 0 && i < valuesDef.length; i++) {
          const value = valuesDef[i];
          if (!valueKeyIds?.includes(value.id))
            continue;
          validation &= animationValidationProcessKey(
            0,
            value,
            domainValues[i],
            columns[i]
          );
        }
      }
      return {
        uniqueKeys: (validation & ANIMATION_VALIDATION_UNIQUE_KEYS) !== 0,
        orderedKeys: (validation & ANIMATION_VALIDATION_ORDERED_KEYS) !== 0
      };
    }
  };
}
function buildGroupAccFn({ mode, separateNegative }) {
  return () => () => (columns, valueIndexes, dataGroup) => {
    const acc = [0, 0];
    for (const valueIdx of valueIndexes) {
      const datumIndices = dataGroup.datumIndices[valueIdx];
      if (datumIndices == null)
        continue;
      for (const datumIndex of datumIndices) {
        const column = columns[valueIdx];
        const currentVal = column[datumIndex];
        const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;
        if (!isFiniteNumber(currentVal))
          continue;
        if (mode === "normal")
          acc[accIndex] += currentVal;
        column[datumIndex] = acc[accIndex];
        if (mode === "trailing")
          acc[accIndex] += currentVal;
      }
    }
  };
}
function buildGroupWindowAccFn({ mode, sum: sum2 }) {
  return () => {
    const lastValues = [];
    let firstRow = true;
    return () => {
      return (columns, valueIndexes, dataGroup) => {
        let acc = 0;
        for (const valueIdx of valueIndexes) {
          const column = columns[valueIdx];
          const datumIndices = dataGroup.datumIndices[valueIdx];
          if (datumIndices == null)
            continue;
          for (const datumIndex of datumIndices) {
            const currentVal = column[datumIndex];
            const lastValue = firstRow && sum2 === "current" ? 0 : lastValues[valueIdx];
            lastValues[valueIdx] = currentVal;
            const sumValue = sum2 === "current" ? currentVal : lastValue;
            if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {
              column[datumIndex] = acc;
              continue;
            }
            if (mode === "normal") {
              acc += sumValue;
            }
            column[datumIndex] = acc;
            if (mode === "trailing") {
              acc += sumValue;
            }
          }
        }
        firstRow = false;
      };
    };
  };
}
function accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {
  let adjust;
  if (mode.startsWith("window")) {
    const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);
  } else {
    adjust = memo({ mode, separateNegative }, buildGroupAccFn);
  }
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust
  };
}
function groupStackAccFn() {
  return () => (columns, valueIndexes, dataGroup) => {
    const acc = new Float64Array(valueIndexes.length);
    let stackCount = 0;
    for (const valueIdx of valueIndexes) {
      const column = columns[valueIdx];
      const datumIndices = dataGroup.datumIndices[valueIdx];
      if (datumIndices == null)
        continue;
      for (const datumIndex of datumIndices) {
        const currentValue = column[datumIndex];
        acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;
        stackCount += 1;
        column[datumIndex] = acc.subarray(0, stackCount);
      }
    }
  };
}
function accumulateStack(matchGroupId) {
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust: groupStackAccFn
  };
}
function valueIdentifier(value) {
  return value.id ?? value.property;
}
function valueIndices(id, previousData, processedData) {
  const properties = /* @__PURE__ */ new Map();
  const previousValues = previousData.defs.values;
  for (let previousIndex = 0; previousIndex < previousValues.length; previousIndex += 1) {
    const previousValue = previousValues[previousIndex];
    if (previousValue.scopes?.includes(id) === false)
      continue;
    const valueId = valueIdentifier(previousValue);
    if (properties.has(valueId))
      return;
    properties.set(valueId, previousIndex);
  }
  const indices = [];
  const nextValues = processedData.defs.values;
  for (let nextIndex = 0; nextIndex < nextValues.length; nextIndex += 1) {
    const nextValue = nextValues[nextIndex];
    if (nextValue.scopes?.includes(id) === false)
      continue;
    const valueId = valueIdentifier(nextValue);
    const previousIndex = properties.get(valueId);
    if (previousIndex == null)
      return;
    properties.delete(valueId);
    indices.push({ previousIndex, nextIndex });
  }
  if (properties.size !== 0)
    return;
  return indices;
}
function columnsEqual(previousColumns, nextColumns, indices, previousDatumIndex, nextDatumIndex) {
  for (const { previousIndex, nextIndex } of indices) {
    const previousColumn = previousColumns[previousIndex];
    const nextColumn = nextColumns[nextIndex];
    const previousValue = previousColumn[previousDatumIndex];
    const nextValue = nextColumn[nextDatumIndex];
    if (previousValue !== nextValue) {
      return false;
    }
  }
  return true;
}
function diff(id, previousData, updateMovedData = true) {
  return {
    type: "processor",
    property: "diff",
    calculate(processedData, previousValue) {
      if (!processedDataIsAnimatable(processedData))
        return;
      const moved = /* @__PURE__ */ new Map();
      const added = /* @__PURE__ */ new Map();
      const updated = /* @__PURE__ */ new Map();
      const removed = /* @__PURE__ */ new Map();
      const previousKeys = previousData.keys;
      const keys = processedData.keys;
      const previousColumns = previousData.columns;
      const columns = processedData.columns;
      const indices = valueIndices(id, previousData, processedData);
      if (indices == null)
        return previousValue;
      const length2 = Math.max(previousData.input.count, processedData.input.count);
      for (let i = 0; i < length2; i++) {
        const hasPreviousDatum = i < previousData.input.count;
        const hasDatum = i < processedData.input.count;
        const prevKeys = hasPreviousDatum ? datumKeys(previousKeys, id, i) : void 0;
        const prevId = prevKeys != null ? createDatumId(prevKeys) : "";
        const dKeys = hasDatum ? datumKeys(keys, id, i) : void 0;
        const datumId = dKeys != null ? createDatumId(dKeys) : "";
        if (hasDatum && hasPreviousDatum && prevId === datumId) {
          if (!columnsEqual(previousColumns, columns, indices, i, i)) {
            updated.set(datumId, i);
          }
          continue;
        }
        const removedIndex = removed.get(datumId);
        if (removedIndex != null) {
          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, removedIndex, i)) {
            updated.set(datumId, i);
            moved.set(datumId, i);
          }
          removed.delete(datumId);
        } else if (hasDatum) {
          added.set(datumId, i);
        }
        const addedIndex = added.get(prevId);
        if (addedIndex != null) {
          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, addedIndex, i)) {
            updated.set(prevId, i);
            moved.set(prevId, i);
          }
          added.delete(prevId);
        } else if (hasPreviousDatum) {
          updated.delete(prevId);
          removed.set(prevId, i);
        }
      }
      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;
      const value = {
        changed,
        added: new Set(added.keys()),
        updated: new Set(updated.keys()),
        removed: new Set(removed.keys()),
        moved: new Set(moved.keys())
      };
      return {
        ...previousValue,
        [id]: value
      };
    }
  };
}
function createDatumId(keys, ...extraKeys) {
  let result;
  if (isArray(keys)) {
    result = keys.map((key) => transformIntegratedCategoryValue(key)).join("___");
  } else {
    result = transformIntegratedCategoryValue(keys);
  }
  const primitiveType = typeof result === "string" || typeof result === "number" || typeof result === "boolean" || result instanceof Date;
  if (primitiveType && extraKeys.length > 0) {
    result += `___${extraKeys.join("___")}`;
  }
  return result;
}

// packages/ag-charts-community/src/chart/axis/tree.ts
var Dimensions = class {
  constructor() {
    this.top = Infinity;
    this.right = -Infinity;
    this.bottom = -Infinity;
    this.left = Infinity;
  }
  update(x, y) {
    if (x > this.right) {
      this.right = x;
    }
    if (x < this.left) {
      this.left = x;
    }
    if (y > this.bottom) {
      this.bottom = y;
    }
    if (y < this.top) {
      this.top = y;
    }
  }
};
var TreeNode = class _TreeNode {
  constructor(label = "", parent, refId) {
    this.label = label;
    this.parent = parent;
    this.refId = refId;
    this.position = 0;
    this.subtreeLeft = NaN;
    this.subtreeRight = NaN;
    this.children = [];
    this.leafCount = 0;
    this.prelim = 0;
    this.mod = 0;
    this.ancestor = this;
    this.change = 0;
    this.shift = 0;
    this.index = 0;
    // screen is meant to be recomputed from (layout) when the tree is resized (without performing another layout)
    this.screen = 0;
    this.depth = parent ? parent.depth + 1 : 0;
  }
  insertTick(tick, index) {
    let root = this;
    for (let i = 0; i < tick.length; i++) {
      const pathPart = tick[i];
      const isNotLeaf = i !== tick.length - 1;
      const { children } = root;
      const existingNode = children.find((child) => child.label === pathPart);
      if (existingNode && isNotLeaf) {
        root = existingNode;
      } else {
        const node = new _TreeNode(pathPart, root, index);
        node.index = children.length;
        children.push(node);
        if (isNotLeaf) {
          root = node;
        }
      }
    }
  }
  getLeftSibling() {
    return this.index > 0 ? this.parent?.children[this.index - 1] : void 0;
  }
  getLeftmostSibling() {
    return this.index > 0 ? this.parent?.children[0] : void 0;
  }
  // traverse the left contour of a subtree, return the successor of v on this contour
  nextLeft() {
    return this.children[0];
  }
  // traverse the right contour of a subtree, return the successor of v on this contour
  nextRight() {
    return this.children.at(-1);
  }
  getSiblings() {
    return this.parent?.children.filter((_, i) => i !== this.index) ?? [];
  }
};
function ticksToTree(ticks) {
  const maxDepth = ticks.reduce((depth, tick) => depth < tick.length ? tick.length : depth, 0);
  const root = new TreeNode();
  for (let i = 0; i < ticks.length; i++) {
    const tick = ticks[i];
    while (tick.length < maxDepth) {
      tick.push("");
    }
    root.insertTick(tick, i);
  }
  return root;
}
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.index - wm.index;
  const ratio2 = shift / subtrees;
  wp.change -= ratio2;
  wp.shift += shift;
  wm.change += ratio2;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts({ children }) {
  let shift = 0;
  let change = 0;
  for (let i = children.length - 1; i >= 0; i--) {
    const w = children[i];
    w.prelim += shift;
    w.mod += shift;
    change += w.change;
    shift += w.shift + change;
  }
}
function apportion(v, defaultAncestor) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + 1;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
function firstWalk(node) {
  const { children } = node;
  if (children.length) {
    let [defaultAncestor] = children;
    for (const child of children) {
      firstWalk(child);
      defaultAncestor = apportion(child, defaultAncestor);
    }
    executeShifts(node);
    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + 1;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + 1 : 0;
  }
}
function secondWalk(v, m, layout) {
  v.position = v.prelim + m;
  layout.insertNode(v);
  for (const w of v.children) {
    secondWalk(w, m + v.mod, layout);
  }
}
function thirdWalk(v) {
  const { children } = v;
  let leafCount = 0;
  for (const w of children) {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  }
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[children.length - 1].subtreeRight;
    v.position = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.position;
    v.subtreeRight = v.position;
  }
}
function treeLayout(ticks) {
  const layout = new TreeLayout();
  const root = ticksToTree(ticks);
  firstWalk(root);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
var TreeLayout = class {
  constructor() {
    this.dimensions = new Dimensions();
    this.nodes = [];
    this.depth = 0;
  }
  insertNode(node) {
    if (this.depth < node.depth) {
      this.depth = node.depth;
    }
    this.dimensions.update(node.position, node.depth);
    this.nodes.push(node);
  }
  scaling(extent3, flip) {
    let scaling = 1;
    if (extent3 > 0) {
      const { left, right } = this.dimensions;
      if (right !== left) {
        scaling = extent3 / (right - left);
      }
    }
    if (flip) {
      scaling *= -1;
    }
    return scaling;
  }
};

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var DepthLabelProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.border = new LabelBorder();
  }
};
__decorateClass([
  Property
], DepthLabelProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "avoidCollisions", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "border", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "color", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "spacing", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "wrapping", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "truncate", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fill", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontStyle", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontWeight", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontSize", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontFamily", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "padding", 2);
var DepthTickProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
};
__decorateClass([
  Property
], DepthTickProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], DepthTickProperties.prototype, "width", 2);
__decorateClass([
  Property
], DepthTickProperties.prototype, "stroke", 2);
var DepthProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.label = new DepthLabelProperties();
    this.tick = new DepthTickProperties();
  }
};
__decorateClass([
  Property
], DepthProperties.prototype, "label", 2);
__decorateClass([
  Property
], DepthProperties.prototype, "tick", 2);
var GroupedCategoryAxis = class extends CategoryAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new GroupedCategoryScale());
    // Label scale (labels are positioned between ticks, tick count = label count + 1).
    // We don't call is `labelScale` for consistency with other axes.
    this.tickScale = new GroupedCategoryScale();
    this.depthOptions = new PropertiesArray(DepthProperties);
    this.includeInvisibleDomains = true;
    this.tickScale.paddingInner = 1;
    this.tickScale.paddingOuter = 0;
  }
  resizeTickTree() {
    if (!this.tickTreeLayout)
      return;
    const { nodes } = this.tickTreeLayout;
    const { range: range4, step, inset, bandwidth } = this.scale;
    const width2 = Math.abs(range4[1] - range4[0]) - step;
    const scaling = this.tickTreeLayout.scaling(width2, range4[0] > range4[1]);
    const shift = inset + bandwidth / 2;
    let offset = 0;
    for (const node of nodes) {
      const screen = node.position * scaling;
      if (offset > screen) {
        offset = screen;
      }
      node.screen = screen + shift;
    }
    for (const node of nodes) {
      node.screen -= offset;
    }
  }
  getDepthOptionsMap(maxDepth) {
    const optionsMap = [];
    const { depthOptions, label } = this;
    const defaultNonLeafRotation = this.horizontal ? 0 : -90;
    for (let i = 0; i < maxDepth; i++) {
      optionsMap.push(
        depthOptions[i]?.label.enabled ?? label.enabled ? {
          enabled: true,
          spacing: depthOptions[i]?.label.spacing ?? label.spacing,
          wrapping: depthOptions[i]?.label.wrapping ?? label.wrapping,
          truncate: depthOptions[i]?.label.truncate ?? label.truncate,
          rotation: depthOptions[i]?.label.rotation ?? (i ? defaultNonLeafRotation : label.rotation),
          // Default top-level label roration only applies to label leaves
          avoidCollisions: depthOptions[i]?.label.avoidCollisions ?? label.avoidCollisions
        } : { enabled: false, spacing: 0, rotation: 0, avoidCollisions: false }
      );
    }
    return optionsMap;
  }
  updateCategoryLabels() {
    if (!this.computedLayout)
      return;
    this.tickLabelGroupSelection.update(this.computedLayout.tickLabelLayout).each((node, datum) => {
      node.fill = datum.color;
      node.text = datum.text;
      node.textBaseline = datum.textBaseline;
      node.textAlign = datum.textAlign ?? "center";
      node.setFont(datum);
      node.setBoxing(datum);
    });
  }
  updateAxisLine() {
    if (!this.computedLayout)
      return;
    this.lineNode.visible = this.line.enabled;
    this.lineNode.stroke = this.line.stroke;
    this.lineNode.strokeWidth = this.line.width;
  }
  computeLayout() {
    this.updateDirection();
    this.updateScale();
    const { step } = this.scale;
    const { title, label, range: range4, depthOptions, horizontal, line } = this;
    this.lineNode.datum = horizontal ? { x1: range4[0], x2: range4[1], y1: 0, y2: 0 } : { x1: 0, x2: 0, y1: range4[0], y2: range4[1] };
    this.lineNode.setProperties({ stroke: line.stroke, strokeWidth: line.enabled ? line.width : 0 });
    this.resizeTickTree();
    if (!this.tickTreeLayout?.depth) {
      return { bbox: BBox.zero, spacing: 0, separatorLayout: [], tickLabelLayout: [] };
    }
    const { depth: maxDepth, nodes: treeLabels } = this.tickTreeLayout;
    const sideFlag = horizontal ? -label.getSideFlag() : label.getSideFlag();
    const tickLabelLayout = [];
    const labelBBoxes = /* @__PURE__ */ new Map();
    const tempText2 = new TransformableText();
    const optionsMap = this.getDepthOptionsMap(maxDepth);
    const labelSpacing = sideFlag * optionsMap[0].spacing;
    const tickFormatter = this.tickFormatter(this.scale.domain, this.scale.domain, false);
    const setLabelProps = (datum, index) => {
      const depth = maxDepth - datum.depth;
      if (!optionsMap[depth]?.enabled || !inRange(datum.screen, range4)) {
        return false;
      }
      let text2 = tickFormatter(datum.label, index - 1);
      const labelStyles = this.getLabelStyles({ value: text2, depth }, depthOptions[depth]?.label);
      if (label.avoidCollisions) {
        const rotation = optionsMap[depth].rotation;
        let maxWidth = (datum.leafCount || 1) * step;
        let maxHeight = this.thickness;
        if (rotation != null) {
          const innerRect = getMaxInnerRectSize(rotation, maxWidth, maxHeight);
          maxWidth = innerRect.width;
          maxHeight = innerRect.height;
        }
        text2 = TextWrapper.wrapText(text2, {
          font: labelStyles,
          textWrap: optionsMap[depth].wrapping,
          overflow: optionsMap[depth].truncate ? "ellipsis" : "hide",
          maxWidth,
          maxHeight
        }) || text2;
      }
      tempText2.x = horizontal ? datum.screen : labelSpacing;
      tempText2.y = horizontal ? labelSpacing : datum.screen;
      tempText2.rotation = 0;
      tempText2.lineHeight = TextUtils.getLineHeight(labelStyles.fontSize);
      tempText2.fill = labelStyles.color;
      tempText2.text = text2;
      tempText2.textAlign = "center";
      tempText2.textBaseline = label.parallel ? "top" : "bottom";
      tempText2.setFont(labelStyles);
      tempText2.setBoxing(labelStyles);
      return true;
    };
    const depthLabelMaxSize = {};
    treeLabels.forEach((datum, index) => {
      const depth = maxDepth - datum.depth;
      depthLabelMaxSize[depth] ?? (depthLabelMaxSize[depth] = 0);
      const isVisible = setLabelProps(datum, index);
      if (!isVisible || !tempText2.getBBox())
        return;
      labelBBoxes.set(index, tempText2.getBBox());
      tempText2.rotation = normalizeAngle360FromDegrees(optionsMap[depth]?.rotation);
      const { width: width2, height: height2 } = tempText2.getBBox();
      const labelSize = horizontal ? height2 : width2;
      if (depthLabelMaxSize[depth] < labelSize) {
        depthLabelMaxSize[depth] = labelSize;
      }
    });
    const idGenerator = createIdsGenerator();
    const separatorData = /* @__PURE__ */ new Map();
    const nestedPadding = (d) => {
      if (d === 0)
        return 0;
      let v = depthLabelMaxSize[0];
      for (let i = 1; i <= d; i++) {
        v += optionsMap[i].spacing;
        if (i !== d) {
          v += depthLabelMaxSize[i];
        }
      }
      return v;
    };
    treeLabels.forEach((datum, index) => {
      if (index === 0)
        return;
      const visible = setLabelProps(datum, index);
      const isLeaf = !datum.children.length;
      const depth = maxDepth - datum.depth;
      if (datum.parent) {
        const separatorX = isLeaf ? datum.position : datum.position - (datum.leafCount - 1) / 2;
        if (!separatorData.has(separatorX)) {
          const tickOptions = this.depthOptions[depth]?.tick;
          let v = depthLabelMaxSize[0];
          for (let i = 0; i <= depth; i++) {
            v += optionsMap[i].spacing;
            if (i !== 0) {
              v += depthLabelMaxSize[i];
            }
          }
          separatorData.set(separatorX, {
            tickSize: v,
            tickStroke: tickOptions?.stroke,
            tickWidth: tickOptions?.enabled !== false ? tickOptions?.width : 0
          });
        }
      }
      if (!visible)
        return;
      const labelRotation = normalizeAngle360FromDegrees(optionsMap[depth].rotation);
      const { width: w, height: h } = labelBBoxes.get(index);
      const depthPadding = nestedPadding(depth);
      tempText2.textAlign = "center";
      tempText2.textBaseline = "middle";
      tempText2.rotation = labelRotation;
      if (horizontal) {
        tempText2.y += (depthPadding + angularPadding(w / 2, h / 2, labelRotation)) * sideFlag;
        tempText2.rotationCenterX = datum.screen;
        tempText2.rotationCenterY = tempText2.y;
      } else {
        tempText2.x += depthPadding * sideFlag + angularPadding(
          (optionsMap[depth].spacing * sideFlag + w) / 2,
          label.mirrored ? w : 0,
          labelRotation
        ) - w / 2;
        tempText2.rotationCenterX = tempText2.x;
        tempText2.rotationCenterY = datum.screen;
      }
      if (optionsMap[depth].avoidCollisions) {
        const { width: width2, height: height2 } = tempText2.getBBox();
        const labelSize = horizontal ? width2 : height2;
        const availableRange = isLeaf ? step : datum.leafCount * step;
        if (labelSize > availableRange) {
          labelBBoxes.delete(index);
          return;
        }
      }
      const text2 = tempText2.getPlainText();
      const boxing = tempText2.getBoxingProperties();
      tickLabelLayout.push({
        text: text2,
        visible: true,
        tickId: idGenerator(text2),
        range: this.scale.range,
        border: boxing.border,
        color: tempText2.fill,
        cornerRadius: boxing.cornerRadius,
        fill: boxing.fill,
        fontFamily: tempText2.fontFamily,
        fontSize: tempText2.fontSize,
        fontStyle: tempText2.fontStyle,
        fontWeight: tempText2.fontWeight,
        padding: boxing.padding,
        rotation: tempText2.rotation,
        rotationCenterX: tempText2.rotationCenterX,
        rotationCenterY: tempText2.rotationCenterY,
        textAlign: tempText2.textAlign,
        textBaseline: tempText2.textBaseline,
        x: tempText2.x,
        y: tempText2.y
      });
      labelBBoxes.set(index, Transformable.toCanvas(tempText2));
    });
    const separatorLayout = [...separatorData.values()];
    separatorLayout.push(separatorLayout[0]);
    const bboxes = [
      this.lineNodeBBox(),
      BBox.merge(labelBBoxes.values()),
      new BBox(0, 0, separatorLayout[0].tickSize * sideFlag, 0)
    ];
    let spacing = 0;
    if (title.enabled) {
      const withoutTitle = BBox.merge(bboxes);
      spacing = horizontal ? withoutTitle.height : withoutTitle.width;
      bboxes.push(this.titleBBox(this.scale.domain, spacing));
    }
    const mergedBBox = BBox.merge(bboxes);
    this.layoutCrossLines();
    return { bbox: mergedBBox, spacing, separatorLayout, tickLabelLayout };
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */
  update() {
    if (!this.computedLayout)
      return;
    this.moduleCtx.animationManager.skipCurrentBatch();
    const { tickScale, tick, gridLine, gridLength } = this;
    const { separatorLayout, spacing } = this.computedLayout;
    const { position, horizontal, gridPadding } = this;
    const direction = position === "bottom" || position === "right" ? -1 : 1;
    const p1 = gridPadding;
    const p2 = direction * gridLength - gridPadding;
    const ticks = tickScale.ticks({
      nice: false,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    }).ticks.map((t, index) => ({
      index,
      tickId: createDatumId(t, index),
      translation: Math.round(tickScale.convert(t))
    }));
    this.gridLineGroupSelection.update(
      gridLine.enabled && gridLength ? this.calculateGridLines(ticks, p1, p2) : []
    );
    this.gridFillGroupSelection.update(
      gridLine.enabled && gridLength ? this.calculateGridFills(ticks, p1, p2) : []
    );
    this.tickLineGroupSelection.update(
      tick.enabled ? ticks.map(({ tickId, translation: offset }, index) => {
        const {
          tickSize = this.getTickSize(),
          tickStroke: stroke3 = tick.stroke,
          tickWidth: strokeWidth = tick.width
        } = separatorLayout[index] ?? {};
        const h = -direction * tickSize;
        const [x1, x2, y1, y2] = horizontal ? [offset, offset, 0, h] : [0, h, offset, offset];
        const lineDash = void 0;
        return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
      }) : []
    );
    this.updatePosition();
    this.updateCategoryLabels();
    this.updateAxisLine();
    this.updateGridLines();
    this.updateGridFills();
    this.updateTickLines();
    this.updateTitle(this.scale.domain, spacing);
    this.updateCrossLines();
    this.resetSelectionNodes();
  }
  calculateLayout() {
    const { separatorLayout, tickLabelLayout, spacing, bbox } = this.computeLayout();
    this.computedLayout = { separatorLayout, tickLabelLayout, spacing };
    return { bbox, niceDomain: this.scale.domain };
  }
  /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */
  onGridVisibilityChange() {
    super.onGridVisibilityChange();
    this.tickLabelGroupSelection.clear();
  }
  updateScale() {
    super.updateScale();
    this.tickScale.range = this.scale.range;
    this.scale.paddingOuter = this.scale.paddingInner / 2;
  }
  processData() {
    const { direction } = this;
    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => series.getDomain(direction));
    this.dataDomain = { domain: extent(flatDomains) ?? this.filterDuplicateArrays(flatDomains), clipped: false };
    if (this.isReversed()) {
      this.dataDomain.domain.reverse();
    }
    const domain = this.dataDomain.domain.map(
      (datum) => (
        // Handle integrated charts data when provided as an object
        toArray(isObject(datum) && "value" in datum ? datum.value : datum)
      )
    );
    this.tickTreeLayout = treeLayout(domain);
    const orderedDomain = [];
    for (const node of this.tickTreeLayout.nodes) {
      if (node.leafCount || node.refId == null)
        continue;
      orderedDomain.push(this.dataDomain.domain[node.refId]);
    }
    this.scale.domain = sortBasedOnArray(this.dataDomain.domain, orderedDomain);
    this.tickScale.domain = domain.concat([[""]]);
  }
  filterDuplicateArrays(array2) {
    const seen = /* @__PURE__ */ new Set();
    return array2.filter((item) => {
      const key = isArray(item) ? JSON.stringify(item) : item;
      if (seen.has(key))
        return false;
      seen.add(key);
      return true;
    });
  }
};
GroupedCategoryAxis.className = "GroupedCategoryAxis";
GroupedCategoryAxis.type = "grouped-category";
__decorateClass([
  Property
], GroupedCategoryAxis.prototype, "depthOptions", 2);

// packages/ag-charts-community/src/scale/logScale.ts
var logFunctions = {
  2: (_base, x) => Math.log2(x),
  [Math.E]: (_base, x) => Math.log(x),
  10: (_base, x) => Math.log10(x)
};
var DEFAULT_LOG = (base, x) => Math.log(x) / Math.log(base);
function log2(base, domain, x) {
  const start2 = Math.min(...domain);
  const fn = logFunctions[base] ?? DEFAULT_LOG;
  return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var powFunctions = {
  [Math.E]: (_base, x) => Math.exp(x),
  10: (_base, x) => x >= 0 ? 10 ** x : 1 / 10 ** -x
};
var DEFAULT_POW = (base, x) => base ** x;
function pow(base, domain, x) {
  const start2 = Math.min(...domain);
  const fn = powFunctions[base] ?? DEFAULT_POW;
  return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor(d = [1, 10], r = [0, 1]) {
    super(d, r);
    this.type = "log";
    // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.
    this.defaultClamp = true;
    this.base = 10;
    this.log = (x) => log2(this.base, this.domain, x);
    this.pow = (x) => pow(this.base, this.domain, x);
  }
  static is(value) {
    return value instanceof _LogScale;
  }
  transform(x) {
    const [min, max] = findMinMax(this.domain);
    if (min >= 0 !== max >= 0)
      return NaN;
    return min >= 0 ? Math.log(x) : -Math.log(-x);
  }
  transformInvert(x) {
    const [min, max] = findMinMax(this.domain);
    if (min >= 0 !== max >= 0)
      return NaN;
    return min >= 0 ? Math.exp(x) : -Math.exp(-x);
  }
  toDomain(d) {
    return d;
  }
  niceDomain(_ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    const { base } = this;
    const [d0, d1] = domain;
    const roundStart = d0 > d1 ? Math.ceil : Math.floor;
    const roundStop = d0 > d1 ? Math.floor : Math.ceil;
    const n0 = pow(base, domain, roundStart(log2(base, domain, d0)));
    const n1 = pow(base, domain, roundStop(log2(base, domain, d1)));
    return [n0, n1];
  }
  ticks({ interval, tickCount = ContinuousScale.defaultTickCount }, domain = this.domain, visibleRange) {
    if (!domain || domain.length < 2 || tickCount < 1) {
      return;
    }
    const base = this.base;
    const [d0, d1] = domain;
    const start2 = Math.min(d0, d1);
    const stop = Math.max(d0, d1);
    let p0 = this.log(start2);
    let p1 = this.log(stop);
    if (interval) {
      const inBounds = (tick) => tick >= start2 && tick <= stop;
      const step = Math.min(Math.abs(interval), Math.abs(p1 - p0));
      const { ticks: rangeTicks, count, firstTickIndex } = range(p0, p1, step, visibleRange);
      const ticks2 = rangeTicks.map(this.pow).filter(inBounds);
      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {
        return { ticks: ticks2, count, firstTickIndex };
      }
    }
    if (!isInteger(base) || p1 - p0 >= tickCount) {
      const step = Math.min(p1 - p0, tickCount);
      const { ticks: ticks2, count, firstTickIndex } = createTicks(p0, p1, step, void 0, void 0, visibleRange);
      return {
        ticks: ticks2.map(this.pow),
        count,
        firstTickIndex
      };
    }
    const ticks = [];
    const isPositive = start2 > 0;
    p0 = Math.floor(p0) - 1;
    p1 = Math.round(p1) + 1;
    const availableSpacing = findRangeExtent(this.range) / tickCount;
    let lastTickPosition = Infinity;
    for (let p = p0; p <= p1; p++) {
      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
      for (let k = 1; k < base; k++) {
        const q = isPositive ? k : base - k + 1;
        const t = this.pow(p) * q;
        const tickPosition = this.convert(t);
        const prevSpacing = Math.abs(lastTickPosition - tickPosition);
        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
        if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {
          ticks.push(t);
          lastTickPosition = tickPosition;
        }
      }
    }
    return filterVisibleTicks(ticks, isPositive, visibleRange);
  }
};

// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super([0, 1], [0, 1]);
    this.type = "number";
  }
  static is(value) {
    return value instanceof _LinearScale;
  }
  static getTickStep(start2, stop, ticks) {
    const { interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = ticks;
    return interval ?? tickStep(start2, stop, tickCount, minTickCount, maxTickCount);
  }
  toDomain(d) {
    return d;
  }
  ticks({ interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount }, domain = this.domain, visibleRange) {
    if (!domain || domain.length < 2 || tickCount < 1 || !domain.every(isFinite)) {
      return { ticks: [], count: 0, firstTickIndex: 0 };
    }
    const [d0, d1] = domain;
    if (interval) {
      const step = Math.abs(interval);
      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {
        return range(d0, d1, step, visibleRange);
      }
    }
    return createTicks(d0, d1, tickCount, minTickCount, maxTickCount, visibleRange);
  }
  niceDomain(ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    const { tickCount = ContinuousScale.defaultTickCount } = ticks;
    let [start2, stop] = domain;
    if (tickCount === 1) {
      [start2, stop] = niceTicksDomain(start2, stop);
    } else if (tickCount > 1) {
      const roundStart = start2 > stop ? Math.ceil : Math.floor;
      const roundStop = start2 > stop ? Math.floor : Math.ceil;
      const maxAttempts = 4;
      for (let i = 0; i < maxAttempts; i++) {
        const prev0 = start2;
        const prev1 = stop;
        const step = _LinearScale.getTickStep(start2, stop, ticks);
        const [d0, d1] = domain;
        start2 = roundStart(d0 / step) * step;
        stop = roundStop(d1 / step) * step;
        if (start2 === prev0 && stop === prev1)
          break;
      }
    }
    return [start2, stop];
  }
};

// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxis = class extends CartesianAxis {
  constructor(moduleCtx, scale2 = new LinearScale()) {
    super(moduleCtx, scale2);
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent3, clipped } = normalisedExtentWithMetadata(d, min, max);
    return { domain: extent3, clipped };
  }
  createDatumFormatter(_domain, ticks) {
    const { format } = this.label;
    return typeof format === "number" ? tickFormat(ticks, format) : void 0;
  }
  tickFormatParams(_domain, _ticks, fractionDigits) {
    return { type: "number", fractionDigits };
  }
  datumFormatParams(value, params, fractionDigits) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    return {
      type: "number",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      fractionDigits
    };
  }
};
NumberAxis.className = "NumberAxis";
NumberAxis.type = "number";
__decorateClass([
  Property
], NumberAxis.prototype, "min", 2);
__decorateClass([
  Property
], NumberAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/axis/logAxis.ts
var LogAxis = class extends NumberAxis {
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent3, clipped } = normalisedExtentWithMetadata(d, min, max);
    if (extent3[0] < 0 && extent3[1] > 0 || d[0] < 0 && d[1] > 0) {
      logger_exports.warn(
        `The log axis domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`
      );
      return { domain: [], clipped };
    } else if (extent3[0] === 0 || extent3[1] === 0 || d[0] === 0 || d[1] === 0) {
      logger_exports.warn(
        `The log axis domain contains a value of 0, the chart data cannot be rendered. See log axis documentation for more information.`
      );
      return { domain: [], clipped };
    }
    return { domain: extent3, clipped };
  }
  set base(value) {
    this.scale.base = value;
  }
  get base() {
    return this.scale.base;
  }
  constructor(moduleCtx) {
    super(moduleCtx, new LogScale());
  }
};
LogAxis.className = "LogAxis";
LogAxis.type = "log";

// packages/ag-charts-community/src/chart/axis/timeAxis.ts
var TimeAxisParentLevel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.label = new AxisLabel();
    this.tick = new AxisTick();
  }
};
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "enabled", 2);
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "label", 2);
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "tick", 2);
var TimeAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new TimeScale());
    this.parentLevel = new TimeAxisParentLevel();
    this.min = void 0;
    this.max = void 0;
    this.minimumTimeGranularity = void 0;
  }
  // eslint-disable-next-line sonarjs/use-type-alias
  get _unit() {
    return void 0;
  }
  set _unit(_unit) {
    logger_exports.warnOnce(`To use 'unit', use an axis with type 'unit-time' instead of 'time'.`);
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  isCategoryLike() {
    return false;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  normaliseDataDomain(d) {
    return normaliseTimeDataDomain(d, this.min, this.max);
  }
  processData() {
    super.processData();
    const { boundSeries, direction, min, max } = this;
    this.minimumTimeGranularity = minimumTimeAxisDatumGranularity(boundSeries, direction, min, max);
  }
  tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
    timeInterval3 ?? (timeInterval3 = lowestGranularityUnitForTicks(ticks));
    const truncateDate = dateTruncationForDomain(domain);
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return { type: "date", unit, step, epoch, truncateDate };
  }
  datumFormatParams(value, params, _fractionDigits, timeInterval3, style2) {
    if (typeof value === "number")
      value = new Date(value);
    if (timeInterval3 == null) {
      const { minimumTimeGranularity } = this;
      const datumGranularity = lowestGranularityUnitForValue(value);
      if (minimumTimeGranularity != null && intervalMilliseconds(minimumTimeGranularity) < intervalMilliseconds(datumGranularity)) {
        timeInterval3 = minimumTimeGranularity;
      } else {
        timeInterval3 = datumGranularity;
      }
    }
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return {
      type: "date",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      unit,
      step,
      epoch,
      style: style2
    };
  }
};
TimeAxis.className = "TimeAxis";
TimeAxis.type = "time";
__decorateClass([
  Property
], TimeAxis.prototype, "parentLevel", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "min", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "max", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("_unit")
], TimeAxis.prototype, "unit", 2);
function minimumTimeAxisDatumGranularity(boundSeries, direction, min, max) {
  const minTimeInterval = boundSeries.reduce((t, series) => {
    return Math.min(series.minTimeInterval() ?? Infinity, t);
  }, Infinity);
  if (Number.isFinite(minTimeInterval)) {
    return lowestGranularityForInterval(minTimeInterval);
  } else {
    return calculateDefaultUnit(boundSeries, direction, min, max)?.unit;
  }
}
function calculateDefaultUnit(boundSeries, direction, min, max) {
  let start2 = Infinity;
  let end2 = -Infinity;
  let interval;
  let maxDataCount = 0;
  const domainValues = [];
  for (const series of boundSeries) {
    if (!series.visible)
      continue;
    const { domain } = normaliseTimeDataDomain(series.getDomain(direction), void 0, void 0);
    if (domain.length === 0)
      continue;
    const d0 = domain[0].valueOf();
    const d1 = domain[domain.length - 1].valueOf();
    domainValues.push(d0, d1);
    start2 = Math.min(start2 ?? Infinity, d0, d1);
    end2 = Math.max(end2 ?? -Infinity, d0, d1);
    const domainExtent = Math.abs(d1 - d0);
    if (domainExtent === 0)
      continue;
    const dataCount = series.dataCount();
    maxDataCount = Math.max(maxDataCount, dataCount);
    if (dataCount <= 1)
      continue;
    const i = domainExtent / (dataCount - 1);
    interval = Math.min(interval ?? Infinity, i);
  }
  start2 = Math.min(start2, min?.valueOf() ?? Infinity, max?.valueOf() ?? Infinity);
  end2 = Math.max(end2, min?.valueOf() ?? -Infinity, max?.valueOf() ?? -Infinity);
  if (!Number.isFinite(start2) || !Number.isFinite(end2))
    return;
  interval ?? (interval = Math.abs(end2 - start2));
  interval = Math.min(interval, minNonZeroDifference(domainValues));
  const unit = lowestGranularityForInterval(interval);
  let step = interval / intervalMilliseconds(unit);
  if (maxDataCount <= 2) {
    step = Math.floor(step);
  } else {
    step = Math.round(step);
  }
  step = Math.max(step, 1);
  const epoch = step === 1 ? void 0 : intervalFloor(unit, start2);
  return { unit, step, epoch };
}
function minNonZeroDifference(values) {
  values.sort((a, b) => a - b);
  let minDiff = Infinity;
  for (let i = 1; i < values.length; i++) {
    const d0 = values[i - 1];
    const d1 = values[i];
    const delta4 = d1 - d0;
    if (delta4 > 0) {
      minDiff = Math.min(minDiff, Math.abs(d1 - d0));
    }
  }
  return minDiff;
}
function normaliseTimeDataDomain(d, min, max) {
  let clipped = false;
  if (typeof min === "number") {
    min = new Date(min);
  }
  if (typeof max === "number") {
    max = new Date(max);
  }
  const de = extent(d)?.map((x) => new Date(x));
  if (de == null) {
    return {
      domain: min != null && max != null && min.valueOf() <= max.valueOf() ? [min, max] : [],
      clipped: false
    };
  }
  let [d0, d1] = de;
  if (min instanceof Date) {
    clipped || (clipped = min > d0);
    d0 = min;
  }
  if (max instanceof Date) {
    clipped || (clipped = max < d1);
    d1 = max;
  }
  if (d0 > d1) {
    return { domain: [], clipped: false };
  }
  return { domain: [d0, d1], clipped };
}

// packages/ag-charts-community/src/chart/axis/discreteTimeAxis.ts
var DiscreteTimeAxis = class extends CategoryAxis {
  calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks) {
    const { gridLine, horizontal, interval, range: range4 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridLine({ index: tickIndex, tickId, translation }, index, p1, p2, ticks);
    }
    const prevTick = ticks[index - 1];
    const offset = prevTick ? translation - (translation - prevTick.translation) / 2 : range4[0];
    const [x1, y1, x2, y2] = horizontal ? [offset, Math.max(p1, p2), offset, Math.min(p1, p2)] : [Math.min(p1, p2), offset, Math.max(p1, p2), offset];
    const { style: style2 } = gridLine;
    const { stroke: stroke3, strokeWidth = 0, lineDash } = style2[tickIndex % style2.length] ?? {};
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
  }
  calculateGridFills(ticks, p1, p2) {
    if (this.interval.placement !== "between") {
      return super.calculateGridFills(ticks, p1, p2);
    }
    return ticks.map((tick, index) => this.calculateGridFill(tick, index, tick.index, p1, p2, ticks));
  }
  calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks) {
    const { gridLine, horizontal, interval, range: range4 } = this;
    if (interval.placement !== "between") {
      return super.calculateGridFill({ tickId, translation }, index, gridFillIndex, p1, p2, ticks);
    }
    const prevTick = ticks[index - 1];
    const nextTick = ticks[index + 1];
    const startOffset = prevTick ? translation - (translation - prevTick.translation) / 2 : range4[0];
    const endOffset = nextTick ? translation + (nextTick.translation - translation) / 2 : range4[1];
    const [x1, y1, x2, y2] = horizontal ? [startOffset, Math.max(p1, p2), endOffset, Math.min(p1, p2)] : [Math.min(p1, p2), startOffset, Math.max(p1, p2), endOffset];
    const { fill, fillOpacity } = gridLine.style[gridFillIndex % gridLine.style.length] ?? {};
    return { tickId, x1, y1, x2, y2, fill, fillOpacity };
  }
  calculateTickLine({ primary, tickId, translation }, index, direction, ticks) {
    const { horizontal, interval, primaryTick, range: range4, tick } = this;
    if (interval.placement !== "between") {
      return super.calculateTickLine({ primary, tickId, translation }, index, direction, ticks);
    }
    const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
    const h = -direction * this.getTickSize(datumTick);
    const prevTick = ticks[index - 1];
    const offset = prevTick ? translation - (translation - prevTick.translation) / 2 : range4[0];
    const [x1, y1, x2, y2] = horizontal ? [offset, 0, offset, h] : [0, offset, h, offset];
    const { stroke: stroke3, width: strokeWidth } = datumTick;
    const lineDash = void 0;
    return { tickId, offset, x1, y1, x2, y2, stroke: stroke3, strokeWidth, lineDash };
  }
};

// packages/ag-charts-community/src/chart/axis/unitTimeAxis.ts
var UnitTimeAxis = class extends DiscreteTimeAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new UnitTimeScale(), false);
    this.parentLevel = new TimeAxisParentLevel();
    this.min = void 0;
    this.max = void 0;
    // eslint-disable-next-line sonarjs/use-type-alias
    this.unit = void 0;
    this.defaultUnit = void 0;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  isCategoryLike() {
    return true;
  }
  processData() {
    super.processData();
    let defaultUnit;
    const { domain } = this.dataDomain;
    if (domain.length === 2 && domain[0].valueOf() === domain[1].valueOf()) {
      defaultUnit = lowestGranularityUnitForValue(domain[0]);
    } else {
      const { boundSeries, direction, min, max } = this;
      defaultUnit = calculateDefaultUnit(boundSeries, direction, min, max);
    }
    if (!objectsEqual(this.defaultUnit, defaultUnit)) {
      this.defaultUnit = defaultUnit;
    }
  }
  updateScale() {
    super.updateScale();
    this.scale.interval = this.unit ?? this.defaultUnit;
  }
  normaliseDataDomain(domain) {
    return normaliseTimeDataDomain(domain, this.min, this.max);
  }
  createDatumFormatter(_domain, _ticks) {
    const timeInterval3 = this.scale.interval;
    const { format } = this.label;
    if (format == null)
      return;
    const specifier = labelSpecifier(
      timeInterval3 != null ? deriveTimeSpecifier(format, intervalUnit(timeInterval3)) : format,
      timeInterval3
    );
    if (specifier == null)
      return;
    return buildDateFormatter(specifier);
  }
  tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
    timeInterval3 ?? (timeInterval3 = lowestGranularityUnitForTicks(ticks));
    const truncateDate = dateTruncationForDomain(domain);
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return { type: "date", unit, step, epoch, truncateDate };
  }
  datumFormatParams(value, params, _fractionDigits, timeInterval3, style2) {
    const interval = this.unit ?? this.defaultUnit ?? "millisecond";
    value = intervalFloor(interval, value);
    if (typeof value === "number")
      value = new Date(value);
    timeInterval3 ?? (timeInterval3 = interval);
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    const unit = intervalUnit(timeInterval3);
    const step = intervalStep(timeInterval3);
    const epoch = intervalEpoch(timeInterval3);
    return {
      type: "date",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      unit,
      step,
      epoch,
      style: style2
    };
  }
};
UnitTimeAxis.className = "UnitTimeAxis";
UnitTimeAxis.type = "unit-time";
__decorateClass([
  Property
], UnitTimeAxis.prototype, "parentLevel", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "min", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "max", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "unit", 2);

// packages/ag-charts-community/src/module/axisModules.ts
var numberAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(number),
  type: required(constant("number")),
  label: cartesianNumericAxisLabel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var logAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(number),
  type: required(constant("log")),
  base: and(
    positiveNumberNonZero,
    attachDescription((value) => value !== 1, "not equal to 1")
  ),
  label: cartesianNumericAxisLabel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var timeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(or(number, date), true),
  type: required(constant("time")),
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  crosshair: cartesianAxisCrosshairOptions(true, true)
};
var categoryAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required(constant("category")),
  label: cartesianAxisLabelOptionsDefs,
  paddingInner: ratio,
  paddingOuter: ratio,
  groupPaddingInner: ratio,
  crosshair: cartesianAxisCrosshairOptions(),
  bandHighlight: cartesianAxisBandHighlightOptions,
  interval: {
    ...commonAxisIntervalOptionsDefs,
    placement: union("on", "between")
  }
};
var groupedCategoryAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required(constant("grouped-category")),
  label: cartesianAxisLabelOptionsDefs,
  crosshair: cartesianAxisCrosshairOptions(),
  bandHighlight: cartesianAxisBandHighlightOptions,
  paddingInner: ratio,
  groupPaddingInner: ratio,
  depthOptions: arrayOfDefs(
    {
      label: {
        enabled: boolean,
        avoidCollisions: boolean,
        wrapping: union("never", "always", "hyphenate", "on-space"),
        truncate: boolean,
        rotation: number,
        spacing: number,
        ...fontOptionsDef,
        ...labelBoxOptionsDef
      },
      tick: {
        enabled: boolean,
        stroke: color,
        width: positiveNumber
      }
    },
    "depth options objects array"
  )
};
var unitTimeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required(constant("unit-time")),
  unit: or(timeInterval2, timeIntervalUnit),
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  paddingInner: ratio,
  paddingOuter: ratio,
  groupPaddingInner: ratio,
  crosshair: cartesianAxisCrosshairOptions(true, true),
  bandHighlight: cartesianAxisBandHighlightOptions,
  min: and(or(number, date), lessThan("max")),
  max: and(or(number, date), greaterThan("min")),
  interval: discreteTimeAxisIntervalOptionsDefs
};
var NumberAxisModule = {
  type: "axis",
  name: "number",
  chartType: "cartesian",
  options: numberAxisOptionsDefs,
  create: (ctx) => new NumberAxis(ctx)
};
var LogAxisModule = {
  type: "axis",
  name: "log",
  chartType: "cartesian",
  options: logAxisOptionsDefs,
  create: (ctx) => new LogAxis(ctx)
};
var TimeAxisModule = {
  type: "axis",
  name: "time",
  chartType: "cartesian",
  options: timeAxisOptionsDefs,
  create: (ctx) => new TimeAxis(ctx)
};
var CategoryAxisModule = {
  type: "axis",
  name: "category",
  chartType: "cartesian",
  options: categoryAxisOptionsDefs,
  create: (ctx) => new CategoryAxis(ctx)
};
var GroupedCategoryAxisModule = {
  type: "axis",
  name: "grouped-category",
  chartType: "cartesian",
  options: groupedCategoryAxisOptionsDefs,
  create: (ctx) => new GroupedCategoryAxis(ctx)
};
var UnitTimeAxisModule = {
  type: "axis",
  name: "unit-time",
  chartType: "cartesian",
  options: unitTimeAxisOptionsDefs,
  create: (ctx) => new UnitTimeAxis(ctx)
};

// packages/ag-charts-community/src/chart/axesOptionsEnterpriseDefs.ts
var ordinalTimeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: required(constant("ordinal-time")),
  paddingInner: ratio,
  paddingOuter: ratio,
  groupPaddingInner: ratio,
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  interval: discreteTimeAxisIntervalOptionsDefs,
  crosshair: cartesianAxisCrosshairOptions(true, true),
  bandHighlight: cartesianAxisBandHighlightOptions
};
var angleNumberAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  ...continuousAxisOptions(number),
  type: required(constant("angle-number")),
  crossLines: arrayOfDefs(commonCrossLineOptionsDefs),
  startAngle: number,
  endAngle: number,
  label: {
    ...commonAxisLabelOptionsDefs,
    orientation: union("fixed", "parallel", "perpendicular"),
    format: numberFormatValidator
  }
};
var invalidOptionsFromIntegratedCharts = {
  // @ts-expect-error integrated sets this from the formatting panel, but it isn't relevant.
  innerRadiusRatio: ratio
};
var angleCategoryAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  ...invalidOptionsFromIntegratedCharts,
  type: required(constant("angle-category")),
  shape: union("polygon", "circle"),
  crossLines: arrayOfDefs(commonCrossLineOptionsDefs),
  startAngle: number,
  endAngle: number,
  paddingInner: ratio,
  groupPaddingInner: ratio,
  label: {
    ...commonAxisLabelOptionsDefs,
    orientation: union("fixed", "parallel", "perpendicular")
  }
};
var radiusNumberAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  ...continuousAxisOptions(number),
  type: required(constant("radius-number")),
  shape: union("polygon", "circle"),
  positionAngle: number,
  innerRadiusRatio: ratio,
  crossLines: arrayOfDefs(
    {
      ...commonCrossLineOptionsDefs,
      label: {
        ...commonCrossLineLabelOptionsDefs,
        positionAngle: number
      }
    },
    "cross-line options"
  ),
  title: {
    enabled: boolean,
    text: string,
    spacing: positiveNumber,
    formatter: callback,
    ...fontOptionsDef
  },
  label: {
    ...commonAxisLabelOptionsDefs,
    format: numberFormatValidator
  }
};
var radiusCategoryAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  type: required(constant("radius-category")),
  positionAngle: number,
  innerRadiusRatio: ratio,
  paddingInner: ratio,
  paddingOuter: ratio,
  groupPaddingInner: ratio,
  label: commonAxisLabelOptionsDefs,
  crossLines: arrayOfDefs(
    {
      ...commonCrossLineOptionsDefs,
      label: {
        ...commonCrossLineLabelOptionsDefs,
        positionAngle: number
      }
    },
    "cross-line options"
  ),
  title: {
    enabled: boolean,
    text: string,
    spacing: positiveNumber,
    formatter: callback,
    ...fontOptionsDef
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesOptionsDef.ts
var highlight = multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef);
var areaSeriesThemeableOptionsDef = {
  showInMiniChart: boolean,
  connectMissingData: boolean,
  interpolation: interpolationOptionsDefs,
  label: seriesLabelOptionsDefs,
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight
};
var areaSeriesOptionsDef = {
  ...areaSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  highlight,
  type: required(constant("area")),
  xKey: required(string),
  yKey: required(string),
  xName: string,
  yName: string,
  stacked: boolean,
  stackGroup: string,
  normalizedTo: number
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesOptionsDef.ts
var highlight2 = multiSeriesHighlightOptionsDef(barHighlightOptionsDef, barHighlightOptionsDef);
var barSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  showInMiniChart: boolean,
  cornerRadius: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  crisp: boolean,
  label: {
    ...seriesLabelOptionsDefs,
    placement: union("inside-center", "inside-start", "inside-end", "outside-start", "outside-end"),
    spacing: positiveNumber
  },
  errorBar: errorBarThemeableOptionsDefs,
  shadow: shadowOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  highlight: highlight2,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
barSeriesThemeableOptionsDef.sparklineMode = undocumented(boolean);
var barSeriesOptionsDef = {
  ...barSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  highlight: highlight2,
  type: required(constant("bar")),
  xKey: required(string),
  yKey: required(string),
  xName: string,
  yName: string,
  direction: union("horizontal", "vertical"),
  grouped: boolean,
  stacked: boolean,
  stackGroup: string,
  normalizedTo: number,
  legendItemName: string,
  errorBar: errorBarOptionsDefs
};
barSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented(boolean);
barSeriesOptionsDef.focusPriority = undocumented(number);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesOptionsDef.ts
var bubbleSeriesThemeableOptionsDef = {
  title: string,
  domain: arrayOf(number),
  maxSize: positiveNumber,
  showInMiniChart: boolean,
  label: {
    placement: union("top", "right", "bottom", "left"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  maxRenderedItems: number,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"]),
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var bubbleSeriesOptionsDef = {
  ...bubbleSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required(constant("bubble")),
  xKey: required(string),
  yKey: required(string),
  sizeKey: required(string),
  labelKey: string,
  xName: string,
  yName: string,
  sizeName: string,
  labelName: string,
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesOptionsDef.ts
var histogramSeriesThemeableOptionsDef = {
  showInMiniChart: boolean,
  cornerRadius: positiveNumber,
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var histogramSeriesOptionsDef = {
  ...commonSeriesOptionsDefs,
  ...histogramSeriesThemeableOptionsDef,
  type: required(constant("histogram")),
  xKey: required(string),
  yKey: string,
  xName: string,
  yName: string,
  areaPlot: boolean,
  aggregation: union("count", "sum", "mean"),
  bins: arrayOf(arrayOf(number)),
  binCount: positiveNumber
};

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesOptionsDef.ts
var highlight3 = multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, lineHighlightOptionsDef);
var lineSeriesThemeableOptionsDef = {
  title: string,
  showInMiniChart: boolean,
  connectMissingData: boolean,
  interpolation: interpolationOptionsDefs,
  label: seriesLabelOptionsDefs,
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  errorBar: errorBarThemeableOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: highlight3
};
lineSeriesThemeableOptionsDef.sparklineMode = undocumented(boolean);
var lineSeriesOptionsDef = {
  ...lineSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  highlight: highlight3,
  type: required(constant("line")),
  xKey: required(string),
  yKey: required(string),
  xName: string,
  yName: string,
  stacked: boolean,
  stackGroup: string,
  normalizedTo: number,
  legendItemName: string,
  errorBar: errorBarOptionsDefs
};
lineSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented(boolean);
lineSeriesOptionsDef.focusPriority = undocumented(number);

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesOptionsDef.ts
var scatterSeriesThemeableOptionsDef = {
  title: string,
  showInMiniChart: boolean,
  label: {
    placement: union("top", "right", "bottom", "left"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  errorBar: errorBarThemeableOptionsDefs,
  maxRenderedItems: number,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"]),
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var scatterSeriesOptionsDef = {
  ...scatterSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required(constant("scatter")),
  xKey: required(string),
  yKey: required(string),
  labelKey: string,
  xName: string,
  yName: string,
  labelName: string,
  errorBar: errorBarOptionsDefs,
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};

// packages/ag-charts-community/src/chart/series/polar/pieSeriesOptionsDef.ts
var highlight4 = multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef);
var pieSeriesThemeableOptionsDef = {
  ...commonSeriesThemeableOptionsDefs,
  radiusMin: positiveNumber,
  radiusMax: positiveNumber,
  rotation: number,
  outerRadiusOffset: number,
  outerRadiusRatio: ratio,
  hideZeroValueSectorsInLegend: boolean,
  sectorSpacing: positiveNumber,
  cornerRadius: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  title: {
    enabled: boolean,
    text: string,
    showInLegend: boolean,
    spacing: positiveNumber,
    ...fontOptionsDef
  },
  calloutLabel: {
    enabled: boolean,
    offset: number,
    minAngle: positiveNumber,
    avoidCollisions: boolean,
    formatter: callback,
    format: string,
    itemStyler: callbackDefs({
      enabled: boolean,
      ...labelBoxOptionsDef,
      ...fontOptionsDef
    }),
    ...labelBoxOptionsDef,
    ...fontOptionsDef
  },
  sectorLabel: {
    enabled: boolean,
    positionOffset: number,
    positionRatio: ratio,
    formatter: callback,
    format: string,
    itemStyler: callbackDefs({
      enabled: boolean,
      ...labelBoxOptionsDef,
      ...fontOptionsDef
    }),
    ...labelBoxOptionsDef,
    ...fontOptionsDef
  },
  calloutLine: {
    colors: arrayOf(color),
    length: positiveNumber,
    strokeWidth: positiveNumber
  },
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  highlight: highlight4,
  ...lineDashOptionsDef,
  ...without(fillOptionsDef, ["fill"]),
  ...without(strokeOptionsDef, ["stroke"])
};
var pieSeriesOptionsDef = {
  ...pieSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: required(constant("pie")),
  angleKey: required(string),
  radiusKey: string,
  calloutLabelKey: string,
  sectorLabelKey: string,
  legendItemKey: string,
  angleName: string,
  radiusName: string,
  calloutLabelName: string,
  sectorLabelName: string,
  highlight: highlight4
};
pieSeriesOptionsDef.defaultColorRange = undocumented(arrayOf(arrayOf(color)));
pieSeriesOptionsDef.defaultPatternFills = undocumented(arrayOf(color));
pieSeriesOptionsDef.title._enabledFromTheme = undocumented(boolean);
pieSeriesOptionsDef.calloutLabel._enabledFromTheme = undocumented(boolean);
pieSeriesOptionsDef.sectorLabel._enabledFromTheme = undocumented(boolean);

// packages/ag-charts-community/src/chart/series/polar/donutSeriesOptionsDef.ts
var donutSeriesThemeableOptionsDef = {
  ...pieSeriesThemeableOptionsDef,
  innerRadiusOffset: number,
  innerRadiusRatio: ratio,
  innerCircle: {
    fill: string,
    fillOpacity: ratio
  },
  innerLabels: {
    spacing: positiveNumber,
    ...fontOptionsDef,
    ...labelBoxOptionsDef
  }
};
var donutSeriesOptionsDef = {
  ...donutSeriesThemeableOptionsDef,
  ...pieSeriesOptionsDef,
  type: required(constant("donut")),
  innerLabels: arrayOfDefs(
    {
      text: required(string),
      spacing: positiveNumber,
      ...fontOptionsDef,
      ...labelBoxOptionsDef
    },
    "inner label options array"
  )
};

// packages/ag-charts-community/src/chart/themes/annotationOptionsDef.ts
var annotationLineOptionsDef = {
  lineStyle: union("solid", "dashed", "dotted"),
  ...lineDashOptionsDef
};
var annotationHandleStylesDefs = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var annotationTextStylesDef = {
  visible: boolean,
  locked: boolean,
  handle: annotationHandleStylesDefs,
  ...fontOptionsDef
};
var annotationLineTextDefs = {
  position: union("top", "center", "bottom"),
  alignment: union("left", "center", "right"),
  ...fontOptionsDef
};
var annotationChannelTextDefs = {
  position: union("top", "inside", "bottom"),
  alignment: union("left", "center", "right"),
  ...fontOptionsDef
};
var annotationAxisLabelOptionsDef = {
  enabled: boolean,
  cornerRadius: positiveNumber,
  formatter: callback,
  ...fontOptionsDef,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var annotationChannelMiddleDefs = {
  visible: boolean,
  ...annotationLineOptionsDef,
  ...strokeOptionsDef
};
var annotationMeasurerStatisticsOptionsDefs = {
  divider: strokeOptionsDef,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...fontOptionsDef
};
var annotationQuickMeasurerDirectionStylesDefs = {
  handle: annotationHandleStylesDefs,
  statistics: annotationMeasurerStatisticsOptionsDefs,
  ...annotationLineOptionsDef,
  ...fillOptionsDef,
  ...strokeOptionsDef
};
var annotationLineStyleDefs = {
  visible: boolean,
  locked: boolean,
  extendStart: boolean,
  extendEnd: boolean,
  handle: annotationHandleStylesDefs,
  text: annotationLineTextDefs,
  ...annotationLineOptionsDef,
  ...strokeOptionsDef
};
var annotationCrossLineStyleDefs = {
  visible: boolean,
  locked: boolean,
  axisLabel: annotationAxisLabelOptionsDef,
  handle: annotationHandleStylesDefs,
  text: annotationLineTextDefs,
  ...annotationLineOptionsDef,
  ...strokeOptionsDef
};
var annotationChannelStyleDefs = {
  visible: boolean,
  locked: boolean,
  extendStart: boolean,
  extendEnd: boolean,
  handle: annotationHandleStylesDefs,
  text: annotationChannelTextDefs,
  background: fillOptionsDef,
  ...annotationLineOptionsDef,
  ...strokeOptionsDef
};
var annotationDisjointChannelStyleDefs = {
  ...annotationChannelStyleDefs
};
var annotationParallelChannelStyleDefs = {
  ...annotationChannelStyleDefs,
  middle: annotationChannelMiddleDefs
};
var annotationFibonacciStylesDefs = {
  label: fontOptionsDef,
  showFill: boolean,
  isMultiColor: boolean,
  strokes: arrayOf(color),
  rangeStroke: color,
  bands: union(4, 6, 10),
  ...annotationLineStyleDefs
};
var annotationCalloutStylesDefs = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...annotationTextStylesDef
};
var annotationCommentStylesDefs = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...annotationTextStylesDef
};
var annotationNoteStylesDefs = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...annotationTextStylesDef,
  background: {
    ...fillOptionsDef,
    ...strokeOptionsDef
  }
};
var annotationShapeStylesDefs = {
  visible: boolean,
  locked: boolean,
  handle: annotationHandleStylesDefs,
  ...fillOptionsDef
};
var annotationMeasurerStylesDefs = {
  visible: boolean,
  locked: boolean,
  extendStart: boolean,
  extendEnd: boolean,
  handle: annotationHandleStylesDefs,
  text: annotationLineTextDefs,
  background: fillOptionsDef,
  statistics: annotationMeasurerStatisticsOptionsDefs,
  ...annotationLineOptionsDef,
  ...strokeOptionsDef
};
var annotationQuickMeasurerStylesDefs = {
  visible: boolean,
  up: annotationQuickMeasurerDirectionStylesDefs,
  down: annotationQuickMeasurerDirectionStylesDefs
};
var annotationOptionsDef = {
  enabled: boolean,
  axesButtons: {
    enabled: boolean,
    axes: union("x", "y", "xy")
  },
  toolbar: {
    enabled: boolean,
    padding: positiveNumber,
    buttons: arrayOfDefs(
      {
        ...toolbarButtonOptionsDefs,
        value: union(
          "line-menu",
          "fibonacci-menu",
          "text-menu",
          "shape-menu",
          "measurer-menu",
          "line",
          "horizontal-line",
          "vertical-line",
          "parallel-channel",
          "disjoint-channel",
          "fibonacci-retracement",
          "fibonacci-retracement-trend-based",
          "text",
          "comment",
          "callout",
          "note",
          "clear"
        )
      },
      "annotation toolbar buttons array"
    )
  },
  optionsToolbar: {
    enabled: boolean,
    buttons: arrayOf(
      or(
        optionsDefs({
          ...toolbarButtonOptionsDefs,
          value: required(
            union(
              "line-stroke-width",
              "line-style-type",
              "line-color",
              "fill-color",
              "text-color",
              "text-size",
              "delete",
              "settings"
            )
          )
        }),
        optionsDefs({
          ...toolbarButtonOptionsDefs,
          value: required(union("lock")),
          checkedOverrides: toolbarButtonOptionsDefs
        })
      )
    )
  }
};
annotationOptionsDef.data = undocumented(array);
annotationOptionsDef.xKey = undocumented(string);
annotationOptionsDef.volumeKey = undocumented(string);
annotationOptionsDef.snap = undocumented(boolean);

// packages/ag-charts-community/src/chart/themes/enterpriseThemeableOptionsDef.ts
var boxPlotStyleOptionsDef = {
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  cornerRadius: positiveNumber,
  whisker: {
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  cap: {
    lengthRatio: ratio
  }
};
var boxPlotHighlightStyleOptionsDef = {
  ...boxPlotStyleOptionsDef,
  opacity: ratio
};
var boxPlotSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  showInMiniChart: boolean,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber,
    whisker: {
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    },
    cap: {
      lengthRatio: ratio
    }
  }),
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...boxPlotStyleOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(boxPlotHighlightStyleOptionsDef, boxPlotHighlightStyleOptionsDef)
};
var candlestickSeriesItemOptionsDef = {
  cornerRadius: positiveNumber,
  wick: {
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var candlestickHighlightStyleOptionsDef = {
  ...candlestickSeriesItemOptionsDef,
  opacity: ratio
};
var candlestickSeriesThemeableOptionsDef = {
  item: {
    up: candlestickSeriesItemOptionsDef,
    down: candlestickSeriesItemOptionsDef
  },
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber,
    wick: {
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }
  }),
  showInMiniChart: boolean,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  highlight: multiSeriesHighlightOptionsDef(candlestickHighlightStyleOptionsDef, candlestickHighlightStyleOptionsDef)
};
var chordSeriesThemeableOptionsDef = {
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  label: {
    spacing: positiveNumber,
    maxWidth: positiveNumber,
    ...seriesLabelOptionsDefs
  },
  link: {
    tension: ratio,
    itemStyler: callbackDefs({
      ...fillOptionsDef,
      ...strokeOptionsDef,
      ...lineDashOptionsDef,
      tension: ratio
    }),
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  node: {
    width: positiveNumber,
    spacing: positiveNumber,
    itemStyler: callbackDefs({
      ...fillOptionsDef,
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }),
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs
};
var coneFunnelSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  label: {
    spacing: positiveNumber,
    placement: union("before", "middle", "after"),
    ...seriesLabelOptionsDefs
  },
  stageLabel: {
    placement: union("before", "after"),
    format: numberFormatValidator,
    ...commonAxisLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["showInLegend"]),
  ...without(fillOptionsDef, ["fill"]),
  ...without(strokeOptionsDef, ["stroke"]),
  ...lineDashOptionsDef,
  highlight: highlightOptionsDef(lineHighlightOptionsDef)
};
var funnelSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  }),
  spacingRatio: ratio,
  crisp: boolean,
  dropOff: {
    enabled: boolean,
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  stageLabel: {
    placement: union("before", "after"),
    format: numberFormatValidator,
    ...commonAxisLabelOptionsDefs
  },
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["showInLegend"]),
  ...without(fillOptionsDef, ["fill"]),
  ...without(strokeOptionsDef, ["stroke"]),
  ...lineDashOptionsDef
};
var heatmapSeriesThemeableOptionsDef = {
  title: string,
  textAlign: union("left", "center", "right"),
  verticalAlign: union("top", "middle", "bottom"),
  itemPadding: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef
  }),
  showInMiniChart: boolean,
  label: autoSizedLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...strokeOptionsDef
};
var ohlcSeriesThemeableOptionsDef = {
  showInMiniChart: boolean,
  itemStyler: callbackDefs({
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  }),
  item: {
    up: {
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    },
    down: {
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  highlight: multiSeriesHighlightOptionsDef(lineHighlightOptionsDef, lineHighlightOptionsDef)
};
var mapLineSeriesThemeableOptionsDef = {
  maxStrokeWidth: positiveNumber,
  itemStyler: callbackDefs({
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  }),
  sizeDomain: arrayOf(positiveNumber),
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlightStyle: {
    // eslint-disable-next-line sonarjs/deprecation
    ...commonSeriesThemeableOptionsDefs.highlightStyle,
    ...strokeOptionsDef
  },
  highlight: multiSeriesHighlightOptionsDef(lineHighlightOptionsDef, lineHighlightOptionsDef)
};
var mapLineBackgroundSeriesThemeableOptionsDef = {
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var mapMarkerSeriesThemeableOptionsDef = {
  colorRange: arrayOf(color),
  maxSize: positiveNumber,
  sizeDomain: arrayOf(positiveNumber),
  label: {
    placement: union("top", "bottom", "left", "right"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"]),
  // TODO Remove in next major version
  highlightStyle: {
    // eslint-disable-next-line sonarjs/deprecation
    ...commonSeriesThemeableOptionsDefs.highlightStyle,
    ...fillOptionsDef,
    ...strokeOptionsDef
  },
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var mapShapeSeriesThemeableOptionsDef = {
  colorRange: arrayOf(color),
  padding: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  }),
  label: autoSizedLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  // TODO Remove in next major version
  highlightStyle: {
    // eslint-disable-next-line sonarjs/deprecation
    ...commonSeriesThemeableOptionsDefs.highlightStyle,
    ...fillOptionsDef,
    ...strokeOptionsDef
  },
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var mapShapeBackgroundSeriesThemeableOptionsDef = {
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var nightingaleSeriesThemeableOptionsDef = {
  cornerRadius: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(barHighlightOptionsDef, barHighlightOptionsDef)
};
var pyramidSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  aspectRatio: positiveNumber,
  spacing: positiveNumber,
  reverse: boolean,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  }),
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  label: seriesLabelOptionsDefs,
  stageLabel: {
    spacing: positiveNumber,
    placement: union("before", "after"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...without(fillOptionsDef, ["fill"]),
  ...without(strokeOptionsDef, ["stroke"]),
  ...lineDashOptionsDef
};
var radarAreaSeriesThemeableOptionsDef = {
  connectMissingData: boolean,
  marker: markerOptionsDefs,
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var radarLineSeriesThemeableOptionsDef = {
  connectMissingData: boolean,
  marker: markerOptionsDefs,
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, lineHighlightOptionsDef)
};
var radialBarSeriesThemeableOptionsDef = {
  cornerRadius: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(barHighlightOptionsDef, barHighlightOptionsDef)
};
var radialColumnSeriesThemeableOptionsDef = {
  cornerRadius: positiveNumber,
  columnWidthRatio: ratio,
  maxColumnWidthRatio: ratio,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(barHighlightOptionsDef, barHighlightOptionsDef)
};
var rangeAreaSeriesThemeableOptionsDef = {
  showInMiniChart: boolean,
  connectMissingData: boolean,
  interpolation: interpolationOptionsDefs,
  label: {
    ...seriesLabelOptionsDefs,
    placement: union("inside", "outside"),
    spacing: positiveNumber
  },
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(shapeHighlightOptionsDef, shapeHighlightOptionsDef)
};
var rangeBarSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  grouped: boolean,
  showInMiniChart: boolean,
  cornerRadius: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  label: {
    ...seriesLabelOptionsDefs,
    placement: union("inside", "outside"),
    spacing: positiveNumber
  },
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef,
  highlight: multiSeriesHighlightOptionsDef(barHighlightOptionsDef, barHighlightOptionsDef)
};
var sankeySeriesThemeableOptionsDef = {
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  label: {
    ...seriesLabelOptionsDefs,
    spacing: positiveNumber
  },
  link: {
    itemStyler: callbackDefs({
      ...fillOptionsDef,
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }),
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  node: {
    width: positiveNumber,
    spacing: positiveNumber,
    alignment: union("left", "center", "right", "justify"),
    itemStyler: callbackDefs({
      ...fillOptionsDef,
      ...strokeOptionsDef,
      ...lineDashOptionsDef
    }),
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs
};
var sunburstSeriesThemeableOptionsDef = {
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  colorRange: arrayOf(color),
  sectorSpacing: positiveNumber,
  cornerRadius: positiveNumber,
  padding: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef
  }),
  label: {
    spacing: positiveNumber,
    ...autoSizedLabelOptionsDefs
  },
  secondaryLabel: autoSizedLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["highlight", "showInLegend"]),
  ...without(fillOptionsDef, ["fill"]),
  ...without(strokeOptionsDef, ["stroke"]),
  // TODO Remove in next major version
  highlightStyle: {
    label: {
      color
    },
    secondaryLabel: {
      color
    },
    ...fillOptionsDef,
    ...strokeOptionsDef
  }
};
var treemapSeriesThemeableOptionsDef = {
  fills: arrayOf(colorUnion),
  strokes: arrayOf(color),
  colorRange: arrayOf(color),
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef
  }),
  group: {
    gap: positiveNumber,
    padding: positiveNumber,
    cornerRadius: positiveNumber,
    textAlign: union("left", "center", "right"),
    interactive: boolean,
    label: {
      ...seriesLabelOptionsDefs,
      spacing: positiveNumber
    },
    ...fillOptionsDef,
    ...strokeOptionsDef
  },
  tile: {
    gap: positiveNumber,
    padding: positiveNumber,
    cornerRadius: positiveNumber,
    textAlign: union("left", "center", "right"),
    verticalAlign: union("top", "middle", "bottom"),
    label: {
      ...seriesLabelOptionsDefs,
      spacing: positiveNumber,
      lineHeight: positiveNumber,
      minimumFontSize: positiveNumber,
      wrapping: union("never", "always", "hyphenate", "on-space"),
      overflowStrategy: union("ellipsis", "hide")
    },
    secondaryLabel: {
      ...seriesLabelOptionsDefs,
      lineHeight: positiveNumber,
      minimumFontSize: positiveNumber,
      wrapping: union("never", "always", "hyphenate", "on-space"),
      overflowStrategy: union("ellipsis", "hide")
    },
    ...fillOptionsDef,
    ...strokeOptionsDef
  },
  tooltip: tooltipOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["highlight", "showInLegend"]),
  // TODO Remove in next major version
  highlightStyle: {
    group: {
      label: {
        color
      },
      ...fillOptionsDef,
      ...strokeOptionsDef
    },
    tile: {
      label: {
        color
      },
      secondaryLabel: {
        color
      },
      ...fillOptionsDef,
      ...strokeOptionsDef
    }
  }
};
var waterfallSeriesItemOptionsDef = {
  name: string,
  cornerRadius: positiveNumber,
  itemStyler: callbackDefs({
    ...fillOptionsDef,
    ...strokeOptionsDef,
    ...lineDashOptionsDef,
    cornerRadius: positiveNumber
  }),
  label: {
    ...seriesLabelOptionsDefs,
    placement: union("inside-start", "inside-center", "inside-end", "outside-start", "outside-end"),
    spacing: positiveNumber
  },
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...fillOptionsDef,
  ...strokeOptionsDef,
  ...lineDashOptionsDef
};
var waterfallSeriesThemeableOptionsDef = {
  direction: union("horizontal", "vertical"),
  showInMiniChart: boolean,
  item: {
    positive: waterfallSeriesItemOptionsDef,
    negative: waterfallSeriesItemOptionsDef,
    total: waterfallSeriesItemOptionsDef
  },
  line: {
    enabled: boolean,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs
};

// packages/ag-charts-community/src/chart/themes/themeOptionsDef.ts
var serializableDate = optionsDefs(
  {
    __type: required(constant("date")),
    value: or(string, number)
  },
  "a serializable date object"
);
var navigatorHandleOptionsDef = {
  width: positiveNumber,
  height: positiveNumber,
  grip: boolean,
  fill: color,
  stroke: color,
  strokeWidth: positiveNumber,
  cornerRadius: positiveNumber
};
var navigatorOptionsDef = {
  enabled: boolean,
  height: positiveNumber,
  spacing: positiveNumber,
  cornerRadius: number,
  mask: {
    fill: color,
    fillOpacity: ratio,
    stroke: color,
    strokeWidth: positiveNumber
  },
  minHandle: navigatorHandleOptionsDef,
  maxHandle: navigatorHandleOptionsDef,
  miniChart: {
    enabled: boolean,
    padding: {
      top: positiveNumber,
      bottom: positiveNumber
    },
    label: {
      enabled: boolean,
      avoidCollisions: boolean,
      spacing: positiveNumber,
      format: numberFormatValidator,
      formatter: callback,
      interval: {
        minSpacing: positiveNumber,
        maxSpacing: positiveNumber,
        values: array,
        step: number
      },
      ...fontOptionsDef
    },
    series: defined
    // series: {
    //     area: without(areaSeriesThemeableOptionsDef, commonIgnoredMiniChartProperties),
    //     bar: without(barSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'errorBar',
    //         'label',
    //         'legendItemName',
    //         'direction',
    //     ]),
    //     'box-plot': without(boxPlotSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'direction',
    //         'legendItemName',
    //         'minName',
    //         'q1Name',
    //         'medianName',
    //         'q3Name',
    //         'maxName',
    //     ]),
    //     bubble: without(bubbleSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'title',
    //         'label',
    //         'labelKey',
    //         'labelName',
    //         'sizeName',
    //     ]),
    //     candlestick: without(candlestickSeriesThemeableOptionsDef, commonIgnoredMiniChartProperties),
    //     heatmap: without(heatmapSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'title',
    //         'label',
    //         'colorName',
    //         'textAlign',
    //         'verticalAlign',
    //         'itemPadding',
    //         'colorRange',
    //     ]),
    //     histogram: without(histogramSeriesThemeableOptionsDef, [...commonIgnoredMiniChartProperties, 'label']),
    //     line: without(lineSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'errorBar',
    //         'title',
    //         'label',
    //     ]),
    //     ohlc: without(ohlcSeriesThemeableOptionsDef, commonIgnoredMiniChartProperties),
    //     'range-area': without(rangeAreaSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'label',
    //         'yLowName',
    //         'yHighName',
    //     ]),
    //     'range-bar': without(rangeBarSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'direction',
    //         'label',
    //         'yLowName',
    //         'yHighName',
    //     ]),
    //     scatter: without(scatterSeriesThemeableOptionsDef, [
    //         ...commonIgnoredMiniChartProperties,
    //         'errorBar',
    //         'title',
    //         'label',
    //         'labelKey',
    //         'labelName',
    //     ]),
    //     waterfall: without(waterfallSeriesThemeableOptionsDef, [...commonIgnoredMiniChartProperties, 'direction']),
    // },
  }
};
var cartesianAxesThemeDef = {
  number: {
    ...without(numberAxisOptionsDefs, ["type", "crossLines"]),
    top: without(numberAxisOptionsDefs, ["type", "crossLines", "position"]),
    right: without(numberAxisOptionsDefs, ["type", "crossLines", "position"]),
    bottom: without(numberAxisOptionsDefs, ["type", "crossLines", "position"]),
    left: without(numberAxisOptionsDefs, ["type", "crossLines", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  },
  log: {
    ...without(logAxisOptionsDefs, ["type", "crossLines"]),
    top: without(logAxisOptionsDefs, ["type", "crossLines", "position"]),
    right: without(logAxisOptionsDefs, ["type", "crossLines", "position"]),
    bottom: without(logAxisOptionsDefs, ["type", "crossLines", "position"]),
    left: without(logAxisOptionsDefs, ["type", "crossLines", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  },
  category: {
    ...without(categoryAxisOptionsDefs, ["type", "crossLines"]),
    top: without(categoryAxisOptionsDefs, ["type", "crossLines", "position"]),
    right: without(categoryAxisOptionsDefs, ["type", "crossLines", "position"]),
    bottom: without(categoryAxisOptionsDefs, ["type", "crossLines", "position"]),
    left: without(categoryAxisOptionsDefs, ["type", "crossLines", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  },
  time: {
    ...without(timeAxisOptionsDefs, ["type", "crossLines"]),
    top: without(timeAxisOptionsDefs, ["type", "crossLines", "position"]),
    right: without(timeAxisOptionsDefs, ["type", "crossLines", "position"]),
    bottom: without(timeAxisOptionsDefs, ["type", "crossLines", "position"]),
    left: without(timeAxisOptionsDefs, ["type", "crossLines", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  },
  "unit-time": {
    ...without(unitTimeAxisOptionsDefs, ["type", "crossLines"]),
    top: without(unitTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    right: without(unitTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    bottom: without(unitTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    left: without(unitTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  },
  "grouped-category": {
    ...without(groupedCategoryAxisOptionsDefs, ["type"]),
    top: without(groupedCategoryAxisOptionsDefs, ["type", "position"]),
    right: without(groupedCategoryAxisOptionsDefs, ["type", "position"]),
    bottom: without(groupedCategoryAxisOptionsDefs, ["type", "position"]),
    left: without(groupedCategoryAxisOptionsDefs, ["type", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  },
  "ordinal-time": {
    ...without(ordinalTimeAxisOptionsDefs, ["type", "crossLines"]),
    top: without(ordinalTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    right: without(ordinalTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    bottom: without(ordinalTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    left: without(ordinalTimeAxisOptionsDefs, ["type", "crossLines", "position"]),
    crossLines: without(cartesianCrossLineOptionsDefs, ["type"])
  }
};
var polarAxesThemeDef = {
  "angle-category": {
    ...without(angleCategoryAxisOptionsDefs, ["type", "crossLines"]),
    crossLines: without(commonCrossLineOptionsDefs, ["type"])
  },
  "angle-number": {
    ...without(angleNumberAxisOptionsDefs, ["type", "crossLines"]),
    crossLines: without(commonCrossLineOptionsDefs, ["type"])
  },
  "radius-category": {
    ...without(radiusCategoryAxisOptionsDefs, ["type", "crossLines"]),
    crossLines: {
      ...without(commonCrossLineOptionsDefs, ["type"]),
      label: {
        ...commonCrossLineLabelOptionsDefs,
        positionAngle: number
      }
    }
  },
  "radius-number": {
    ...without(radiusNumberAxisOptionsDefs, ["type", "crossLines"]),
    crossLines: {
      ...without(commonCrossLineOptionsDefs, ["type"]),
      label: {
        ...commonCrossLineLabelOptionsDefs,
        positionAngle: number
      }
    }
  }
};
var undocumentedSeriesOptionsDef = {
  visible: boolean
};
var themeOverridesOptionsDef = {
  common: {
    ...commonChartOptionsDefs,
    navigator: navigatorOptionsDef,
    axes: {
      ...cartesianAxesThemeDef,
      ...polarAxesThemeDef
    },
    annotations: {
      ...annotationOptionsDef,
      line: annotationLineStyleDefs,
      "horizontal-line": annotationCrossLineStyleDefs,
      "vertical-line": annotationCrossLineStyleDefs,
      "disjoint-channel": annotationDisjointChannelStyleDefs,
      "parallel-channel": annotationParallelChannelStyleDefs,
      "fibonacci-retracement": annotationFibonacciStylesDefs,
      "fibonacci-retracement-trend-based": annotationFibonacciStylesDefs,
      callout: annotationCalloutStylesDefs,
      comment: annotationCommentStylesDefs,
      note: annotationNoteStylesDefs,
      text: annotationTextStylesDef,
      arrow: annotationLineStyleDefs,
      "arrow-up": annotationShapeStylesDefs,
      "arrow-down": annotationShapeStylesDefs,
      "date-range": annotationMeasurerStylesDefs,
      "price-range": annotationMeasurerStylesDefs,
      "date-price-range": annotationMeasurerStylesDefs,
      "quick-date-price-range": annotationQuickMeasurerStylesDefs
    },
    chartToolbar: {
      enabled: boolean
    },
    initialState: {
      legend: arrayOfDefs(
        {
          visible: boolean,
          seriesId: string,
          itemId: string,
          legendItemName: string
        },
        "legend state array"
      ),
      zoom: {
        rangeX: {
          start: or(number, serializableDate),
          end: or(number, serializableDate)
        },
        rangeY: {
          start: or(number, serializableDate),
          end: or(number, serializableDate)
        },
        ratioX: {
          start: ratio,
          end: ratio
        },
        ratioY: {
          start: ratio,
          end: ratio
        },
        autoScaledAxes: arrayOf(constant("y"))
      }
    }
  },
  line: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: lineSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  scatter: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: scatterSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  bubble: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: bubbleSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  area: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: areaSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  bar: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: barSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "box-plot": {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: boxPlotSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  candlestick: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: candlestickSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "cone-funnel": {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: coneFunnelSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  funnel: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: funnelSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  ohlc: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: ohlcSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  histogram: {
    ...commonChartOptionsDefs,
    axes: without(cartesianAxesThemeDef, ["category", "grouped-category", "unit-time", "ordinal-time"]),
    series: histogramSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  heatmap: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: heatmapSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  waterfall: {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: waterfallSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "range-bar": {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: rangeBarSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "range-area": {
    ...commonChartOptionsDefs,
    axes: cartesianAxesThemeDef,
    series: rangeAreaSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  donut: {
    ...commonChartOptionsDefs,
    series: donutSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  pie: {
    ...commonChartOptionsDefs,
    series: pieSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "radar-line": {
    ...commonChartOptionsDefs,
    axes: polarAxesThemeDef,
    series: radarLineSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "radar-area": {
    ...commonChartOptionsDefs,
    axes: polarAxesThemeDef,
    series: radarAreaSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "radial-bar": {
    ...commonChartOptionsDefs,
    axes: polarAxesThemeDef,
    series: radialBarSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "radial-column": {
    ...commonChartOptionsDefs,
    axes: polarAxesThemeDef,
    series: radialColumnSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  nightingale: {
    ...commonChartOptionsDefs,
    axes: polarAxesThemeDef,
    series: nightingaleSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  sunburst: {
    ...commonChartOptionsDefs,
    series: sunburstSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  treemap: {
    ...commonChartOptionsDefs,
    series: treemapSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "map-shape": {
    ...commonChartOptionsDefs,
    series: mapShapeSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "map-line": {
    ...commonChartOptionsDefs,
    series: mapLineSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "map-marker": {
    ...commonChartOptionsDefs,
    series: mapMarkerSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "map-shape-background": {
    ...commonChartOptionsDefs,
    series: mapShapeBackgroundSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "map-line-background": {
    ...commonChartOptionsDefs,
    series: mapLineBackgroundSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  sankey: {
    ...commonChartOptionsDefs,
    series: sankeySeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  chord: {
    ...commonChartOptionsDefs,
    series: chordSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  pyramid: {
    ...commonChartOptionsDefs,
    series: pyramidSeriesThemeableOptionsDef,
    navigator: navigatorOptionsDef,
    ...undocumentedSeriesOptionsDef
  },
  "radial-gauge": {
    ...commonChartOptionsDefs,
    ...radialGaugeSeriesThemeableOptionsDef,
    targets: without(radialGaugeTargetOptionsDef, ["value"]),
    tooltip: {
      ...radialGaugeSeriesThemeableOptionsDef.tooltip,
      ...commonChartOptionsDefs.tooltip
    }
  },
  "linear-gauge": {
    ...commonChartOptionsDefs,
    ...linearGaugeSeriesThemeableOptionsDef,
    targets: without(linearGaugeTargetOptionsDef, ["value"]),
    tooltip: {
      ...linearGaugeSeriesThemeableOptionsDef.tooltip,
      ...commonChartOptionsDefs.tooltip
    }
  }
};
function mapValues2(object2, mapper) {
  const result = {};
  for (const key of Reflect.ownKeys(object2)) {
    result[key] = mapper(object2[key], key, object2);
  }
  return result;
}
var themeOverridesOptionsWithOperatorsDef = mapValues2(
  themeOverridesOptionsDef,
  function themeOperatorMapper(value, key) {
    if (isSymbol(key))
      return value;
    if (isFunction(value)) {
      return or(value, themeOperator, isSymbol);
    } else if (isObject(value)) {
      return or(
        optionsDefs(
          unionSymbol in value ? mapValues2(value, (val) => isObject(val) ? mapValues2(val, themeOperatorMapper) : val) : mapValues2(value, themeOperatorMapper)
        ),
        themeOperator,
        isSymbol
      );
    }
    throw new Error(`Invalid theme override value: ${String(value)}`);
  }
);

// packages/ag-charts-community/src/chart/themes/vividDark.ts
var VIVID_DARK_FILLS = {
  BLUE: "#0083ff",
  ORANGE: "#ff6600",
  GREEN: "#00af00",
  CYAN: "#00ccff",
  YELLOW: "#f7c700",
  VIOLET: "#ac26ff",
  GRAY: "#a7a7b7",
  MAGENTA: "#e800c5",
  BROWN: "#b54300",
  RED: "#ff0000"
};
var VIVID_DARK_STROKES = {
  BLUE: "#67b7ff",
  ORANGE: "#ffc24d",
  GREEN: "#5cc86f",
  CYAN: "#54ebff",
  VIOLET: "#fff653",
  YELLOW: "#c18aff",
  GRAY: "#aeaeae",
  MAGENTA: "#f078d4",
  BROWN: "#ba8438",
  RED: "#ff726e"
};
var VividDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: VIVID_DARK_FILLS,
      fillsFallback: Object.values(VIVID_DARK_FILLS),
      strokes: VIVID_DARK_STROKES,
      sequentialColors: getSequentialColors(VIVID_DARK_FILLS),
      divergingColors: [VIVID_DARK_FILLS.ORANGE, VIVID_DARK_FILLS.YELLOW, VIVID_DARK_FILLS.GREEN],
      hierarchyColors: [],
      secondSequentialColors: [
        "#0083ff",
        "#0076e6",
        "#0069cc",
        "#005cb3",
        "#004f99",
        "#004280",
        "#003466",
        "#00274c"
      ],
      secondDivergingColors: [VIVID_DARK_FILLS.GREEN, VIVID_DARK_FILLS.YELLOW, VIVID_DARK_FILLS.RED],
      secondHierarchyColors: [],
      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },
      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },
      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },
      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },
      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },
      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/vividLight.ts
var VIVID_FILLS = {
  BLUE: "#0083ff",
  ORANGE: "#ff6600",
  GREEN: "#00af00",
  CYAN: "#00ccff",
  YELLOW: "#f7c700",
  VIOLET: "#ac26ff",
  GRAY: "#a7a7b7",
  MAGENTA: "#e800c5",
  BROWN: "#b54300",
  RED: "#ff0000"
};
var VIVID_STROKES = {
  BLUE: "#0f68c0",
  ORANGE: "#d47100",
  GREEN: "#007922",
  CYAN: "#009ac2",
  VIOLET: "#bca400",
  YELLOW: "#753cac",
  GRAY: "#646464",
  MAGENTA: "#9b2685",
  BROWN: "#6c3b00",
  RED: "#cb0021"
};
var VividLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      ...super.getDefaultColors(),
      fills: VIVID_FILLS,
      fillsFallback: Object.values(VIVID_FILLS),
      strokes: VIVID_STROKES,
      sequentialColors: getSequentialColors(VIVID_FILLS),
      divergingColors: [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN],
      hierarchyColors: [],
      secondSequentialColors: [
        "#0083ff",
        "#1a8fff",
        "#339cff",
        "#4da8ff",
        "#66b5ff",
        "#80c1ff",
        "#99cdff",
        "#b3daff"
      ],
      secondDivergingColors: [VIVID_FILLS.GREEN, VIVID_FILLS.YELLOW, VIVID_FILLS.RED],
      secondHierarchyColors: [],
      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },
      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },
      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },
      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },
      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },
      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, VIVID_FILLS.BLUE);
    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/mapping/themes.ts
var lightTheme = simpleMemorize(() => new ChartTheme());
var themeCacheDebug = Debug.create(true, "perf");
var cacheCallback = (status, fn, keys) => {
  themeCacheDebug(`[CACHE] ChartTheme`, status, fn.name, keys);
};
var themes = {
  // darkThemes,
  "ag-default-dark": simpleMemorize(() => new DarkTheme()),
  "ag-sheets-dark": simpleMemorize(() => new SheetsDark(), cacheCallback),
  "ag-polychroma-dark": simpleMemorize(() => new PolychromaDark(), cacheCallback),
  "ag-vivid-dark": simpleMemorize(() => new VividDark(), cacheCallback),
  "ag-material-dark": simpleMemorize(() => new MaterialDark(), cacheCallback),
  "ag-financial-dark": simpleMemorize(() => new FinancialDark(), cacheCallback),
  // lightThemes,
  "ag-default": lightTheme,
  "ag-sheets": simpleMemorize(() => new SheetsLight(), cacheCallback),
  "ag-polychroma": simpleMemorize(() => new PolychromaLight(), cacheCallback),
  "ag-vivid": simpleMemorize(() => new VividLight(), cacheCallback),
  "ag-material": simpleMemorize(() => new MaterialLight(), cacheCallback),
  "ag-financial": simpleMemorize(() => new FinancialLight(), cacheCallback)
};
var getChartTheme = simpleMemorize(createChartTheme, cacheCallback);
function createChartTheme(value) {
  if (value instanceof ChartTheme) {
    return value;
  } else if (!validateStructure(value)) {
    return lightTheme();
  }
  if (value == null || typeof value === "string") {
    const stockTheme = themes[value ?? "ag-default"];
    if (stockTheme) {
      return stockTheme();
    }
    throw new Error(`Cannot find theme \`${value}\`.`);
  }
  const { cleared, invalid } = validate(reduceThemeOptions(value), themeOptionsDef, "theme");
  for (const error2 of invalid) {
    logger_exports.warnOnce(String(error2));
  }
  const baseTheme = cleared?.baseTheme ? getChartTheme(cleared.baseTheme) : lightTheme();
  return cleared ? new baseTheme.constructor(cleared) : baseTheme;
}
function reduceThemeOptions(options) {
  if (!isObject(options) || !isObject(options.baseTheme))
    return options;
  let maybeNested = options;
  let palette;
  let params;
  const overrides = [];
  while (typeof maybeNested === "object") {
    palette ?? (palette = maybeNested.palette);
    params ?? (params = maybeNested.params);
    if (maybeNested.overrides) {
      overrides.push(maybeNested.overrides);
    }
    maybeNested = maybeNested.baseTheme;
  }
  return {
    baseTheme: maybeNested,
    overrides: mergeDefaults(...overrides),
    params,
    palette
  };
}
var themeOptionsDef = {
  baseTheme: or(string, object),
  overrides: themeOverridesOptionsWithOperatorsDef,
  params: {
    accentColor: color,
    axisColor: color,
    backgroundColor: color,
    borderColor: color,
    borderRadius: number,
    chartBackgroundColor: color,
    chartPadding: number,
    focusShadow: string,
    foregroundColor: color,
    fontFamily: fontFamilyFull,
    fontSize: number,
    fontWeight: or(string, number),
    gridLineColor: color,
    popupShadow: string,
    subtleTextColor: color,
    textColor: color,
    chromeBackgroundColor: color,
    chromeFontFamily: fontFamilyFull,
    chromeFontSize: number,
    chromeFontWeight: or(string, number),
    chromeSubtleTextColor: color,
    chromeTextColor: color,
    buttonBackgroundColor: color,
    buttonBorder: boolean,
    buttonFontWeight: number,
    buttonTextColor: color,
    inputBackgroundColor: color,
    inputBorder: boolean,
    inputTextColor: color,
    menuBackgroundColor: color,
    menuBorder: boolean,
    menuTextColor: color,
    panelBackgroundColor: color,
    panelSubtleTextColor: color,
    tooltipBackgroundColor: color,
    tooltipBorder: boolean,
    tooltipTextColor: color,
    tooltipSubtleTextColor: color,
    crosshairLabelBackgroundColor: color,
    crosshairLabelTextColor: color
  },
  palette: {
    fills: arrayOf(colorUnion),
    strokes: arrayOf(color),
    up: { fill: or(color, gradientStrict), stroke: color },
    down: { fill: or(color, gradientStrict), stroke: color },
    neutral: { fill: or(color, gradientStrict), stroke: color }
  }
};
var themeNameValidator = union(
  "ag-default",
  "ag-default-dark",
  "ag-sheets",
  "ag-sheets-dark",
  "ag-polychroma",
  "ag-polychroma-dark",
  "ag-vivid",
  "ag-vivid-dark",
  "ag-material",
  "ag-material-dark",
  "ag-financial",
  "ag-financial-dark"
);
function validateStructure(value) {
  const { invalid } = validate(
    { theme: value },
    { theme: or(themeNameValidator, object) }
  );
  for (const error2 of invalid) {
    logger_exports.warnOnce(String(error2));
  }
  return invalid.length === 0;
}

// packages/ag-charts-community/src/module/enterpriseModule.ts
var enterpriseModule = {
  isEnterprise: false
};

// packages/ag-charts-community/src/module/optionsGraphUtils.ts
var PATH_EDGE = "path";
var PATH_ARRAY_EDGE = "pathArray";
var DEFAULTS_EDGE = "default";
var OVERRIDES_EDGE = "override";
var USER_OPTIONS_EDGE = "user";
var OPERATION_EDGE = "operation";
var OPERATION_VALUE_EDGE = "operationValue";
var DEPENDENCY_EDGE = "dependency";
var AUTO_ENABLE_EDGE = "autoEnable";
var AUTO_ENABLE_VALUE_EDGE = "autoEnableValue";
function isRatio(value) {
  return isNumber(value) && value >= 0 && value <= 1;
}
function hasPathSafe(object2, path) {
  let result = object2;
  for (const part of path) {
    const isPartKey = typeof part === "string" && result != null && (typeof result === "object" || Array.isArray(result)) && part in result;
    if (!isPartKey)
      return false;
    result = result[part];
  }
  return true;
}
function getPathSafe(object2, path) {
  let result = object2;
  for (const part of path) {
    const isPartKey = typeof part === "string" && result != null && (typeof result === "object" || Array.isArray(result)) && part in result;
    if (!isPartKey)
      return;
    result = result[part];
  }
  return result;
}
function setPathSafe(object2, path, value) {
  const pathLength = path.length;
  if (pathLength === 0)
    return;
  let result = object2;
  const lastIndex = pathLength - 1;
  const lastPart = path[lastIndex];
  for (let i = 0; i < lastIndex; i++) {
    const part = path[i];
    const nextPart = path[i + 1];
    let currentValue = result[part];
    if (currentValue == null || !isObjectLike(currentValue)) {
      currentValue = isNaN(Number(nextPart)) ? {} : [];
      result[part] = currentValue;
    }
    result = currentValue;
  }
  result[lastPart] = value;
}
var DIGITS_ONLY_REGEX = /^\d+$/;
function getPathLastIndexIndex(pathArray) {
  for (let i = pathArray.length - 1; i >= 0; i--) {
    const part = pathArray[i];
    if (DIGITS_ONLY_REGEX.test(part)) {
      return i;
    }
  }
  return -1;
}
function getPathLastIndex(pathArray) {
  const indexIndex = getPathLastIndexIndex(pathArray);
  return Number(pathArray[indexIndex]);
}
function resolvePath(currentPath, path, variables) {
  const relativePathParts = path.split("/");
  let resolvedPath = [...currentPath];
  if (path.startsWith("/")) {
    resolvedPath = [];
    relativePathParts.shift();
  }
  let prevPartWasTwoDots = false;
  for (const part of relativePathParts) {
    if (part === "..") {
      resolvedPath.pop();
      if (!prevPartWasTwoDots)
        resolvedPath.pop();
    } else if (part === ".") {
      resolvedPath.pop();
    } else if (part === "$index") {
      const index = getPathLastIndex(currentPath);
      if (isNaN(index))
        return UNRESOLVABLE_PATH;
      resolvedPath.push(`${index}`);
    } else if (part === "$prevIndex") {
      const index = getPathLastIndex(currentPath);
      if (isNaN(index) || Number(index) <= 0)
        return UNRESOLVABLE_PATH;
      resolvedPath.push(`${Number(index) - 1}`);
    } else if (part.startsWith("$")) {
      const variable = variables?.[part.slice(1)];
      if (variable == null)
        return UNRESOLVABLE_PATH;
      resolvedPath.push(variable);
    } else if (part.length !== 0) {
      resolvedPath.push(part);
    }
    prevPartWasTwoDots = part === "..";
  }
  return resolvedPath;
}
var UNRESOLVABLE_PATH = Symbol("unresolvable-path");
var RESOLVED_TO_BRANCH = Symbol("resolved-to-branch");

// packages/ag-charts-community/src/module/optionsGraphOperations.ts
function getOperation(value, keys) {
  if (value == null || typeof value !== "object" || Array.isArray(value))
    return;
  keys ?? (keys = Object.keys(value));
  if (keys.length === 0)
    return;
  const operation = keys[0];
  if (!operationTypes.has(operation))
    return;
  return {
    operation,
    values: Array.isArray(value[operation]) ? value[operation] : [value[operation]]
  };
}
function getOperationTargetVertex(graph, vertex, valueVertex) {
  const operation = getOperation(graph.getVertexValue(valueVertex));
  switch (operation?.operation) {
    case "$path" /* Path */: {
      const [relativePath] = operation.values;
      const pathArray = graph.getPathArray(vertex);
      const path = resolvePath(pathArray, relativePath);
      if (path === UNRESOLVABLE_PATH)
        return;
      return graph.findVertexAtPath(path);
    }
    case "$value" /* Value */:
      return vertex;
  }
}
var chartOperations = {
  $hasSeriesType: { dependencies: seriesTypeDependencyFactory, resolve: hasSeriesTypeOperation },
  $isChartType: { dependencies: seriesTypeDependencyFactory, resolve: isChartTypeOperation },
  $isSeriesType: { dependencies: seriesTypeDependencyFactory, resolve: isSeriesTypeOperation }
};
function seriesTypeDependencyFactory(graph, vertex, _values) {
  const dependencyVertex = graph.findVertexAtPath(["series", "0", "type"]);
  if (dependencyVertex) {
    graph.addEdge(vertex, dependencyVertex, DEPENDENCY_EDGE);
  }
}
function hasSeriesTypeOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  const series = graph.getResolvedPath(["series"]);
  if (!Array.isArray(series))
    return false;
  for (const s of series) {
    if (s.type === value)
      return true;
  }
  return false;
}
function isSeriesTypeOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  const seriesType = graph.getResolvedPath(["series", "0", "type"]);
  return seriesType === value;
}
function isChartTypeOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  const seriesType = graph.getResolvedPath(["series", "0", "type"]);
  if (typeof seriesType !== "string")
    return false;
  switch (value) {
    case "cartesian":
      return chartTypes2.isCartesian(seriesType);
    case "polar":
      return chartTypes2.isPolar(seriesType);
    case "standalone":
      return chartTypes2.isStandalone(seriesType);
  }
  return false;
}
var colorOperations = {
  $foregroundBackgroundMix: foregroundBackgroundMixOperation,
  $foregroundOpacity: foregroundOpacityOperation,
  $interpolate: interpolateOperation,
  $isGradient: isGradientOperation,
  $isImage: isImageOperation,
  $isPattern: isPatternOperation,
  $mix: mixOperation
};
function foregroundBackgroundMixOperation(graph, vertex, values) {
  const [foregroundRatioVertex] = values;
  const foregroundRatio = graph.resolveVertexValue(vertex, foregroundRatioVertex);
  const foregroundColor = graph.getParamValue("foregroundColor");
  const backgroundColor = graph.getParamValue("backgroundColor");
  if (typeof foregroundColor === "string" && typeof backgroundColor === "string" && isRatio(foregroundRatio)) {
    return Color.mix(
      Color.fromString(foregroundColor),
      Color.fromString(backgroundColor),
      1 - foregroundRatio
    ).toString();
  }
  Debug.inDevelopmentMode(
    () => logger_exports.warnOnce(
      `\`$foregroundBackgroundMix\` json operation failed on [${String(foregroundRatio)}}}] at [${graph.getPathArray(vertex).join(".")}], expecting a number between 0 and 1.`
    )
  );
}
function foregroundOpacityOperation(graph, vertex, values) {
  const [opacityVertex] = values;
  const opacity = graph.resolveVertexValue(vertex, opacityVertex);
  const foregroundColor = graph.getParamValue("foregroundColor");
  if (typeof foregroundColor === "string" && isRatio(opacity)) {
    const color2 = Color.fromString(foregroundColor);
    return new Color(color2.r, color2.g, color2.b, opacity).toString();
  }
  Debug.inDevelopmentMode(
    () => logger_exports.warnOnce(
      `\`$foregroundOpacity\` json operation failed on [${String(opacity)}}}] at [${graph.getPathArray(vertex).join(".")}], expecting a number between 0 and 1.`
    )
  );
}
function interpolateOperation(graph, vertex, values) {
  const [colorsVertex, countVertex] = values;
  const colors = graph.resolveVertexValue(vertex, colorsVertex);
  const count = graph.resolveVertexValue(vertex, countVertex);
  if (!isArray(colors) || !isNumber(count))
    return;
  return Color.interpolate(
    colors.map((color2) => Color.fromString(color2)),
    count
  ).map((color2) => color2.toString());
}
function isGradientOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  return isGradientFill(value);
}
function isImageOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  return isImageFill(value);
}
function isPatternOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  return isPatternFill(value);
}
function mixOperation(graph, vertex, values) {
  const [colorAVertex, colorBVertex, ratioVertex] = values;
  const colorA = graph.resolveVertexValue(vertex, colorAVertex);
  const colorB = graph.resolveVertexValue(vertex, colorBVertex);
  const ratio2 = graph.resolveVertexValue(vertex, ratioVertex);
  const pathArray = graph.getPathArray(vertex);
  const warningPrefix = `\`$mix\` json operation failed on [${String(colorA)}, ${String(colorB)}, ${String(ratio2)}] at [${pathArray.join(".")}], expecting`;
  const warningMessage = `${warningPrefix} two colors and a number between 0 and 1.`;
  if (typeof colorB !== "string" || !isRatio(ratio2)) {
    Debug.inDevelopmentMode(() => logger_exports.warnOnce(warningMessage));
    return;
  }
  if (typeof colorA === "string") {
    try {
      return Color.mix(Color.fromString(colorA), Color.fromString(colorB), ratio2).toString();
    } catch {
      Debug.inDevelopmentMode(() => logger_exports.warnOnce(warningMessage));
      return;
    }
  }
  if (!isGradientFill(colorA)) {
    Debug.inDevelopmentMode(() => logger_exports.warnOnce(warningMessage));
    return;
  }
  let colorStops = colorA.colorStops;
  try {
    colorStops = colorStops?.map((value) => {
      let color2;
      if (typeof value.color === "string") {
        color2 = Color.mix(Color.fromString(value.color), Color.fromString(colorB), ratio2).toString();
      }
      return { ...value, color: color2 };
    });
  } catch {
    Debug.inDevelopmentMode(
      () => logger_exports.warnOnce(`${warningPrefix} a gradient, a color and a number between 0 and 1.`)
    );
    return;
  }
  return { ...colorA, colorStops };
}
var fontOperations = {
  $rem: remOperation
};
function remOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.getVertexValue(valueVertex);
  const fontSize = graph.getParamValue("fontSize");
  if (typeof fontSize === "number" && typeof value === "number") {
    return Math.round(value * fontSize);
  }
  Debug.inDevelopmentMode(
    () => logger_exports.warnOnce(
      `\`$rem\` json operation failed on [${String(value)}] at [${graph.getPathArray(vertex).join(".")}], expecting a number.`
    )
  );
}
var logicOperations = {
  $and: andOperation,
  $eq: eqOperation,
  $greaterThan: greaterThanOperation,
  $if: ifOperation,
  $lessThan: lessThanOperation,
  $not: notOperation,
  $or: orOperation,
  $switch: switchOperation
};
function andOperation(graph, vertex, values) {
  for (const valueVertex of values) {
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (!value)
      return false;
  }
  return true;
}
function eqOperation(graph, vertex, values) {
  let compare;
  let first2 = true;
  for (const valueVertex of values) {
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (first2) {
      compare = value;
      first2 = false;
    } else if (value !== compare) {
      return false;
    }
  }
  return true;
}
function greaterThanOperation(graph, vertex, values) {
  const [value, compare] = values;
  return graph.resolveVertexValue(vertex, value) > graph.resolveVertexValue(vertex, compare);
}
function ifOperation(graph, vertex, values) {
  const [conditionVertex, thenVertex, elseVertex] = values;
  const condition = graph.resolveVertexValue(vertex, conditionVertex);
  const valueVertex = condition ? thenVertex : elseVertex;
  const neighbours = graph.neighboursWithEdgeValue(valueVertex, PATH_EDGE);
  if (neighbours) {
    for (const neighbour of neighbours) {
      graph.addEdge(vertex, neighbour, PATH_EDGE);
    }
  }
  return graph.resolveVertexValue(vertex, valueVertex);
}
function lessThanOperation(graph, vertex, values) {
  const [value, compare] = values;
  return graph.resolveVertexValue(vertex, value) < graph.resolveVertexValue(vertex, compare);
}
function notOperation(graph, vertex, values) {
  for (const valueVertex of values) {
    return !graph.resolveVertexValue(vertex, valueVertex);
  }
}
function orOperation(graph, vertex, values) {
  for (const valueVertex of values) {
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (value)
      return true;
  }
  return false;
}
function switchOperation(graph, vertex, values) {
  const [conditionValueVertex, defaultValueVertex, ...caseVertices] = values;
  const conditionValue = graph.resolveVertexValue(vertex, conditionValueVertex);
  for (const caseVertex of caseVertices) {
    const caseValue = graph.getVertexValue(caseVertex);
    if (!Array.isArray(caseValue))
      continue;
    const [caseConditionValue, caseResultValue] = caseValue;
    if (conditionValue === caseConditionValue || Array.isArray(caseConditionValue) && caseConditionValue.includes(conditionValue)) {
      return caseResultValue;
    }
  }
  return graph.getVertexValue(defaultValueVertex);
}
var locationOperations = {
  $isUserOption: isUserOptionOperation,
  $isThemeOverride: isThemeOverrideOperation,
  $palette: paletteOperation,
  $mapPalette: mapPaletteOperation,
  $path: {
    dependencies: pathOperationDependenciesFactory,
    resolve: pathOperation
  },
  $pathString: {
    dependencies: pathOperationDependenciesFactory,
    resolve: pathStringOperation
  },
  $ref: refOperation
};
function isUserOptionOperation(graph, vertex, values) {
  const [relativePathVertices, thenVertex, elseVertex] = values;
  const children = graph.neighboursWithEdgeValue(relativePathVertices, PATH_EDGE);
  if (children) {
    for (const child of children) {
      const relativePathVertex = graph.findNeighbour(child, DEFAULTS_EDGE);
      if (relativePathVertex && isUserOptionCheck(graph, vertex, relativePathVertex)) {
        return graph.resolveVertexValue(vertex, thenVertex);
      }
    }
  } else if (isUserOptionCheck(graph, vertex, relativePathVertices)) {
    return graph.resolveVertexValue(vertex, thenVertex);
  }
  return graph.resolveVertexValue(vertex, elseVertex);
}
function isUserOptionCheck(graph, vertex, relativePathVertex) {
  const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
  if (!isString(relativePath)) {
    throw new Error(`\`$isUserOption\` json operation failed on [${String(relativePath)}], expecting a string.`);
  }
  const pathArray = graph.getPathArray(vertex);
  const path = resolvePath(pathArray, relativePath);
  if (path === UNRESOLVABLE_PATH)
    return false;
  return graph.hasUserOption(path);
}
function isThemeOverrideOperation(graph, vertex, values) {
  const [relativePathVertex, thenVertex, elseVertex] = values;
  const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
  if (!isString(relativePath)) {
    throw new Error(`\`$isThemeOverride\` json operation failed on [${String(relativePath)}], expecting a string.`);
  }
  const pathArray = graph.getPathArray(vertex);
  const path = resolvePath(pathArray, relativePath);
  if (path === UNRESOLVABLE_PATH)
    return;
  if (graph.hasThemeOverride(path)) {
    return graph.resolveVertexValue(vertex, thenVertex);
  }
  return graph.resolveVertexValue(vertex, elseVertex);
}
var PALETTE_INDEX_KEYS = /* @__PURE__ */ new Set(["fill", "fillFallback", "stroke", "gradient", "range2"]);
function paletteOperation(graph, vertex, values) {
  const [keyVertex] = values;
  const key = graph.resolveVertexValue(vertex, keyVertex);
  if (!isString(key))
    return;
  if (PALETTE_INDEX_KEYS.has(key)) {
    const pathArray = graph.getPathArray(vertex);
    const index = getPathLastIndex(pathArray);
    if (isNaN(index))
      return;
    switch (key) {
      case "fill":
        return circularSliceArray(graph.palette.fills, 1, index)[0];
      case "fillFallback":
        return circularSliceArray(graph.palette.fillsFallback, 1, index)[0];
      case "stroke":
        return circularSliceArray(graph.palette.strokes, 1, index)[0];
      case "gradient":
        return circularSliceArray(graph.palette.sequentialColors, 1, index)[0];
      case "range2":
        return circularSliceArray(graph.palette.fills, 2, index);
    }
    return;
  }
  if (key === "gradients") {
    return graph.palette.sequentialColors;
  }
  const value = getPathSafe(graph.palette, key.split("."));
  if (Array.isArray(value))
    return [...value];
  if (typeof value === "object")
    return { ...value };
  return value;
}
function mapPaletteOperation(graph, vertex, values) {
  const [keyVertex] = values;
  const key = graph.resolveVertexValue(vertex, keyVertex);
  if (!isString(key))
    return;
  if (PALETTE_INDEX_KEYS.has(key)) {
    const pathArray = graph.getPathArray(vertex);
    let index = getPathLastIndex(pathArray);
    let ignoreIndexOffset = 0;
    const path = ["series", "0", "type"];
    for (let i = 0; i < index; i++) {
      path[1] = `${i}`;
      const siblingSeriesType = graph.getResolvedPath(path);
      if ("map-shape-background" === siblingSeriesType || "map-line-background" === siblingSeriesType) {
        ignoreIndexOffset++;
      }
    }
    index -= ignoreIndexOffset;
    if (isNaN(index))
      return;
    switch (key) {
      case "fill":
        return circularSliceArray(graph.palette.fills, 1, index)[0];
      case "fillFallback":
        return circularSliceArray(graph.palette.fillsFallback, 1, index)[0];
      case "stroke":
        return circularSliceArray(graph.palette.strokes, 1, index)[0];
      case "gradient":
        return circularSliceArray(graph.palette.sequentialColors, 1, index)[0];
      case "range2":
        return circularSliceArray(graph.palette.fills, 2, index);
    }
    return;
  }
  if (key === "gradients") {
    return graph.palette.sequentialColors;
  }
  const value = getPathSafe(graph.palette, key.split("."));
  if (Array.isArray(value))
    return [...value];
  if (typeof value === "object")
    return { ...value };
  return value;
}
function pathOperationDependenciesFactory(graph, vertex, values) {
  const [relativePathVertex] = values;
  const relativePath = graph.getVertexValue(relativePathVertex);
  if (isString(relativePath)) {
    const pathArray = graph.getPathArray(vertex);
    const path = resolvePath(pathArray, relativePath);
    if (path === UNRESOLVABLE_PATH) {
      return;
    }
    const dependencyVertex = graph.findVertexAtPath(path);
    if (dependencyVertex) {
      graph.addEdge(vertex, dependencyVertex, DEPENDENCY_EDGE);
    }
  }
}
function pathOperation(graph, vertex, values) {
  const hasDefaultValue = values.length > 1;
  const hasCustomBranch = values.length > 2;
  const [relativePathVertex, defaultValueVertex, customBranchVertex] = values;
  const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
  const customBranch = hasCustomBranch ? graph.resolveVertexValue(vertex, customBranchVertex) : null;
  if (!isString(relativePath)) {
    throw new Error(`\`$path\` json operation failed on [${String(relativePath)}], expecting a string.`);
  }
  const pathArray = graph.getPathArray(vertex);
  const path = resolvePath(pathArray, relativePath);
  if (path === UNRESOLVABLE_PATH) {
    return;
  }
  const resolved = customBranch ? getPathSafe(customBranch, path) : graph.getResolvedPath(path);
  if (resolved != null) {
    return resolved;
  }
  if (hasDefaultValue) {
    return graph.resolveVertexValue(vertex, defaultValueVertex);
  }
}
function pathStringOperation(graph, vertex, values) {
  const [relativePathVertex, variablesVertex] = values;
  const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
  if (!isString(relativePath)) {
    throw new Error(`\`$path\` json operation failed on [${String(relativePath)}], expecting a string.`);
  }
  let variables;
  if (variablesVertex) {
    variables = graph.graftAndResolveOrphan(vertex, variablesVertex);
  }
  const pathArray = graph.getPathArray(vertex);
  const path = resolvePath(pathArray, relativePath, variables);
  if (path === UNRESOLVABLE_PATH) {
    throw new Error(`Unresolvable path [${relativePath}] at [${pathArray.join(".")}]`);
  }
  return path;
}
function refOperation(graph, _vertex, values) {
  const [value] = values;
  const paramKey = graph.getVertexValue(value);
  return graph.getParamValue(paramKey);
}
var transformOperations = {
  $apply: applyOperation,
  $applyTheme: applyThemeOperation,
  $findFirstSiblingNotOperation: findFirstSiblingNotOperationOperation,
  $map: mapOperation,
  $merge: mergeOperation,
  $omit: omitOperation,
  $size: sizeOperation,
  $shallow: shallowOperation,
  $value: valueOperation
};
function applyOperation(graph, vertex, values) {
  const [objectVertex, defaultValueVertex, overridesPathVertex1, overridesPathVertex2] = values;
  const object2 = graph.getVertexValue(objectVertex);
  if (!isPlainObject(object2))
    return;
  const defaultValue = defaultValueVertex ? graph.getVertexValue(defaultValueVertex) : void 0;
  const children = graph.neighboursWithEdgeValue(vertex, PATH_EDGE);
  const overridesPath1 = overridesPathVertex1 ? graph.resolveVertexValue(vertex, overridesPathVertex1) : void 0;
  const overridesPath2 = overridesPathVertex2 ? graph.resolveVertexValue(vertex, overridesPathVertex2) : void 0;
  if ((!children || children.length === 0) && defaultValue != null) {
    if (getOperation(defaultValue)) {
      const resolvedDefaultValue = graph.resolveVertexValue(vertex, defaultValueVertex);
      if (isPlainObject(resolvedDefaultValue)) {
        graph.graftObject(vertex, resolvedDefaultValue, [overridesPath1, overridesPath2]);
      }
    } else {
      graph.graftObject(vertex, defaultValue, [overridesPath1, overridesPath2]);
    }
  }
  if (!children)
    return RESOLVED_TO_BRANCH;
  for (const child of children) {
    const childNeighbours = graph.neighboursWithEdgeValue(child, PATH_EDGE);
    if (!childNeighbours || childNeighbours.length === 0) {
      const stubVertex = graph.addVertex({});
      graph.addEdge(child, stubVertex, DEFAULTS_EDGE);
    } else {
      graph.graftObject(child, object2, [overridesPath1, overridesPath2]);
    }
  }
  return RESOLVED_TO_BRANCH;
}
function applyThemeOperation(graph, vertex, values) {
  const [fromPathVertex, variablesVertex, ignorePathsVertex] = values;
  let fromPaths = graph.getVertexValue(fromPathVertex);
  if (typeof fromPaths === "string") {
    fromPaths = [fromPaths];
  }
  if (!Array.isArray(fromPaths))
    return;
  const children = graph.neighboursWithEdgeValue(vertex, PATH_EDGE);
  const ignorePathsValue = ignorePathsVertex ? graph.getVertexValue(ignorePathsVertex) : [];
  const ignorePaths = Array.isArray(ignorePathsValue) ? new Set(ignorePathsValue) : /* @__PURE__ */ new Set();
  if (!children)
    return RESOLVED_TO_BRANCH;
  for (const child of children) {
    const variables = graph.graftAndResolveOrphan(child, variablesVertex);
    for (const fromPath of fromPaths) {
      const fromPathResolved = resolvePath([], fromPath, variables);
      if (fromPathResolved === UNRESOLVABLE_PATH) {
        continue;
      }
      graph.graftConfig(child, fromPathResolved, ignorePaths);
    }
  }
  return RESOLVED_TO_BRANCH;
}
function findFirstSiblingNotOperationOperation(graph, vertex, values) {
  const [defaultValueVertex] = values;
  const pathArray = graph.getPathArray(vertex);
  const indexIndex = getPathLastIndexIndex(pathArray);
  if (indexIndex < 0) {
    return graph.resolveVertexValue(vertex, defaultValueVertex);
  }
  const parentPathArray = pathArray.slice(0, indexIndex);
  const parentVertex = graph.findVertexAtPath(parentPathArray);
  if (!parentVertex) {
    return graph.resolveVertexValue(vertex, defaultValueVertex);
  }
  const siblings = graph.neighboursWithEdgeValue(parentVertex, PATH_EDGE);
  if (siblings) {
    for (let index = 0; index < siblings.length; index++) {
      if (`${index}` === pathArray[indexIndex])
        continue;
      const siblingChildPathArray = parentPathArray.concat([`${index}`, ...pathArray.slice(indexIndex + 1)]);
      const siblingChildVertex = graph.findVertexAtPath(siblingChildPathArray);
      if (!siblingChildVertex)
        continue;
      const siblingChildUserOptionsValue = graph.findNeighbourValue(siblingChildVertex, USER_OPTIONS_EDGE);
      if (siblingChildUserOptionsValue != null) {
        return siblingChildUserOptionsValue;
      }
      const siblingChildOverridesValue = graph.findNeighbourValue(siblingChildVertex, OVERRIDES_EDGE);
      if (siblingChildOverridesValue != null) {
        return siblingChildOverridesValue;
      }
    }
  }
  return graph.resolveVertexValue(vertex, defaultValueVertex);
}
function mapOperation(graph, vertex, values) {
  const [mapOperationVertex, mapValuesVertex] = values;
  const mapOperationFn = graph.getVertexValue(mapOperationVertex);
  const mapValues4 = graph.resolveVertexValue(vertex, mapValuesVertex);
  if (!Array.isArray(mapValues4))
    return;
  if (!getOperation(mapOperationFn))
    return mapValues4.map(() => mapOperationFn);
  let index = 0;
  for (const value of mapValues4) {
    graph.graftValue(vertex, `${index}`, mapOperationFn, value);
    index++;
  }
  return RESOLVED_TO_BRANCH;
}
function mergeOperation(graph, vertex, values) {
  for (const valueVertex of values) {
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (!isPlainObject(value))
      continue;
    graph.graftObject(vertex, value);
  }
  return RESOLVED_TO_BRANCH;
}
function omitOperation(graph, vertex, values) {
  const [keysVertex, objectVertex] = values;
  let keys = graph.getVertexValue(keysVertex);
  if (!Array.isArray(keys)) {
    const targetVertex = getOperationTargetVertex(graph, vertex, objectVertex);
    if (!targetVertex)
      return;
    keys = graph.resolveVertexValue(targetVertex, keysVertex);
  }
  const object2 = graph.resolveVertexValue(vertex, objectVertex);
  if (!Array.isArray(keys) || !isPlainObject(object2))
    return;
  return without(object2, keys);
}
function sizeOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  if (!isObjectLike(value))
    return 0;
  return Object.keys(value).length;
}
function shallowOperation(graph, _vertex, values) {
  const shallowValues = [];
  for (const valueVertex of values) {
    shallowValues.push(graph.getVertexValue(valueVertex));
  }
  return shallowValues;
}
function valueOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.getVertexValue(valueVertex);
  const pathArray = graph.getPathArray(vertex);
  if (value === "$index") {
    return getPathLastIndex(pathArray);
  }
  if (value === "$1") {
    return graph.resolveValue$1(pathArray);
  }
}
var numericOperations = {
  $isEven: isEvenOperation,
  $mul: mulOperation,
  $round: roundOperation
};
function isEvenOperation(graph, vertex, values) {
  const [valueVertex] = values;
  const value = graph.resolveVertexValue(vertex, valueVertex);
  if (isNaN(Number(value)))
    return false;
  return Number(value) % 2 === 0;
}
function mulOperation(graph, vertex, values) {
  let result;
  for (const valueVertex of values) {
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (result == null) {
      result = Number(value);
    } else {
      result *= Number(value);
    }
  }
  return result;
}
function roundOperation(graph, vertex, values) {
  for (const valueVertex of values) {
    return Math.round(Number(graph.resolveVertexValue(vertex, valueVertex)));
  }
}
var operations = {
  ...chartOperations,
  ...colorOperations,
  ...fontOperations,
  ...locationOperations,
  ...logicOperations,
  ...numericOperations,
  ...transformOperations
};
var operationTypes = new Set(Object.keys(operations));
function isOperation(value) {
  return operationTypes.has(value);
}

// packages/ag-charts-community/src/module/optionsGraph.ts
var createOptionsGraph = simpleMemorize(createOptionsGraphFn);
function createOptionsGraphFn(theme, options) {
  return new OptionsGraph(
    theme.config,
    options,
    theme.params,
    theme.palette,
    theme.overrides,
    theme.getTemplateParameters()
  );
}
var _OptionsGraph = class _OptionsGraph extends AdjacencyListGraph {
  constructor(config = {}, userOptions = {}, params = void 0, palette = void 0, overrides = {}, internalParams = /* @__PURE__ */ new Map()) {
    super(PATH_EDGE, OPERATION_EDGE);
    this.config = config;
    this.userOptions = userOptions;
    this.overrides = overrides;
    this.internalParams = internalParams;
    this.resolvedParams = {};
    this.resolvedAnnotations = {};
    // The current value referenced by operations that use `$1`.
    // eslint-disable-next-line @typescript-eslint/prefer-readonly
    this.value$1 = {};
    this.cachedPathVertices = /* @__PURE__ */ new Map();
    this.EMPTY_PATH_ARRAY_VERTEX = this.addVertex([]);
    this.root = this.addVertex("root");
    this.params = this.addVertex("params");
    this.annotations = this.addVertex("annotations");
    this.config = config;
    this.overrides = overrides;
    this.internalParams = internalParams;
    this.palette = palette ? deepClone(palette) : {};
    this.palette.type = isObject(userOptions?.theme) ? paletteType(userOptions.theme?.palette) : "inbuilt";
    const DEFAULT_SERIES_TYPE = "line";
    const seriesType = userOptions.series?.[0]?.type ?? DEFAULT_SERIES_TYPE;
    const defaultAxes = seriesRegistry.cloneDefaultAxes(seriesType);
    userOptions.axes ?? (userOptions.axes = defaultAxes?.axes ?? []);
    this.buildGraphFromObject(this.root, USER_OPTIONS_EDGE, without(userOptions, ["theme"]));
    this.buildGraphFromObject(this.root, DEFAULTS_EDGE, without(config[seriesType], _OptionsGraph.COMPLEX_KEYS));
    const seriesOverrides = overrides ? without(overrides[seriesType], _OptionsGraph.COMPLEX_KEYS) : {};
    if (Object.keys(seriesOverrides).length > 0) {
      this.buildGraphFromObject(this.root, OVERRIDES_EDGE, seriesOverrides);
    }
    const commonOverrides = overrides ? without(overrides.common, _OptionsGraph.COMPLEX_KEYS) : {};
    if (Object.keys(commonOverrides).length > 0) {
      this.buildGraphFromObject(
        this.root,
        OVERRIDES_EDGE,
        chartTypes2.isCartesian(seriesType) ? commonOverrides : without(commonOverrides, ["zoom", "navigator"])
      );
    }
    if (params) {
      this.buildGraphFromObject(this.params, DEFAULTS_EDGE, params);
    }
    const axesVertex = this.findNeighbourWithValue(this.root, "axes", PATH_EDGE);
    const seriesVertex = this.findNeighbourWithValue(this.root, "series", PATH_EDGE);
    if (axesVertex) {
      this.buildGraphFromObject(axesVertex, DEFAULTS_EDGE, {
        $applyTheme: [
          ["/$seriesType/axes/$axisType/$position", "/$seriesType/axes/$axisType"],
          {
            seriesType: { $path: ["/series/0/type", "line"] },
            axisType: { $path: ["./type", "category"] },
            position: { $path: ["./position"] }
          },
          ["top", "right", "bottom", "left"]
        ]
      });
    }
    if (seriesVertex) {
      this.buildGraphFromObject(seriesVertex, DEFAULTS_EDGE, {
        $applyTheme: ["/$seriesType/series", { seriesType: { $path: ["./type", "line"] } }]
      });
    }
    const annotationsTypeConfig = without(
      config[seriesType]?.annotations ?? {},
      _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS
    );
    if (Object.keys(annotationsTypeConfig).length > 0) {
      this.buildGraphFromObject(this.annotations, DEFAULTS_EDGE, annotationsTypeConfig);
    }
    const annotationsTypeOverrides = without(
      overrides?.common?.annotations ?? {},
      _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS
    );
    if (Object.keys(annotationsTypeOverrides).length > 0) {
      this.buildGraphFromObject(this.annotations, OVERRIDES_EDGE, annotationsTypeOverrides);
    }
    const annotationsConfig = pick(config[seriesType]?.annotations ?? {}, _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS);
    if (Object.keys(annotationsConfig).length > 0) {
      this.buildGraphFromObject(this.root, DEFAULTS_EDGE, { annotations: annotationsConfig });
    }
    const annotationsOverrides = pick(overrides?.common?.annotations ?? {}, _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS);
    if (Object.keys(annotationsOverrides).length > 0) {
      this.buildGraphFromObject(this.root, OVERRIDES_EDGE, { annotations: annotationsOverrides });
    }
    this.buildDependencyGraph();
  }
  clear() {
    super.clear();
    this.cachedPathVertices.clear();
  }
  resolve() {
    this.resolved = {};
    this.resolvedParams = {};
    this.resolvedAnnotations = {};
    this.resolveVertex(this.params, this.resolvedParams);
    this.resolveVertex(this.annotations, this.resolvedAnnotations);
    this.resolveVertex(this.root);
    return this.resolved;
  }
  resolveParams() {
    return this.resolvedParams;
  }
  resolveAnnotationThemes() {
    return this.resolvedAnnotations;
  }
  findVertexAtPath(path) {
    const key = path.join(".");
    if (this.cachedPathVertices.has(key)) {
      return this.cachedPathVertices.get(key);
    }
    const vertex = this.findVertexAlongEdge(this.root, path, PATH_EDGE);
    if (!vertex)
      return;
    this.cachedPathVertices.set(key, vertex);
    return vertex;
  }
  hasUserOption(path) {
    return hasPathSafe(this.userOptions, path);
  }
  hasThemeOverride(path) {
    if (path[0] === "axes" && path.length > 1) {
      const axisType = this.getResolvedPath(["axes", path[1], "type"]);
      if (hasPathSafe(this.overrides, ["common", "axes", axisType, ...path.slice(2)])) {
        return true;
      }
      const seriesType = this.getResolvedPath(["series", "0", "type"]);
      return hasPathSafe(this.overrides, [seriesType, "axes", axisType, ...path.slice(2)]);
    }
    if (path[0] === "series" && path.length > 1) {
      const seriesType = this.getResolvedPath(["series", path[1], "type"]);
      return hasPathSafe(this.overrides, [seriesType, "series", ...path.slice(2)]);
    }
    return hasPathSafe(this.overrides, path);
  }
  getParamValue(path) {
    if (this.resolvedParams[path] != null) {
      return this.resolvedParams[path];
    }
    const paramVertex = this.findVertexAlongEdge(this.params, [path], PATH_EDGE);
    if (!paramVertex)
      return;
    const defaultValueVertex = this.findNeighbour(paramVertex, DEFAULTS_EDGE);
    if (!defaultValueVertex)
      return;
    const resolved = this.resolveVertexValue(paramVertex, defaultValueVertex);
    this.resolvedParams[path] = resolved;
    return resolved;
  }
  getPathArray(vertex) {
    return this.findNeighbourValue(vertex, PATH_ARRAY_EDGE) ?? [];
  }
  getResolvedPath(path) {
    return getPathSafe(this.resolved, path);
  }
  resolveVertexValue(vertex, valueVertex) {
    this.resolveVertexDependencies(valueVertex);
    const operation = this.findNeighbourValue(valueVertex, OPERATION_EDGE);
    if (operation && isOperation(operation)) {
      const operationValues = this.neighboursWithEdgeValue(valueVertex, OPERATION_VALUE_EDGE);
      const operator = operations[operation];
      const operatorFn = typeof operator === "function" ? operator : operator.resolve;
      const resolved = operatorFn?.(this, vertex, operationValues ?? []);
      return resolved === RESOLVED_TO_BRANCH ? void 0 : resolved;
    }
    let value = this.getVertexValue(valueVertex);
    if (Array.isArray(value)) {
      const object2 = {};
      this.resolveVertexChildren(valueVertex, object2);
      value = getPathSafe(object2, this.getPathArray(vertex));
    }
    return this.resolveValueOrSymbol(value);
  }
  // Resolve the value currently referenced by `$1`
  resolveValue$1(pathArray) {
    return getPathSafe(this.value$1, pathArray);
  }
  // Graft a branch of the theme config onto the target vertex.
  graftConfig(target, configPathArray, ignorePaths) {
    const targetConfigObject = getPathSafe(this.config, configPathArray);
    const targetPathArrayVertex = this.findNeighbour(target, PATH_ARRAY_EDGE);
    if (isPlainObject(targetConfigObject)) {
      this.buildGraphFromObject(
        target,
        DEFAULTS_EDGE,
        targetConfigObject,
        targetPathArrayVertex,
        void 0,
        ignorePaths
      );
    }
    if (this.overrides) {
      const targetOverridesObject = getPathSafe(this.overrides, configPathArray);
      if (isPlainObject(targetOverridesObject)) {
        this.buildGraphFromObject(
          target,
          OVERRIDES_EDGE,
          targetOverridesObject,
          targetPathArrayVertex,
          void 0,
          ignorePaths
        );
      }
      const commonOverridesObject = getPathSafe(this.overrides, ["common", ...configPathArray.slice(1)]);
      if (isPlainObject(commonOverridesObject)) {
        this.buildGraphFromObject(
          target,
          OVERRIDES_EDGE,
          commonOverridesObject,
          targetPathArrayVertex,
          void 0,
          ignorePaths
        );
      }
    }
    this.buildDependencyGraph();
  }
  // Graft a given object onto the target vertex.
  graftObject(target, object2, overridesPathArrays) {
    const pathArrayVertex = this.findNeighbour(target, PATH_ARRAY_EDGE);
    this.buildGraphFromObject(target, DEFAULTS_EDGE, object2, pathArrayVertex);
    if (this.overrides && overridesPathArrays) {
      for (const overridePathArray of overridesPathArrays) {
        if (overridePathArray == null)
          continue;
        const overrides = getPathSafe(this.overrides, overridePathArray);
        if (overrides) {
          this.buildGraphFromObject(target, OVERRIDES_EDGE, overrides, pathArrayVertex);
        }
      }
    }
    this.buildDependencyGraph();
  }
  // Graft a given operation and value onto `path` child of the target vertex.
  graftValue(target, path, operation, value) {
    const pathArray = [...this.getPathArray(target), path];
    setPathSafe(this.value$1, pathArray, value);
    const pathVertex = this.findVertexAtPath(pathArray) ?? this.addVertex(path);
    this.buildGraphFromValue(target, pathVertex, DEFAULTS_EDGE, pathArray, operation);
    this.buildDependencyGraph();
  }
  // Resolve a branch as if it were a child of the context vertex, but without attaching it to the resolved root.
  graftAndResolveOrphan(context, branch) {
    const orphan = {};
    const orphanVertex = this.addVertex(orphan);
    const contextPathArray = this.getPathArray(context);
    this.graftAndResolveChildren(branch, orphanVertex, contextPathArray, []);
    this.resolveVertex(orphanVertex, orphan);
    return getPathSafe(orphan, contextPathArray);
  }
  buildGraphFromObject(parentVertex, edgeValue, object2, pathArrayVertex, shallowPaths = _OptionsGraph.SHALLOW_KEYS, ignorePaths) {
    const keys = Object.keys(object2);
    const operation = getOperation(object2, keys);
    if (operation) {
      const valueVertex = this.addVertex(object2);
      this.addEdge(parentVertex, valueVertex, edgeValue);
      this.buildGraphFromOperation(valueVertex, edgeValue, operation, pathArrayVertex);
      return;
    }
    if (keys.length === 0) {
      this.addEdge(parentVertex, this.addVertex(Array.isArray(object2) ? [] : {}), edgeValue);
      this.buildGraphAutoEnable(parentVertex, edgeValue, object2, void 0);
      return;
    }
    const pathVertices = this.getVertexChildrenByKey(parentVertex);
    const pathArray = pathArrayVertex ? this.getVertexValue(pathArrayVertex) : [];
    let enabledVertex;
    const childPathArray = [...pathArray];
    const pathArrayLength = pathArray.length;
    for (const key of keys) {
      if (ignorePaths?.has(key))
        continue;
      const childPathVertex = pathVertices?.get(key) ?? this.addVertex(key);
      childPathArray[pathArrayLength] = key;
      if (shallowPaths?.has(key)) {
        this.buildShallowGraphFromValue(parentVertex, childPathVertex, edgeValue, childPathArray, object2[key]);
      } else {
        this.buildGraphFromValue(
          parentVertex,
          childPathVertex,
          edgeValue,
          childPathArray,
          object2[key],
          shallowPaths
        );
      }
      if (key === "enabled") {
        enabledVertex = childPathVertex;
      }
    }
    this.buildGraphAutoEnable(parentVertex, edgeValue, object2, enabledVertex);
  }
  buildGraphAutoEnable(parentVertex, edgeValue, object2, enabledVertex) {
    if (edgeValue === DEFAULTS_EDGE && !enabledVertex)
      return;
    if (edgeValue === USER_OPTIONS_EDGE && enabledVertex)
      return;
    if (edgeValue !== DEFAULTS_EDGE && edgeValue !== USER_OPTIONS_EDGE && edgeValue !== OVERRIDES_EDGE)
      return;
    let autoEnableVertex = this.findNeighbour(parentVertex, AUTO_ENABLE_EDGE);
    if (!autoEnableVertex) {
      autoEnableVertex = this.addVertex(AUTO_ENABLE_EDGE);
      this.addEdge(parentVertex, autoEnableVertex, AUTO_ENABLE_EDGE);
    }
    if (enabledVertex) {
      this.addEdge(enabledVertex, autoEnableVertex, AUTO_ENABLE_VALUE_EDGE);
    }
    const { enabled, _enabledFromTheme } = object2;
    this.addEdge(
      autoEnableVertex,
      this.addVertex({ enabled, _enabledFromTheme, keys: Object.keys(object2).length }),
      edgeValue
    );
  }
  getVertexChildrenByKey(vertex) {
    const pathNeighbours = this.neighboursWithEdgeValue(vertex, PATH_EDGE);
    if (!pathNeighbours)
      return;
    const pathVertices = /* @__PURE__ */ new Map();
    for (const neighbour of pathNeighbours) {
      pathVertices.set(this.getVertexValue(neighbour), neighbour);
    }
    return pathVertices;
  }
  buildGraphFromValue(parentVertex, pathVertex, edgeValue, pathArray, value, shallowPaths) {
    this.addEdge(parentVertex, pathVertex, PATH_EDGE);
    let pathArrayVertex = this.findNeighbour(pathVertex, PATH_ARRAY_EDGE);
    if (!pathArrayVertex) {
      pathArrayVertex = this.addVertex([...pathArray]);
      this.addEdge(pathVertex, pathArrayVertex, PATH_ARRAY_EDGE);
    }
    const operation = getOperation(value);
    if (operation) {
      const valueVertex = this.addVertex(value);
      this.addEdge(pathVertex, valueVertex, edgeValue);
      this.addEdge(valueVertex, pathArrayVertex, PATH_ARRAY_EDGE);
      this.buildGraphFromOperation(valueVertex, edgeValue, operation, pathArrayVertex);
    } else if (isObjectLike(value)) {
      this.buildGraphFromObject(pathVertex, edgeValue, value, pathArrayVertex, shallowPaths);
    } else {
      const valueVertex = this.addVertex(value);
      this.addEdge(pathVertex, valueVertex, edgeValue);
    }
  }
  buildShallowGraphFromValue(parentVertex, pathVertex, edgeValue, pathArray, value) {
    this.addEdge(parentVertex, pathVertex, PATH_EDGE);
    let pathArrayVertex = this.findNeighbour(pathVertex, PATH_ARRAY_EDGE);
    if (!pathArrayVertex) {
      pathArrayVertex = this.addVertex([...pathArray]);
      this.addEdge(pathVertex, pathArrayVertex, PATH_ARRAY_EDGE);
    }
    const valueVertex = this.addVertex(value);
    this.addEdge(pathVertex, valueVertex, edgeValue);
  }
  buildGraphFromOperation(valueVertex, edgeValue, operation, pathArrayVertex) {
    const operationVertex = this.addVertex(operation.operation);
    this.addEdge(valueVertex, operationVertex, OPERATION_EDGE);
    for (const operationValue of operation.values) {
      this.buildGraphFromOperationValue(valueVertex, operationValue, edgeValue, pathArrayVertex);
    }
  }
  buildGraphFromOperationValue(valueVertex, operationValue, edgeValue, pathArrayVertex = this.EMPTY_PATH_ARRAY_VERTEX) {
    const operationValueVertex = this.addVertex(operationValue);
    this.addEdge(valueVertex, pathArrayVertex, PATH_ARRAY_EDGE);
    this.addEdge(valueVertex, operationValueVertex, OPERATION_VALUE_EDGE);
    const innerOperation = getOperation(operationValue);
    if (innerOperation) {
      this.buildGraphFromOperation(operationValueVertex, edgeValue, innerOperation, pathArrayVertex);
    } else if (isObjectLike(operationValue)) {
      this.buildGraphFromObject(operationValueVertex, edgeValue, operationValue, pathArrayVertex);
    }
  }
  buildDependencyGraph() {
    for (let i = 0; i < this.pendingProcessingEdgesFrom.length; i++) {
      const valueVertex = this.pendingProcessingEdgesFrom[i];
      const operationKeyVertex = this.pendingProcessingEdgesTo[i];
      const operation = this.getVertexValue(operationKeyVertex);
      if (!isOperation(operation))
        continue;
      const operationValues = this.neighboursWithEdgeValue(valueVertex, OPERATION_VALUE_EDGE);
      const operator = operations[operation];
      const dependenciesFn = typeof operator === "function" ? void 0 : operator.dependencies;
      dependenciesFn?.(this, valueVertex, operationValues ?? []);
    }
    this.pendingProcessingEdgesFrom = [];
    this.pendingProcessingEdgesTo = [];
  }
  resolveVertex(vertex, object2 = this.resolved) {
    const pathArray = this.getPathArray(vertex);
    this.resolveVertexInEdgePriority(vertex, object2, pathArray);
    this.resolveVertexAutoEnable(vertex, object2, pathArray);
    this.resolveVertexChildren(vertex, object2);
  }
  resolveVertexInEdgePriority(vertex, object2, pathArray) {
    const children = this.neighboursWithEdgeValue(vertex, PATH_EDGE);
    const [highestPriority] = _OptionsGraph.EDGE_PRIORITY;
    for (const edgeValue of _OptionsGraph.EDGE_PRIORITY) {
      const valueVertex = this.findNeighbour(vertex, edgeValue);
      if (valueVertex == null)
        continue;
      const value = this.resolveVertexValueInternal(vertex, valueVertex);
      if (value == null && edgeValue !== highestPriority)
        continue;
      if (children && children.length > 0 && Array.isArray(value) && edgeValue !== highestPriority)
        continue;
      if (pathArray.length === 0) {
        if (value == null)
          continue;
        this.resolved = value;
      } else {
        setPathSafe(object2, pathArray, value);
      }
      break;
    }
  }
  resolveVertexValueInternal(vertex, valueVertex) {
    this.resolveVertexDependencies(valueVertex);
    const operation = this.findNeighbourValue(valueVertex, OPERATION_EDGE);
    if (operation && isOperation(operation)) {
      const operationValues = this.neighboursWithEdgeValue(valueVertex, OPERATION_VALUE_EDGE);
      const operator = operations[operation];
      const operatorFn = typeof operator === "function" ? operator : operator.resolve;
      const resolved = operatorFn?.(this, vertex, operationValues ?? []);
      return resolved === RESOLVED_TO_BRANCH ? void 0 : resolved;
    }
    return this.resolveValueOrSymbol(this.getVertexValue(valueVertex));
  }
  resolveVertexAutoEnable(vertex, object2, pathArray) {
    const autoEnableValueVertex = this.neighboursWithEdgeValue(vertex, AUTO_ENABLE_VALUE_EDGE)?.[0];
    if (!autoEnableValueVertex)
      return;
    const defaultsEnabled = this.findNeighbourValue(autoEnableValueVertex, DEFAULTS_EDGE);
    const overridesEnabled = this.findNeighbourValue(autoEnableValueVertex, OVERRIDES_EDGE);
    const userOptionsEnabled = this.findNeighbourValue(autoEnableValueVertex, USER_OPTIONS_EDGE);
    if (userOptionsEnabled && userOptionsEnabled.enabled == null && !defaultsEnabled?._enabledFromTheme && !overridesEnabled?._enabledFromTheme) {
      setPathSafe(object2, pathArray, true);
    }
  }
  resolveVertexChildren(vertex, object2) {
    const children = this.neighboursWithEdgeValue(vertex, PATH_EDGE);
    if (!children)
      return;
    for (const child of children) {
      const path = this.getVertexValue(child);
      if (children.length > 1 && isOperation(path))
        continue;
      if (path === "_enabledFromTheme")
        continue;
      this.resolveVertex(child, object2);
    }
  }
  resolveVertexDependencies(vertex) {
    const dependencies = this.neighboursWithEdgeValue(vertex, DEPENDENCY_EDGE);
    if (!dependencies)
      return;
    for (const dependency of dependencies) {
      this.resolveVertex(dependency);
    }
  }
  graftAndResolveChildren(remoteBranch, orphanBranch, contextPathArray, orphanPathArray) {
    const remoteChildren = this.neighboursWithEdgeValue(remoteBranch, PATH_EDGE);
    if (!remoteChildren)
      return;
    for (const remoteChild of remoteChildren) {
      const remoteChildPath = this.getVertexValue(remoteChild);
      const childContextPathArray = [...contextPathArray, remoteChildPath];
      const childOrphanPathArray = [...orphanPathArray, remoteChildPath];
      const orphanChildPathVertex = this.addVertex(remoteChildPath);
      const defaultValue = this.findNeighbourValue(remoteChild, DEFAULTS_EDGE);
      this.addEdge(orphanBranch, orphanChildPathVertex, PATH_EDGE);
      const orphanChildPathArrayVertex = this.addVertex(childContextPathArray);
      this.addEdge(orphanChildPathVertex, orphanChildPathArrayVertex, PATH_ARRAY_EDGE);
      if (isPlainObject(defaultValue)) {
        this.buildGraphFromObject(
          orphanChildPathVertex,
          DEFAULTS_EDGE,
          defaultValue,
          orphanChildPathArrayVertex
        );
        const orphanChildValueVertex = this.findNeighbour(orphanChildPathVertex, DEFAULTS_EDGE);
        this.addEdge(orphanChildValueVertex, this.addVertex(childContextPathArray), PATH_ARRAY_EDGE);
        const operation = this.findNeighbourValue(orphanChildValueVertex, OPERATION_EDGE);
        if (isOperation(operation)) {
          const operationValues = this.neighboursWithEdgeValue(orphanChildValueVertex, OPERATION_VALUE_EDGE);
          const operator = operations[operation];
          const dependenciesFn = typeof operator === "function" ? void 0 : operator.dependencies;
          dependenciesFn?.(this, orphanChildValueVertex, operationValues ?? []);
        }
      }
      this.graftAndResolveChildren(
        remoteChild,
        orphanChildPathVertex,
        childContextPathArray,
        childOrphanPathArray
      );
    }
  }
  resolveValueOrSymbol(value) {
    return typeof value === "symbol" && this.internalParams?.has(value) ? this.internalParams.get(value) : value;
  }
};
// The priority order in which to resolve options values.
_OptionsGraph.EDGE_PRIORITY = [USER_OPTIONS_EDGE, OVERRIDES_EDGE, DEFAULTS_EDGE];
// These keys must be stored as shallow objects in the graph and not manipulated.
_OptionsGraph.SHALLOW_KEYS = /* @__PURE__ */ new Set(["context", "data", "topology"]);
// These keys must be excluded when building the graph, they are instead resolved separately since they are objects
// that must be applied to arrays.
_OptionsGraph.COMPLEX_KEYS = ["annotations", "axes", "series"];
_OptionsGraph.ANNOTATIONS_OPTIONS_KEYS = [
  "axesButtons",
  "data",
  "enabled",
  "optionsToolbar",
  "snap",
  "toolbar",
  "xKey",
  "volumeKey"
];
var OptionsGraph = _OptionsGraph;

// packages/ag-charts-community/src/module/optionsModule.ts
var stringFormat = (value) => `'${value}'`;
var _ChartOptions = class _ChartOptions {
  constructor(currentUserOptions, newUserOptions, processedOverrides, specialOverrides, metadata, deltaOptions, stripSymbols = false, apiStartTime) {
    this.themeParameters = {};
    this.optionMetadata = metadata ?? {};
    this.processedOverrides = processedOverrides ?? {};
    let baseChartOptions = null;
    if (currentUserOptions instanceof _ChartOptions) {
      baseChartOptions = currentUserOptions;
      this.specialOverrides = baseChartOptions.specialOverrides;
      if (deltaOptions === void 0) {
        deltaOptions = jsonDiff(
          baseChartOptions.userOptions,
          newUserOptions,
          _ChartOptions.JSON_DIFF_OPTS
        );
      }
      this.userOptions = deepClone(merge(deltaOptions, baseChartOptions.userOptions), {
        ..._ChartOptions.OPTIONS_CLONE_OPTS_SLOW,
        seen: []
      });
    } else {
      this.userOptions = deepClone(currentUserOptions ?? newUserOptions, {
        ..._ChartOptions.OPTIONS_CLONE_OPTS_SLOW,
        seen: []
      });
      this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });
    }
    if (stripSymbols) {
      this.removeLeftoverSymbols(this.userOptions);
    }
    let activeTheme, processedOptions, fastDelta, themeParameters, annotationThemes, googleFonts;
    if (!stripSymbols && deltaOptions !== void 0 && _ChartOptions.isFastPathDelta(deltaOptions) && baseChartOptions != null) {
      ({ activeTheme, processedOptions, fastDelta } = this.fastSetup(deltaOptions, baseChartOptions));
      themeParameters = baseChartOptions.themeParameters;
      annotationThemes = baseChartOptions.annotationThemes;
    } else {
      _ChartOptions.perfDebug(`ChartOptions.slowSetup()`);
      ({ activeTheme, processedOptions, themeParameters, annotationThemes, googleFonts } = this.slowSetup(
        processedOverrides,
        deltaOptions,
        stripSymbols
      ));
    }
    this.activeTheme = activeTheme;
    this.processedOptions = processedOptions;
    this.fastDelta = fastDelta ?? void 0;
    this.themeParameters = themeParameters;
    this.annotationThemes = annotationThemes;
    this.googleFonts = googleFonts;
    if (apiStartTime !== void 0 && typeof apiStartTime === "number" && !isNaN(apiStartTime)) {
      const endTime = performance.now();
      this.optionsProcessingTime = endTime - apiStartTime;
    }
    Debug.inDevelopmentMode(() => deepFreeze(this));
  }
  static isFastPathDelta(deltaOptions) {
    for (const key of Object.keys(deltaOptions ?? {})) {
      if (!this.FAST_PATH_OPTIONS.has(key)) {
        _ChartOptions.perfDebug("ChartOptions.isFastPathDelta() - slow path required due to presence of: ", key);
        return false;
      }
    }
    _ChartOptions.perfDebug(`ChartOptions.isFastPathDelta() - fast path possible.`);
    return true;
  }
  fastSetup(deltaOptions, baseChartOptions) {
    const { activeTheme, processedOptions: baseOptions } = baseChartOptions;
    const { presetType } = this.optionMetadata;
    if (presetType != null && deltaOptions?.data != null) {
      const presetDef = moduleRegistry_exports.getPresetModule(presetType);
      if (presetDef?.processData) {
        const { series, data } = presetDef.processData(deltaOptions.data);
        deltaOptions = mergeDefaults({ series, data }, deltaOptions);
      }
    }
    this.fastSeriesSetup(deltaOptions, baseOptions);
    const processedOptions = mergeDefaults(deltaOptions, baseOptions);
    _ChartOptions.debug("ChartOptions.fastSetup() - processed options", processedOptions);
    return { activeTheme, processedOptions, fastDelta: deltaOptions };
  }
  fastSeriesSetup(deltaOptions, baseOptions) {
    if (!deltaOptions?.series)
      return;
    if (deltaOptions.series?.every((s, i) => jsonPropertyCompare(s, baseOptions.series?.[i] ?? {}))) {
      delete deltaOptions["series"];
    } else {
      deltaOptions.series = deltaOptions.series.map((s, i) => {
        return merge(s, baseOptions.series?.[i] ?? {});
      });
    }
  }
  slowSetup(processedOverrides, deltaOptions, stripSymbols = false) {
    let options = deepClone(this.userOptions, _ChartOptions.OPTIONS_CLONE_OPTS_FAST);
    if (deltaOptions) {
      options = mergeDefaults(deltaOptions, options);
      if (stripSymbols) {
        this.removeLeftoverSymbols(options);
      }
    }
    const { presetType } = this.optionMetadata;
    if (presetType != null) {
      const presetDef = moduleRegistry_exports.getPresetModule(presetType);
      if (presetDef) {
        const { validate: validatePreset = validate } = presetDef;
        const presetParams = options;
        const presetSubType = options.type;
        const presetTheme = presetSubType != null ? getChartTheme(options.theme).presets[presetSubType] : void 0;
        const { cleared, invalid } = validatePreset(presetParams, presetDef.options, "");
        invalid.forEach((error2) => logger_exports.warn(error2));
        if (hasRequiredInPath(invalid, "")) {
          options = {};
        } else {
          _ChartOptions.debug(">>> AgCharts.createOrUpdate() - applying preset", cleared);
          options = presetDef.create(cleared, presetTheme, () => this.activeTheme);
        }
      }
    }
    this.soloSeriesIntegrity(options);
    if (!enterpriseModule.isEnterprise) {
      removeUsedEnterpriseOptions(options);
    }
    const activeTheme = getChartTheme(options.theme);
    if (presetType != null) {
      activeTheme.templateTheme(options, false);
    }
    this.validateSeriesOptions(options);
    this.chartDef = moduleRegistry_exports.detectChartDefinition(options);
    if (!this.chartDef.placeholder) {
      const { validate: validateChart = validate } = this.chartDef;
      const { cleared, invalid } = validateChart(options, this.chartDef.options, "");
      invalid.forEach((error2) => logger_exports.warn(error2));
      options = cleared;
    }
    this.validateAxesOptions(options);
    this.removeDisabledOptions(options);
    let googleFonts = this.processFonts(activeTheme.params);
    googleFonts = this.processFonts(options, googleFonts);
    this.processSeriesOptions(options);
    const optionsGraph = createOptionsGraph(activeTheme, options);
    const resolvedOptions = optionsGraph.resolve();
    const themeParameters = optionsGraph.resolveParams();
    const annotationThemes = optionsGraph.resolveAnnotationThemes();
    optionsGraph.clear();
    const processedOptions = mergeDefaults(processedOverrides, resolvedOptions);
    removeUnusedEnterpriseOptions(processedOptions);
    if (!enterpriseModule.isEnterprise) {
      removeUsedEnterpriseOptions(processedOptions, true);
    }
    this.validateSeriesOptions(processedOptions);
    this.validateAxesOptions(processedOptions);
    this.validatePluginOptions(processedOptions);
    this.processMiniChartSeriesOptions(processedOptions);
    if (!processedOptions.loadGoogleFonts) {
      googleFonts.clear();
    }
    _ChartOptions.debug(() => ["ChartOptions.slowSetup() - processed options", deepClone(processedOptions)]);
    return { activeTheme, processedOptions, themeParameters, annotationThemes, googleFonts };
  }
  validatePluginOptions(options) {
    for (const pluginDef of moduleRegistry_exports.listModulesByType("plugin" /* Plugin */)) {
      const pluginKey = pluginDef.name;
      if (pluginKey in options && (!pluginDef.chartType || pluginDef.chartType === this.chartDef?.name)) {
        const { cleared, invalid } = validate(options[pluginKey], pluginDef.options, pluginDef.name);
        invalid.forEach((error2) => logger_exports.warn(error2));
        options[pluginKey] = cleared;
      }
    }
  }
  validateSeriesOptions(options) {
    const chartType = this.chartDef?.name;
    const validatedSeriesOptions = [];
    const seriesCount = options.series?.length ?? 0;
    let validSeriesTypes;
    for (let index = 0; index < seriesCount; index++) {
      const keyPath = `series[${index}]`;
      const seriesOptions = options.series[index];
      const seriesDef = moduleRegistry_exports.getSeriesModule(seriesOptions.type);
      if (seriesDef == null) {
        validSeriesTypes ?? (validSeriesTypes = joinFormatted(
          Array.from(moduleRegistry_exports.listModulesByType("series" /* Series */)).filter((def) => !chartType || def.chartType === chartType).map((def) => def.name),
          "or",
          stringFormat
        ));
        logger_exports.warn(
          seriesOptions.type == null ? `Option \`${keyPath}.type\` is required and has not been provided; expecting ${validSeriesTypes}, ignoring.` : `Unknown type \`${seriesOptions.type}\` at \`${keyPath}.type\`; expecting ${validSeriesTypes}, ignoring.`
        );
        continue;
      } else if (chartType && seriesDef.chartType !== chartType) {
        logger_exports.warn(
          `Series type \`${seriesDef.name}\` at \`${keyPath}.type\` is not supported by chart type \`${chartType}\`, ignoring.`
        );
        continue;
      }
      const { validate: validateSeries = validate } = seriesDef;
      const { cleared, invalid } = validateSeries(seriesOptions, seriesDef.options, keyPath);
      invalid.forEach((error2) => logger_exports.warn(error2));
      if (!hasRequiredInPath(invalid, keyPath)) {
        validatedSeriesOptions.push(cleared);
      }
    }
    options.series = validatedSeriesOptions;
  }
  validateAxesOptions(options) {
    if (!("axes" in options) || !options.axes)
      return;
    const chartType = this.chartDef?.name;
    const validatedAxesOptions = [];
    const axesCount = options.axes.length ?? 0;
    let validAxesTypes;
    for (let index = 0; index < axesCount; index++) {
      const keyPath = `axes[${index}]`;
      const axisOptions = options.axes[index];
      const axisDef = moduleRegistry_exports.getAxisModule(axisOptions.type);
      if (axisDef == null) {
        validAxesTypes ?? (validAxesTypes = joinFormatted(
          Array.from(moduleRegistry_exports.listModulesByType("axis" /* Axis */)).filter((def) => def.chartType === chartType).map((def) => def.name),
          "or",
          stringFormat
        ));
        logger_exports.warn(
          `Unknown type \`${axisOptions.type}\` at  \`${keyPath}.type\`; expecting one of ${validAxesTypes}, ignoring all axes options.`
        );
        delete options.axes;
        break;
      } else if (axisDef.chartType !== chartType) {
        logger_exports.warn(
          `Axis type \`${axisDef.name}\` at  \`${keyPath}.type\` is not supported by chart type \`${chartType}\`, ignoring.`
        );
        break;
      }
      const { validate: validateAxis = validate } = axisDef;
      const { cleared, invalid } = validateAxis(axisOptions, axisDef.options, keyPath);
      invalid.forEach((error2) => logger_exports.warn(error2));
      if (!hasRequiredInPath(invalid, keyPath)) {
        validatedAxesOptions.push(cleared);
      }
    }
    options.axes = validatedAxesOptions;
  }
  diffOptions(other) {
    if (this === other)
      return {};
    if (other == null)
      return this.processedOptions;
    return this.fastDelta ?? jsonDiff(other.processedOptions, this.processedOptions, _ChartOptions.JSON_DIFF_OPTS);
  }
  optionsType(options) {
    return options.series?.[0]?.type ?? "line";
  }
  processSeriesOptions(options) {
    const processedSeries = options.series?.map((series) => {
      series.type ?? (series.type = "line");
      const seriesDef = moduleRegistry_exports.getSeriesModule(series.type);
      const visibleDefined = Boolean(seriesDef?.options.visible);
      const seriesOptions = mergeDefaults(
        this.getSeriesGroupingOptions(series),
        series,
        visibleDefined && { visible: true }
      );
      return seriesOptions;
    });
    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);
  }
  processMiniChartSeriesOptions(options) {
    const miniChartSeries = options.navigator?.miniChart?.series;
    if (miniChartSeries == null)
      return;
    options.navigator.miniChart.series = this.setSeriesGroupingOptions(
      miniChartSeries
    );
  }
  getSeriesGroupingOptions(series) {
    const groupable = seriesRegistry.isGroupable(series.type);
    const stackable = seriesRegistry.isStackable(series.type);
    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);
    if (series.grouped && !groupable) {
      logger_exports.warnOnce(`unsupported grouping of series type "${series.type}".`);
    }
    if ((series.stacked || series.stackGroup) && !stackable) {
      logger_exports.warnOnce(`unsupported stacking of series type "${series.type}".`);
    }
    let { grouped, stacked } = series;
    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));
    grouped ?? (grouped = true);
    return {
      stacked: stackable && stacked,
      grouped: groupable && grouped && !(stackable && stacked)
    };
  }
  setSeriesGroupingOptions(allSeries) {
    const seriesGroups = this.getSeriesGrouping(allSeries);
    _ChartOptions.debug("ChartOptions.setSeriesGroupingOptions() - series grouping: ", seriesGroups);
    const groupIdx = {};
    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {
      var _a;
      if (seriesGroup.groupType === "default" /* DEFAULT */) {
        return countMap;
      }
      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);
      countMap[seriesGroup.seriesType] += seriesGroup.groupType === "stack" /* STACK */ ? 1 : seriesGroup.series.length;
      return countMap;
    }, {});
    return seriesGroups.flatMap((seriesGroup) => {
      var _a;
      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);
      switch (seriesGroup.groupType) {
        case "stack" /* STACK */: {
          const groupIndex = groupIdx[seriesGroup.seriesType]++;
          return seriesGroup.series.map(
            (series, stackIndex) => Object.assign(series, {
              seriesGrouping: {
                groupId: seriesGroup.groupId,
                groupIndex,
                groupCount: groupCount2[seriesGroup.seriesType],
                stackIndex,
                stackCount: seriesGroup.series.length
              }
            })
          );
        }
        case "group" /* GROUP */:
          return seriesGroup.series.map(
            (series) => Object.assign(series, {
              seriesGrouping: {
                groupId: seriesGroup.groupId,
                groupIndex: groupIdx[seriesGroup.seriesType]++,
                groupCount: groupCount2[seriesGroup.seriesType],
                stackIndex: 0,
                stackCount: 0
              }
            })
          );
      }
      return seriesGroup.series;
    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);
  }
  getSeriesGroupId(series) {
    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? "stacked" : "grouped"].filter(Boolean).join("-");
  }
  getSeriesGrouping(allSeries) {
    const groupMap = /* @__PURE__ */ new Map();
    return allSeries.reduce((result, series) => {
      const seriesType = series.type;
      if (!series.stacked && !series.grouped) {
        result.push({ groupType: "default" /* DEFAULT */, seriesType, series: [series], groupId: "__default__" });
      } else {
        const groupId = this.getSeriesGroupId(series);
        if (!groupMap.has(groupId)) {
          const groupType = series.stacked ? "stack" /* STACK */ : "group" /* GROUP */;
          const record = { groupType, seriesType, series: [], groupId };
          groupMap.set(groupId, record);
          result.push(record);
        }
        groupMap.get(groupId).series.push(series);
      }
      return result;
    }, []);
  }
  soloSeriesIntegrity(options) {
    if (!isArray(options.series))
      return;
    const allSeries = options.series;
    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {
      const mainSeriesType = this.optionsType(options);
      if (seriesRegistry.isSolo(mainSeriesType)) {
        logger_exports.warn(
          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`
        );
        options.series = allSeries.slice(0, 1);
      } else {
        const { solo, nonSolo } = groupBy(
          allSeries,
          (s) => seriesRegistry.isSolo(s.type) ? "solo" : "nonSolo"
        );
        const rejects = unique(solo.map((s) => s.type)).join(", ");
        logger_exports.warn(`Unable to mix these series types with the lead series type: ${rejects}`);
        options.series = nonSolo;
      }
    }
  }
  static processFontOptions(node, _, __, googleFonts = /* @__PURE__ */ new Set()) {
    if (typeof node === "object" && "fontFamily" in node) {
      if (Array.isArray(node.fontFamily)) {
        const fontFamily = [];
        for (const font3 of node.fontFamily) {
          if (typeof font3 === "object" && "googleFont" in font3) {
            fontFamily.push(font3.googleFont);
            googleFonts?.add(font3.googleFont);
          } else {
            fontFamily.push(font3);
          }
        }
        node.fontFamily = fontFamily.join(", ");
      } else if (typeof node.fontFamily === "object" && "googleFont" in node.fontFamily) {
        node.fontFamily = node.fontFamily.googleFont;
        googleFonts?.add(node.fontFamily);
      }
    }
    return googleFonts;
  }
  processFonts(options, googleFonts = /* @__PURE__ */ new Set()) {
    return jsonWalk(
      options,
      _ChartOptions.processFontOptions,
      /* @__PURE__ */ new Set(["data", "theme"]),
      void 0,
      void 0,
      googleFonts
    );
  }
  static removeDisabledOptionJson(optionsNode) {
    if ("enabled" in optionsNode && optionsNode.enabled === false) {
      Object.keys(optionsNode).forEach((key) => {
        if (key === "enabled")
          return;
        delete optionsNode[key];
      });
    }
  }
  removeDisabledOptions(options) {
    jsonWalk(options, _ChartOptions.removeDisabledOptionJson, /* @__PURE__ */ new Set(["data", "theme", "contextMenu"]));
  }
  static removeLeftoverSymbolsJson(optionsNode) {
    if (!optionsNode || !isObject(optionsNode))
      return;
    for (const key of Object.keys(optionsNode)) {
      const value = optionsNode[key];
      if (isSymbol(value)) {
        delete optionsNode[key];
      }
    }
  }
  removeLeftoverSymbols(options) {
    jsonWalk(options, _ChartOptions.removeLeftoverSymbolsJson, /* @__PURE__ */ new Set(["data"]));
  }
  specialOverridesDefaults(options) {
    if (options.window == null) {
      options.window = getWindow();
    } else {
      setWindow(options.window);
    }
    if (options.document == null) {
      options.document = getDocument();
    } else {
      setDocument(options.document);
    }
    if (options.window == null) {
      throw new Error("AG Charts - unable to resolve global window");
    }
    if (options.document == null) {
      throw new Error("AG Charts - unable to resolve global document");
    }
    return options;
  }
};
_ChartOptions.OPTIONS_CLONE_OPTS_SLOW = {
  shallow: /* @__PURE__ */ new Set(["data", "container"]),
  assign: /* @__PURE__ */ new Set(["context", "theme"])
};
_ChartOptions.OPTIONS_CLONE_OPTS_FAST = {
  shallow: /* @__PURE__ */ new Set(["container"]),
  assign: /* @__PURE__ */ new Set(["data", "context", "theme"])
};
_ChartOptions.JSON_DIFF_OPTS = /* @__PURE__ */ new Set(["data"]);
_ChartOptions.perfDebug = Debug.create(true, "perf");
_ChartOptions.FAST_PATH_OPTIONS = /* @__PURE__ */ new Set(["data", "width", "height", "container"]);
_ChartOptions.debug = Debug.create(true, "opts");
var ChartOptions = _ChartOptions;

// packages/ag-charts-community/src/chart/chartProxy.ts
var debug2 = Debug.create(true, "opts");
var DESTROYED_ERROR = "AG Charts - Chart was destroyed, cannot perform request.";
var _AgChartInstanceProxy = class _AgChartInstanceProxy {
  constructor(chart, factoryApi, licenseManager) {
    this.factoryApi = factoryApi;
    this.licenseManager = licenseManager;
    this.chart = chart;
  }
  async update(options) {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    return debug2.group("AgChartInstance.update()", async () => {
      const apiStartTime = Debug.check("scene:stats", "scene:stats:verbose") ? performance.now() : void 0;
      this.factoryApi.update(options, this, void 0, apiStartTime);
      await this.chart?.waitForUpdate();
    });
  }
  async updateDelta(deltaOptions) {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    return debug2.group("AgChartInstance.updateDelta()", async () => {
      const apiStartTime = Debug.check("scene:stats", "scene:stats:verbose") ? performance.now() : void 0;
      this.factoryApi.updateUserDelta(this, deltaOptions, apiStartTime);
      await this.chart?.waitForUpdate();
    });
  }
  getOptions() {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    const options = deepClone(this.chart.getOptions(), ChartOptions.OPTIONS_CLONE_OPTS_FAST);
    for (const key of Object.keys(options)) {
      if (key.startsWith("_")) {
        delete options[key];
      }
    }
    return options;
  }
  waitForUpdate() {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    return this.chart.waitForUpdate();
  }
  async download(opts) {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    const clone2 = await this.prepareResizedChart(this, this.chart, opts);
    try {
      clone2.chart?.download(opts?.fileName, opts?.fileFormat);
    } finally {
      clone2.destroy();
    }
  }
  async __toSVG(opts) {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    const clone2 = await this.prepareResizedChart(this, this.chart, { width: 600, height: 300, ...opts });
    try {
      return clone2?.chart?.toSVG();
    } finally {
      clone2?.destroy();
    }
  }
  async getImageDataURL(opts) {
    if (!this.chart)
      throw new Error(DESTROYED_ERROR);
    const clone2 = await this.prepareResizedChart(this, this.chart, opts);
    try {
      return clone2.chart.getCanvasDataURL(opts?.fileFormat);
    } finally {
      clone2.destroy();
    }
  }
  getState() {
    return this.factoryApi.caretaker.save(...this.getEnabledOriginators());
  }
  async setState(state) {
    const { chart } = this;
    if (!chart)
      return;
    const originators = this.getEnabledOriginators();
    if (!originators.includes(chart.ctx.legendManager)) {
      await this.setStateOriginators(state, originators);
      return;
    }
    await this.setStateOriginators(
      state,
      originators.filter((originator) => originator !== chart.ctx.zoomManager)
    );
    await this.setStateOriginators(state, [chart.ctx.zoomManager]);
  }
  resetAnimations() {
    this.chart?.resetAnimations();
  }
  skipAnimations() {
    this.chart?.skipAnimations();
  }
  destroy() {
    if (this.releaseChart) {
      this.releaseChart();
      this.releaseChart = void 0;
    } else if (this.chart) {
      this.chart.publicApi = void 0;
      this.chart.destroy();
    }
    this.chart = void 0;
  }
  async prepareResizedChart(proxy, chart, opts = {}) {
    const width2 = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;
    const height2 = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;
    const state = proxy.getState();
    const isEnterprise = moduleRegistry.hasEnterpriseModules();
    const processedOverrides = {
      ...chart.chartOptions.processedOverrides,
      container: document.createElement("div"),
      width: width2,
      height: height2
    };
    if (opts.width != null && opts.height != null) {
      processedOverrides.overrideDevicePixelRatio = 1;
    }
    const userOptions = chart.getOptions();
    if (isEnterprise) {
      processedOverrides.animation = { enabled: false };
      if (this.licenseManager?.isDisplayWatermark()) {
        processedOverrides.foreground = {
          text: this.licenseManager.getWatermarkMessage(),
          image: {
            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,
            width: 170,
            height: 25,
            right: 25,
            bottom: 50,
            opacity: 0.7
          }
        };
      }
    }
    const specialOverrides = { ...chart.chartOptions.specialOverrides };
    const optionsMetadata = { ...chart.chartOptions.optionMetadata };
    const data = await this.chart?.ctx.dataService.getData();
    const cloneProxy = this.factoryApi.create(
      userOptions,
      processedOverrides,
      specialOverrides,
      optionsMetadata,
      data
    );
    await cloneProxy.setState(state);
    cloneProxy.chart?.ctx.zoomManager.updateZoom("chartProxy", chart.ctx.zoomManager.getZoom());
    cloneProxy.chart?.ctx.legendManager.clearData();
    cloneProxy.chart?.ctx.legendManager.update(chart.ctx.legendManager.getData());
    chart.series.forEach((series, index) => {
      cloneProxy.chart.series[index].visible = series.visible;
    });
    const legendPages = [];
    for (const legend of chart.modulesManager.legends()) {
      legendPages.push(legend.legend.pagination?.currentPage ?? 0);
    }
    for (const legend of cloneProxy.chart.modulesManager.legends()) {
      const page = legendPages.shift() ?? 0;
      if (!legend.legend.pagination)
        continue;
      legend.legend.pagination.setPage(page);
    }
    cloneProxy.chart?.update(0 /* FULL */, { forceNodeDataRefresh: true });
    await cloneProxy.waitForUpdate();
    return cloneProxy;
  }
  getEnabledOriginators() {
    if (!this.chart)
      return [];
    const {
      chartOptions: { processedOptions, optionMetadata },
      ctx: { annotationManager, chartTypeOriginator, zoomManager, legendManager }
    } = this.chart;
    const originators = [];
    if ("annotations" in processedOptions && processedOptions.annotations?.enabled) {
      originators.push(annotationManager);
    }
    const isFinancialChart = optionMetadata.presetType === "price-volume";
    if (isFinancialChart) {
      originators.push(chartTypeOriginator);
    }
    if (processedOptions.navigator?.enabled || processedOptions.zoom?.enabled) {
      originators.push(zoomManager);
    }
    if ("legend" in this.chart) {
      originators.push(legendManager);
    }
    return originators;
  }
  async setStateOriginators(state, originators) {
    this.factoryApi.caretaker.restore(state, ...originators);
    this.chart?.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
    await this.chart?.waitForUpdate();
  }
};
_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    oldValue(chart) {
      if (!chart.destroyed) {
        chart.publicApi = void 0;
      }
      _AgChartInstanceProxy.chartInstances.delete(chart);
    },
    newValue(chart) {
      if (!chart)
        return;
      chart.publicApi = this;
      _AgChartInstanceProxy.chartInstances.set(chart, this);
    }
  })
], _AgChartInstanceProxy.prototype, "chart", 2);
var AgChartInstanceProxy = _AgChartInstanceProxy;

// packages/ag-charts-community/src/locale/locale.ts
var Locale = class extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.localeText = void 0;
  }
};
__decorateClass([
  ObserveChanges((target) => {
    target.ctx.localeManager.setLocaleText(target.localeText);
  }),
  Property
], Locale.prototype, "localeText", 2);
__decorateClass([
  ObserveChanges((target) => {
    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);
  }),
  Property
], Locale.prototype, "getLocaleText", 2);

// packages/ag-charts-community/src/locale/localeModule.ts
var LocaleModule = {
  type: "root",
  optionsKey: "locale",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new Locale(ctx)
};

// packages/ag-charts-community/src/chart/background/background.ts
var Background = class extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.rectNode = new Rect();
    this.textNode = new Text();
    this.fill = "white";
    this.node = this.createNode();
    this.node.append([this.rectNode, this.textNode]);
    this.visible = true;
    this.cleanup.register(
      ctx.scene.attachNode(this.node),
      ctx.eventsHub.on("layout:complete", (e) => this.onLayoutComplete(e))
    );
  }
  createNode() {
    return new Group({ name: "background", zIndex: 0 /* CHART_BACKGROUND */ });
  }
  onLayoutComplete(e) {
    const { width: width2, height: height2 } = e.chart;
    this.rectNode.width = width2;
    this.rectNode.height = height2;
  }
};
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "visible")
], Background.prototype, "visible", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("rectNode", "fill")
], Background.prototype, "fill", 2);
__decorateClass([
  Property
], Background.prototype, "image", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("textNode")
], Background.prototype, "text", 2);

// packages/ag-charts-community/src/chart/background/backgroundModule.ts
var BackgroundModule = {
  type: "root",
  optionsKey: "background",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new Background(ctx)
};

// packages/ag-charts-community/src/util/border.ts
var Border = class extends BaseProperties {
  constructor(node) {
    super();
    this.node = node;
    this.enabled = false;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  ActionOnSet({
    changeValue(newValue) {
      if (newValue) {
        this.node.strokeWidth = this.strokeWidth;
      } else {
        this.node.strokeWidth = 0;
      }
    }
  }),
  Property
], Border.prototype, "enabled", 2);
__decorateClass([
  ProxyPropertyOnWrite("node", "stroke"),
  Property
], Border.prototype, "stroke", 2);
__decorateClass([
  ProxyPropertyOnWrite("node", "strokeOpacity"),
  Property
], Border.prototype, "strokeOpacity", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue) {
      if (this.enabled) {
        this.node.strokeWidth = newValue;
      } else {
        this.node.strokeWidth = 0;
      }
    }
  }),
  Property
], Border.prototype, "strokeWidth", 2);

// packages/ag-charts-community/src/chart/gridLayout.ts
function gridLayout({
  orientation,
  bboxes,
  maxHeight,
  maxWidth,
  itemPaddingY = 0,
  itemPaddingX = 0,
  forceResult = false
}) {
  const horizontal = orientation === "horizontal";
  const primary = {
    max: horizontal ? maxWidth : maxHeight,
    fn: horizontal ? (b) => b.width : (b) => b.height,
    padding: horizontal ? itemPaddingX : itemPaddingY
  };
  const secondary = {
    max: horizontal ? maxHeight : maxWidth,
    fn: horizontal ? (b) => b.height : (b) => b.width,
    padding: horizontal ? itemPaddingY : itemPaddingX
  };
  let processedBBoxCount = 0;
  const rawPages = [];
  while (processedBBoxCount < bboxes.length) {
    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);
    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);
    if (!result) {
      return;
    }
    processedBBoxCount += result.processedBBoxCount;
    rawPages.push(result.pageIndices);
  }
  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);
}
function processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {
  const minGuess = 1;
  let startingGuess = estimateStartingGuess(bboxes, primary);
  if (startingGuess < minGuess) {
    if (!forceResult) {
      return;
    }
    startingGuess = minGuess;
  }
  let guess = startingGuess;
  while (guess >= minGuess) {
    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);
    if (pageIndices == null && guess <= minGuess) {
      return;
    }
    if (pageIndices == null) {
      guess--;
      continue;
    }
    if (typeof pageIndices === "number") {
      if (pageIndices <= minGuess) {
        return;
      }
      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;
      guess--;
      continue;
    }
    const processedBBoxCount = pageIndices.length * pageIndices[0].length;
    return { processedBBoxCount, pageIndices };
  }
}
function calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {
  const result = [];
  let sumSecondary = 0;
  let currentMaxSecondary = 0;
  let currentPrimaryIndices = [];
  const maxPrimaryValues = [];
  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {
    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;
    if (primaryValueIdx === 0) {
      sumSecondary += currentMaxSecondary;
      currentMaxSecondary = 0;
      if (currentPrimaryIndices.length > 0) {
        result.push(currentPrimaryIndices);
      }
      currentPrimaryIndices = [];
    }
    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;
    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);
    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);
    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;
    const returnResult = !forceResult || result.length > 0;
    if (currentSecondaryDimension > secondary.max && returnResult) {
      currentPrimaryIndices = [];
      break;
    }
    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);
    if (sumPrimary > primary.max && !forceResult) {
      if (maxPrimaryValues.length < primaryCount) {
        return maxPrimaryValues.length;
      }
      return;
    }
    currentPrimaryIndices.push(bboxIndex + indexOffset);
  }
  if (currentPrimaryIndices.length > 0) {
    result.push(currentPrimaryIndices);
  }
  return result.length > 0 ? result : void 0;
}
function buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {
  let maxPageWidth = 0;
  let maxPageHeight = 0;
  const pages = rawPages.map((indices) => {
    if (orientation === "horizontal") {
      indices = transpose(indices);
    }
    let endIndex = 0;
    const columns = indices.map((colIndices) => {
      const colBBoxes = colIndices.map((bboxIndex) => {
        endIndex = Math.max(bboxIndex, endIndex);
        return bboxes[bboxIndex];
      });
      let columnHeight = 0;
      let columnWidth = 0;
      colBBoxes.forEach((bbox) => {
        columnHeight += bbox.height + itemPaddingY;
        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);
      });
      return {
        indices: colIndices,
        bboxes: colBBoxes,
        columnHeight: Math.ceil(columnHeight),
        columnWidth: Math.ceil(columnWidth)
      };
    });
    let pageWidth = 0;
    let pageHeight = 0;
    columns.forEach((column) => {
      pageWidth += column.columnWidth;
      pageHeight = Math.max(pageHeight, column.columnHeight);
    });
    maxPageWidth = Math.max(pageWidth, maxPageWidth);
    maxPageHeight = Math.max(pageHeight, maxPageHeight);
    return {
      columns,
      startIndex: indices[0][0],
      endIndex,
      pageWidth,
      pageHeight
    };
  });
  return { pages, maxPageWidth, maxPageHeight };
}
function transpose(data) {
  const result = [];
  for (const _ of data[0]) {
    result.push([]);
  }
  data.forEach((innerData, dataIdx) => {
    innerData.forEach((item, itemIdx) => {
      result[itemIdx][dataIdx] = item;
    });
  });
  return result;
}
function estimateStartingGuess(bboxes, primary) {
  const n = bboxes.length;
  let primarySum = 0;
  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {
    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;
    if (primarySum > primary.max) {
      const ratio2 = n / bboxIndex;
      if (ratio2 < 2) {
        return Math.ceil(n / 2);
      }
      return bboxIndex;
    }
  }
  return n;
}

// packages/ag-charts-community/src/chart/pagination/pagination.ts
var PaginationLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12 /* SMALL */;
    this.fontFamily = "Verdana, sans-serif";
  }
};
__decorateClass([
  Property
], PaginationLabel.prototype, "color", 2);
__decorateClass([
  Property
], PaginationLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], PaginationLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], PaginationLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], PaginationLabel.prototype, "fontFamily", 2);
var PaginationMarkerStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.size = 15;
    this.fill = void 0;
    this.fillOpacity = void 0;
    this.stroke = void 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
  }
};
__decorateClass([
  Property
], PaginationMarkerStyle.prototype, "size", 2);
__decorateClass([
  Property
], PaginationMarkerStyle.prototype, "fill", 2);
__decorateClass([
  Property
], PaginationMarkerStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], PaginationMarkerStyle.prototype, "stroke", 2);
__decorateClass([
  Property
], PaginationMarkerStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], PaginationMarkerStyle.prototype, "strokeOpacity", 2);
var PaginationMarker = class extends BaseProperties {
  constructor(parent) {
    super();
    this.parent = parent;
    this.shape = "triangle";
    this.size = 15;
    this.padding = 8;
  }
};
__decorateClass([
  ActionOnSet({
    changeValue() {
      if (this.parent.marker === this) {
        this.parent.onMarkerShapeChange();
      }
    }
  })
], PaginationMarker.prototype, "shape", 2);
__decorateClass([
  Property
], PaginationMarker.prototype, "size", 2);
__decorateClass([
  Property
], PaginationMarker.prototype, "padding", 2);
var Pagination = class extends BaseProperties {
  constructor(chartUpdateCallback, pageUpdateCallback) {
    super();
    this.chartUpdateCallback = chartUpdateCallback;
    this.pageUpdateCallback = pageUpdateCallback;
    this.id = createId(this);
    this.marker = new PaginationMarker(this);
    this.activeStyle = new PaginationMarkerStyle();
    this.inactiveStyle = new PaginationMarkerStyle();
    this.highlightStyle = new PaginationMarkerStyle();
    this.label = new PaginationLabel();
    this.group = new TranslatableGroup({ name: "pagination" });
    this.labelNode = new Text();
    this.totalPages = 0;
    this.currentPage = 0;
    this.translationX = 0;
    this.translationY = 0;
    this.nextButtonDisabled = false;
    this.previousButtonDisabled = false;
    this._visible = true;
    this._enabled = true;
    this._orientation = "vertical";
    this.nextButton = new Marker();
    this.previousButton = new Marker();
    this.labelNode.setProperties({
      textBaseline: "middle",
      fontSize: 12 /* SMALL */,
      fontFamily: "Verdana, sans-serif",
      fill: "black",
      y: 1
    });
    this.group.append([this.nextButton, this.previousButton, this.labelNode]);
    this.update();
    this.updateMarkers();
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  set enabled(value) {
    this._enabled = value;
    this.updateGroupVisibility();
  }
  get enabled() {
    return this._enabled;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible;
  }
  set orientation(value) {
    this._orientation = value;
    switch (value) {
      case "horizontal": {
        this.previousButton.rotation = -Math.PI / 2;
        this.nextButton.rotation = Math.PI / 2;
        break;
      }
      case "vertical":
      default: {
        this.previousButton.rotation = 0;
        this.nextButton.rotation = Math.PI;
      }
    }
  }
  get orientation() {
    return this._orientation;
  }
  update() {
    this.updateLabel();
    this.updatePositions();
    this.enableOrDisableButtons();
  }
  updatePositions() {
    this.group.translationX = this.translationX;
    this.group.translationY = this.translationY;
    this.updateLabelPosition();
    this.updateNextButtonPosition();
  }
  updateLabelPosition() {
    const { size: markerSize, padding: markerPadding } = this.marker;
    this.nextButton.size = markerSize;
    this.previousButton.size = markerSize;
    this.labelNode.x = markerSize / 2 + markerPadding;
  }
  updateNextButtonPosition() {
    const labelBBox = this.labelNode.getBBox();
    this.nextButton.translationX = labelBBox.width + (this.marker.size / 2 + this.marker.padding) * 2;
  }
  updateLabel() {
    const {
      currentPage,
      totalPages: pages,
      labelNode,
      label: { color: color2, fontStyle, fontWeight, fontSize, fontFamily }
    } = this;
    labelNode.text = `${currentPage + 1} / ${pages}`;
    labelNode.fill = color2;
    labelNode.fontStyle = fontStyle;
    labelNode.fontWeight = fontWeight;
    labelNode.fontSize = fontSize;
    labelNode.fontFamily = fontFamily;
  }
  updateMarkers() {
    const {
      nextButton,
      previousButton,
      nextButtonDisabled,
      previousButtonDisabled,
      activeStyle,
      inactiveStyle,
      highlightStyle,
      highlightActive
    } = this;
    const buttonStyle = (button, disabled) => {
      if (disabled) {
        return inactiveStyle;
      } else if (button === highlightActive) {
        return highlightStyle;
      }
      return activeStyle;
    };
    this.updateMarker(nextButton, buttonStyle("next", nextButtonDisabled));
    this.updateMarker(previousButton, buttonStyle("previous", previousButtonDisabled));
  }
  updateMarker(marker, style2) {
    const { shape, size } = this.marker;
    marker.shape = shape;
    marker.size = size;
    marker.fill = style2.fill;
    marker.fillOpacity = style2.fillOpacity ?? 1;
    marker.stroke = style2.stroke;
    marker.strokeWidth = style2.strokeWidth;
    marker.strokeOpacity = style2.strokeOpacity;
  }
  enableOrDisableButtons() {
    const { currentPage, totalPages } = this;
    const zeroPagesToDisplay = totalPages === 0;
    const onLastPage = currentPage === totalPages - 1;
    const onFirstPage = currentPage === 0;
    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;
  }
  setPage(pageNumber) {
    pageNumber = clamp(0, pageNumber, Math.max(0, this.totalPages - 1));
    if (this.currentPage !== pageNumber) {
      this.currentPage = pageNumber;
      this.onPaginationChanged();
    }
  }
  getCursor(node) {
    return { previous: this.previousButtonDisabled, next: this.nextButtonDisabled }[node] ? void 0 : "pointer";
  }
  onClick(event, node) {
    event.preventDefault();
    if (node === "next" && !this.nextButtonDisabled) {
      this.incrementPage();
      this.onPaginationChanged();
    } else if (node === "previous" && !this.previousButtonDisabled) {
      this.decrementPage();
      this.onPaginationChanged();
    }
  }
  onMouseHover(node) {
    this.highlightActive = node;
    this.updateMarkers();
    this.chartUpdateCallback(7 /* SCENE_RENDER */);
  }
  onPaginationChanged() {
    this.pageUpdateCallback(this.currentPage);
  }
  incrementPage() {
    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
  }
  decrementPage() {
    this.currentPage = Math.max(this.currentPage - 1, 0);
  }
  onMarkerShapeChange() {
    this.updatePositions();
    this.updateMarkers();
    this.chartUpdateCallback(7 /* SCENE_RENDER */);
  }
  attachPagination(node) {
    node.append(this.group);
  }
  getBBox() {
    return this.group.getBBox();
  }
  computeCSSBounds() {
    const prev = Transformable.toCanvas(this.previousButton);
    const next = Transformable.toCanvas(this.nextButton);
    return { prev, next };
  }
};
Pagination.className = "Pagination";
__decorateClass([
  Property
], Pagination.prototype, "marker", 2);
__decorateClass([
  Property
], Pagination.prototype, "activeStyle", 2);
__decorateClass([
  Property
], Pagination.prototype, "inactiveStyle", 2);
__decorateClass([
  Property
], Pagination.prototype, "highlightStyle", 2);
__decorateClass([
  Property
], Pagination.prototype, "label", 2);

// packages/ag-charts-community/src/chart/legend/legendDOMProxy.ts
var LegendDOMProxy = class {
  constructor(ctx, idPrefix) {
    this.dirty = true;
    this.itemList = ctx.proxyInteractionService.createProxyContainer({
      type: "list",
      domManagerId: `${idPrefix}-toolbar`,
      classList: ["ag-charts-proxy-legend-toolbar"],
      ariaLabel: { id: "ariaLabelLegend" }
    });
    this.paginationGroup = ctx.proxyInteractionService.createProxyContainer({
      type: "group",
      domManagerId: `${idPrefix}-pagination`,
      classList: ["ag-charts-proxy-legend-pagination"],
      ariaLabel: { id: "ariaLabelLegendPagination" }
    });
    this.itemDescription = createElement("p");
    this.itemDescription.style.display = "none";
    this.itemDescription.id = createElementId();
    this.itemDescription.textContent = this.getItemAriaDescription(ctx.localeManager);
    this.itemList.getElement().append(this.itemDescription);
  }
  initLegendList(params) {
    if (!this.dirty)
      return;
    const { ctx, itemSelection, datumReader, itemListener } = params;
    const lm = ctx.localeManager;
    const count = itemSelection.length;
    itemSelection.each((markerLabel, datum, index) => {
      markerLabel.proxyButton?.destroy();
      markerLabel.proxyButton = ctx.proxyInteractionService.createProxyElement({
        type: "listswitch",
        textContent: this.getItemAriaText(lm, datumReader.getItemLabel(datum), index, count),
        ariaChecked: !!markerLabel.datum.enabled,
        ariaDescribedBy: this.itemDescription.id,
        parent: this.itemList
      });
      const button = markerLabel.proxyButton;
      button.addListener("click", (ev) => itemListener.onClick(ev.sourceEvent, markerLabel.datum, button));
      button.addListener("dblclick", (ev) => itemListener.onDoubleClick(ev.sourceEvent, markerLabel.datum));
      button.addListener("mouseenter", (ev) => itemListener.onHover(ev.sourceEvent, markerLabel));
      button.addListener("mouseleave", () => itemListener.onLeave());
      button.addListener("contextmenu", (ev) => itemListener.onContextClick(ev, markerLabel));
      button.addListener("blur", () => itemListener.onLeave());
      button.addListener("focus", (ev) => itemListener.onHover(ev.sourceEvent, markerLabel));
      button.addListener("drag-start", () => {
      });
    });
    this.dirty = false;
  }
  update(params) {
    if (params.visible) {
      this.initLegendList(params);
      this.updateItemProxyButtons(params);
      this.updatePaginationProxyButtons(params, true);
    }
    this.updateVisibility(params.visible);
  }
  updateVisibility(visible) {
    this.itemList.setHidden(!visible);
    this.paginationGroup.setHidden(!visible);
  }
  updateItemProxyButtons({ itemSelection, group, pagination, interactive }) {
    const groupBBox = Transformable.toCanvas(group);
    this.itemList.setBounds(groupBBox);
    const maxHeight = Math.max(...itemSelection.nodes().map((l) => l.getBBox().height));
    itemSelection.each((l, _datum) => {
      if (l.proxyButton) {
        const visible = l.pageIndex === pagination.currentPage;
        const { x, y, height: height2, width: width2 } = Transformable.toCanvas(l);
        const margin = (maxHeight - height2) / 2;
        const bbox = { x: x - groupBBox.x, y: y - margin - groupBBox.y, height: maxHeight, width: width2 };
        const enabled = interactive && visible;
        l.proxyButton.setCursor("pointer");
        l.proxyButton.setEnabled(enabled);
        l.proxyButton.setPointerEvents(enabled ? void 0 : "none");
        l.proxyButton.setBounds(bbox);
      }
    });
  }
  updatePaginationProxyButtons(params, init) {
    const { pagination } = params;
    this.paginationGroup.setHidden(!pagination.visible);
    if (init && "ctx" in params) {
      const { ctx, oldPages, newPages } = params;
      const oldNeedsButtons = (oldPages?.length ?? newPages.length) > 1;
      const newNeedsButtons = newPages.length > 1;
      if (oldNeedsButtons !== newNeedsButtons) {
        if (newNeedsButtons) {
          this.prevButton = ctx.proxyInteractionService.createProxyElement({
            type: "button",
            textContent: { id: "ariaLabelLegendPagePrevious" },
            tabIndex: 0,
            parent: this.paginationGroup
          });
          this.prevButton.addListener("click", (ev) => this.onPageButton(params, ev, "previous"));
          this.prevButton.addListener("mouseenter", () => pagination.onMouseHover("previous"));
          this.prevButton.addListener("mouseleave", () => pagination.onMouseHover(void 0));
          this.nextButton ?? (this.nextButton = ctx.proxyInteractionService.createProxyElement({
            type: "button",
            textContent: { id: "ariaLabelLegendPageNext" },
            tabIndex: 0,
            parent: this.paginationGroup
          }));
          this.nextButton.addListener("click", (ev) => this.onPageButton(params, ev, "next"));
          this.nextButton.addListener("mouseenter", () => pagination.onMouseHover("next"));
          this.nextButton.addListener("mouseleave", () => pagination.onMouseHover(void 0));
        } else {
          this.nextButton?.destroy();
          this.prevButton?.destroy();
          this.nextButton = void 0;
          this.prevButton = void 0;
        }
      }
      this.paginationGroup.setAriaHidden(newNeedsButtons ? void 0 : true);
    }
    if (this.prevButton && this.nextButton) {
      const { prev, next } = pagination.computeCSSBounds();
      const group = BBox.merge([prev, next]);
      prev.x -= group.x;
      prev.y -= group.y;
      next.x -= group.x;
      next.y -= group.y;
      this.paginationGroup.setBounds(group);
      this.prevButton.setBounds(prev);
      this.nextButton.setBounds(next);
      this.prevButton.setEnabled(pagination.currentPage !== 0);
      this.nextButton.setEnabled(pagination.currentPage !== pagination.totalPages - 1);
      this.nextButton.setCursor(pagination.getCursor("next"));
      this.prevButton.setCursor(pagination.getCursor("previous"));
    }
  }
  onPageButton(params, ev, node) {
    params.pagination.onClick(ev.sourceEvent, node);
    this.updatePaginationProxyButtons(params, false);
  }
  onDataUpdate(oldData, newData) {
    this.dirty = oldData.length !== newData.length || oldData.some((_v, index, _a) => {
      const [newValue, oldValue] = [newData[index], oldData[index]];
      return newValue.id !== oldValue.id;
    });
  }
  onLocaleChanged(localeManager, itemSelection, datumReader) {
    const count = itemSelection.length;
    itemSelection.each(({ proxyButton }, datum, index) => {
      const button = proxyButton?.getElement();
      if (button != null) {
        const label = datumReader.getItemLabel(datum);
        button.textContent = this.getItemAriaText(localeManager, label, index, count);
      }
    });
    this.itemDescription.textContent = this.getItemAriaDescription(localeManager);
  }
  onPageChange(params) {
    this.updateItemProxyButtons(params);
    this.updatePaginationProxyButtons(params, false);
  }
  getItemAriaText(localeManager, label, index, count) {
    if (index >= 0 && label) {
      index++;
      return localeManager.t("ariaLabelLegendItem", { label, index, count });
    }
    return localeManager.t("ariaLabelLegendItemUnknown");
  }
  getItemAriaDescription(localeManager) {
    return localeManager.t("ariaDescriptionLegendItem");
  }
};

// packages/ag-charts-community/src/chart/legend/legendEvent.ts
function makeLegendItemEvent(type, { itemId, seriesId, label: { text: text2 } }, event) {
  const result = {
    defaultPrevented: false,
    apiEvent: {
      type,
      itemId,
      seriesId,
      text: text2,
      event,
      preventDefault: () => result.defaultPrevented = true
    }
  };
  return result;
}

// packages/ag-charts-community/src/chart/legend/legendMarkerLabel.ts
var LegendMarkerLabel = class extends TranslatableGroup {
  constructor() {
    super({ name: "markerLabelGroup" });
    this.symbolsGroup = this.appendChild(
      new Group({
        name: "legend-markerLabel-symbols"
      })
    );
    this.label = this.appendChild(new Text());
    this.enabled = true;
    this.pageIndex = NaN;
    this.spacing = 0;
    this.length = 0;
    this.isCustomMarker = false;
    this.marker = this.symbolsGroup.appendChild(new Marker({ zIndex: 1 }));
    this.line = this.symbolsGroup.appendChild(new Line({ zIndex: 0 }));
    const { label, line, symbolsGroup } = this;
    line.visible = false;
    symbolsGroup.renderToOffscreenCanvas = true;
    symbolsGroup.optimizeForInfrequentRedraws = true;
    label.textBaseline = "middle";
    label.fontSize = 12;
    label.fontFamily = "Verdana, sans-serif";
    label.fill = "black";
    label.y = 1;
  }
  destroy() {
    super.destroy();
    this.proxyButton?.destroy();
  }
  setEnabled(enabled) {
    this.enabled = enabled;
    this.refreshVisibilities();
  }
  getTextMeasureBBox() {
    this.layout();
    return BBox.merge([this.symbolsGroup.getBBox(), this.label.getTextMeasureBBox()]);
  }
  refreshVisibilities() {
    const opacity = this.enabled ? 1 : 0.5;
    this.label.opacity = opacity;
    this.opacity = opacity;
  }
  layout() {
    const { marker, line, length: length2, isCustomMarker } = this;
    let centerTranslateX = 0;
    let centerTranslateY = 0;
    if (marker.visible) {
      const { size } = marker;
      const anchor = Marker.anchor(marker.shape);
      centerTranslateX = (anchor.x - 0.5) * size + length2 / 2;
      centerTranslateY = (anchor.y - 0.5) * size;
      if (isCustomMarker) {
        marker.x = 0;
        marker.y = 0;
        marker.translationX = centerTranslateX;
        marker.translationY = centerTranslateY;
      } else {
        marker.x = centerTranslateX;
        marker.y = centerTranslateY;
        marker.translationX = 0;
        marker.translationY = 0;
      }
    }
    if (line.visible) {
      line.x1 = 0;
      line.x2 = length2;
      line.y1 = 0;
      line.y2 = 0;
    }
  }
  preRender(renderCtx) {
    const out = super.preRender(renderCtx);
    this.layout();
    return out;
  }
  layoutLabel() {
    const { length: length2, spacing } = this;
    this.label.x = length2 + spacing;
  }
  computeBBox() {
    this.layout();
    return super.computeBBox();
  }
};
LegendMarkerLabel.className = "MarkerLabel";
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "text", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontStyle", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontWeight", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontSize", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontFamily", 2);
__decorateClass([
  ProxyPropertyOnWrite("label", "fill")
], LegendMarkerLabel.prototype, "color", 2);
__decorateClass([
  ObserveChanges((target) => target.layoutLabel())
], LegendMarkerLabel.prototype, "spacing", 2);
__decorateClass([
  ObserveChanges((target) => target.layoutLabel())
], LegendMarkerLabel.prototype, "length", 2);
__decorateClass([
  SceneChangeDetection()
], LegendMarkerLabel.prototype, "isCustomMarker", 2);

// packages/ag-charts-community/src/chart/legend/legendUtil.ts
function expandLegendPosition(position) {
  const {
    placement = "bottom",
    floating = false,
    xOffset = 0,
    yOffset = 0
  } = typeof position === "string" ? { placement: position, floating: false } : position;
  return { placement, floating, xOffset, yOffset };
}

// packages/ag-charts-community/src/chart/legend/legend.ts
var LegendLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.maxLength = void 0;
    this.color = "black";
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12 /* SMALL */;
    this.fontFamily = "Verdana, sans-serif";
  }
};
__decorateClass([
  Property
], LegendLabel.prototype, "maxLength", 2);
__decorateClass([
  Property
], LegendLabel.prototype, "color", 2);
__decorateClass([
  Property
], LegendLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], LegendLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], LegendLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], LegendLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], LegendLabel.prototype, "formatter", 2);
var LegendMarker = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.shape = void 0;
    this.size = 15;
    this.padding = 8;
  }
};
__decorateClass([
  Property
], LegendMarker.prototype, "shape", 2);
__decorateClass([
  Property
], LegendMarker.prototype, "size", 2);
__decorateClass([
  Property
], LegendMarker.prototype, "padding", 2);
__decorateClass([
  Property
], LegendMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LegendMarker.prototype, "enabled", 2);
var LegendLine = class extends BaseProperties {
};
__decorateClass([
  Property
], LegendLine.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LegendLine.prototype, "length", 2);
var LegendItem = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.paddingX = 16;
    this.paddingY = 8;
    this.showSeriesStroke = false;
    this.marker = new LegendMarker();
    this.label = new LegendLabel();
    this.line = new LegendLine();
  }
};
__decorateClass([
  Property
], LegendItem.prototype, "maxWidth", 2);
__decorateClass([
  Property
], LegendItem.prototype, "paddingX", 2);
__decorateClass([
  Property
], LegendItem.prototype, "paddingY", 2);
__decorateClass([
  Property
], LegendItem.prototype, "showSeriesStroke", 2);
__decorateClass([
  Property
], LegendItem.prototype, "marker", 2);
__decorateClass([
  Property
], LegendItem.prototype, "label", 2);
__decorateClass([
  Property
], LegendItem.prototype, "line", 2);
var LegendListeners = class extends BaseProperties {
};
__decorateClass([
  Property
], LegendListeners.prototype, "legendItemClick", 2);
__decorateClass([
  Property
], LegendListeners.prototype, "legendItemDoubleClick", 2);
var fillGradientDefaults2 = {
  type: "gradient",
  bounds: "item",
  gradient: "linear",
  colorStops: [{ color: "black" }],
  rotation: 0,
  reverse: false
};
var fillPatternDefaults2 = {
  type: "pattern",
  pattern: "forward-slanted-lines",
  width: 8,
  height: 8,
  padding: 1,
  fill: "black",
  fillOpacity: 1,
  backgroundFill: "white",
  backgroundFillOpacity: 1,
  stroke: "black",
  strokeOpacity: 1,
  strokeWidth: 1,
  rotation: 0,
  scale: 1
};
var fillImageDefaults2 = {
  type: "image",
  backgroundFill: "black",
  backgroundFillOpacity: 1,
  rotation: 0,
  repeat: "no-repeat",
  fit: "contain",
  width: 8,
  height: 8
};
var Legend = class extends BaseProperties {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId(this);
    this.group = new TranslatableGroup({ name: "legend", zIndex: 16 /* LEGEND */ });
    this.itemSelection = Selection.select(
      this.group,
      LegendMarkerLabel
    );
    this.containerNode = this.group.appendChild(new Rect({ name: "legend-container" }));
    this.oldSize = [0, 0];
    this.pages = [];
    this.maxPageSize = [0, 0];
    /** Item index to track on re-pagination, so current page updates appropriately. */
    this.paginationTrackingIndex = 0;
    this.truncatedItems = /* @__PURE__ */ new Set();
    this._data = [];
    this.toggleSeries = true;
    this.item = new LegendItem();
    this.listeners = new LegendListeners();
    this.enabled = true;
    this.position = "bottom";
    this.border = new Border(this.containerNode);
    this.cornerRadius = 0;
    this.fillOpacity = 1;
    this.padding = 4;
    this.spacing = 20;
    this.cleanup = new CleanupRegistry();
    this.size = [0, 0];
    this._visible = true;
    this.pagination = new Pagination(
      (type) => ctx.updateService.update(type),
      (page) => this.updatePageNumber(page)
    );
    this.pagination.attachPagination(this.group);
    const { items } = ctx.contextMenuRegistry.builtins;
    items["toggle-series-visibility"].action = (params) => this.contextToggleVisibility(params);
    items["toggle-other-series"].action = (params) => this.contextToggleOtherSeries(params);
    this.cleanup.register(
      ctx.eventsHub.on("legend:change", this.onLegendDataChange.bind(this)),
      ctx.layoutManager.registerElement(1 /* Legend */, (e) => this.positionLegend(e)),
      ctx.eventsHub.on("locale:change", () => this.onLocaleChanged()),
      () => delete items["toggle-series-visibility"].action,
      () => delete items["toggle-other-series"].action,
      () => this.group.remove()
    );
    this.domProxy = new LegendDOMProxy(this.ctx, this.id);
    this.ctx.historyManager.addMementoOriginator(ctx.legendManager);
  }
  set data(value) {
    if (objectsEqual(value, this._data))
      return;
    this.domProxy.onDataUpdate(this._data, value);
    this._data = value;
    this.updateGroupVisibility();
  }
  get data() {
    return this._data;
  }
  onLegendDataChange({ legendData = [] }) {
    if (!this.enabled)
      return;
    this.data = legendData.filter((datum) => !datum.hideInLegend);
  }
  destroy() {
    this.ctx.domManager.removeChild("canvas-overlay", `${this.id}-toolbar`);
    this.ctx.domManager.removeChild("canvas-overlay", `${this.id}-pagination`);
    this.cleanup.flush();
    this.itemSelection.clear();
  }
  getOrientation() {
    return this.orientation ?? "horizontal";
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible && this.data.length > 0;
  }
  attachLegend(scene) {
    scene.appendChild(this.group);
  }
  getItemLabel(datum) {
    const { formatter: formatter2 } = this.item.label;
    if (formatter2) {
      const seriesDatum = datum.datum;
      return this.cachedCallWithContext(formatter2, {
        itemId: datum.itemId,
        value: datum.label.text,
        seriesId: datum.seriesId,
        ...seriesDatum && { datum: seriesDatum }
      });
    }
    return datum.label.text;
  }
  /**
   * The method is given the desired size of the legend, which only serves as a hint.
   * The vertically oriented legend will take as much horizontal space as needed, but will
   * respect the height constraints, and the horizontal legend will take as much vertical
   * space as needed in an attempt not to exceed the given width.
   * After the layout is done, the {@link size} will contain the actual size of the legend.
   * If the actual size is not the same as the previous actual size, the legend will fire
   * the 'layoutChange' event to communicate that another layout is needed, and the above
   * process should be repeated.
   * @param width
   * @param height
   */
  calcLayout(width2, height2) {
    const {
      paddingX,
      paddingY,
      label,
      maxWidth,
      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }
    } = this.item;
    const data = [...this.data];
    if (this.reverseOrder) {
      data.reverse();
    }
    this.itemSelection.update(data);
    const bboxes = [];
    const measurer3 = CachedTextMeasurerPool.getMeasurer({ font: label });
    const itemMaxWidthPercentage = 0.8;
    const maxItemWidth = maxWidth ?? width2 * itemMaxWidthPercentage;
    const { markerWidth, anyLineEnabled } = this.calculateMarkerWidth();
    this.itemSelection.each((markerLabel, datum) => {
      markerLabel.fontStyle = fontStyle;
      markerLabel.fontWeight = fontWeight;
      markerLabel.fontSize = fontSize;
      markerLabel.fontFamily = fontFamily;
      const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, markerWidth, anyLineEnabled);
      const id = datum.itemId ?? datum.id;
      const labelText = this.getItemLabel(datum);
      const text2 = (labelText ?? "<unknown>").replace(/\r?\n/g, " ");
      markerLabel.text = this.truncate(text2, maxLength, maxItemWidth, paddedSymbolWidth, measurer3, id);
      bboxes.push(markerLabel.getTextMeasureBBox());
    });
    width2 = Math.max(1, width2);
    height2 = Math.max(1, height2);
    if (!isFinite(width2)) {
      return {};
    }
    [width2, height2] = this.updateContainer(width2, height2);
    const size = this.size;
    const oldSize = this.oldSize;
    size[0] = width2;
    size[1] = height2;
    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      oldSize[0] = size[0];
      oldSize[1] = size[1];
    }
    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width2, height2);
    const oldPages = this.pages;
    this.pages = pages;
    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];
    const pageNumber = this.pagination.currentPage;
    const page = this.pages[pageNumber];
    if (this.pages.length < 1 || !page) {
      this.visible = false;
      return { oldPages };
    }
    this.visible = true;
    this.updatePositions(pageNumber);
    this.update();
    return { oldPages };
  }
  isCustomMarker(markerEnabled, shape) {
    return markerEnabled && shape !== void 0 && typeof shape !== "string";
  }
  calcSymbolsEnabled(symbol) {
    const { showSeriesStroke, marker } = this.item;
    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);
    const lineEnabled = !!(symbol.line && showSeriesStroke);
    const isCustomMarker = this.isCustomMarker(markerEnabled, symbol.marker.shape);
    return { markerEnabled, lineEnabled, isCustomMarker };
  }
  calcSymbolsLengths(symbol, markerEnabled, lineEnabled) {
    const { marker, line } = this.item;
    let customMarkerSize;
    const { shape } = symbol.marker;
    if (this.isCustomMarker(markerEnabled, shape)) {
      const tmpShape = new Marker();
      tmpShape.shape = shape;
      tmpShape.updatePath();
      const bbox = tmpShape.getBBox();
      customMarkerSize = Math.max(bbox.width, bbox.height);
    }
    const markerLength = markerEnabled ? marker.size : 0;
    const lineLength = lineEnabled ? line.length ?? 25 : 0;
    return { markerLength, lineLength, customMarkerSize };
  }
  calculateMarkerWidth() {
    let markerWidth = 0;
    let anyLineEnabled = false;
    this.itemSelection.each((_, datum) => {
      const { symbol } = datum;
      const { lineEnabled, markerEnabled } = this.calcSymbolsEnabled(symbol);
      const {
        markerLength,
        lineLength,
        customMarkerSize = -Infinity
      } = this.calcSymbolsLengths(symbol, markerEnabled, lineEnabled);
      markerWidth = Math.max(markerWidth, lineLength, customMarkerSize, markerLength);
      anyLineEnabled || (anyLineEnabled = lineEnabled);
    });
    return { markerWidth, anyLineEnabled };
  }
  updateMarkerLabel(markerLabel, datum, markerWidth, anyLineEnabled) {
    const { marker: itemMarker, paddingX } = this.item;
    const { symbol } = datum;
    let paddedSymbolWidth = paddingX;
    const { markerEnabled, isCustomMarker } = this.calcSymbolsEnabled(symbol);
    const spacing = itemMarker.padding;
    if (markerEnabled || anyLineEnabled) {
      paddedSymbolWidth += spacing + markerWidth;
    }
    const { marker, line } = markerLabel;
    marker.visible = markerEnabled;
    if (marker.visible) {
      marker.shape = itemMarker.shape ?? symbol.marker.shape ?? "square";
      marker.size = itemMarker.size;
      applyShapeStyle(marker, this.getMarkerStyles(symbol));
    }
    line.visible = anyLineEnabled;
    if (line.visible) {
      applyShapeStyle(line, this.getLineStyles(symbol));
    }
    markerLabel.length = markerWidth;
    markerLabel.spacing = spacing;
    markerLabel.isCustomMarker = isCustomMarker;
    return paddedSymbolWidth;
  }
  updateContainer(width2, height2) {
    const containerStyles = this.getContainerStyles();
    this.containerNode.width = 0;
    this.containerNode.height = 0;
    applyShapeStyle(this.containerNode, containerStyles);
    this.containerNode.cornerRadius = containerStyles.cornerRadius;
    width2 -= containerStyles.strokeWidth * 2 + containerStyles.padding.left + containerStyles.padding.right;
    height2 -= containerStyles.strokeWidth * 2 + containerStyles.padding.top + containerStyles.padding.bottom;
    return [width2, height2];
  }
  truncate(text2, maxCharLength, maxItemWidth, paddedMarkerWidth, measurer3, id) {
    let addEllipsis = false;
    if (text2.length > maxCharLength) {
      text2 = text2.substring(0, maxCharLength);
      addEllipsis = true;
    }
    const result = TextWrapper.truncateLine(text2, measurer3, maxItemWidth - paddedMarkerWidth, addEllipsis);
    if (result.endsWith(TextUtils.EllipsisChar)) {
      this.truncatedItems.add(id);
    } else {
      this.truncatedItems.delete(id);
    }
    return result;
  }
  updatePagination(bboxes, width2, height2) {
    const orientation = this.getOrientation();
    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);
    this.pagination.orientation = orientation;
    this.pagination.translationX = 0;
    this.pagination.translationY = 0;
    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(
      bboxes,
      width2,
      height2
    );
    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);
    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);
    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
    const paginationComponentPadding = 8;
    const legendItemsWidth = maxPageWidth - itemPaddingX;
    const legendItemsHeight = maxPageHeight - itemPaddingY;
    let paginationX = 0;
    let paginationY = -paginationBBox.y - this.item.marker.size / 2;
    if (paginationVertical) {
      paginationY += legendItemsHeight + paginationComponentPadding;
    } else {
      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;
      paginationY += (legendItemsHeight - paginationBBox.height) / 2;
    }
    this.pagination.translationX = paginationX;
    this.pagination.translationY = paginationY;
    this.pagination.update();
    this.pagination.updateMarkers();
    let pageIndex = 0;
    this.itemSelection.each((markerLabel, _, nodeIndex) => {
      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {
        pageIndex++;
      }
      markerLabel.pageIndex = pageIndex;
    });
    return {
      maxPageHeight,
      maxPageWidth,
      pages
    };
  }
  calculatePagination(bboxes, width2, height2) {
    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
    const vertPositions = [
      "left",
      "left-top",
      "left-bottom",
      "right",
      "right-top",
      "right-bottom"
    ];
    const { placement } = expandLegendPosition(this.position);
    const orientation = this.getOrientation();
    const paginationVertical = vertPositions.includes(placement);
    let paginationBBox = this.pagination.getBBox();
    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);
    let pages = [];
    let maxPageWidth = 0;
    let maxPageHeight = 0;
    let count = 0;
    const stableOutput = (bbox) => {
      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;
    };
    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;
    do {
      if (count++ > 10) {
        logger_exports.warn("unable to find stable legend layout.");
        break;
      }
      paginationBBox = lastPassPaginationBBox;
      const maxWidth = width2 - (paginationVertical ? 0 : paginationBBox.width);
      const maxHeight = height2 - (paginationVertical ? paginationBBox.height : 0);
      const layout = gridLayout({
        orientation,
        bboxes,
        maxHeight,
        maxWidth,
        itemPaddingY,
        itemPaddingX,
        forceResult
      });
      pages = layout?.pages ?? [];
      maxPageWidth = layout?.maxPageWidth ?? 0;
      maxPageHeight = layout?.maxPageHeight ?? 0;
      const totalPages = pages.length;
      this.pagination.visible = totalPages > 1;
      this.pagination.totalPages = totalPages;
      this.pagination.update();
      this.pagination.updateMarkers();
      lastPassPaginationBBox = this.pagination.getBBox();
      if (!this.pagination.visible) {
        break;
      }
    } while (!stableOutput(lastPassPaginationBBox));
    return { maxPageWidth, maxPageHeight, pages, paginationBBox: lastPassPaginationBBox, paginationVertical };
  }
  updatePositions(pageNumber = 0) {
    const {
      item: { paddingY },
      itemSelection,
      pages
    } = this;
    if (pages.length < 1 || !pages[pageNumber]) {
      return;
    }
    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];
    let x = 0;
    let y = 0;
    const columnCount = columns.length;
    const rowCount = columns[0].indices.length;
    const horizontal = this.getOrientation() === "horizontal";
    const itemHeight = columns[0].bboxes[0].height + paddingY;
    const rowSumColumnWidths = [];
    itemSelection.each((markerLabel, _, i) => {
      if (i < visibleStart || i > visibleEnd) {
        markerLabel.visible = false;
        return;
      }
      const pageIndex = i - visibleStart;
      let columnIndex;
      let rowIndex;
      if (horizontal) {
        columnIndex = pageIndex % columnCount;
        rowIndex = Math.floor(pageIndex / columnCount);
      } else {
        columnIndex = Math.floor(pageIndex / rowCount);
        rowIndex = pageIndex % rowCount;
      }
      markerLabel.visible = true;
      const column = columns[columnIndex];
      if (!column) {
        return;
      }
      y = Math.floor(itemHeight * rowIndex);
      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);
      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;
      markerLabel.translationX = x;
      markerLabel.translationY = y;
    });
  }
  updatePageNumber(pageNumber) {
    const { itemSelection, group, pagination, pages, toggleSeries: interactive } = this;
    const { startIndex, endIndex } = pages[pageNumber];
    if (startIndex === 0) {
      this.paginationTrackingIndex = 0;
    } else if (pageNumber === pages.length - 1) {
      this.paginationTrackingIndex = endIndex;
    } else {
      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);
    }
    this.pagination.update();
    this.pagination.updateMarkers();
    this.updatePositions(pageNumber);
    this.domProxy.onPageChange({ itemSelection, group, pagination, interactive });
    this.ctx.updateService.update(7 /* SCENE_RENDER */);
  }
  update() {
    const {
      label: { color: color2 }
    } = this.item;
    this.itemSelection.each((markerLabel, datum) => {
      markerLabel.setEnabled(datum.enabled);
      markerLabel.color = color2;
    });
    this.updateContextMenu();
  }
  updateContextMenu() {
    this.ctx.contextMenuRegistry.setVisible("toggle-series-visibility", this.toggleSeries);
    this.ctx.contextMenuRegistry.setVisible("toggle-other-series", this.toggleSeries);
  }
  getLineStyles(datum) {
    const { stroke: stroke3, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};
    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);
    return {
      stroke: stroke3,
      strokeOpacity,
      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,
      lineDash
    };
  }
  getMarkerStyles({ marker }) {
    const { fill, stroke: stroke3, strokeOpacity = 1, fillOpacity = 1, strokeWidth, lineDash, lineDashOffset } = marker;
    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);
    if (isPatternFill(fill)) {
      fill.width = 8;
      fill.height = 8;
      fill.padding = 1;
      fill.strokeWidth = Math.min(2, fill.strokeWidth ?? 2);
    }
    if (isImageFill(fill)) {
      fill.fit = "contain";
      fill.width = void 0;
      fill.height = void 0;
      fill.repeat = "no-repeat";
    }
    return getShapeStyle(
      {
        fill,
        stroke: stroke3,
        strokeOpacity,
        fillOpacity,
        strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth,
        lineDash,
        lineDashOffset
      },
      fillGradientDefaults2,
      fillPatternDefaults2,
      fillImageDefaults2
    );
  }
  getContainerStyles() {
    const { stroke: stroke3, strokeOpacity, strokeWidth } = this.border;
    const { cornerRadius, fill, fillOpacity, padding: padding2 } = this;
    const isPaddingNumber = typeof padding2 === "number";
    return getShapeStyle(
      {
        cornerRadius,
        fill,
        fillOpacity,
        padding: {
          top: isPaddingNumber ? padding2 : padding2.top ?? 0,
          right: isPaddingNumber ? padding2 : padding2.right ?? 0,
          bottom: isPaddingNumber ? padding2 : padding2.bottom ?? 0,
          left: isPaddingNumber ? padding2 : padding2.left ?? 0
        },
        stroke: stroke3,
        strokeOpacity,
        strokeWidth: this.border.enabled ? strokeWidth : 0
      },
      fillGradientDefaults2,
      fillPatternDefaults2,
      fillImageDefaults2
    );
  }
  computePagedBBox() {
    const actualBBox = Group.computeChildrenBBox(this.group.excludeChildren({ name: "legend-container" }));
    if (this.pages.length > 1) {
      const [maxPageWidth, maxPageHeight] = this.maxPageSize;
      actualBBox.height = Math.max(maxPageHeight, actualBBox.height);
      actualBBox.width = Math.max(maxPageWidth, actualBBox.width);
    }
    const { strokeWidth, padding: padding2 } = this.getContainerStyles();
    actualBBox.grow(padding2).grow(strokeWidth);
    return actualBBox;
  }
  findNode(params) {
    const { datum, proxyButton } = this.itemSelection.select((ml) => ml.datum?.itemId === params.itemId)[0] ?? {};
    if (datum === void 0 || proxyButton === void 0) {
      throw new Error(
        `AG Charts - Missing required properties { datum: ${datum}, proxyButton: ${JSON.stringify(proxyButton)} }`
      );
    }
    return { datum, proxyButton };
  }
  contextToggleVisibility(params) {
    const { datum, proxyButton } = this.findNode(params);
    this.doClick(params.event, datum, proxyButton);
  }
  contextToggleOtherSeries(params) {
    this.doDoubleClick(params.event, this.findNode(params).datum);
  }
  onContextClick(widgetEvent, node) {
    const { sourceEvent } = widgetEvent;
    const legendItem = node.datum;
    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {
      this.ctx.contextMenuRegistry.builtins.items["toggle-series-visibility"].enabled = false;
    } else {
      this.ctx.contextMenuRegistry.builtins.items["toggle-series-visibility"].enabled = true;
    }
    const toggleOtherSeriesVisible = this.ctx.chartService.series.length > 1 && this.ctx.chartService.series[0]?.getLegendData("category")[0]?.hideToggleOtherSeries !== true;
    this.ctx.contextMenuRegistry.setVisible("toggle-other-series", toggleOtherSeriesVisible);
    const { offsetX, offsetY } = sourceEvent;
    const { x: canvasX, y: canvasY } = Transformable.toCanvasPoint(node, offsetX, offsetY);
    this.ctx.contextMenuRegistry.dispatchContext("legend-item", { widgetEvent, canvasX, canvasY }, { legendItem });
  }
  onClick(event, datum, proxyButton) {
    if (this.doClick(event, datum, proxyButton)) {
      event.preventDefault();
    }
  }
  getVisibleItemCount() {
    return this.ctx.chartService.series.flatMap((s) => s.getLegendData("category")).filter((d) => d.enabled).length;
  }
  doClick(event, datum, proxyButton) {
    const {
      listeners: { legendItemClick },
      ctx: { chartService, highlightManager },
      preventHidingAll,
      toggleSeries
    } = this;
    if (!datum) {
      return false;
    }
    const { legendType, seriesId, itemId, enabled, legendItemName } = datum;
    const series = chartService.series.find((s) => s.id === seriesId);
    if (!series) {
      return false;
    }
    let newEnabled = enabled;
    const clickEvent = makeLegendItemEvent("click", datum, event);
    if (legendItemClick) {
      callWithContext([series.properties, this.ctx.chartService], legendItemClick, clickEvent.apiEvent);
    }
    if (clickEvent.defaultPrevented)
      return true;
    if (toggleSeries) {
      newEnabled = !enabled;
      if (preventHidingAll && !newEnabled) {
        const numVisibleItems = this.getVisibleItemCount();
        if (numVisibleItems < 2) {
          newEnabled = true;
        }
      }
      proxyButton.setChecked(newEnabled);
      this.ctx.eventsHub.emit("legend:item-click", {
        legendType,
        series,
        itemId,
        enabled: newEnabled,
        legendItemName
      });
    }
    if (newEnabled) {
      highlightManager.updateHighlight(this.id, {
        series,
        itemId,
        datum: void 0,
        datumIndex: void 0,
        legendItemName
      });
    } else {
      highlightManager.updateHighlight(this.id);
    }
    this.ctx.legendManager.update();
    this.ctx.updateService.update(2 /* PROCESS_DATA */, {
      forceNodeDataRefresh: true,
      skipAnimations: datum.skipAnimations ?? false
    });
    return true;
  }
  onDoubleClick(event, datum) {
    if (this.doDoubleClick(event, datum)) {
      event.preventDefault();
    }
  }
  doDoubleClick(event, datum) {
    const {
      listeners: { legendItemDoubleClick },
      ctx: { chartService },
      toggleSeries
    } = this;
    if (!datum) {
      return false;
    }
    const { legendType, id, itemId, seriesId } = datum;
    const series = chartService.series.find((s) => s.id === id);
    if (!series) {
      return false;
    }
    const doubleClickEvent = makeLegendItemEvent("dblclick", datum, event);
    if (legendItemDoubleClick) {
      callWithContext(
        [series.properties, this.ctx.chartService],
        legendItemDoubleClick,
        doubleClickEvent.apiEvent
      );
    }
    if (doubleClickEvent.defaultPrevented)
      return true;
    if (toggleSeries) {
      const legendData = chartService.series.flatMap((s) => s.getLegendData("category"));
      let numVisibleItems = 0;
      const visibleLegendItemNames = /* @__PURE__ */ new Set();
      for (const d of legendData) {
        if (!d.enabled)
          continue;
        numVisibleItems += 1;
        if (d.legendItemName != null) {
          visibleLegendItemNames.add(d.legendItemName);
        }
      }
      if (visibleLegendItemNames.size > 0) {
        numVisibleItems = visibleLegendItemNames.size;
      }
      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);
      this.ctx.eventsHub.emit("legend:item-double-click", {
        legendType,
        series,
        itemId,
        numVisibleItems,
        enabled: clickedItem?.enabled ?? false,
        legendItemName: clickedItem?.legendItemName
      });
    }
    this.ctx.legendManager.update();
    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
    return true;
  }
  toTooltipMeta(event, node) {
    let point;
    if (event instanceof FocusEvent) {
      point = Transformable.toCanvas(node).computeCenter();
    } else {
      event.preventDefault();
      point = Transformable.toCanvasPoint(node, event.offsetX, event.offsetY);
    }
    return { canvasX: point.x, canvasY: point.y, showArrow: false };
  }
  onHover(event, node) {
    if (!this.enabled)
      throw new Error("AG Charts - onHover handler called on disabled legend");
    this.pagination.setPage(node.pageIndex);
    const datum = node.datum;
    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;
    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {
      const meta = this.toTooltipMeta(event, node);
      this.ctx.tooltipManager.updateTooltip(this.id, meta, [
        { type: "structured", title: this.getItemLabel(datum) }
      ]);
    } else {
      this.ctx.tooltipManager.removeTooltip(this.id);
    }
    if (datum?.enabled && series) {
      this.updateHighlight({
        series,
        itemId: datum?.itemId,
        datum: void 0,
        datumIndex: void 0,
        legendItemName: datum?.legendItemName
      });
    } else {
      this.updateHighlight();
    }
  }
  onLeave() {
    this.ctx.tooltipManager.removeTooltip(this.id);
    this.updateHighlight();
  }
  updateHighlight(datum) {
    if (this.ctx.interactionManager.isState(32 /* Default */)) {
      this.ctx.highlightManager.updateHighlight(this.id, datum);
    } else if (this.ctx.interactionManager.isState(2 /* Animation */)) {
      this.pendingHighlightDatum = datum;
      this.ctx.animationManager.onBatchStop(() => {
        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);
      });
    }
  }
  onLocaleChanged() {
    this.domProxy.onLocaleChanged(this.ctx.localeManager, this.itemSelection, this);
  }
  positionLegend(ctx) {
    const oldPages = this.positionLegendScene(ctx);
    this.positionLegendDOM(oldPages);
  }
  positionLegendScene(ctx) {
    if (!this.enabled || !this.data.length)
      return;
    const { placement, floating, xOffset, yOffset } = expandLegendPosition(this.position);
    const layoutBox = floating ? new BBox(0, 0, ctx.width, ctx.height) : ctx.layoutBox;
    const { x, y, width: width2, height: height2 } = layoutBox;
    const [legendWidth, legendHeight] = this.calculateLegendDimensions(layoutBox);
    const { oldPages } = this.calcLayout(legendWidth, legendHeight);
    const legendBBox = this.computePagedBBox();
    if (this.visible) {
      let unreachable2 = function(_a) {
        return void 0;
      };
      var unreachable = unreachable2;
      const legendSpacing = this.spacing;
      let translationX;
      let translationY;
      switch (placement) {
        case "top":
          translationX = (width2 - legendBBox.width) / 2;
          translationY = 0;
          break;
        case "bottom":
          translationX = (width2 - legendBBox.width) / 2;
          translationY = height2 - legendBBox.height;
          break;
        case "right":
          translationX = width2 - legendBBox.width;
          translationY = (height2 - legendBBox.height) / 2;
          break;
        case "left":
          translationX = 0;
          translationY = (height2 - legendBBox.height) / 2;
          break;
        case "top-right":
        case "right-top":
          translationX = width2 - legendBBox.width;
          translationY = 0;
          break;
        case "top-left":
        case "left-top":
          translationX = 0;
          translationY = 0;
          break;
        case "bottom-right":
        case "right-bottom":
          translationX = width2 - legendBBox.width;
          translationY = height2 - legendBBox.height;
          break;
        case "bottom-left":
        case "left-bottom":
          translationX = 0;
          translationY = height2 - legendBBox.height;
          break;
        default:
          unreachable2(placement);
      }
      if (!floating) {
        let shrinkAmount;
        let shrinkDirection;
        switch (placement) {
          case "top":
          case "top-right":
          case "top-left":
            shrinkAmount = legendBBox.height + legendSpacing;
            shrinkDirection = "top";
            break;
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            shrinkAmount = legendBBox.height + legendSpacing;
            shrinkDirection = "bottom";
            break;
          case "left":
          case "left-top":
          case "left-bottom":
            shrinkAmount = legendBBox.width + legendSpacing;
            shrinkDirection = "left";
            break;
          case "right":
          case "right-top":
          case "right-bottom":
            shrinkAmount = legendBBox.width + legendSpacing;
            shrinkDirection = "right";
            break;
          default:
            unreachable2(placement);
        }
        layoutBox.shrink(shrinkAmount, shrinkDirection);
      }
      translationX += xOffset;
      translationY += yOffset;
      this.group.translationX = Math.floor(x + translationX - legendBBox.x);
      this.group.translationY = Math.floor(y + translationY - legendBBox.y);
      this.containerNode.x = legendBBox.x;
      this.containerNode.y = legendBBox.y;
      this.containerNode.width = legendBBox.width;
      this.containerNode.height = legendBBox.height;
    }
    return oldPages;
  }
  positionLegendDOM(oldPages) {
    const {
      ctx,
      itemSelection,
      pagination,
      pages: newPages,
      toggleSeries,
      group,
      listeners: { legendItemClick, legendItemDoubleClick }
    } = this;
    const visible = this.visible && this.enabled;
    const interactive = toggleSeries || legendItemDoubleClick != null || legendItemClick != null;
    this.domProxy.update({
      visible,
      interactive,
      ctx,
      itemSelection,
      group,
      pagination,
      oldPages,
      newPages,
      datumReader: this,
      itemListener: this
    });
  }
  calculateLegendDimensions(shrinkRect) {
    const { width: width2, height: height2 } = shrinkRect;
    const { placement } = expandLegendPosition(this.position);
    const aspectRatio = width2 / height2;
    const maxCoefficient = 0.5;
    const minHeightCoefficient = 0.2;
    const minWidthCoefficient = 0.25;
    let legendWidth, legendHeight;
    function unreachable(_a) {
      return void 0;
    }
    switch (placement) {
      case "top":
      case "top-left":
      case "top-right":
      case "bottom":
      case "bottom-left":
      case "bottom-right": {
        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : width2;
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : Math.round(height2 * heightCoefficient);
        break;
      }
      case "left":
      case "left-top":
      case "left-bottom":
      case "right":
      case "right-top":
      case "right-bottom": {
        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : Math.round(width2 * widthCoefficient);
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : height2;
        break;
      }
      default:
        unreachable(placement);
    }
    return [legendWidth, legendHeight];
  }
  cachedCallWithContext(fn, ...params) {
    const { callbackCache, chartService } = this.ctx;
    return callbackCache.call([this, chartService], fn, ...params);
  }
};
Legend.className = "Legend";
__decorateClass([
  Property
], Legend.prototype, "toggleSeries", 2);
__decorateClass([
  Property
], Legend.prototype, "pagination", 2);
__decorateClass([
  Property
], Legend.prototype, "item", 2);
__decorateClass([
  Property
], Legend.prototype, "listeners", 2);
__decorateClass([
  ObserveChanges((target, newValue, oldValue) => {
    target.updateGroupVisibility();
    if (newValue === oldValue) {
      return;
    }
    const {
      ctx: { legendManager, stateManager }
    } = target;
    if (oldValue === false && newValue === true) {
      stateManager.restoreState(legendManager);
    }
  }),
  Property
], Legend.prototype, "enabled", 2);
__decorateClass([
  Property
], Legend.prototype, "position", 2);
__decorateClass([
  Property
], Legend.prototype, "maxWidth", 2);
__decorateClass([
  Property
], Legend.prototype, "maxHeight", 2);
__decorateClass([
  Property
], Legend.prototype, "reverseOrder", 2);
__decorateClass([
  Property
], Legend.prototype, "orientation", 2);
__decorateClass([
  Property
], Legend.prototype, "preventHidingAll", 2);
__decorateClass([
  Property
], Legend.prototype, "border", 2);
__decorateClass([
  Property
], Legend.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], Legend.prototype, "fill", 2);
__decorateClass([
  Property
], Legend.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], Legend.prototype, "padding", 2);
__decorateClass([
  Property
], Legend.prototype, "spacing", 2);
__decorateClass([
  Property
], Legend.prototype, "xOffset", 2);
__decorateClass([
  Property
], Legend.prototype, "yOffset", 2);

// packages/ag-charts-community/src/chart/legend/legendModule.ts
var CommunityLegendModule = {
  type: "legend",
  optionsKey: "legend",
  identifier: "category",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new Legend(ctx),
  packageType: "community",
  removable: "standalone-only"
};

// packages/ag-charts-community/src/chart/series-area/seriesArea.ts
var SeriesArea = class extends BaseProperties {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.rectNode = new Rect();
    this.border = new Border(this.rectNode);
    this.cornerRadius = 0;
    this.padding = 0;
    this.cleanup = new CleanupRegistry();
    this.node = this.createNode();
    this.node.append([this.rectNode]);
    this.rectNode.fill = void 0;
    this.cleanup.register(
      ctx.scene.attachNode(this.node),
      ctx.eventsHub.on("layout:complete", (e) => this.onLayoutComplete(e))
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  getPadding() {
    const { border, padding: padding2 } = this;
    const strokeWidth = border.enabled ? border.strokeWidth : 0;
    if (typeof padding2 === "number") {
      const total = padding2 + strokeWidth;
      return { top: total, right: total, bottom: total, left: total };
    }
    return {
      top: (padding2.top ?? 0) + strokeWidth,
      right: (padding2.right ?? 0) + strokeWidth,
      bottom: (padding2.bottom ?? 0) + strokeWidth,
      left: (padding2.left ?? 0) + strokeWidth
    };
  }
  createNode() {
    return new Group({ name: "series-area-container", zIndex: 4 /* SERIES_AREA_CONTAINER */ });
  }
  onLayoutComplete(event) {
    const { x, y, width: width2, height: height2 } = event.series.paddedRect;
    this.rectNode.x = x;
    this.rectNode.y = y;
    this.rectNode.width = width2;
    this.rectNode.height = height2;
  }
};
__decorateClass([
  Property
], SeriesArea.prototype, "border", 2);
__decorateClass([
  Property
], SeriesArea.prototype, "clip", 2);
__decorateClass([
  ProxyPropertyOnWrite("rectNode", "cornerRadius"),
  Property
], SeriesArea.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], SeriesArea.prototype, "padding", 2);

// packages/ag-charts-community/src/chart/series-area/seriesAreaModule.ts
var SeriesAreaModule = {
  type: "root",
  optionsKey: "seriesArea",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new SeriesArea(ctx)
};

// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
  const animate = (phase, path, collapsable, updateFn) => {
    animationManager.animate({
      id: `${groupId}_${subId}_${path.id}_${phase}`,
      groupId,
      from: collapsable ? 1 : 0,
      to: 1,
      ease: easeOut,
      collapsable,
      onUpdate(ratio2, preInit) {
        if (preInit && phase !== "removed")
          return;
        path.path.clear(true);
        updateFn(ratio2, path);
        path.checkPathDirty();
      },
      onStop() {
        if (phase !== "added")
          return;
        path.path.clear(true);
        updateFn(1, path);
        path.checkPathDirty();
      },
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
    });
  };
  const tempPath = new Path();
  const resultsChange = (updateFn) => {
    tempPath.resetPathDirty();
    updateFn(0, tempPath);
    tempPath.resetPathDirty();
    updateFn(1, tempPath);
    tempPath.checkPathDirty();
    return tempPath.isPathDirty();
  };
  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
  for (const path of paths) {
    if (!animationManager.isSkipped()) {
      animate("removed", path, !resultsChange(removePhaseFn), removePhaseFn);
      animate("updated", path, !resultsChange(updatePhaseFn), updatePhaseFn);
    }
    animate("added", path, !resultsChange(addPhaseFn), addPhaseFn);
  }
}

// packages/ag-charts-community/src/chart/labelUtil.ts
function getLabelStyles(series, nodeDatum, params, label, highlighted, highlightState) {
  if (label.itemStyler) {
    const styleParams = {
      border: label.border,
      color: label.color,
      cornerRadius: label.cornerRadius,
      datum: nodeDatum?.datum,
      enabled: label.enabled,
      fill: label.fill,
      fillOpacity: label.fillOpacity,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight,
      itemId: void 0,
      seriesId: series.id,
      padding: label.padding,
      highlighted,
      highlightState
    };
    return mergeDefaults(series.callWithContext(label.itemStyler, { ...params, ...styleParams }), styleParams);
  }
  return label;
}
function updateLabelNode(series, textNode, params, label, labelDatum, highlighted, highlightState) {
  if (label.enabled && labelDatum) {
    const style2 = getLabelStyles(series, labelDatum, params, label, highlighted, highlightState);
    textNode.visible = true;
    textNode.x = labelDatum.x;
    textNode.y = labelDatum.y;
    textNode.text = labelDatum.text;
    textNode.fill = style2.color;
    textNode.setAlign(labelDatum);
    textNode.setFont(style2);
    textNode.setBoxing(style2);
  } else {
    textNode.visible = false;
  }
}
var placements = {
  "inside-start": { inside: true, direction: -1, textAlignment: 1 },
  "inside-end": { inside: true, direction: 1, textAlignment: -1 },
  "outside-start": { inside: false, direction: -1, textAlignment: -1 },
  "outside-end": { inside: false, direction: 1, textAlignment: 1 }
};
function adjustLabelPlacement({
  isUpward,
  isVertical,
  placement,
  spacing = 0,
  rect
}) {
  let x = rect.x + rect.width / 2;
  let y = rect.y + rect.height / 2;
  let textAlign = "center";
  let textBaseline = "middle";
  if (placement !== "inside-center") {
    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);
    const { direction, textAlignment } = placements[placement];
    const displacementRatio = (direction + 1) * 0.5;
    if (isVertical) {
      const y0 = isUpward ? rect.y + rect.height : rect.y;
      const height2 = rect.height * barDirection;
      y = y0 + height2 * displacementRatio + spacing * textAlignment * barDirection;
      textBaseline = textAlignment === barDirection ? "top" : "bottom";
    } else {
      const x0 = isUpward ? rect.x : rect.x + rect.width;
      const width2 = rect.width * barDirection;
      x = x0 + width2 * displacementRatio + spacing * textAlignment * barDirection;
      textAlign = textAlignment === barDirection ? "left" : "right";
    }
  }
  return { x, y, textAlign, textBaseline };
}

// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {
  for (const labelSelection of labelSelections) {
    labelSelection.cleanup();
  }
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 0 },
    { opacity: 1 },
    { phase: "trailing" }
  );
}
function seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 1 },
    { opacity: 0 },
    { phase: "remove" }
  );
}
function resetLabelFn(_node) {
  return { opacity: 1 };
}

// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this._dirty = true;
  }
  markDirty() {
    this._dirty = true;
  }
  markClean(_opts) {
    this._dirty = false;
  }
  isDirty() {
    return this._dirty;
  }
  onChangeDetection(_property) {
    this.markDirty();
  }
};

// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = "rgba(0, 0, 0, 0.5)";
    this.xOffset = 0;
    this.yOffset = 0;
    this.blur = 5;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "enabled", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "color", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "xOffset", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "yOffset", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "blur", 2);

// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var SeriesMarker = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.shape = "circle";
    this.size = 6;
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
  getStyle() {
    const { size, shape, fill, fillOpacity, stroke: stroke3, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      size,
      shape,
      fill,
      fillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
  getDiameter() {
    return this.size + this.strokeWidth;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "enabled", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], SeriesMarker.prototype, "shape", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "size", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: objectsEqual })
], SeriesMarker.prototype, "fill", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "fillOpacity", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "stroke", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "lineDash", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "lineDashOffset", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], SeriesMarker.prototype, "itemStyler", 2);

// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Property
], SeriesTooltipInteraction.prototype, "enabled", 2);
var SeriesTooltip = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.interaction = new SeriesTooltipInteraction();
    this.position = new TooltipPosition();
    this.range = void 0;
    this.class = void 0;
  }
  formatTooltip(callers, content, params) {
    const overrides = this.renderer == null ? void 0 : callWithContext(callers, this.renderer, params);
    if (typeof overrides === "string")
      return { type: "raw", rawHtmlString: overrides };
    if (overrides != null)
      return { type: "structured", ...content, ...overrides };
    return { type: "structured", ...content };
  }
};
__decorateClass([
  Property
], SeriesTooltip.prototype, "enabled", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "showArrow", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "renderer", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "interaction", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "position", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "range", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "class", 2);
function makeSeriesTooltip() {
  return new SeriesTooltip();
}

// packages/ag-charts-community/src/scene/util/quadtree.ts
var QuadtreeNearest = class {
  constructor(capacity, maxdepth, boundary) {
    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);
  }
  clear(boundary) {
    this.root.clear(boundary);
  }
  addValue(hitTester, value) {
    const elem = {
      hitTester,
      value,
      distanceSquared: (x, y) => {
        return hitTester.distanceSquared(x, y);
      }
    };
    this.root.addElem(elem);
  }
  find(x, y) {
    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };
    this.root.find(x, y, arg);
    return arg.best;
  }
};
var QuadtreeSubdivisions = class {
  constructor(nw, ne, sw, se) {
    this.nw = nw;
    this.ne = ne;
    this.sw = sw;
    this.se = se;
  }
  addElem(elem) {
    this.nw.addElem(elem);
    this.ne.addElem(elem);
    this.sw.addElem(elem);
    this.se.addElem(elem);
  }
  find(x, y, arg) {
    this.nw.find(x, y, arg);
    this.ne.find(x, y, arg);
    this.sw.find(x, y, arg);
    this.se.find(x, y, arg);
  }
};
var QuadtreeNode = class {
  constructor(capacity, maxdepth, boundary) {
    this.capacity = capacity;
    this.maxdepth = maxdepth;
    this.boundary = boundary ?? BBox.NaN;
    this.elems = [];
    this.subdivisions = void 0;
  }
  clear(boundary) {
    this.elems.length = 0;
    this.boundary = boundary;
    this.subdivisions = void 0;
  }
  addElem(e) {
    if (this.addCondition(e)) {
      if (this.subdivisions === void 0) {
        if (this.maxdepth === 0 || this.elems.length < this.capacity) {
          this.elems.push(e);
        } else {
          this.subdivide(e);
        }
      } else {
        this.subdivisions.addElem(e);
      }
    }
  }
  find(x, y, arg) {
    if (this.findCondition(x, y, arg)) {
      if (this.subdivisions === void 0) {
        this.findAction(x, y, arg);
      } else {
        this.subdivisions.find(x, y, arg);
      }
    }
  }
  subdivide(newElem) {
    this.subdivisions = this.makeSubdivisions();
    for (const e of this.elems) {
      this.subdivisions.addElem(e);
    }
    this.subdivisions.addElem(newElem);
    this.elems.length = 0;
  }
  makeSubdivisions() {
    const { x, y, width: width2, height: height2 } = this.boundary;
    const { capacity } = this;
    const depth = this.maxdepth - 1;
    const halfWidth = width2 / 2;
    const halfHeight = height2 / 2;
    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);
    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);
    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);
    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
    return new QuadtreeSubdivisions(
      this.child(capacity, depth, nwBoundary),
      this.child(capacity, depth, neBoundary),
      this.child(capacity, depth, swBoundary),
      this.child(capacity, depth, seBoundary)
    );
  }
};
var QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {
  addCondition(e) {
    const { x, y } = e.hitTester.midPoint;
    return this.boundary.containsPoint(x, y);
  }
  findCondition(x, y, arg) {
    const { best } = arg;
    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;
  }
  findAction(x, y, arg) {
    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);
    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {
      arg.best = other;
    }
  }
  child(capacity, depth, boundary) {
    return new _QuadtreeNodeNearest(capacity, depth, boundary);
  }
};

// packages/ag-charts-community/src/chart/series/dataModelSeries.ts
var DataModelSeries = class extends Series {
  constructor({ clipFocusBox, categoryKey, ...seriesOpts }) {
    super(seriesOpts);
    this.categoryKey = categoryKey;
    this.clipFocusBox = clipFocusBox ?? true;
  }
  dataCount() {
    return this.processedData?.dataSources?.get(this.id)?.length ?? 0;
  }
  getScaleInformation({
    xScale,
    yScale
  }) {
    const isContinuousX = ContinuousScale.is(xScale);
    const isContinuousY = ContinuousScale.is(yScale);
    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };
  }
  getModulePropertyDefinitions() {
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    return this.moduleMap.mapModules((mod) => mod.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();
  }
  // Request data, but with message dispatching to series-options (modules).
  async requestDataModel(dataController, data, opts) {
    opts.props.push(...this.getModulePropertyDefinitions());
    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);
    this.dataModel = dataModel;
    this.processedData = processedData;
    this.events.emit("data-processed", { dataModel, processedData });
    return { dataModel, processedData };
  }
  isProcessedDataAnimatable() {
    const { processedData } = this;
    if (!processedData)
      return false;
    const validationResults = processedData.reduced?.animationValidation;
    if (!validationResults)
      return true;
    const { orderedKeys, uniqueKeys } = validationResults;
    return orderedKeys && uniqueKeys;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  pickFocus(opts) {
    const nodeData = this.getNodeData();
    if (nodeData === void 0 || nodeData.length === 0) {
      return;
    }
    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);
    if (datumIndex === void 0) {
      return;
    }
    const { clipFocusBox } = this;
    const datum = nodeData[datumIndex];
    const derivedOpts = { ...opts, datumIndex };
    const bounds = this.computeFocusBounds(derivedOpts);
    if (bounds !== void 0) {
      return { bounds, clipFocusBox, datum, datumIndex };
    }
  }
  pickNodesExactShape(point) {
    const datums = super.pickNodesExactShape(point);
    datums.sort((a, b) => a.datumIndex - b.datumIndex);
    return datums;
  }
  isDatumEnabled(nodeData, datumIndex) {
    const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex];
    return !missing && enabled && focusable;
  }
  computeFocusDatumIndex(opts, nodeData) {
    const searchBackward = (datumIndex2, delta4) => {
      while (datumIndex2 >= 0 && !this.isDatumEnabled(nodeData, datumIndex2)) {
        datumIndex2 += delta4;
      }
      return datumIndex2 === -1 ? void 0 : datumIndex2;
    };
    const searchForward = (datumIndex2, delta4) => {
      while (datumIndex2 < nodeData.length && !this.isDatumEnabled(nodeData, datumIndex2)) {
        datumIndex2 += delta4;
      }
      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;
    };
    let datumIndex;
    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);
    if (opts.datumIndexDelta < 0) {
      datumIndex = searchBackward(clampedIndex, opts.datumIndexDelta);
    } else if (opts.datumIndexDelta > 0) {
      datumIndex = searchForward(clampedIndex, opts.datumIndexDelta);
    } else {
      datumIndex = searchForward(clampedIndex, 1) ?? searchBackward(clampedIndex, -1);
    }
    if (datumIndex === void 0) {
      if (opts.datumIndexDelta === 0) {
        return;
      } else {
        return opts.datumIndex - opts.datumIndexDelta;
      }
    } else {
      return datumIndex;
    }
  }
  // Workaround - it would be nice if this difference didn't exist
  dataModelPropertyIsKey(key) {
    const { processedData } = this;
    if (!processedData)
      return false;
    return processedData.defs.keys.some((def) => def.id === key && def.idsMap?.get(this.id)?.has(key) === true);
  }
  keysOrValues(xKey) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    return this.dataModelPropertyIsKey(xKey) ? dataModel.resolveKeysById(this, xKey, processedData) : dataModel.resolveColumnById(this, xKey, processedData);
  }
  sortOrder(xKey) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return;
    return this.dataModelPropertyIsKey(xKey) ? dataModel.getKeySortOrder(this, xKey, processedData) : dataModel.getColumnSortOrder(this, xKey, processedData);
  }
  getCategoryKey() {
    return this.categoryKey;
  }
  getCategoryValue(datumIndex) {
    const { processedData, dataModel } = this;
    const categoryKey = this.getCategoryKey();
    if (!processedData || !dataModel || !categoryKey)
      return;
    const invalid = processedData.invalidData?.get(this.id)?.[datumIndex] ?? false;
    return invalid ? void 0 : this.keysOrValues(categoryKey)[datumIndex];
  }
  datumIndexForCategoryValue(categoryValue) {
    const { processedData, dataModel } = this;
    const categoryKey = this.getCategoryKey();
    if (!processedData || !dataModel || !categoryKey)
      return;
    categoryValue = categoryValue.valueOf();
    const invalidValues = processedData.invalidData?.get(this.id);
    const xValues = this.keysOrValues(categoryKey);
    for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
      if (invalidValues?.[datumIndex] === true)
        continue;
      const xValue2 = xValues[datumIndex]?.valueOf();
      if (objectsEqual(categoryValue, xValue2))
        return datumIndex;
    }
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_CARTESIAN_DIRECTION_KEYS = {
  ["x" /* X */]: ["xKey"],
  ["y" /* Y */]: ["yKey"]
};
var DEFAULT_CARTESIAN_DIRECTION_NAMES = {
  ["x" /* X */]: ["xName"],
  ["y" /* Y */]: ["yName"]
};
var CartesianSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yKey = series.properties.yKey;
  }
};
var CartesianSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.pickOutsideVisibleMinorAxis = false;
  }
};
__decorateClass([
  Property
], CartesianSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Property
], CartesianSeriesProperties.prototype, "pickOutsideVisibleMinorAxis", 2);
var RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD = 100;
var CartesianSeries = class extends DataModelSeries {
  constructor({
    pathsPerSeries = ["path"],
    pathsZIndexSubOrderOffset = [],
    datumSelectionGarbageCollection = true,
    animationAlwaysUpdateSelections = false,
    animationResetFns,
    propertyKeys,
    propertyNames,
    ...otherOpts
  }) {
    super({
      propertyKeys,
      propertyNames,
      canHaveAxes: true,
      ...otherOpts
    });
    this.NodeEvent = CartesianSeriesNodeEvent;
    this.dataNodeGroup = this.contentGroup.appendChild(
      new Group({ name: `${this.id}-series-dataNodes`, zIndex: 1 })
    );
    this.labelGroup = this.contentGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-series-labels` })
    );
    this.labelSelection = Selection.select(this.labelGroup, Text);
    this.highlightSelection = Selection.select(this.highlightGroup, () => this.nodeFactory());
    this.annotationSelections = /* @__PURE__ */ new Set();
    this.debug = Debug.create();
    if (!propertyKeys || !propertyNames)
      throw new Error(`Unable to initialise series type ${this.type}`);
    this.opts = {
      pathsPerSeries,
      pathsZIndexSubOrderOffset,
      propertyKeys,
      propertyNames,
      animationResetFns,
      animationAlwaysUpdateSelections,
      datumSelectionGarbageCollection
    };
    this.paths = pathsPerSeries.map((path) => {
      return new Path({ name: `${this.id}-${path}` });
    });
    this.datumSelection = Selection.select(
      this.dataNodeGroup,
      () => this.nodeFactory(),
      datumSelectionGarbageCollection
    );
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => {
              if (this.ctx.animationManager.isSkipped()) {
                this.resetAllAnimation(data);
              } else {
                this.animateWaitingUpdateReady(data);
              }
            }
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        disabled: {
          update: (data) => this.resetAllAnimation(data),
          reset: "empty"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  get contextNodeData() {
    return this._contextNodeData;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    this.attachPaths(this.paths);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    this.detachPaths(this.paths);
  }
  updatedDomains() {
    this.animationState.transition("updateData");
  }
  attachPaths(paths) {
    for (const path of paths) {
      this.contentGroup.appendChild(path);
    }
  }
  detachPaths(paths) {
    for (const path of paths) {
      this.contentGroup.removeChild(path);
    }
  }
  renderToOffscreenCanvas() {
    const nodeData = this.getNodeData();
    return nodeData != null && nodeData.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    } else if (phase === "disabled") {
      this.animationState.transition("disable");
    }
  }
  addChartEventListeners() {
    this.cleanup.register(
      this.ctx.eventsHub.on("legend:item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.eventsHub.on("legend:item-double-click", (event) => this.onLegendItemDoubleClick(event))
    );
  }
  destroy() {
    super.destroy();
    this._contextNodeData = void 0;
  }
  isSeriesHighlighted(highlightedDatum) {
    const { series, legendItemName: activeLegendItemName } = highlightedDatum ?? {};
    const { legendItemName } = this.properties;
    return series === this || legendItemName != null && legendItemName === activeLegendItemName;
  }
  strokewidthChange() {
    const unhighlightedStrokeWidth = ("strokeWidth" in this.properties && this.properties.strokeWidth) ?? 0;
    const highlightedSeriesStrokeWidth = this.properties.highlight.highlightedSeries.strokeWidth ?? unhighlightedStrokeWidth;
    const highlightedItemStrokeWidth = this.properties.highlight.highlightedItem?.strokeWidth ?? unhighlightedStrokeWidth;
    return unhighlightedStrokeWidth > highlightedItemStrokeWidth || highlightedSeriesStrokeWidth > highlightedItemStrokeWidth;
  }
  update({ seriesRect }) {
    const { _contextNodeData: previousContextData } = this;
    const resize = this.checkResize(seriesRect);
    const itemHighlighted = this.updateHighlightSelection();
    this.contentGroup.batchedUpdate(() => {
      const dataChanged = this.updateSelections();
      this.updateNodes(itemHighlighted, resize || dataChanged);
    });
    const animationData = this.getAnimationData(seriesRect, previousContextData);
    if (!animationData)
      return;
    if (resize) {
      this.animationState.transition("resize", animationData);
    }
    this.animationState.transition("update", animationData);
  }
  updateSelections() {
    var _a;
    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
    if (!this.visible && animationSkipUpdate) {
      return false;
    }
    const { nodeDataRefresh } = this;
    if (!nodeDataRefresh && !this.isPathOrSelectionDirty()) {
      return false;
    }
    if (nodeDataRefresh) {
      this.nodeDataRefresh = false;
      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);
      this.markQuadtreeDirty();
      this._contextNodeData = this.createNodeData();
      const animationValid = this.isProcessedDataAnimatable();
      if (this._contextNodeData) {
        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);
      }
      const { dataModel, processedData } = this;
      if (dataModel !== void 0 && processedData !== void 0) {
        this.events.emit("data-update", { dataModel, processedData });
      }
      this.updateSeriesSelections();
    }
    return nodeDataRefresh;
  }
  updateSeriesSelections() {
    const { datumSelection, labelSelection, paths } = this;
    const contextData = this._contextNodeData;
    if (!contextData)
      return;
    const { nodeData, labelData, itemId } = contextData;
    this.updatePaths({ itemId, contextData, paths });
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.labelGroup.batchedUpdate(() => {
      this.labelSelection = this.updateLabelSelection({ labelData, labelSelection }) ?? labelSelection;
    });
  }
  getShapeFillBBox() {
    const { axes } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const [axisX1, axisX2] = findMinMax(xAxis?.range ?? [0, 1]);
    const [axisY1, axisY2] = findMinMax(yAxis?.range ?? [0, 1]);
    const xSeriesDomain = this.getSeriesDomain("x" /* X */);
    const xSeriesRange = [xAxis?.scale.convert(xSeriesDomain.at(0)), xAxis?.scale.convert(xSeriesDomain.at(-1))];
    const ySeriesDomain = this.getSeriesDomain("y" /* Y */);
    const ySeriesRange = [yAxis?.scale.convert(ySeriesDomain.at(0)), yAxis?.scale.convert(ySeriesDomain.at(-1))];
    const [seriesX1, seriesX2] = findMinMax(xSeriesRange);
    const [seriesY1, seriesY2] = findMinMax(ySeriesRange);
    return {
      axis: new BBox(axisX1, axisY1, axisX2 - axisX1, axisY2 - axisY1),
      series: new BBox(seriesX1, seriesY1, seriesX2 - seriesX1, seriesY2 - seriesY1)
    };
  }
  updateNodes(itemHighlighted, nodeRefresh) {
    const { highlightSelection, datumSelection } = this;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const visible = this.visible && this._contextNodeData != null;
    this.contentGroup.visible = animationEnabled || visible;
    this.highlightGroup.visible = (animationEnabled || visible) && itemHighlighted;
    this.updateDatumNodes({
      datumSelection: highlightSelection,
      isHighlight: true
    });
    this.animationState.transition("highlight", highlightSelection);
    const { dataNodeGroup, labelSelection, paths, labelGroup } = this;
    const { itemId } = this.contextNodeData ?? {};
    this.updatePathNodes({
      itemId,
      paths,
      visible,
      animationEnabled
    });
    dataNodeGroup.visible = animationEnabled || visible;
    labelGroup.visible = visible;
    if (!dataNodeGroup.visible) {
      return;
    }
    const redrawAll = this.strokewidthChange() || this.hasChangesOnHighlight;
    if (nodeRefresh || redrawAll) {
      this.updateDatumNodes({ datumSelection, isHighlight: false });
      if (!this.usesPlacedLabels) {
        this.labelGroup.batchedUpdate(() => {
          this.updateLabelNodes({ labelSelection, isHighlight: false });
        });
      }
    }
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter(
      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId
    );
    return labelItems.length === 0 ? void 0 : labelItems;
  }
  getHighlightData(_nodeData, highlightedItem) {
    return highlightedItem ? [highlightedItem] : void 0;
  }
  updateHighlightSelection() {
    const { highlightSelection, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return false;
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const seriesHighlighted = this.isSeriesHighlighted(highlightedDatum);
    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;
    if (item == null)
      return false;
    const { nodeData } = contextNodeData;
    const highlightItems = this.getHighlightData(nodeData, item);
    this.highlightSelection = this.updateHighlightSelectionItem({
      items: highlightItems,
      highlightSelection
    });
    return true;
  }
  markQuadtreeDirty() {
    this.quadtree = void 0;
  }
  *datumNodesIter() {
    for (const { node } of this.datumSelection) {
      if (node.datum.missing === true)
        continue;
      yield node;
    }
  }
  getQuadTree() {
    if (this.quadtree === void 0) {
      const { width: width2, height: height2 } = this.ctx.scene.canvas;
      const canvasRect = new BBox(0, 0, width2, height2);
      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);
      this.initQuadTree(this.quadtree);
    }
    return this.quadtree;
  }
  initQuadTree(_quadtree) {
  }
  pickNodesExactShape(point) {
    const result = super.pickNodesExactShape(point);
    if (result.length !== 0) {
      return result;
    }
    const { x, y } = point;
    const { dataNodeGroup } = this;
    const matches = dataNodeGroup.pickNodes(x, y).filter((match) => match.datum.missing !== true);
    if (matches.length !== 0) {
      const datums = matches.map((match) => match.datum);
      return datums;
    }
    for (const mod of this.moduleMap.modules()) {
      const { datum } = mod.pickNodeExact(point) ?? {};
      if (datum == null)
        continue;
      if (datum?.missing === true)
        continue;
      return [datum];
    }
    return [];
  }
  pickNodeClosestDatum(point) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const hitPoint = { x, y };
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);
      if (!isInRange) {
        continue;
      }
      const distance2 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);
      if (distance2 < minDistance) {
        minDistance = distance2;
        closestDatum = datum;
      }
    }
    for (const mod of this.moduleMap.modules()) {
      const modPick = mod.pickNodeNearest(point);
      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
        minDistance = modPick.distanceSquared;
        closestDatum = modPick.datum;
        break;
      }
    }
    if (closestDatum) {
      const distance2 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0) / 2, 0);
      return { datum: closestDatum, distance: distance2 };
    }
  }
  pickNodeMainAxisFirst(point, requireCategoryAxis) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    const { pickOutsideVisibleMinorAxis } = this.properties;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (xAxis == null || yAxis == null)
      return;
    const directions2 = [xAxis, yAxis].filter((axis) => axis.isCategoryLike()).map((a) => a.direction);
    if (requireCategoryAxis && directions2.length === 0)
      return;
    const [majorDirection = "x" /* X */] = directions2;
    const hitPointCoords = [x, y];
    if (majorDirection !== "x" /* X */)
      hitPointCoords.reverse();
    const minDistance = [Infinity, Infinity];
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};
      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)
        continue;
      const visible = [xAxis?.inRange(datumX, 1), yAxis?.inRange(datumY, 1)];
      if (majorDirection !== "x" /* X */) {
        visible.reverse();
      }
      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])
        continue;
      const datumPoint = [datumX, datumY];
      if (majorDirection !== "x" /* X */) {
        datumPoint.reverse();
      }
      let newMinDistance = true;
      for (let i = 0; i < datumPoint.length; i++) {
        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);
        if (dist > minDistance[i]) {
          newMinDistance = false;
          break;
        } else if (dist < minDistance[i]) {
          minDistance[i] = dist;
          minDistance.fill(Infinity, i + 1, minDistance.length);
        }
      }
      if (newMinDistance) {
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      let closestDistanceSquared = Math.max(
        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),
        0
      );
      for (const mod of this.moduleMap.modules()) {
        const modPick = mod.pickNodeMainAxisFirst(point, majorDirection);
        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
          closestDatum = modPick.datum;
          closestDistanceSquared = modPick.distanceSquared;
          break;
        }
      }
      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };
    }
  }
  isPathOrSelectionDirty() {
    return false;
  }
  shouldFlipXY() {
    return false;
  }
  visibleRangeIndices(axisKey, visibleRange, indices, sortOrderParams) {
    let sortOrder;
    if (sortOrderParams == null) {
      const { processedData, dataModel } = this;
      sortOrder = dataModel.getColumnSortOrder(this, axisKey, processedData) ?? 1;
    } else {
      sortOrder = sortOrderParams.sortOrder;
    }
    const xValues = this.keysOrValues(axisKey);
    const pixelSize = 0;
    const [start2, end2] = visibleRangeIndices(
      sortOrder,
      indices?.length ?? xValues.length,
      visibleRange,
      (topIndex) => {
        const datumIndex = indices?.[topIndex] ?? topIndex;
        return this.xCoordinateRange(xValues[datumIndex], pixelSize, datumIndex);
      }
    );
    return start2 < end2 ? [start2, end2] : [end2, start2];
  }
  domainForVisibleRange(_direction, axisKeys, crossAxisKey, visibleRange, indices) {
    const { processedData, dataModel } = this;
    const [r0, r1] = visibleRange;
    const crossAxisValues = this.keysOrValues(crossAxisKey);
    const sortOrder = this.sortOrder(crossAxisKey);
    if (sortOrder != null) {
      const crossAxisRange = this.visibleRangeIndices(crossAxisKey, visibleRange, indices, { sortOrder });
      return dataModel.getDomainBetweenRange(this, axisKeys, crossAxisRange, processedData);
    }
    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));
    let axisMin = Infinity;
    let axisMax = -Infinity;
    crossAxisValues.forEach((crossAxisValue, i) => {
      const [x0, x1] = this.xCoordinateRange(crossAxisValue, 0, i);
      if (x1 < r0 || x0 > r1)
        return;
      for (let j = 0; j < axisKeys.length; j++) {
        const axisValue = allAxisValues[j][i];
        axisMin = Math.min(axisMin, axisValue);
        axisMax = Math.max(axisMax, axisValue);
      }
    });
    if (axisMin > axisMax)
      return [NaN, NaN];
    return [axisMin, axisMax];
  }
  domainForClippedRange(direction, axisKeys, crossAxisKey) {
    const { processedData, dataModel, axes } = this;
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossAxisRange = axisExtent(axes[crossDirection]);
    if (!crossAxisRange) {
      return axisKeys.flatMap((axisKey) => dataModel.getDomain(this, axisKey, "value", processedData));
    }
    const crossAxisValues = this.keysOrValues(crossAxisKey);
    const sortOrder = dataModel.getColumnSortOrder(this, crossAxisKey, processedData);
    if (sortOrder != null) {
      const crossRange = clippedRangeIndices(
        sortOrder,
        crossAxisValues.length,
        crossAxisRange,
        (index) => crossAxisValues[index]
      );
      return dataModel.getDomainBetweenRange(this, axisKeys, crossRange, processedData);
    }
    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));
    const range0 = crossAxisRange[0].valueOf();
    const range1 = crossAxisRange[1].valueOf();
    const axisValues = [];
    crossAxisValues.forEach((crossAxisValue, i) => {
      const c = crossAxisValue.valueOf();
      if (c < range0 || c > range1)
        return;
      const values = allAxisValues.map((v) => v[i]);
      if (c >= range0) {
        axisValues.push(...values);
      }
      if (c <= range1) {
        axisValues.push(...values);
      }
    });
    return axisValues;
  }
  countVisibleItems(crossAxisKey, axisKeys, xVisibleRange, yVisibleRange, minVisibleItems) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return Infinity;
    const crossValues = this.keysOrValues(crossAxisKey);
    const allAxisValues = axisKeys.map((axisKey) => dataModel.resolveColumnById(this, axisKey, processedData));
    const crossAxis = this.axes["x" /* X */];
    const axis = this.axes["y" /* Y */];
    const shouldFlipXY = this.shouldFlipXY();
    if (yVisibleRange == null) {
      const sortOrder = this.sortOrder(crossAxisKey);
      if (sortOrder == null) {
        yVisibleRange = [0, 1];
      } else {
        const crossScale = crossAxis.scale;
        const crossScaleRange = crossScale.range;
        crossScale.range = [0, 1];
        let [r0, r1] = this.visibleRangeIndices(crossAxisKey, xVisibleRange, void 0, { sortOrder });
        const xValues = this.keysOrValues(crossAxisKey);
        const pixelSize2 = 0;
        if (this.xCoordinateRange(xValues[r0], pixelSize2, r0)[0] < xVisibleRange[0]) {
          r0 += 1;
        }
        if (r1 < xValues.length && this.xCoordinateRange(xValues[r1], pixelSize2, r1)[1] > xVisibleRange[1]) {
          r1 -= 1;
        }
        const xItemsVisible = Math.abs(r1 - r0);
        crossScale.range = crossScaleRange;
        return xItemsVisible;
      }
    }
    const convert2 = (d, r, v) => {
      return d[0] + (v - r[0]) / (r[1] - r[0]) * (d[1] - d[0]);
    };
    const crossAxisRange = crossAxis.range;
    const range4 = axis.range;
    const crossMin = convert2(crossAxisRange, crossAxis.visibleRange, xVisibleRange[0]);
    const crossMax = convert2(crossAxisRange, crossAxis.visibleRange, xVisibleRange[1]);
    const axisMin = convert2(range4, axis.visibleRange, shouldFlipXY ? yVisibleRange[0] : yVisibleRange[1]);
    const axisMax = convert2(range4, axis.visibleRange, shouldFlipXY ? yVisibleRange[1] : yVisibleRange[0]);
    const startIndex = Math.round(
      (xVisibleRange[0] + (xVisibleRange[1] - xVisibleRange[0]) / 2) * crossValues.length
    );
    const pixelSize = 0;
    return countExpandingSearch(0, crossValues.length - 1, startIndex, minVisibleItems, (index) => {
      let [x0, x1] = this.xCoordinateRange(crossValues[index], pixelSize, index);
      let [y0, y1] = this.yCoordinateRange(
        allAxisValues.map((axisValues) => axisValues[index]),
        pixelSize,
        index
      );
      if (!isFiniteNumber(x0) || !isFiniteNumber(x1) || !isFiniteNumber(y0) || !isFiniteNumber(y1)) {
        return false;
      }
      if (shouldFlipXY)
        [x0, x1, y0, y1] = [y0, y1, x0, x1];
      return x0 >= crossMin && x1 <= crossMax && y0 >= axisMin && y1 <= axisMax;
    });
  }
  // @todo(AG-13777) - Remove this function.
  // We need data model updates to know if a data set is sorted & unique - and at the same time
  // it should generate the equivalent of `SMALLEST_KEY_INTERVAL`. We'll use that value here
  minTimeInterval() {
    let xValues;
    try {
      xValues = this.keysOrValues("xValue");
    } catch {
    }
    if (xValues == null || xValues.length > 1e3)
      return;
    let minInterval = Infinity;
    let x0 = xValues[0];
    let sortOrder;
    for (let i = 1; i < xValues.length; i++) {
      const x1 = xValues[i];
      if (x1 != null && x0 != null) {
        const interval = x1.valueOf() - x0.valueOf();
        const sign = Math.sign(interval);
        if (sign === 0)
          continue;
        if (sortOrder !== void 0 && sign !== sortOrder)
          return;
        minInterval = Math.min(minInterval, Math.abs(interval));
        sortOrder = sign;
      }
      x0 = x1;
    }
    if (Number.isFinite(minInterval))
      return minInterval;
  }
  updateHighlightSelectionItem(opts) {
    const { items, highlightSelection } = opts;
    const nodeData = items ?? [];
    return this.updateDatumSelection({
      nodeData,
      datumSelection: highlightSelection
    });
  }
  updateHighlightSelectionLabel(opts) {
    return this.updateLabelSelection({
      labelData: opts.items ?? [],
      labelSelection: opts.highlightLabelSelection
    });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection;
  }
  updateDatumNodes(_opts) {
  }
  updatePaths(opts) {
    opts.paths.forEach((p) => p.visible = false);
  }
  updatePathNodes(opts) {
    const { paths, visible } = opts;
    for (const path of paths) {
      path.visible = visible;
    }
  }
  resetPathAnimation(data) {
    const { path } = this.opts?.animationResetFns ?? {};
    if (path) {
      data.paths.forEach((paths) => {
        resetMotion([paths], path);
      });
    }
  }
  resetDatumAnimation(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data.datumSelection], datum);
    }
  }
  resetLabelAnimation(data) {
    const { label } = this.opts?.animationResetFns ?? {};
    if (label) {
      resetMotion([data.labelSelection], label);
    }
  }
  resetAllAnimation(data) {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.resetPathAnimation(data);
    this.resetDatumAnimation(data);
    this.resetLabelAnimation(data);
    if (data.contextData?.animationValid === false) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data], datum);
    }
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  getAnimationData(seriesRect, previousContextData) {
    const { _contextNodeData: contextData } = this;
    if (!contextData)
      return;
    const animationData = {
      datumSelection: this.datumSelection,
      labelSelection: this.labelSelection,
      annotationSelections: [...this.annotationSelections],
      contextData,
      previousContextData,
      paths: this.paths,
      seriesRect
    };
    return animationData;
  }
  updateLabelSelection(opts) {
    return opts.labelSelection;
  }
  getScaling(scale2) {
    if (scale2 instanceof LogScale) {
      const { range: range4, domain } = scale2;
      return {
        type: "log",
        convert: (d) => scale2.convert(d),
        domain: [domain[0], domain[1]],
        range: [range4[0], range4[1]]
      };
    } else if (scale2 instanceof ContinuousScale) {
      const { range: range4, domain } = scale2;
      return {
        type: "continuous",
        domain: [domain[0], domain[1]],
        range: [range4[0], range4[1]]
      };
    } else if (scale2 instanceof BandScale) {
      const domain = scale2 instanceof UnitTimeScale ? scale2.bands : scale2.domain;
      return {
        type: "category",
        domain,
        inset: scale2.inset,
        step: scale2.step
      };
    }
  }
  calculateScaling() {
    const result = {};
    for (const direction of Object.values(ChartAxisDirection)) {
      const axis = this.axes[direction];
      if (!axis)
        continue;
      const scalingResult = this.getScaling(axis.scale);
      if (scalingResult != null) {
        result[direction] = scalingResult;
      }
    }
    return result;
  }
};
function axisExtent(axis) {
  let min;
  let max;
  if (axis instanceof NumberAxis || axis instanceof TimeAxis) {
    ({ min, max } = axis);
  }
  if (min == null && max == null)
    return;
  min ?? (min = -Infinity);
  max ?? (max = Infinity);
  return [min, max];
}
function clippedRangeIndices(sortOrder, length2, range4, xValue2) {
  const range0 = range4[0].valueOf();
  const range1 = range4[1].valueOf();
  let xMinIndex = findMinIndex(0, length2 - 1, (i) => {
    const index = sortOrder === 1 ? i : length2 - i;
    const x = xValue2(index)?.valueOf();
    return !Number.isFinite(x) || x >= range0;
  });
  let xMaxIndex = findMaxIndex(0, length2 - 1, (i) => {
    const index = sortOrder === 1 ? i : length2 - i;
    const x = xValue2(index)?.valueOf();
    return !Number.isFinite(x) || x <= range1;
  });
  if (xMinIndex == null || xMaxIndex == null)
    return [0, 0];
  if (sortOrder === -1) {
    [xMinIndex, xMaxIndex] = [length2 - xMaxIndex, length2 - xMinIndex];
  }
  xMinIndex = Math.max(xMinIndex, 0);
  xMaxIndex = Math.min(xMaxIndex + 1, length2);
  return [xMinIndex, xMaxIndex];
}

// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts
var InterpolationProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "linear";
    this.tension = 1;
    this.position = "end";
  }
};
__decorateClass([
  Property
], InterpolationProperties.prototype, "type", 2);
__decorateClass([
  Property
], InterpolationProperties.prototype, "tension", 2);
__decorateClass([
  Property
], InterpolationProperties.prototype, "position", 2);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.xName = void 0;
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.shadow = new DropShadow();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = makeSeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts
function spanRange(span) {
  switch (span.type) {
    case "linear":
    case "step":
      return [
        { x: span.x0, y: span.y0 },
        { x: span.x1, y: span.y1 }
      ];
    case "cubic":
      return [
        { x: span.cp0x, y: span.cp0y },
        { x: span.cp3x, y: span.cp3y }
      ];
  }
}
function spanRangeNormalized(span) {
  const range4 = spanRange(span);
  if (range4[0].x > range4[1].x) {
    range4.reverse();
  }
  return range4;
}
function collapseSpanToPoint(span, point) {
  const { x, y } = point;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: x,
        y0: y,
        x1: x,
        y1: y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: x,
        y0: y,
        x1: x,
        y1: y,
        stepX: x
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: x,
        cp0y: y,
        cp1x: x,
        cp1y: y,
        cp2x: x,
        cp2y: y,
        cp3x: x,
        cp3y: y
      };
  }
}
function rescaleSpan(span, nextStart, nextEnd) {
  const [prevStart, prevEnd] = spanRange(span);
  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;
  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: nextStart.x,
        cp0y: nextStart.y,
        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,
        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,
        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,
        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,
        cp3x: nextEnd.x,
        cp3y: nextEnd.y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y,
        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale
      };
  }
}
function clipSpanX(span, x0, x1) {
  const { moveTo } = span;
  const [start2, end2] = spanRangeNormalized(span);
  const { x: spanX0, y: spanY0 } = start2;
  const { x: spanX1, y: spanY1 } = end2;
  if (x1 < spanX0) {
    return rescaleSpan(span, start2, start2);
  } else if (x0 > spanX1) {
    return rescaleSpan(span, end2, end2);
  }
  switch (span.type) {
    case "linear": {
      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);
      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;
      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;
      return { type: "linear", moveTo, x0, y0, x1, y1 };
    }
    case "step":
      if (x1 <= span.stepX) {
        const y = span.y0;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };
      } else if (x0 >= span.stepX) {
        const y = span.y1;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };
      } else {
        const { y0, y1, stepX } = span;
        return { type: "step", moveTo, x0, y0, x1, y1, stepX };
      }
    case "cubic": {
      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);
      let [_unused, bezier] = splitBezier2D(
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        t0
      );
      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);
      [bezier, _unused] = splitBezier2D(
        bezier[0].x,
        bezier[0].y,
        bezier[1].x,
        bezier[1].y,
        bezier[2].x,
        bezier[2].y,
        bezier[3].x,
        bezier[3].y,
        t1
      );
      return {
        type: "cubic",
        moveTo,
        cp0x: bezier[0].x,
        cp0y: bezier[0].y,
        cp1x: bezier[1].x,
        cp1y: bezier[1].y,
        cp2x: bezier[2].x,
        cp2y: bezier[2].y,
        cp3x: bezier[3].x,
        cp3y: bezier[3].y
      };
    }
  }
}
function linearPoints(points) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      spans.push({ type: "linear", moveTo, x0, y0, x1, y1 });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var lineSteps = {
  start: 0,
  middle: 0.5,
  end: 1
};
function stepPoints(points, position) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  const p0 = typeof position === "number" ? position : lineSteps[position];
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      const stepX = x0 + (x1 - x0) * p0;
      spans.push({ type: "step", moveTo, x0, y0, x1, y1, stepX });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var flatnessRatio = 0.05;
function smoothPoints(iPoints, tension) {
  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);
  if (points.length <= 1)
    return [];
  const gradients = points.map((c, i) => {
    const p = i === 0 ? c : points[i - 1];
    const n = i === points.length - 1 ? c : points[i + 1];
    const isTerminalPoint = i === 0 || i === points.length - 1;
    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {
      return 0;
    }
    if (!isTerminalPoint) {
      const range4 = Math.abs(p.y - n.y);
      const prevRatio = Math.abs(c.y - p.y) / range4;
      const nextRatio = Math.abs(c.y - n.y) / range4;
      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {
        return 0;
      }
    }
    return (n.y - p.y) / (n.x - p.x);
  });
  if (gradients[1] === 0) {
    gradients[0] *= 2;
  }
  if (gradients[gradients.length - 2] === 0) {
    gradients[gradients.length - 1] *= 2;
  }
  const spans = [];
  for (let i = 1; i < points.length; i += 1) {
    const prev = points[i - 1];
    const prevM = gradients[i - 1];
    const cur = points[i];
    const curM = gradients[i];
    const dx2 = cur.x - prev.x;
    const dy2 = cur.y - prev.y;
    let dcp1x = dx2 * tension / 3;
    let dcp1y = dx2 * prevM * tension / 3;
    let dcp2x = dx2 * tension / 3;
    let dcp2y = dx2 * curM * tension / 3;
    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy2)) {
      dcp1x *= Math.abs(dy2 / dcp1y);
      dcp1y = Math.sign(dcp1y) * Math.abs(dy2);
    }
    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy2)) {
      dcp2x *= Math.abs(dy2 / dcp2y);
      dcp2y = Math.sign(dcp2y) * Math.abs(dy2);
    }
    spans.push({
      type: "cubic",
      moveTo: i === 1,
      cp0x: prev.x,
      cp0y: prev.y,
      cp1x: prev.x + dcp1x,
      cp1y: prev.y + dcp1y,
      cp2x: cur.x - dcp2x,
      cp2y: cur.y - dcp2y,
      cp3x: cur.x,
      cp3y: cur.y
    });
  }
  return spans;
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts
function lerp2(a, b, ratio2) {
  return (b - a) * ratio2 + a;
}
function linearSupertype(span, stepX) {
  const { x0, y0, x1, y1 } = span;
  const m = (y1 - y0) / (x1 - x0);
  const stepY = m * (stepX - x0) + y0;
  return {
    leftCp1x: x0,
    leftCp1y: y0,
    leftCp2x: stepX,
    leftCp2y: stepY,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: stepX,
    rightCp1y: stepY,
    rightCp2x: x1,
    rightCp2y: y1
  };
}
function bezierSupertype(span, stepX) {
  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;
  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);
  const [left, right] = splitBezier2D(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);
  const stepY = left[3].y;
  return {
    leftCp1x: left[1].x,
    leftCp1y: left[1].y,
    leftCp2x: left[2].x,
    leftCp2y: left[2].y,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: right[1].x,
    rightCp1y: right[1].y,
    rightCp2x: right[2].x,
    rightCp2y: right[2].y
  };
}
function stepSupertype(span) {
  const { x0, y0, x1, y1, stepX } = span;
  return {
    leftCp1x: (x0 + stepX) / 2,
    leftCp1y: y0,
    leftCp2x: (x0 + stepX) / 2,
    leftCp2y: y0,
    stepX,
    stepY0: y0,
    stepY1: y1,
    rightCp1x: (stepX + x1) / 2,
    rightCp1y: y1,
    rightCp2x: (stepX + x1) / 2,
    rightCp2y: y1
  };
}
function spanSupertype(span, stepX) {
  if (span.type === "linear") {
    return linearSupertype(span, stepX);
  } else if (span.type === "cubic") {
    return bezierSupertype(span, stepX);
  } else {
    return stepSupertype(span);
  }
}
function plotStart(path, moveTo, x0, y0, x1, y1, reversed) {
  switch (moveTo) {
    case 0 /* MoveTo */:
      if (reversed) {
        path.moveTo(x1, y1);
      } else {
        path.moveTo(x0, y0);
      }
      break;
    case 1 /* LineTo */:
      if (reversed) {
        path.lineTo(x1, y1);
      } else {
        path.lineTo(x0, y0);
      }
      break;
  }
}
function plotLinear(path, x0, y0, x1, y1, reversed) {
  if (reversed) {
    path.lineTo(x0, y0);
  } else {
    path.lineTo(x1, y1);
  }
}
function plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {
  if (reversed) {
    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);
  } else {
    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
  }
}
function plotStep(path, x0, y0, x1, y1, stepX, reversed) {
  if (reversed) {
    path.lineTo(stepX, y1);
    path.lineTo(stepX, y0);
    path.lineTo(x0, y0);
  } else {
    path.lineTo(stepX, y0);
    path.lineTo(stepX, y1);
    path.lineTo(x1, y1);
  }
}
function plotSpan(path, span, moveTo, reversed) {
  const [start2, end2] = spanRange(span);
  plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);
  switch (span.type) {
    case "linear":
      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);
      break;
    case "cubic":
      plotCubic(
        path,
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        reversed
      );
      break;
    case "step":
      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);
      break;
  }
}
function interpolatedSpanRange(a, b, ratio2) {
  const [aStart, aEnd] = spanRange(a);
  const [bStart, bEnd] = spanRange(b);
  const x0 = lerp2(aStart.x, bStart.x, ratio2);
  const y0 = lerp2(aStart.y, bStart.y, ratio2);
  const x1 = lerp2(aEnd.x, bEnd.x, ratio2);
  const y1 = lerp2(aEnd.y, bEnd.y, ratio2);
  return [
    { x: x0, y: y0 },
    { x: x1, y: y1 }
  ];
}
function plotInterpolatedSpans(path, a, b, ratio2, moveTo, reversed) {
  const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = interpolatedSpanRange(a, b, ratio2);
  plotStart(path, moveTo, x0, y0, x1, y1, reversed);
  if (a.type === "cubic" && b.type === "cubic") {
    const cp1x = lerp2(a.cp1x, b.cp1x, ratio2);
    const cp1y = lerp2(a.cp1y, b.cp1y, ratio2);
    const cp2x = lerp2(a.cp2x, b.cp2x, ratio2);
    const cp2y = lerp2(a.cp2y, b.cp2y, ratio2);
    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);
  } else if (a.type === "step" && b.type === "step") {
    const stepX = lerp2(a.stepX, b.stepX, ratio2);
    plotStep(path, x0, y0, x1, y1, stepX, reversed);
  } else if (a.type === "linear" && b.type === "linear") {
    plotLinear(path, x0, y0, x1, y1, reversed);
  } else {
    let defaultStepX;
    if (a.type === "step") {
      defaultStepX = a.stepX;
    } else if (b.type === "step") {
      defaultStepX = b.stepX;
    } else {
      defaultStepX = (x0 + x1) / 2;
    }
    const as = spanSupertype(a, defaultStepX);
    const bs = spanSupertype(b, defaultStepX);
    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio2);
    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio2);
    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio2);
    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio2);
    const stepX = lerp2(as.stepX, bs.stepX, ratio2);
    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio2);
    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio2);
    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio2);
    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio2);
    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio2);
    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio2);
    if (reversed) {
      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);
      path.lineTo(stepX, stepY0);
      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);
    } else {
      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);
      path.lineTo(stepX, stepY1);
      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);
    }
  }
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts
var MAX_CATEGORIES = 1e3;
var CollapseMode = /* @__PURE__ */ ((CollapseMode3) => {
  CollapseMode3[CollapseMode3["Zero"] = 0] = "Zero";
  CollapseMode3[CollapseMode3["Split"] = 1] = "Split";
  return CollapseMode3;
})(CollapseMode || {});
function integratedCategoryMatch(a, b) {
  if (a == null || b == null)
    return false;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if ("id" in a && "id" in b) {
    return a.id === b.id;
  }
  return a.toString() === b.toString();
}
function toAxisValue(value) {
  return transformIntegratedCategoryValue(value).valueOf();
}
function scale(val, scaling) {
  if (!scaling)
    return NaN;
  if (val instanceof Date) {
    val = val.getTime();
  }
  if (scaling.type === "continuous" && typeof val === "number") {
    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
  }
  if (scaling.type === "log" && typeof val === "number") {
    return scaling.convert(val);
  }
  if (scaling.type !== "category")
    return NaN;
  const axisValue = toAxisValue(val);
  let matchingIndex = scaling.domain.findIndex((d) => toAxisValue(d) === axisValue);
  if (matchingIndex === -1) {
    matchingIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));
  }
  if (matchingIndex >= 0) {
    return scaling.inset + scaling.step * matchingIndex;
  }
  return NaN;
}
function getAxisIndices({ data }, values) {
  return data.map((datum, datumIndex) => ({
    xValue0Index: values.indexOf(toAxisValue(datum.xValue0)),
    xValue1Index: values.indexOf(toAxisValue(datum.xValue1)),
    datumIndex
  }));
}
function isValidScaling(data) {
  return Object.values(data.scales).every((s) => {
    if (s.type === "category") {
      return s.domain.length < MAX_CATEGORIES;
    }
    return true;
  });
}
function validateCategorySorting(newData, oldData) {
  const oldScale = oldData.scales.x;
  const newScale = newData.scales.x;
  if (oldScale?.type !== "category" || newScale?.type !== "category")
    return true;
  let x0 = -Infinity;
  for (const oldValue of oldScale.domain) {
    const x = scale(oldValue, newScale);
    if (!Number.isFinite(x))
      continue;
    if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function validateAxisEntriesOrder(axisValues, data) {
  let x0 = -Infinity;
  for (const axisValue of axisValues) {
    const x = scale(axisValue.value, data.scales.x);
    if (!Number.isFinite(x))
      continue;
    if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function spanAxisContext(newData, oldData) {
  const allAxisEntries = /* @__PURE__ */ new Map();
  for (const { xValue0, xValue1 } of newData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    allAxisEntries.set(xValue0Value, xValue0).set(xValue1Value, xValue1);
  }
  const newAxisEntries = Array.from(allAxisEntries, ([axisValue, value]) => ({ axisValue, value }));
  newAxisEntries.sort((a, b) => {
    return scale(a.value, newData.scales.x) - scale(b.value, newData.scales.x);
  });
  const exclusivelyOldAxisEntries = [];
  for (const { xValue0, xValue1 } of oldData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    if (!allAxisEntries.has(xValue0Value)) {
      allAxisEntries.set(xValue0Value, xValue0);
      exclusivelyOldAxisEntries.push({ axisValue: xValue0Value, value: xValue0 });
    }
    if (!allAxisEntries.has(xValue1Value)) {
      allAxisEntries.set(xValue1Value, xValue1);
      exclusivelyOldAxisEntries.push({ axisValue: xValue1Value, value: xValue1 });
    }
  }
  exclusivelyOldAxisEntries.sort((a, b) => {
    return scale(a.value, oldData.scales.x) - scale(b.value, oldData.scales.x);
  });
  const axisEntries = newAxisEntries;
  let insertionIndex = 0;
  for (const oldAxisEntry of exclusivelyOldAxisEntries) {
    for (let i = axisEntries.length - 1; i >= insertionIndex; i -= 1) {
      const oldValueX = scale(oldAxisEntry.value, oldData.scales.x);
      const newValueX = scale(axisEntries[i].value, oldData.scales.x);
      if (oldValueX > newValueX) {
        insertionIndex = i + 1;
        break;
      }
    }
    axisEntries.splice(insertionIndex, 0, oldAxisEntry);
    insertionIndex += 1;
  }
  if (!validateAxisEntriesOrder(axisEntries, oldData))
    return;
  const axisValues = axisEntries.map((axisEntry) => axisEntry.axisValue);
  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);
  const newDataAxisIndices = getAxisIndices(newData, axisValues);
  return { axisValues, oldDataAxisIndices, newDataAxisIndices };
}
function clipSpan(span, xValue0Index, xIndices) {
  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)
    return span;
  const range4 = spanRange(span);
  const step = (range4[1].x - range4[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);
  const start2 = range4[0].x + (xValue0Index - xIndices.xValue0Index) * step;
  const end2 = start2 + step;
  return clipSpanX(span, start2, end2);
}
function axisZeroSpan(span, data) {
  const [r0, r1] = spanRange(span);
  const y0 = scale(0, data.scales.y);
  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });
}
function collapseSpanToMidpoint(span) {
  const [r0, r1] = spanRange(span);
  return collapseSpanToPoint(span, {
    x: (r0.x + r1.x) / 2,
    y: (r0.y + r1.y) / 2
  });
}
function collapseSpan(span, collapseMode, data, axisIndices, indices, range4) {
  let xValue2;
  let yValue;
  if (indices.xValue0Index >= range4.xValue1Index) {
    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range4.xValue1Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue2 = datum?.xValue1;
    yValue = datum?.yValue1;
  } else if (indices.xValue0Index <= range4.xValue0Index) {
    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range4.xValue0Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue2 = datum?.xValue0;
    yValue = datum?.yValue0;
  }
  if (xValue2 == null || yValue == null) {
    switch (collapseMode) {
      case 0 /* Zero */:
        return axisZeroSpan(span, data);
      case 1 /* Split */:
        return collapseSpanToMidpoint(span);
    }
  }
  const x = scale(xValue2, data.scales.x);
  const y = scale(yValue, data.scales.y);
  const point = { x, y };
  return rescaleSpan(span, point, point);
}
function zeroDataSpan(spanDatum, zeroData) {
  if (zeroData == null)
    return;
  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);
  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);
  return zeroData.find(
    (zeroSpanDatum) => toAxisValue(zeroSpanDatum.xValue0) === newSpanXValue0 && toAxisValue(zeroSpanDatum.xValue1) === newSpanXValue1
  )?.span;
}
function addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range4, out) {
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const newSpan = newSpanDatum.span;
  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: zeroSpan, to: zeroSpan });
    out.moved.push({ from: zeroSpan, to: newSpan });
    out.added.push({ from: newSpan, to: newSpan });
  } else {
    const oldSpan = collapseSpan(newSpan, collapseMode, newData, newAxisIndices, newIndices, range4);
    out.added.push({ from: oldSpan, to: newSpan });
  }
}
function removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range4, out) {
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const oldSpan = oldSpanDatum.span;
  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: oldSpan, to: oldSpan });
    out.moved.push({ from: oldSpan, to: zeroSpan });
    out.added.push({ from: zeroSpan, to: zeroSpan });
  } else {
    const newSpan = collapseSpan(oldSpan, collapseMode, oldData, oldAxisIndices, oldIndices, range4);
    out.removed.push({ from: oldSpan, to: newSpan });
  }
}
function alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {
  const startXValue0 = axisValues[postSpanIndices.xValue0Index];
  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);
  const endXValue1 = axisValues[postSpanIndices.xValue1Index];
  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);
  if (startDatum == null || endDatum == null)
    return;
  const [{ x: x0 }, { x: x1 }] = spanRange(span);
  const startX = scale(startDatum.xValue0, preData.scales.x);
  const startY = scale(startDatum.yValue0, preData.scales.y);
  const endX = scale(endDatum.xValue1, preData.scales.x);
  const endY = scale(endDatum.yValue1, preData.scales.y);
  let altSpan = postData.data[postSpanIndices.datumIndex].span;
  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });
  altSpan = clipSpanX(altSpan, x0, x1);
  return altSpan;
}
function appendSpanPhases(newData, oldData, collapseMode, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range4, out) {
  const xValue1Index = xValue0Index + 1;
  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const oldZeroData = oldData.zeroData;
  const newZeroData = newData.zeroData;
  if (oldIndices == null && newIndices != null) {
    addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range4, out);
    return;
  } else if (oldIndices != null && newIndices == null) {
    removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range4, out);
    return;
  } else if (oldIndices == null || newIndices == null) {
    return;
  }
  let ordering;
  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {
    ordering = 0;
  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {
    ordering = -1;
  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {
    ordering = 1;
  } else {
    ordering = 0;
  }
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);
  if (ordering === 1) {
    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(
      clippedOldSpanOldScale,
      axisValues,
      oldData,
      newData,
      newIndices
    );
    if (clippedPostRemoveOldSpanOldScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });
      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });
      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range4, out);
    }
  } else if (ordering === -1) {
    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(
      clippedNewSpanNewScale,
      axisValues,
      newData,
      oldData,
      oldIndices
    );
    if (clippedPreAddedNewSpanNewScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });
      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range4, out);
    }
  } else {
    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });
    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
  }
}
function phaseAnimation(axisContext, newData, oldData, collapseMode) {
  const out = {
    removed: [],
    moved: [],
    added: []
  };
  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;
  const range4 = {
    xValue0Index: Math.max(
      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,
      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity
    ),
    xValue1Index: Math.min(
      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,
      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity
    )
  };
  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {
    appendSpanPhases(
      newData,
      oldData,
      collapseMode,
      axisValues,
      xValue0Index,
      newDataAxisIndices,
      oldDataAxisIndices,
      range4,
      out
    );
  }
  return out;
}
function resetSpan(data, spanDatum, collapseMode) {
  const { span } = spanDatum;
  switch (collapseMode) {
    case 0 /* Zero */:
      return zeroDataSpan(spanDatum, data.zeroData) ?? axisZeroSpan(span, data);
    case 1 /* Split */:
      return collapseSpanToMidpoint(span);
  }
}
function resetAnimation(newData, oldData, collapseMode) {
  const added = [];
  const removed = [];
  for (const oldSpanDatum of oldData.data) {
    const oldSpan = oldSpanDatum.span;
    const collapsedSpan = resetSpan(oldData, oldSpanDatum, collapseMode);
    removed.push({ from: oldSpan, to: collapsedSpan });
  }
  for (const newSpanDatum of newData.data) {
    const newSpan = newSpanDatum.span;
    const collapsedSpan = resetSpan(newData, newSpanDatum, collapseMode);
    added.push({ from: collapsedSpan, to: newSpan });
  }
  return {
    removed,
    moved: [],
    added
  };
}
function pairUpSpans(newData, oldData, collapseMode) {
  if (!isValidScaling(newData) || !isValidScaling(oldData))
    return;
  if (!validateCategorySorting(newData, oldData))
    return;
  const axisContext = spanAxisContext(newData, oldData);
  return axisContext == null ? resetAnimation(newData, oldData, collapseMode) : phaseAnimation(axisContext, newData, oldData, collapseMode);
}

// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts
function isContinuousScaling(scaling) {
  return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
  return scaling.type === "category";
}
function areScalingEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a !== void 0 || b !== void 0;
  }
  if (isContinuousScaling(a) && isContinuousScaling(b)) {
    return a.type === b.type && arraysEqual(a.domain, b.domain) && arraysEqual(a.range, b.range);
  }
  if (isCategoryScaling(a) && isCategoryScaling(b)) {
    return a.inset === b.inset && a.step === b.step && arraysEqual(a.domain, b.domain);
  }
  return false;
}
function isScaleValid(scale2) {
  if (scale2 == null)
    return false;
  if (scale2.type === "category")
    return scale2.domain.every((v) => v != null);
  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date) && scale2.range.every((v) => Number.isFinite(v));
}

// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function interpolatePoints(points, interpolation) {
  let spans;
  const pointsIter = points.map((point) => point.point);
  switch (interpolation.type) {
    case "linear":
      spans = linearPoints(pointsIter);
      break;
    case "smooth":
      spans = smoothPoints(pointsIter, interpolation.tension);
      break;
    case "step":
      spans = stepPoints(pointsIter, interpolation.position);
      break;
  }
  return spans.map((span, i) => ({
    span,
    xValue0: points[i].xDatum,
    yValue0: points[i].yDatum,
    xValue1: points[i + 1].xDatum,
    yValue1: points[i + 1].yDatum
  }));
}
function pointsEq(a, b, delta4 = 1e-3) {
  return Math.abs(a.x - b.x) < delta4 && Math.abs(a.y - b.y) < delta4;
}
function plotLinePathStroke({ path }, spans) {
  let lastPoint;
  for (const { span } of spans) {
    const [start2, end2] = spanRange(span);
    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;
    plotSpan(path, span, join, false);
    lastPoint = end2;
  }
}
function plotInterpolatedLinePathStroke(ratio2, path, spans) {
  let lastPoint;
  for (const span of spans) {
    const [start2, end2] = interpolatedSpanRange(span.from, span.to, ratio2);
    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;
    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, join, false);
    lastPoint = end2;
  }
}
function prepareLinePathStrokeAnimationFns(status, spans, visibleToggleMode) {
  const removePhaseFn = (ratio2, path) => plotInterpolatedLinePathStroke(ratio2, path, spans.removed);
  const updatePhaseFn = (ratio2, path) => plotInterpolatedLinePathStroke(ratio2, path, spans.moved);
  const addPhaseFn = (ratio2, path) => plotInterpolatedLinePathStroke(ratio2, path, spans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
  const phase = visibleToggleMode === "none" ? "updated" : status;
  const result = {
    fromFn: (_path) => {
      let mixin;
      if (status === "removed") {
        mixin = { finish: { visible: false } };
      } else if (status === "added") {
        mixin = { start: { visible: true } };
      } else {
        mixin = {};
      }
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };
    },
    toFn: (_path) => {
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };
    }
  };
  if (visibleToggleMode === "fade") {
    return {
      fromFn: (path) => {
        const opacity = status === "added" ? 0 : path.opacity;
        return { opacity, ...result.fromFn(path) };
      },
      toFn: (path) => {
        const opacity = status === "removed" ? 0 : 1;
        return { opacity, ...result.toFn(path) };
      }
    };
  }
  return result;
}
function prepareLinePathAnimation(newData, oldData, diff8) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  if (newData.strokeData == null || oldData.strokeData == null) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const strokeSpans = pairUpSpans(
    { scales: newData.scales, data: newData.strokeData.spans },
    { scales: oldData.scales, data: oldData.strokeData.spans },
    1 /* Split */
  );
  if (strokeSpans == null)
    return;
  const stroke3 = prepareLinePathStrokeAnimationFns(status, strokeSpans, "fade");
  const hasMotion = (diff8?.changed ?? true) || !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y) || status !== "updated";
  return { status, stroke: stroke3, hasMotion };
}

// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
function plotAreaPathFill({ path }, { spans, phantomSpans }) {
  let phantomSpanIndex = 0;
  let sp = { x: NaN, y: NaN };
  let pp = { x: NaN, y: NaN };
  for (let i = 0; i < spans.length; i += 1) {
    const { span } = spans[i];
    const { span: phantomSpan } = phantomSpans[i];
    const { 0: sp0, 1: sp1 } = spanRange(span);
    const { 0: pp0, 1: pp1 } = spanRange(phantomSpan);
    if (pointsEq(sp, sp0) && pointsEq(pp, pp0)) {
      plotSpan(path, span, 1 /* LineTo */, false);
    } else {
      for (let j = i - 1; j >= phantomSpanIndex; j -= 1) {
        plotSpan(path, phantomSpans[j].span, 1 /* LineTo */, true);
      }
      path.closePath();
      plotSpan(path, span, 0 /* MoveTo */, false);
      phantomSpanIndex = i;
    }
    sp = sp1;
    pp = pp1;
  }
  for (let j = spans.length - 1; j >= phantomSpanIndex; j -= 1) {
    plotSpan(path, phantomSpans[j].span, 1 /* LineTo */, true);
  }
  path.closePath();
}
function plotInterpolatedAreaSeriesFillSpans(ratio2, { path }, spans, fillPhantomSpans) {
  for (let i = 0; i < spans.length; i += 1) {
    const span = spans[i];
    const reversedPhantomSpan = fillPhantomSpans[i];
    plotInterpolatedSpans(path, span.from, span.to, ratio2, 0 /* MoveTo */, false);
    plotInterpolatedSpans(path, reversedPhantomSpan.from, reversedPhantomSpan.to, ratio2, 1 /* LineTo */, true);
    path.closePath();
  }
}
function prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {
  const removePhaseFn = (ratio2, path) => plotInterpolatedAreaSeriesFillSpans(ratio2, path, spans.removed, fillPhantomSpans.removed);
  const updatePhaseFn = (ratio2, path) => plotInterpolatedAreaSeriesFillSpans(ratio2, path, spans.moved, fillPhantomSpans.moved);
  const addPhaseFn = (ratio2, path) => plotInterpolatedAreaSeriesFillSpans(ratio2, path, spans.added, fillPhantomSpans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareAreaPathAnimation(newData, oldData) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const fillSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.spans },
    { scales: oldData.scales, data: oldData.fillData.spans },
    0 /* Zero */
  );
  if (fillSpans == null)
    return;
  const fillPhantomSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.phantomSpans },
    { scales: oldData.scales, data: oldData.fillData.phantomSpans },
    0 /* Zero */
  );
  if (fillPhantomSpans == null)
    return;
  const strokeSpans = pairUpSpans(
    {
      scales: newData.scales,
      data: newData.strokeData.spans,
      zeroData: newData.fillData.phantomSpans
    },
    {
      scales: oldData.scales,
      data: oldData.strokeData.spans,
      zeroData: oldData.fillData.phantomSpans
    },
    0 /* Zero */
  );
  if (strokeSpans == null)
    return;
  const fadeMode = "none";
  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);
  const stroke3 = prepareLinePathStrokeAnimationFns(status, strokeSpans, fadeMode);
  return { status, fill, stroke: stroke3 };
}

// packages/ag-charts-community/src/chart/series/aggregation.ts
var AGGREGATION_INDEX_X_MIN = 0;
var AGGREGATION_INDEX_X_MAX = 1;
var AGGREGATION_INDEX_Y_MIN = 2;
var AGGREGATION_INDEX_Y_MAX = 3;
var AGGREGATION_SPAN = 4;
function aggregationRangeFittingPoints(data) {
  let power = Math.ceil(Math.log2(data.length)) - 1;
  power = Math.min(Math.max(power, 0), 24);
  return 2 ** power | 0;
}
function aggregationDomain(scale2, domain) {
  switch (scale2) {
    case "category":
      return [NaN, NaN];
    case "number":
    case "time":
    case "ordinal-time":
    case "unit-time": {
      let min = Infinity;
      let max = -Infinity;
      for (const d of domain) {
        const value = Number(d);
        min = Math.min(min, value);
        max = Math.max(max, value);
      }
      return [min, max];
    }
    case "color":
    case "log":
    case "mercator":
      return [0, 0];
  }
}
function aggregationXRatioForDatumIndex(datumIndex, domainCount) {
  return datumIndex / domainCount;
}
function aggregationXRatioForXValue(xValue2, d0, d1) {
  return (xValue2.valueOf() - d0) / (d1 - d0);
}
function aggregationIndexForXRatio(xRatio, maxRange) {
  return Math.min(Math.floor(xRatio * maxRange), maxRange - 1) * AGGREGATION_SPAN | 0;
}
function createAggregationIndices(xValues, yMaxValues, yMinValues, d0, d1, maxRange) {
  const indexData = new Int32Array(maxRange * AGGREGATION_SPAN).fill(-1);
  const valueData = new Float64Array(maxRange * AGGREGATION_SPAN).fill(NaN);
  const continuous = Number.isFinite(d0) && Number.isFinite(d1);
  const domainCount = xValues.length;
  for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
    const xValue2 = xValues[datumIndex];
    if (xValue2 == null)
      continue;
    const xRatio = continuous ? aggregationXRatioForXValue(xValue2, d0, d1) : aggregationXRatioForDatumIndex(datumIndex, domainCount);
    const aggIndex = aggregationIndexForXRatio(xRatio, maxRange);
    const yMaxValue = yMaxValues[datumIndex];
    const yMinValue = yMinValues[datumIndex];
    const yMax = yMaxValue != null ? yMaxValue.valueOf() : NaN;
    const yMin = yMinValue != null ? yMinValue.valueOf() : NaN;
    const unset = indexData[aggIndex + AGGREGATION_INDEX_X_MIN] === -1;
    if (unset || xRatio < valueData[aggIndex + AGGREGATION_INDEX_X_MIN]) {
      indexData[aggIndex + AGGREGATION_INDEX_X_MIN] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_X_MIN] = xRatio;
    }
    if (unset || xRatio > valueData[aggIndex + AGGREGATION_INDEX_X_MAX]) {
      indexData[aggIndex + AGGREGATION_INDEX_X_MAX] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_X_MAX] = xRatio;
    }
    if (!Number.isNaN(yMin) && (unset || yMin < valueData[aggIndex + AGGREGATION_INDEX_Y_MIN])) {
      indexData[aggIndex + AGGREGATION_INDEX_Y_MIN] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_Y_MIN] = yMin;
    }
    if (!Number.isNaN(yMax) && (unset || yMax > valueData[aggIndex + AGGREGATION_INDEX_Y_MAX])) {
      indexData[aggIndex + AGGREGATION_INDEX_Y_MAX] = datumIndex;
      valueData[aggIndex + AGGREGATION_INDEX_Y_MAX] = yMax;
    }
  }
  return { indexData, valueData };
}
function compactAggregationIndices(indexData, valueData, maxRange, { inPlace = false } = {}) {
  const nextMaxRange = maxRange / 2 | 0;
  const nextIndexData = !inPlace ? new Int32Array(nextMaxRange * AGGREGATION_SPAN) : indexData;
  const nextValueData = !inPlace ? new Float64Array(nextMaxRange * AGGREGATION_SPAN) : valueData;
  for (let i = 0; i < nextMaxRange; i += 1) {
    const aggIndex = i * AGGREGATION_SPAN | 0;
    const index0 = aggIndex * 2 | 0;
    const index1 = index0 + AGGREGATION_SPAN | 0;
    const index1Unset = indexData[index1 + AGGREGATION_INDEX_X_MIN] === -1;
    const xMinAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_X_MIN] < valueData[index1 + AGGREGATION_INDEX_X_MIN] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_X_MIN] = indexData[xMinAggIndex + AGGREGATION_INDEX_X_MIN];
    nextValueData[aggIndex + AGGREGATION_INDEX_X_MIN] = valueData[xMinAggIndex + AGGREGATION_INDEX_X_MIN];
    const xMaxAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_X_MAX] > valueData[index1 + AGGREGATION_INDEX_X_MAX] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_X_MAX] = indexData[xMaxAggIndex + AGGREGATION_INDEX_X_MAX];
    nextValueData[aggIndex + AGGREGATION_INDEX_X_MAX] = valueData[xMaxAggIndex + AGGREGATION_INDEX_X_MAX];
    const yMinAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_Y_MIN] < valueData[index1 + AGGREGATION_INDEX_Y_MIN] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_Y_MIN] = indexData[yMinAggIndex + AGGREGATION_INDEX_Y_MIN];
    nextValueData[aggIndex + AGGREGATION_INDEX_Y_MIN] = valueData[yMinAggIndex + AGGREGATION_INDEX_Y_MIN];
    const yMaxAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_Y_MAX] > valueData[index1 + AGGREGATION_INDEX_Y_MAX] ? index0 : index1;
    nextIndexData[aggIndex + AGGREGATION_INDEX_Y_MAX] = indexData[yMaxAggIndex + AGGREGATION_INDEX_Y_MAX];
    nextValueData[aggIndex + AGGREGATION_INDEX_Y_MAX] = valueData[yMaxAggIndex + AGGREGATION_INDEX_Y_MAX];
  }
  return { maxRange: nextMaxRange, indexData: nextIndexData, valueData: nextValueData };
}

// packages/ag-charts-community/src/chart/series/cartesian/lineAggregation.ts
var AGGREGATION_THRESHOLD = 1e3;
var MAX_POINTS = 10;
function aggregationContainsIndex(xValues, d0, d1, indexData, maxRange, datumIndex) {
  const xValue2 = xValues[datumIndex];
  if (xValue2 == null)
    return false;
  const xRatio = Number.isFinite(d0) ? aggregationXRatioForXValue(xValue2, d0, d1) : aggregationXRatioForDatumIndex(datumIndex, xValues.length);
  const aggIndex = aggregationIndexForXRatio(xRatio, maxRange);
  return datumIndex === indexData[aggIndex + AGGREGATION_INDEX_X_MIN] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_X_MAX] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MIN] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MAX];
}
function aggregateLineData(scale2, xValues, yValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD)
    return;
  const [d0, d1] = aggregationDomain(scale2, domain);
  let maxRange = aggregationRangeFittingPoints(xValues);
  const { indexData, valueData } = createAggregationIndices(xValues, yValues, yValues, d0, d1, maxRange);
  let indices = [];
  for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
    if (aggregationContainsIndex(xValues, d0, d1, indexData, maxRange, datumIndex)) {
      indices.push(datumIndex);
    }
  }
  const filters = [{ maxRange, indices }];
  while (indices.length > MAX_POINTS && maxRange > 64) {
    ({ maxRange } = compactAggregationIndices(indexData, valueData, maxRange, { inPlace: true }));
    indices = indices.filter(aggregationContainsIndex.bind(null, xValues, d0, d1, indexData, maxRange));
    filters.push({ maxRange, indices });
  }
  filters.reverse();
  return filters;
}

// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts
function markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {
  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing" };
  staticFromToMotion(id, "markers", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);
  markerSelections.forEach((s) => s.cleanup());
}
function markerScaleInAnimation({ id }, animationManager, ...markerSelections) {
  staticFromToMotion(
    id,
    "markers",
    animationManager,
    markerSelections,
    { scalingX: 0, scalingY: 0 },
    { scalingX: 1, scalingY: 1 },
    { phase: "initial" }
  );
  markerSelections.forEach((s) => s.cleanup());
}
function markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {
  const seriesWidth = nodeDataDependencies.seriesRectWidth;
  const fromFn = (_, datum) => {
    const x = datum.midPoint?.x ?? seriesWidth;
    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);
    if (isNaN(delay)) {
      delay = 0;
    }
    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: "initial" };
  };
  const toFn = () => {
    return { scalingX: 1, scalingY: 1 };
  };
  fromToMotion(id, "markers", animationManager, markerSelections, { fromFn, toFn });
}
function resetMarkerFn(_node) {
  return { opacity: 1, scalingX: 1, scalingY: 1 };
}
function resetMarkerPositionFn(_node, datum) {
  return {
    x: datum.point?.x ?? NaN,
    y: datum.point?.y ?? NaN,
    scalingCenterX: datum.point?.x ?? NaN,
    scalingCenterY: datum.point?.y ?? NaN
  };
}
function computeMarkerFocusBounds(series, { datumIndex }) {
  const nodeData = series.getNodeData();
  if (nodeData === void 0)
    return void 0;
  const datum = nodeData[datumIndex];
  const { point } = datum ?? {};
  if (datum == null || point == null)
    return void 0;
  const style2 = series.getFormattedMarkerStyle(datum);
  const anchor = Marker.anchor(style2.shape);
  const size = point.focusSize ?? style2.size;
  const paddedSize = 4 + size;
  const paddedRadius = paddedSize / 2;
  const anchorX = (anchor.x - 0.5) * size;
  const anchorY = (anchor.y - 0.5) * size;
  const x = datum.point.x - paddedRadius - anchorX;
  const y = datum.point.y - paddedRadius - anchorY;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, paddedSize, paddedSize));
}

// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {
  const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;
  staticFromToMotion(
    id,
    "path_properties",
    animationManager,
    paths,
    { clipX: 0 },
    { clipX: width2 },
    {
      phase: "initial",
      start: { clip: true, clipY: height2, visible },
      finish: { clip: false, visible }
    }
  );
}
function pathFadeInAnimation({ id }, subId, animationManager, phase = "add", ...selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });
}
function buildResetPathFn(opts) {
  return (_node) => ({
    visible: opts.getVisible(),
    opacity: opts.getOpacity(),
    clipScalingX: 1,
    clip: false
  });
}
function updateClipPath({ nodeDataDependencies }, path) {
  const toFinite = (value) => isFinite(value) ? value : 0;
  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;
var CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;
var memoizedAggregateLineData = simpleMemorize2(aggregateLineData);
var AreaSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pathsPerSeries: ["fill", "stroke"],
      pathsZIndexSubOrderOffset: [0, 1e3],
      datumSelectionGarbageCollection: false,
      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        datum: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new AreaSeriesProperties();
    this.connectsToYAxis = true;
    this.dataAggregationFilters = void 0;
    this.backgroundGroup = new Group({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this._isStacked = void 0;
  }
  get pickModeAxis() {
    return "main";
  }
  renderToOffscreenCanvas() {
    return super.renderToOffscreenCanvas() || this.contextNodeData != null && (this.contextNodeData.fillData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD || this.contextNodeData.strokeData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD);
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  attachPaths([fill, stroke3]) {
    this.backgroundGroup.appendChild(fill);
    this.contentGroup.appendChild(stroke3);
    stroke3.zIndex = -1;
  }
  detachPaths([fill, stroke3]) {
    this.backgroundGroup.removeChild(fill);
    this.contentGroup.removeChild(stroke3);
  }
  isStacked() {
    const stackCount = this.seriesGrouping?.stackCount ?? 1;
    return stackCount > 1;
  }
  setSeriesIndex(index) {
    const isStacked = this.isStacked();
    const isStackedChanged = isStacked === this._isStacked;
    this._isStacked = isStackedChanged;
    return super.setSeriesIndex(index, isStackedChanged);
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    if (this.isStacked()) {
      this.backgroundGroup.zIndex = [0 /* BACKGROUND */, zIndex];
      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */];
    } else {
      this.backgroundGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */, 0];
      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, zIndex, 0 /* FOREGROUND */, 1];
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stacked = stackCount > 1 || normalizedTo != null;
    const idMap = {
      value: `area-stack-${groupIndex}-yValue`,
      values: `area-stack-${groupIndex}-yValues`,
      stack: `area-stack-${groupIndex}-yValue-stack`,
      marker: `area-stack-${groupIndex}-yValues-marker`
    };
    const common = { invalidValue: null };
    if ((isDefined(normalizedTo) || connectMissingData) && stackCount > 1) {
      common.invalidValue = 0;
    }
    if (!visible) {
      common.forceValue = 0;
    }
    const props = [
      keyProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),
      ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" })] : [],
      ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),
      valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value })
    ];
    if (stacked) {
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: idMap.values },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: idMap.marker },
          yScaleType
        )
      );
    }
    if (isDefined(normalizedTo)) {
      props.push(normaliseGroupTo(Object.values(idMap), normalizedTo));
    }
    if (animationEnabled) {
      props.push(animationValidation());
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: stacked,
      groupByData: !stacked
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue2, pixelSize) {
    const { marker } = this.properties;
    const x = this.axes["x" /* X */].scale.convert(xValue2);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const { marker } = this.properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [y - r, y + r];
  }
  yCumulativeKey(processData) {
    return processData.type === "grouped" ? "yValueCumulative" : "yValue";
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!processedData || !dataModel)
      return [];
    const yAxis = axes["y" /* Y */];
    if (direction === "x" /* X */) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent(extent(keys));
    }
    const yExtent = this.domainForClippedRange(
      "y" /* Y */,
      [this.yCumulativeKey(processedData)],
      "xValue"
    );
    if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]] : [];
      return fixNumericExtent(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    const [y0, y1] = this.domainForVisibleRange(
      "y" /* Y */,
      [this.yCumulativeKey(this.processedData)],
      "xValue",
      visibleRange
    );
    return [Math.min(y0, 0), Math.max(y1, 0)];
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    return this.countVisibleItems(
      "xValue",
      [this.yCumulativeKey(this.processedData)],
      xVisibleRange,
      yVisibleRange,
      minVisibleItems
    );
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type === "grouped")
      return;
    if (processedDataIsAnimatable(processedData))
      return;
    const xAxis = this.axes["x" /* X */];
    if (xAxis == null)
      return;
    const { scale: scale2 } = xAxis;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
    return memoizedAggregateLineData(scale2.type, xValues, yValues, domain);
  }
  createNodeData() {
    const { axes, data, processedData, dataModel, dataAggregationFilters } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !data || !dataModel || !processedData)
      return;
    const {
      yKey,
      xKey,
      xName,
      yName,
      yFilterKey,
      marker,
      label,
      fill: seriesFill,
      stroke: seriesStroke,
      connectMissingData,
      interpolation
    } = this.properties;
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const stacked = processedData.type === "grouped";
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, `yValueCumulative`, processedData) : yRawValues;
    const yFilterValues = yFilterKey != null ? dataModel.resolveColumnById(this, "yFilterRaw", processedData) : void 0;
    const yStackValues = processedData.type === "grouped" ? dataModel.resolveColumnById(this, "yValueStack", processedData) : void 0;
    const labelData = [];
    const markerData = [];
    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    let crossFiltering = false;
    const { dataSources } = processedData;
    const rawData = dataSources.get(this.id) ?? [];
    const [r0, r1] = xScale.range;
    const range4 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range4);
    let startIndex = 0;
    let endIndex = 0;
    const indices = dataAggregationFilter?.indices;
    [startIndex, endIndex] = this.visibleRangeIndices("xValue", xAxis.range, indices);
    startIndex = Math.max(startIndex - 1, 0);
    endIndex = Math.min(endIndex + 1, indices?.length ?? xValues.length);
    if (processedData.input.count < 1e3) {
      startIndex = 0;
      endIndex = processedData.input.count;
    }
    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {
      let currY;
      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
        currY = yEnd;
      }
      return {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(currY),
        size: marker.size
      };
    };
    const handleDatum = (datumIndex) => {
      const xDatum = xValues[datumIndex];
      if (xDatum == null)
        return;
      const seriesDatum = rawData[datumIndex];
      const yDatum = yRawValues[datumIndex];
      const yValueCumulative = yCumulativeValues[datumIndex];
      const validPoint = Number.isFinite(yDatum);
      const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
      const selected = yFilterValues != null ? yFilterValues[datumIndex] === yDatum : void 0;
      if (selected === false) {
        crossFiltering = true;
      }
      if (validPoint && marker) {
        markerData.push({
          series: this,
          itemId: yKey,
          datum: seriesDatum,
          datumIndex,
          midPoint: { x: point.x, y: point.y },
          cumulativeValue: yValueCumulative,
          yValue: yDatum,
          xValue: xDatum,
          yKey,
          xKey,
          point,
          fill: marker.fill ?? seriesFill,
          stroke: marker.stroke ?? seriesStroke,
          strokeWidth: marker.strokeWidth ?? this.properties.strokeWidth,
          selected
        });
      }
      if (label.enabled && validPoint) {
        const labelText = this.getLabelText(
          yDatum,
          seriesDatum,
          yKey,
          "y",
          yDomain,
          label,
          { value: yDatum, datum: seriesDatum, xKey, yKey, xName, yName }
        );
        labelData.push({
          series: this,
          itemId: yKey,
          datum: seriesDatum,
          datumIndex,
          x: point.x,
          y: point.y,
          labelText
        });
      }
    };
    if (processedData.type === "grouped") {
      for (const { datumIndex } of dataModel.forEachGroupDatum(this, processedData)) {
        handleDatum(datumIndex);
      }
    } else {
      for (let i = startIndex; i < endIndex; i += 1) {
        const datumIndex = indices?.[i] ?? i;
        if (xValues[datumIndex] == null)
          continue;
        handleDatum(datumIndex);
      }
    }
    const spansForPoints = (points) => {
      return points.flatMap((p) => {
        return Array.isArray(p) ? interpolatePoints(p, interpolation) : new Array(p.skip).fill(null);
      });
    };
    const createPoint = (xDatum, yDatum) => ({
      point: {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(yDatum)
      },
      xDatum,
      yDatum
    });
    const getSeriesSpans = (index) => {
      const points = [];
      const handleSeriesPoint = (pIdx, datumIndex, nIdx) => {
        const xDatum = xValues[datumIndex];
        const yDatum = yStackValues != null ? yStackValues?.[datumIndex][index] : yRawValues[datumIndex];
        if (connectMissingData && !Number.isFinite(yRawValues[datumIndex]))
          return;
        const yDatumIsFinite = Number.isFinite(yDatum);
        let yValueEndBackwards = 0;
        let yBackwardsFinite = true;
        let yValueEndForwards = 0;
        let yForwardsFinite = true;
        if (yStackValues == null) {
          yBackwardsFinite = pIdx == null || Number.isFinite(yRawValues[pIdx]);
          yForwardsFinite = nIdx == null || Number.isFinite(yRawValues[nIdx]);
          yValueEndBackwards = pIdx != null && Number.isFinite(yRawValues[pIdx]) ? yDatum : 0;
          yValueEndForwards = nIdx != null && Number.isFinite(yRawValues[nIdx]) ? yDatum : 0;
        } else {
          const yValueStack = yStackValues[datumIndex];
          const lastYValueStack = pIdx != null ? yStackValues[pIdx] : void 0;
          const nextYValueStack = nIdx != null ? yStackValues[nIdx] : void 0;
          for (let j = 0; j <= index; j += 1) {
            const value = yValueStack[j];
            if (Number.isFinite(value)) {
              const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);
              const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);
              if (lastWasFinite) {
                yValueEndBackwards += value;
              } else {
                yBackwardsFinite = false;
              }
              if (nextWasFinite) {
                yValueEndForwards += value;
              } else {
                yForwardsFinite = false;
              }
            }
          }
        }
        const currentPoints = points[points.length - 1];
        if (!connectMissingData && (!yBackwardsFinite || !yForwardsFinite || !yDatumIsFinite || yValueEndBackwards !== yValueEndForwards)) {
          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {
            points[points.length - 1] = { skip: 1 };
          } else {
            const pointBackwards = createPoint(xDatum, yValueEndBackwards);
            const pointForwards = createPoint(xDatum, yValueEndForwards);
            if (Array.isArray(currentPoints)) {
              currentPoints.push(pointBackwards);
            } else if (currentPoints != null) {
              currentPoints.skip += 1;
            }
            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });
          }
        } else {
          const yValue = connectMissingData ? yDatum : Math.max(yValueEndBackwards, yValueEndForwards);
          const point = createPoint(xDatum, yValue);
          if (Array.isArray(currentPoints)) {
            currentPoints.push(point);
          } else if (currentPoints != null) {
            currentPoints.skip += 1;
            points.push([point]);
          } else {
            points.push([point]);
          }
        }
      };
      if (processedData.type === "grouped") {
        for (const {
          datumIndexes: [pIdx, datumIndex, nIdx]
        } of dataModel.forEachGroupDatumTuple(this, processedData)) {
          handleSeriesPoint(pIdx, datumIndex, nIdx);
        }
      } else {
        let pIdx;
        let datumIndex;
        for (let i = startIndex; i < endIndex; i += 1) {
          const nIdx = indices?.[i] ?? i;
          if (xValues[nIdx] == null)
            continue;
          if (datumIndex != null) {
            handleSeriesPoint(pIdx, datumIndex, nIdx);
          }
          pIdx = datumIndex;
          datumIndex = nIdx;
        }
        if (datumIndex != null) {
          handleSeriesPoint(pIdx, datumIndex, void 0);
        }
      }
      return spansForPoints(points);
    };
    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;
    const getAxisSpans = () => {
      const getPoint = (datumIndex) => {
        const xDatum = xValues[datumIndex];
        const yDatum = yStackValues?.[datumIndex][stackIndex] ?? yRawValues[datumIndex];
        if (connectMissingData && !Number.isFinite(yDatum))
          return;
        return createPoint(xDatum, 0);
      };
      let yValueZeroPoints;
      if (processedData.type === "grouped") {
        yValueZeroPoints = Array.from(dataModel.forEachGroupDatum(this, processedData), ({ datumIndex }) => {
          return getPoint(datumIndex);
        });
      } else {
        yValueZeroPoints = [];
        for (let i = startIndex; i < endIndex; i += 1) {
          const datumIndex = indices?.[i] ?? i;
          if (xValues[datumIndex] == null)
            continue;
          yValueZeroPoints.push(getPoint(datumIndex));
        }
      }
      yValueZeroPoints = yValueZeroPoints.filter((x) => x != null);
      return interpolatePoints(yValueZeroPoints, interpolation);
    };
    const currentSeriesSpans = getSeriesSpans(stackIndex);
    const phantomSpans = currentSeriesSpans.map(() => null);
    for (let j = stackIndex - 1; j >= -1; j -= 1) {
      let spans;
      for (let i = 0; i < phantomSpans.length; i += 1) {
        if (phantomSpans[i] != null)
          continue;
        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());
        phantomSpans[i] = spans[i];
      }
    }
    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);
    const strokeSpans = currentSeriesSpans.filter((span) => span != null);
    const context = {
      itemId: yKey,
      fillData: { itemId: yKey, spans: fillSpans, phantomSpans },
      strokeData: { itemId: yKey, spans: strokeSpans },
      labelData,
      nodeData: markerData,
      scales: this.calculateScaling(),
      visible: this.visible,
      stackVisible: visibleSameStackCount > 0,
      crossFiltering
    };
    return context;
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const { visible, animationEnabled } = opts;
    const [fill, stroke3] = opts.paths;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    const {
      strokeWidth,
      stroke: strokeColor,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fill: fillColor,
      fillOpacity,
      opacity
    } = mergeDefaults(this.getHighlightStyle(), this.properties);
    stroke3.setProperties({
      fill: void 0,
      lineCap: "round",
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      stroke: strokeColor,
      strokeWidth,
      strokeOpacity: strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),
      lineDash,
      lineDashOffset,
      opacity,
      visible: visible || animationEnabled
    });
    const seriesFill = getShapeFill(
      fillColor,
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    applyShapeStyle(
      fill,
      {
        fill: seriesFill,
        stroke: void 0,
        fillOpacity: fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1)
      },
      this.getShapeFillBBox()
    );
    fill.setProperties({
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      fillShadow: this.properties.shadow,
      opacity,
      visible: visible || animationEnabled
    });
    updateClipPath(this, stroke3);
    updateClipPath(this, fill);
  }
  updatePaths(opts) {
    this.updateAreaPaths(opts.paths, opts.contextData);
  }
  updateAreaPaths(paths, contextData) {
    for (const path of paths) {
      path.visible = contextData.visible;
    }
    if (contextData.visible) {
      this.updateFillPath(paths, contextData);
      this.updateStrokePath(paths, contextData);
    } else {
      for (const path of paths) {
        path.path.clear();
        path.markDirty("AreaSeries");
      }
    }
  }
  updateFillPath(paths, contextData) {
    const [fill] = paths;
    fill.path.clear();
    plotAreaPathFill(fill, contextData.fillData);
    fill.markDirty("AreaSeries");
  }
  updateStrokePath(paths, contextData) {
    const { spans } = contextData.strokeData;
    const [, stroke3] = paths;
    stroke3.path.clear();
    plotLinePathStroke(stroke3, spans);
    stroke3.markDirty("AreaSeries");
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    return datumSelection.update(markersEnabled ? nodeData : []);
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yKey, marker, stroke: stroke3, strokeWidth, strokeOpacity } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((node, datum) => {
      const { xValue: xValue2, yValue } = datum;
      const params = datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain);
      const style2 = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
        stroke: stroke3,
        strokeWidth,
        strokeOpacity
      });
      this.applyMarkerStyle(style2, node, datum.point, fillBBox, { selected: datum.selected });
    });
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    opts.labelSelection.each((text2, datum) => {
      const { x, y, labelText } = datum;
      const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
      const style2 = getLabelStyles(
        this,
        datum,
        this.properties,
        this.properties.label,
        highlighted,
        highlightState
      );
      const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color: color2 } = style2;
      if (labelText && labelEnabled && this.visible) {
        text2.fontStyle = fontStyle;
        text2.fontWeight = fontWeight;
        text2.fontSize = fontSize;
        text2.fontFamily = fontFamily;
        text2.textAlign = "center";
        text2.textBaseline = "bottom";
        text2.text = labelText;
        text2.x = x;
        text2.y = y - 10;
        text2.fill = color2;
        text2.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
        text2.visible = true;
        text2.setBoxing(style2);
      } else {
        text2.visible = false;
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, tooltip, marker, legendItemName } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];
    const { xDomain, yDomain } = this.cachedDatumCallback("domain", () => ({
      xDomain: this.getSeriesDomain("x" /* X */),
      yDomain: this.getSeriesDomain("y" /* Y */)
    }));
    if (xValue2 == null)
      return;
    const activeStyle = this.getMarkerStyle(
      marker,
      { datum, datumIndex },
      datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain),
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke3,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      marker,
      fillGradientDefaults: fillGradientDefaults4,
      fillPatternDefaults: fillPatternDefaults4,
      fillImageDefaults: fillImageDefaults4
    } = this.properties;
    const useAreaFill = !marker.enabled || marker.fill === void 0;
    const legendMarkerFill = useAreaFill ? getShapeFill(fill, fillGradientDefaults4, fillPatternDefaults4, fillImageDefaults4) : getShapeFill(
      marker.fill,
      marker.fillGradientDefaults,
      marker.fillPatternDefaults,
      marker.fillImageDefaults
    );
    const markerStyle = this.getMarkerStyle(
      marker,
      {},
      void 0,
      false,
      {
        size: marker.size,
        fill: legendMarkerFill,
        fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity
      },
      void 0,
      false
    );
    return {
      marker: {
        ...markerStyle,
        enabled: marker.enabled || strokeWidth <= 0
      },
      line: {
        stroke: stroke3,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, legendItemName, showInLegend } = this.properties;
    return [
      {
        legendType,
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: legendItemName ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady(animationData) {
    const { datumSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([datumSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, datumSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const { datumSelection, labelSelection, contextData, paths, previousContextData } = animationData;
    const [fill, stroke3] = paths;
    if (contextData.visible === false && previousContextData?.visible === false)
      return;
    if (fill == null && stroke3 == null)
      return;
    this.resetDatumAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateAreaPaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", datumSelection);
      pathFadeInAnimation(this, "fill_path_properties", animationManager, "add", fill);
      pathFadeInAnimation(this, "stroke_path_properties", animationManager, "add", stroke3);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareAreaPathAnimation(contextData, previousContextData);
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    markerFadeInAnimation(this, animationManager, void 0, datumSelection);
    fromToMotion(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
    pathMotion(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
    fromToMotion(this.id, "stroke_path_properties", animationManager, [stroke3], fns.stroke.pathProperties);
    pathMotion(this.id, "stroke_path_update", animationManager, [stroke3], fns.stroke.path);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    this.ctx.animationManager.animate({
      id: this.id,
      groupId: "reset_after_animation",
      phase: "trailing",
      from: {},
      to: {},
      onComplete: () => this.updateAreaPaths(paths, contextData)
    });
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Marker();
  }
  getFormattedMarkerStyle(datum) {
    const { xValue: xValue2, yValue, xKey, yKey } = datum;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    return this.getMarkerStyle(
      this.properties.marker,
      datum,
      datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain),
      true
    );
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
AreaSeries.className = "AreaSeries";
AreaSeries.type = "area";

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "area",
  moduleFactory: (ctx) => new AreaSeries(ctx),
  stackable: true,
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      nodeClickRange: "nearest",
      fill: { $palette: "fill" },
      fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      stroke: { $palette: "stroke" },
      fillOpacity: 0.8,
      strokeOpacity: 1,
      strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
      lineDash: [0],
      lineDashOffset: 0,
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      interpolation: {
        type: "linear"
      },
      marker: {
        enabled: false,
        shape: "circle",
        size: 7,
        strokeWidth: { $isUserOption: ["./stroke", 1, 0] },
        fill: { $palette: "fill" },
        stroke: { $palette: "stroke" },
        // @ts-expect-error undocumented option
        fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
        fillPatternDefaults: FILL_PATTERN_DEFAULTS
      },
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewAreaSeriesModule = {
  type: "series",
  name: "area",
  chartType: "cartesian",
  options: areaSeriesOptionsDef,
  create: (ctx) => new AreaSeries(ctx)
};

// packages/ag-charts-community/src/scene/shape/barShape.ts
var BarShape = class extends Rect {
  constructor() {
    super(...arguments);
    this.direction = "x";
    this.featherRatio = 0;
  }
  get feathered() {
    return Math.abs(this.featherRatio) > 1e-6;
  }
  isPointInPath(x, y) {
    if (!this.feathered) {
      return super.isPointInPath(x, y);
    }
    const bbox = this.getBBox();
    return bbox.containsPoint(x, y);
  }
  updatePath() {
    if (!this.feathered) {
      super.updatePath();
      return;
    }
    const { path, x, y, width: width2, height: height2, direction, featherRatio } = this;
    path.clear();
    if (direction === "x") {
      const featherInsetX = Math.abs(featherRatio) * width2;
      if (featherRatio > 0) {
        path.moveTo(x, y);
        path.lineTo(x + width2 - featherInsetX, y);
        path.lineTo(x + width2, y + height2 / 2);
        path.lineTo(x + width2 - featherInsetX, y + height2);
        path.lineTo(x, y + height2);
        path.closePath();
      } else {
        path.moveTo(x + featherInsetX, y);
        path.lineTo(x + width2, y);
        path.lineTo(x + width2, y + height2);
        path.lineTo(x + featherInsetX, y + height2);
        path.lineTo(x, y + height2 / 2);
        path.closePath();
      }
    } else {
      const featherInsetY = Math.abs(featherRatio) * height2;
      if (featherRatio > 0) {
        path.moveTo(x, y + featherInsetY);
        path.lineTo(x + width2 / 2, y);
        path.lineTo(x + width2, y + featherInsetY);
        path.lineTo(x + width2, y + height2);
        path.lineTo(x, y + height2);
        path.closePath();
      } else {
        path.moveTo(x, y);
        path.lineTo(x + width2, y);
        path.lineTo(x + width2, y + height2 - featherInsetY);
        path.lineTo(x + width2 / 2, y + height2);
        path.lineTo(x, y + height2 - featherInsetY);
        path.closePath();
      }
    }
  }
};
__decorateClass([
  SceneChangeDetection()
], BarShape.prototype, "direction", 2);
__decorateClass([
  SceneChangeDetection()
], BarShape.prototype, "featherRatio", 2);

// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts
function addHitTestersToQuadtree(quadtree, hitTesters) {
  for (const node of hitTesters) {
    const datum = node.datum;
    if (datum === void 0) {
      logger_exports.error("undefined datum");
    } else {
      quadtree.addValue(node, datum);
    }
  }
}
function findQuadtreeMatch(series, point) {
  const { x, y } = point;
  const { nearest, distanceSquared: distanceSquared2 } = series.getQuadTree().find(x, y);
  if (nearest !== void 0) {
    return { datum: nearest.value, distance: Math.sqrt(distanceSquared2) };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
  }
};
__decorateClass([
  Property
], AbstractBarSeriesProperties.prototype, "direction", 2);
var AbstractBarSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments);
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new CategoryScale();
    this.smallestDataInterval = void 0;
    this.largestDataInterval = void 0;
  }
  padBandExtent(keys, alignStart) {
    const ratio2 = typeof alignStart === "boolean" ? 1 : 0.5;
    const scalePadding = isFiniteNumber(this.smallestDataInterval) ? this.smallestDataInterval * ratio2 : 0;
    const keysExtent = extent(keys) ?? [NaN, NaN];
    if (typeof alignStart === "boolean") {
      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;
    } else {
      keysExtent[0] -= scalePadding;
      keysExtent[1] += scalePadding;
    }
    return fixNumericExtent(keysExtent);
  }
  getBandScalePadding() {
    return { inner: 0.3, outer: 0.15 };
  }
  shouldFlipXY() {
    return !this.isVertical();
  }
  isVertical() {
    return this.properties.direction === "vertical";
  }
  getBarDirection() {
    return this.shouldFlipXY() ? "x" /* X */ : "y" /* Y */;
  }
  getCategoryDirection() {
    return this.shouldFlipXY() ? "y" /* Y */ : "x" /* X */;
  }
  getValueAxis() {
    const direction = this.getBarDirection();
    return this.axes[direction];
  }
  getCategoryAxis() {
    const direction = this.getCategoryDirection();
    return this.axes[direction];
  }
  getBandwidth(xAxis, minWidth) {
    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval, minWidth) : xAxis.scale.bandwidth;
  }
  xCoordinateRange(xValue2) {
    const xAxis = this.axes[this.getCategoryDirection()];
    const xScale = xAxis.scale;
    const bandWidth = this.getBandwidth(xAxis, 0) ?? 0;
    const barOffset = ContinuousScale.is(xScale) ? bandWidth * -0.5 : 0;
    const x = xScale.convert(xValue2) + barOffset;
    return [x, x + bandWidth];
  }
  yCoordinateRange(yValues) {
    const yAxis = this.axes[this.getBarDirection()];
    const yScale = yAxis.scale;
    const ys = yValues.map((yValue) => yScale.convert(yValue));
    if (ys.length === 1) {
      const y0 = yScale.convert(0);
      return [Math.min(ys[0], y0), Math.max(ys[0], y0)];
    }
    return [Math.min(...ys), Math.max(...ys)];
  }
  updateGroupScale(xAxis) {
    const domain = [];
    const { groupScale } = this;
    const xBandWidth = this.getBandwidth(xAxis);
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
      domain.push(String(groupIdx));
    }
    groupScale.domain = domain;
    groupScale.range = [0, xBandWidth ?? 0];
    if (xAxis instanceof GroupedCategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
    } else if (xAxis instanceof CategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
      groupScale.round = groupScale.padding !== 0;
    } else {
      groupScale.padding = 0;
    }
    const barWidth = groupScale.bandwidth >= 1 ? (
      // Pixel-rounded value for low-volume bar charts.
      groupScale.bandwidth
    ) : (
      // Handle high-volume bar charts gracefully.
      groupScale.rawBandwidth
    );
    return { barWidth, groupIndex };
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === "x" /* X */) {
      if (direction === "x" /* X */) {
        return "y" /* Y */;
      }
      return "x" /* X */;
    }
    return direction;
  }
  initQuadTree(quadtree) {
    addHitTestersToQuadtree(quadtree, this.datumNodesIter());
  }
  pickNodesExactShape(point) {
    const item = findQuadtreeMatch(this, point);
    return item != null && item.distance <= 0 ? [item.datum] : [];
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/barAggregation.ts
var BAR_X_MIN = AGGREGATION_INDEX_X_MIN;
var BAR_X_MAX = AGGREGATION_INDEX_X_MAX;
var BAR_Y_MIN = AGGREGATION_INDEX_Y_MIN;
var BAR_Y_MAX = AGGREGATION_INDEX_Y_MAX;
var BAR_SPAN = AGGREGATION_SPAN;
var AGGREGATION_THRESHOLD2 = 1e3;
function getIndices(maxRange, indexData) {
  return Array.from({ length: maxRange }, (_, index) => {
    const aggIndex = index * AGGREGATION_SPAN;
    const xMinIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MIN];
    const xMaxIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MAX];
    return (xMinIndex + xMaxIndex) / 2 | 0;
  });
}
function aggregateBarData(scale2, xValues, yValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD2)
    return;
  const [d0, d1] = aggregationDomain(scale2, domain);
  let maxRange = aggregationRangeFittingPoints(xValues);
  let { indexData, valueData } = createAggregationIndices(xValues, yValues, yValues, d0, d1, maxRange);
  let indices = getIndices(maxRange, indexData);
  const filters = [{ maxRange, indexData, indices }];
  while (maxRange > 64) {
    ({ indexData, valueData, maxRange } = compactAggregationIndices(indexData, valueData, maxRange));
    indices = getIndices(maxRange, indexData);
    filters.push({ maxRange, indexData, indices });
  }
  filters.reverse();
  return filters;
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "inside-center";
    this.spacing = 0;
  }
};
__decorateClass([
  Property
], BarSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Property
], BarSeriesLabel.prototype, "spacing", 2);
var BarSeriesProperties = class extends AbstractBarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.crisp = void 0;
    this.shadow = new DropShadow();
    this.label = new BarSeriesLabel();
    this.tooltip = makeSeriesTooltip();
    this.sparklineMode = false;
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke3, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass([
  Property
], BarSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "crisp", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "sparklineMode", 2);

// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts
function checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {
  if (visibleRange != null) {
    const [visibleMin, visibleMax] = visibleRange;
    const isZoomed = visibleMin !== 0 || visibleMax !== 1;
    if (isZoomed)
      return false;
  }
  if (ContinuousScale.is(scale2)) {
    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);
    if (spacing > 0 && spacing < 1)
      return false;
  }
  if (BandScale.is(scale2)) {
    const { bandwidth, step } = scale2;
    if (bandwidth > 0 && bandwidth < 1)
      return false;
    const spacing = step - bandwidth;
    if (spacing > 0 && spacing < 1)
      return false;
  }
  return true;
}
var isDatumNegative = (datum) => {
  return isNegative(datum.yValue ?? 0);
};
function collapsedStartingBarPosition(isVertical, axes, mode) {
  const { startingX, startingY } = getStartingValues(isVertical, axes);
  const calculate = (datum, prevDatum) => {
    let x = isVertical ? datum.x : startingX;
    let y = isVertical ? startingY : datum.y;
    let width2 = isVertical ? datum.width : 0;
    let height2 = isVertical ? 0 : datum.height;
    const { opacity = 1 } = datum;
    if (prevDatum && (isNaN(x) || isNaN(y))) {
      ({ x, y } = prevDatum);
      width2 = isVertical ? prevDatum.width : 0;
      height2 = isVertical ? 0 : prevDatum.height;
      if (isVertical && !isDatumNegative(prevDatum)) {
        y += prevDatum.height;
      } else if (!isVertical && isDatumNegative(prevDatum)) {
        x += prevDatum.width;
      }
    }
    let clipBBox;
    if (datum.clipBBox == null) {
      clipBBox = void 0;
    } else if (isDatumNegative(datum)) {
      clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);
    } else {
      clipBBox = new BBox(x, y, width2, height2);
    }
    return { x, y, width: width2, height: height2, clipBBox, opacity };
  };
  return { isVertical, calculate, mode };
}
function midpointStartingBarPosition(isVertical, mode) {
  return {
    isVertical,
    calculate: (datum) => {
      return {
        x: isVertical ? datum.x : datum.x + datum.width / 2,
        y: isVertical ? datum.y + datum.height / 2 : datum.y,
        width: isVertical ? datum.width : 0,
        height: isVertical ? 0 : datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity ?? 1
      };
    },
    mode
  };
}
function prepareBarAnimationFunctions(initPos) {
  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);
  const fromFn = (rect, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(rect.previousDatum)) {
      status = "added";
    }
    let source;
    if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
      source = {
        ...resetBarSelectionsFn(rect, datum),
        opacity: 0
      };
    } else if (status === "unknown" || status === "added") {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        clipBBox: rect.clipBBox,
        opacity: rect.opacity ?? 1
      };
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { ...source, phase };
  };
  const toFn = (rect, datum, status) => {
    if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
      return { ...resetBarSelectionsFn(rect, datum), opacity: 0 };
    } else if (status === "removed" || isRemoved(datum)) {
      return initPos.calculate(datum, rect.previousDatum);
    } else {
      return {
        x: datum.x,
        y: datum.y,
        width: datum.width,
        height: datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity ?? 1
      };
    }
  };
  const applyFn = (rect, datum, status) => {
    rect.setProperties(datum);
    rect.crisp = status === "end" && (rect.datum?.crisp ?? false);
  };
  return { toFn, fromFn, applyFn };
}
function getStartingValues(isVertical, axes) {
  const axis = axes[isVertical ? "y" /* Y */ : "x" /* X */];
  let startingX = Infinity;
  let startingY = 0;
  if (!axis) {
    return { startingX, startingY };
  }
  if (isVertical) {
    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
  } else {
    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
  }
  return { startingX, startingY };
}
function resetBarSelectionsFn(rect, { x, y, width: width2, height: height2, clipBBox, opacity = 1 }) {
  return { x, y, width: width2, height: height2, clipBBox, opacity, crisp: rect.datum?.crisp ?? false };
}
function computeBarFocusBounds(series, datum) {
  if (datum === void 0)
    return void 0;
  const { x, y, width: width2, height: height2 } = datum;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, width2, height2));
}

// packages/ag-charts-community/src/chart/series/cartesian/diffUtil.ts
function calculateDataDiff(seriesId, datumSelection, getDatumId, contextNodeData, previousContextNodeData, processedData) {
  let dataDiff = processedData?.reduced?.diff?.[seriesId];
  if (dataDiff?.changed) {
    return dataDiff;
  }
  const scalingChanged = hasScalingChanged(contextNodeData, previousContextNodeData);
  if (dataDiff == null && processedData?.reduced?.diff != null) {
    dataDiff = {
      changed: true,
      added: /* @__PURE__ */ new Set(),
      updated: /* @__PURE__ */ new Set(),
      removed: /* @__PURE__ */ new Set(),
      moved: /* @__PURE__ */ new Set()
    };
    if (scalingChanged) {
      dataDiff.updated = new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum)));
    } else {
      dataDiff.added = new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum)));
    }
  } else if (scalingChanged) {
    dataDiff = {
      changed: true,
      added: /* @__PURE__ */ new Set(),
      updated: new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum))),
      removed: /* @__PURE__ */ new Set(),
      moved: /* @__PURE__ */ new Set()
    };
  }
  return dataDiff;
}
function isGroupScaleContext(ctx) {
  return typeof ctx === "object" && ctx !== null && "groupScale" in ctx;
}
function hasScalingChanged(contextNodeData, previousContextNodeData) {
  if (!previousContextNodeData)
    return false;
  const scales = contextNodeData.scales;
  const prevScales = previousContextNodeData.scales;
  if (!areScalingEqual(scales.x, prevScales.x))
    return true;
  if (!areScalingEqual(scales.y, prevScales.y))
    return true;
  if (!isGroupScaleContext(contextNodeData) || !isGroupScaleContext(previousContextNodeData))
    return false;
  const groupScale = contextNodeData.groupScale;
  const prevGroupScale = previousContextNodeData.groupScale;
  return !areScalingEqual(groupScale, prevGroupScale);
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var memoizedAggregateBarData = simpleMemorize2(aggregateBarData);
var BarSeries = class extends AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pickModes: [
        2 /* AXIS_ALIGNED */,
        // Only used in sparklineMode
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new BarSeriesProperties();
    this.connectsToYAxis = true;
    this.dataAggregationFilters = void 0;
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : void 0;
  }
  crossFilteringEnabled() {
    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);
  }
  async processData(dataController) {
    if (!this.data)
      return;
    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;
    const { seriesGrouping: { groupIndex = this.id } = {}, data } = this;
    const stackCount = this.seriesGrouping?.stackCount ?? 0;
    const stacked = stackCount > 1 || normalizedTo != null;
    const grouped = stacked;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stackGroupName = `bar-stack-${groupIndex}-yValues`;
    const stackGroupTrailingName = `${stackGroupName}-trailing`;
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const props = [
      keyProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps })
    ];
    if (this.crossFilteringEnabled()) {
      props.push(
        valueProperty(yFilterKey, yScaleType, {
          id: `yFilterValue`,
          invalidValue: null,
          ...visibleProps
        })
      );
    }
    if (stacked) {
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          {
            id: `yValue-end`,
            rangeId: `yValue-range`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "trailing",
          "current",
          {
            id: `yValue-start`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupTrailingName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        )
      );
    }
    if (isContinuousX) {
      props.push(SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL);
    }
    if (isFiniteNumber(normalizedTo)) {
      props.push(normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo)));
    }
    if (animationEnabled && this.processedData) {
      props.push(diff(this.id, this.processedData));
    }
    if (animationEnabled || !grouped) {
      props.push(animationValidation());
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: grouped,
      groupByData: !grouped
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (dataModel == null || processedData == null)
      return [];
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    }
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    let yExtent = this.domainForClippedRange(direction, [yKey], "xValue");
    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, "value", processedData) : void 0;
    if (yFilterExtent != null) {
      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];
    }
    if (this.getValueAxis() instanceof LogAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])] : [];
      return fixNumericExtent(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    const [y0, y1] = this.domainForVisibleRange("y" /* Y */, [yKey], "xValue", visibleRange);
    return [Math.min(y0, 0), Math.max(y1, 0)];
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    return this.countVisibleItems("xValue", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable(processedData))
      return;
    const xAxis = this.axes["x" /* X */];
    if (xAxis == null)
      return;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue-raw`, processedData);
    const { index } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const domain = processedData.domain.keys[index];
    return memoizedAggregateBarData(xAxis.scale.type, xValues, yValues, domain);
  }
  createNodeData() {
    const { dataModel, processedData, groupScale, dataAggregationFilters } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const rawData = processedData.dataSources?.get(this.id);
    if (rawData == null)
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const { xKey, yKey, xName, yName, legendItemName, label } = this.properties;
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const yReversed = yAxis.isReversed();
    const { barWidth, groupIndex: groupScaleIndex } = this.updateGroupScale(xAxis);
    const groupOffset = groupScale.convert(String(groupScaleIndex));
    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yValue-raw`, processedData);
    const yFilterValues = this.crossFilteringEnabled() ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xPosition = (index) => xScale.convert(xValues[index]) + groupOffset + barOffset;
    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);
    const bboxBottom = yScale.convert(0);
    const nodeDatum = ({
      datum,
      datumIndex,
      xValue: xValue2,
      yValue,
      cumulativeValue,
      phantom,
      currY,
      prevY,
      x,
      width: width2,
      isPositive,
      yRange,
      labelText,
      opacity,
      featherRatio,
      crossScale = 1
    }) => {
      const isUpward = isPositive !== yReversed;
      const y = yScale.convert(currY);
      const bottomY = yScale.convert(prevY);
      const bboxHeight = yScale.convert(yRange);
      const barAlongX = this.getBarDirection() === "x" /* X */;
      const xOffset = width2 * 0.5 * (1 - crossScale);
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : x + xOffset,
        y: barAlongX ? x + xOffset : Math.min(y, bottomY),
        width: barAlongX ? Math.abs(bottomY - y) : width2 * crossScale,
        height: barAlongX ? width2 * crossScale : Math.abs(bottomY - y)
      };
      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);
      const barRect = {
        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : x + xOffset,
        y: barAlongX ? x + xOffset : Math.min(bboxBottom, bboxHeight),
        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : width2 * crossScale,
        height: barAlongX ? width2 * crossScale : Math.abs(bboxBottom - bboxHeight)
      };
      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
      const spacing = label.spacing + (typeof label.padding === "number" ? label.padding : 0);
      return {
        series: this,
        itemId: phantom ? createDatumId(yKey, phantom) : yKey,
        datum,
        datumIndex,
        cumulativeValue,
        phantom,
        xValue: xValue2,
        yValue,
        yKey,
        xKey,
        capDefaults: {
          lengthRatioMultiplier,
          lengthMax: lengthRatioMultiplier
        },
        x: barRect.x,
        y: barRect.y,
        width: barRect.width,
        height: barRect.height,
        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
        opacity,
        featherRatio,
        topLeftCornerRadius: barAlongX !== isUpward,
        topRightCornerRadius: isUpward,
        bottomRightCornerRadius: barAlongX === isUpward,
        bottomLeftCornerRadius: !isUpward,
        clipBBox,
        crisp,
        label: labelText != null ? {
          text: labelText,
          ...adjustLabelPlacement({
            isUpward,
            isVertical: !barAlongX,
            placement: label.placement,
            spacing,
            rect
          })
        } : void 0,
        missing: yValue == null,
        focusable: !phantom
      };
    };
    const phantomNodes = [];
    const nodes = [];
    const labels = [];
    const handleDatum = (datumIndex, x, width2, yStart, yEnd, yRange, featherRatio = 0, opacity = 1) => {
      const xValue2 = xValues[datumIndex];
      if (xValue2 == null)
        return;
      const datum = rawData[datumIndex];
      const yRawValue = yRawValues[datumIndex];
      const yFilterValue = yFilterValues != null ? Number(yFilterValues[datumIndex]) : void 0;
      const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
      if (!Number.isFinite(yEnd))
        return;
      if (yFilterValue != null && !Number.isFinite(yFilterValue))
        return;
      const labelText = label.enabled && yRawValue != null ? this.getLabelText(
        yFilterValue ?? yRawValue,
        datum,
        yKey,
        "y",
        yDomain,
        label,
        { datum, value: yFilterValue ?? yRawValue, xKey, yKey, xName, yName, legendItemName }
      ) : void 0;
      const inset = yFilterValue != null && yFilterValue > yRawValue;
      const nodeData = nodeDatum({
        datum,
        datumIndex,
        xValue: xValue2,
        yValue: yFilterValue ?? yRawValue,
        cumulativeValue: yFilterValue ?? yEnd,
        phantom: false,
        currY: yFilterValue != null ? yStart + yFilterValue : yEnd,
        prevY: yStart,
        x,
        width: width2,
        isPositive,
        yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),
        labelText,
        opacity,
        featherRatio,
        crossScale: inset ? 0.6 : void 0
      });
      nodes.push(nodeData);
      labels.push(nodeData);
      if (yFilterValue != null) {
        const phantomNodeData = nodeDatum({
          datum: rawData[datumIndex],
          datumIndex,
          xValue: xValue2,
          yValue: yFilterValue,
          cumulativeValue: yFilterValue,
          phantom: true,
          currY: yEnd,
          prevY: yStart,
          x,
          width: width2,
          isPositive,
          yRange,
          labelText: void 0,
          opacity,
          featherRatio,
          crossScale: void 0
        });
        phantomNodes.push(phantomNodeData);
      }
    };
    const [r0, r1] = xScale.range;
    const range4 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range4);
    if (processedData.type === "grouped") {
      const width2 = barWidth;
      const stacked = dataModel.hasColumnById(this, `yValue-start`);
      const yStartValues = stacked ? dataModel.resolveColumnById(this, `yValue-start`, processedData) : void 0;
      const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValue-end`, processedData) : void 0;
      const yRangeIndex = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValue-range`) : -1;
      for (const {
        datumIndex,
        group: { aggregation }
      } of dataModel.forEachGroupDatum(this, processedData)) {
        const x = xPosition(datumIndex);
        const yRawValue = yRawValues[datumIndex];
        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
        const yStart = stacked ? Number(yStartValues?.[datumIndex]) : 0;
        const yEnd = stacked ? Number(yEndValues?.[datumIndex]) : yRawValue;
        let yRange = yEnd;
        if (stacked) {
          yRange = aggregation[yRangeIndex][isPositive ? 1 : 0];
        }
        handleDatum(datumIndex, x, width2, yStart, yEnd, yRange);
      }
    } else if (dataAggregationFilter == null) {
      const invalidData = processedData.invalidData?.get(this.id);
      const width2 = barWidth;
      let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range);
      if (processedData.input.count < 1e3) {
        start2 = 0;
        end2 = processedData.input.count;
      }
      for (let datumIndex = start2; datumIndex < end2; datumIndex += 1) {
        if (invalidData?.[datumIndex] === true)
          continue;
        const x = xPosition(datumIndex);
        const yEnd = Number(yRawValues[datumIndex]);
        handleDatum(datumIndex, x, width2, 0, yEnd, yEnd);
      }
    } else {
      const { indexData, indices } = dataAggregationFilter;
      const [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, indices);
      const sign = yReversed ? -1 : 1;
      for (let i = start2; i < end2; i += 1) {
        const aggIndex = i * BAR_SPAN;
        const xMinIndex = indexData[aggIndex + BAR_X_MIN];
        const xMaxIndex = indexData[aggIndex + BAR_X_MAX];
        const yMinIndex = indexData[aggIndex + BAR_Y_MIN];
        const yMaxIndex = indexData[aggIndex + BAR_Y_MAX];
        if (xMinIndex === -1)
          continue;
        const x = xPosition((xMinIndex + xMaxIndex) / 2 | 0);
        const width2 = Math.abs(xPosition(xMaxIndex) - xPosition(xMinIndex)) + barWidth;
        const bandCount = Math.abs(xMaxIndex - xMinIndex);
        const opacity = BandScale.is(xScale) ? xScale.bandwidth * Math.max(bandCount - 1, 1) / (xScale.step * bandCount) : 1;
        const yEndMax = xValues[yMaxIndex] != null ? Number(yRawValues[yMaxIndex]) : NaN;
        const yEndMin = xValues[yMinIndex] != null ? Number(yRawValues[yMinIndex]) : NaN;
        if (yEndMax > 0) {
          const featherRatio = yEndMin >= 0 ? sign * (1 - yEndMin / yEndMax) : sign;
          handleDatum(yMaxIndex, x, width2, 0, yEndMax, yEndMax, featherRatio, opacity);
        }
        if (yEndMin < 0) {
          const featherRatio = yEndMax <= 0 ? -sign * (1 - yEndMax / yEndMin) : -sign;
          handleDatum(yMinIndex, x, width2, 0, yEndMin, yEndMin, featherRatio, opacity);
        }
      }
    }
    return {
      itemId: yKey,
      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,
      labelData: labels,
      scales: this.calculateScaling(),
      visible: this.visible || animationEnabled,
      groupScale: this.getScaling(this.groupScale)
    };
  }
  nodeFactory() {
    return new BarShape();
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItem = nodeData.find(
      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom
    );
    return highlightItem != null ? [highlightItem] : void 0;
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => this.getDatumId(datum));
  }
  getItemStyle(nodeDatum, isHighlight) {
    const { id: seriesId, properties } = this;
    const { xKey, yKey, itemStyler, fillGradientDefaults: fillGradientDefaults4, fillPatternDefaults: fillPatternDefaults4, fillImageDefaults: fillImageDefaults4 } = properties;
    const { xValue: xValue2, yValue, datum, datumIndex } = nodeDatum;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    let style2 = getShapeStyle(
      mergeDefaults(highlightStyle, properties.getStyle()),
      fillGradientDefaults4,
      fillPatternDefaults4,
      fillImageDefaults4
    );
    if (itemStyler && nodeDatum != null) {
      const { xDomain, yDomain } = this.cachedDatumCallback("domain", () => ({
        xDomain: this.getSeriesDomain("x" /* X */),
        yDomain: this.getSeriesDomain("y" /* Y */)
      }));
      const overrides = this.cachedDatumCallback(
        createDatumId(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            ...datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain),
            datum,
            xValue: xValue2,
            yValue,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle(
          mergeDefaults(overrides, style2),
          fillGradientDefaults4,
          fillPatternDefaults4,
          fillImageDefaults4
        );
      }
    }
    return style2;
  }
  updateDatumNodes(opts) {
    const { shadow } = this.properties;
    const categoryAlongX = this.getCategoryDirection() === "x" /* X */;
    const fillBBox = this.getShapeFillBBox();
    const direction = this.getBarDirection();
    opts.datumSelection.each((rect, datum) => {
      const style2 = this.getItemStyle(datum, opts.isHighlight);
      applyShapeStyle(rect, style2, fillBBox);
      const cornerRadius = style2.cornerRadius ?? 0;
      rect.topLeftCornerRadius = datum.topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = datum.topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = datum.bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = datum.bottomLeftCornerRadius ? cornerRadius : 0;
      rect.visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;
      rect.direction = direction;
      rect.featherRatio = datum.featherRatio;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
    });
  }
  updateLabelSelection(opts) {
    const data = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(data, (text2) => {
      text2.pointerEvents = 1 /* None */;
    });
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const params = {
      xKey: this.properties.xKey,
      xName: this.properties.xName ?? this.properties.xKey,
      yKey: this.properties.yKey,
      yName: this.properties.yName ?? this.properties.yKey,
      legendItemName: this.properties.legendItemName ?? this.properties.xName ?? this.properties.xKey
    };
    opts.labelSelection.each((textNode, datum) => {
      textNode.fillOpacity = this.getHighlightStyle(isHighlight, datum?.datumIndex).opacity ?? 1;
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
      updateLabelNode(this, textNode, params, this.properties.label, datum.label, isHighlight, highlightState);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { xKey, xName, yKey, yName, legendItemName, stackGroup, tooltip } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    const nodeDatum = this.contextNodeData?.nodeData?.[datumIndex];
    if (!dataModel || !processedData || !xAxis || !yAxis || !nodeDatum) {
      return;
    }
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue-raw`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const format = this.getItemStyle(nodeDatum, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        legendItemName,
        stackGroup,
        ...format,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke3,
      strokeWidth,
      fillOpacity,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults4,
      fillPatternDefaults: fillPatternDefaults4,
      fillImageDefaults: fillImageDefaults4
    } = this.properties;
    return {
      marker: getShapeStyle(
        {
          fill: fill ?? "rgba(0, 0, 0, 0)",
          stroke: stroke3 ?? "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults4,
        fillPatternDefaults4,
        fillImageDefaults4
      )
    };
  }
  getLegendData(legendType) {
    const { showInLegend } = this.properties;
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, legendItemName } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: { text: legendItemName ?? yName ?? itemId },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection, labelSelection, annotationSelections, contextData, previousContextData } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const dataDiff = calculateDataDiff(
      this.id,
      datumSelection,
      this.getDatumId.bind(this),
      data.contextData,
      previousContextData,
      this.processedData
    );
    const mode = previousContextData == null ? "fade" : "normal";
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
    fromToMotion(
      this.id,
      "nodes",
      this.ctx.animationManager,
      [datumSelection],
      fns,
      (_, datum) => this.getDatumId(datum),
      dataDiff
    );
    if (dataDiff?.changed || !areScalingEqual(contextData.groupScale, previousContextData?.groupScale)) {
      seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
      seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
  }
  getDatumId(datum) {
    return createDatumId(datum.xValue, datum.phantom);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;
    return computeBarFocusBounds(this, datumBox);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
BarSeries.className = "BarSeries";
BarSeries.type = "bar";

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var BarSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bar",
  moduleFactory: (ctx) => new BarSeries(ctx),
  stackable: true,
  groupable: true,
  defaultAxes: DIRECTION_SWAP_AXES,
  themeTemplate: {
    series: {
      direction: "vertical",
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 1,
      strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        padding: { $isUserOption: ["./spacing", 0, 8] },
        // compatibility with old `padding` property (now named `spacing`).
        enabled: false,
        fontWeight: { $ref: "fontWeight" },
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        color: {
          $if: [
            {
              $or: [
                { $eq: [{ $path: "./placement" }, "outside-start"] },
                { $eq: [{ $path: "./placement" }, "outside-end"] }
              ]
            },
            { $ref: "textColor" },
            { $ref: "chartBackgroundColor" }
          ]
        },
        placement: "inside-center"
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      errorBar: {
        cap: {
          lengthRatio: 0.3
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewBarSeriesModule = {
  type: "series",
  name: "bar",
  chartType: "cartesian",
  options: barSeriesOptionsDef,
  create: (ctx) => new BarSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/bubbleAggregation.ts
var SIZE_QUANTIZATION = 3;
var FILTER_DATUM_THRESHOLD = 5;
function getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
  let currentIndex = 0;
  let currentDistanceSquared = Infinity;
  const midX = (x0 + x1) / 2;
  const midY = (y0 + y1) / 2;
  for (const datumIndex of indices) {
    const xValue2 = xValues[datumIndex];
    const yValue = yValues[datumIndex];
    if (xValue2 == null || yValue == null)
      continue;
    const xRatio = aggregationXRatioForXValue(xValue2, xd0, xd1);
    const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
    const distanceSquared2 = (xRatio - midX) ** 2 + (yRatio - midY) ** 2;
    if (distanceSquared2 < currentDistanceSquared) {
      currentDistanceSquared = distanceSquared2;
      currentIndex = datumIndex;
    }
  }
  return currentIndex;
}
function countVisibleItems(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
  let count = 0;
  for (const datumIndex of indices) {
    const xValue2 = xValues[datumIndex];
    const yValue = yValues[datumIndex];
    if (xValue2 == null || yValue == null)
      continue;
    const xRatio = aggregationXRatioForXValue(xValue2, xd0, xd1);
    const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
    if (xRatio >= x0 && xRatio <= x1 && yRatio >= y0 && yRatio <= y1) {
      count += 1;
    }
  }
  return count;
}
function aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
  if (indices.length < FILTER_DATUM_THRESHOLD) {
    return;
  } else if (x0 === x1 && y0 === y1) {
    const primaryDatumIndex2 = getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1);
    return { scale: 0, x0, y0, x1, y1, indices, primaryDatumIndex: primaryDatumIndex2, children: null };
  }
  const childBuckets = [
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] },
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] },
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] },
    { x0: 1, y0: 1, x1: 0, y1: 0, indices: [] }
  ];
  const midX = (x0 + x1) / 2;
  const midY = (y0 + y1) / 2;
  for (const datumIndex of indices) {
    const xValue2 = xValues[datumIndex];
    const yValue = yValues[datumIndex];
    if (xValue2 == null || yValue == null)
      continue;
    const xRatio = aggregationXRatioForXValue(xValue2, xd0, xd1);
    const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
    const childIndex = (xRatio > midX ? 1 : 0) + (yRatio > midY ? 2 : 0);
    const childBucket = childBuckets[childIndex];
    childBucket.indices.push(datumIndex);
    childBucket.x0 = Math.min(childBucket.x0, xRatio);
    childBucket.y0 = Math.min(childBucket.y0, yRatio);
    childBucket.x1 = Math.max(childBucket.x1, xRatio);
    childBucket.y1 = Math.max(childBucket.y1, yRatio);
  }
  let children = [];
  for (const childBucket of childBuckets) {
    const { indices: childIndices, x0: cx0, x1: cx1, y0: cy0, y1: cy1 } = childBucket;
    const child = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, childIndices, cx0, cy0, cx1, cy1);
    if (child != null)
      children.push(child);
  }
  if (children.length === 1) {
    return children[0];
  } else if (children.length === 0) {
    children = null;
  }
  const scale2 = Math.hypot(x1 - x0, y1 - y0);
  const primaryDatumIndex = getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1);
  return { scale: scale2, x0, y0, x1, y1, indices, primaryDatumIndex, children };
}
function aggregateBubbleData(xScale, yScale, xValues, yValues, sizeValues, xDomain, yDomain, sizeDomain) {
  const [xd0, xd1] = aggregationDomain(xScale, xDomain);
  const [yd0, yd1] = aggregationDomain(yScale, yDomain);
  const [sd0, sd1] = sizeDomain;
  const filters = [];
  if (sizeValues != null && sd1 > sd0) {
    const sizeIndices = Array.from({ length: SIZE_QUANTIZATION }, () => []);
    for (let datumIndex = 0; datumIndex < sizeValues.length; datumIndex += 1) {
      const sizeValue = sizeValues[datumIndex];
      const sizeRatio = (sizeValue - sd0) / (sd1 - sd0);
      const sizeIndex = sizeRatio * SIZE_QUANTIZATION | 0;
      if (sizeIndex >= 0 && sizeIndex < SIZE_QUANTIZATION) {
        sizeIndices[sizeIndex].push(datumIndex);
      }
    }
    for (let i = 0; i < sizeIndices.length; i += 1) {
      const indices = sizeIndices[i];
      const node = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, 0, 0, 1, 1);
      if (node != null) {
        const sizeRatio = i / SIZE_QUANTIZATION;
        filters.push({ sizeRatio, node });
      }
    }
  } else {
    const indices = xValues.map((_, i) => i);
    const node = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, 0, 0, 1, 1);
    if (node != null) {
      filters.push({ sizeRatio: 0, node });
    }
  }
  return filters.length > 0 ? { xValues, yValues, xd0, xd1, yd0, yd1, filters } : void 0;
}
function computeBubbleAggregationCountIndices(dilation, dataAggregation, options, counter, groupedAggregation, singleDatumIndices) {
  const {
    xRange,
    yRange,
    xVisibleRange: [xvr0, xvr1],
    yVisibleRange: [yvr0, yvr1],
    minSize,
    maxSize
  } = options;
  const { xValues, yValues, xd0, xd1, yd0, yd1 } = dataAggregation;
  const baseScalingFactor = 1 / Math.min(xRange / (xvr1 - xvr0), yRange / (yvr1 - yvr0));
  for (const { sizeRatio, node } of dataAggregation.filters) {
    const radius = 0.5 * (minSize + sizeRatio * (maxSize - minSize));
    const baseMinScale = radius * baseScalingFactor;
    const minScale = dilation * baseMinScale;
    const x0 = xvr0 - radius / xRange;
    const x1 = xvr1 + radius / xRange;
    const y0 = yvr0 - radius / yRange;
    const y1 = yvr1 + radius / yRange;
    const queue = [node];
    while (queue.length > 0) {
      const item = queue.pop();
      if (item.x1 < x0 || item.x0 > x1 || item.y1 < y0 || item.y0 > y1) {
        continue;
      }
      if (item.scale <= minScale) {
        if (counter != null) {
          counter.count += 1;
        }
        groupedAggregation?.push({
          datumIndex: item.primaryDatumIndex,
          count: item.indices.length,
          dilation: clamp(1, item.scale / baseMinScale, dilation)
        });
      } else if (item.children == null) {
        const { indices } = item;
        if (counter != null) {
          const fullyVisible = item.x0 >= xvr0 && item.x1 <= xvr1 && item.y0 >= yvr0 && item.y1 <= yvr1;
          const itemCount = fullyVisible ? indices.length : countVisibleItems(xValues, yValues, xd0, yd0, xd1, yd1, indices, xvr0, yvr0, xvr1, yvr1);
          counter.count += itemCount;
        }
        singleDatumIndices?.push(...indices);
      } else {
        queue.push(...item.children);
      }
    }
  }
}
function computeBubbleAggregationCount(dilation, dataAggregation, options) {
  const counter = { count: 0 };
  computeBubbleAggregationCountIndices(dilation, dataAggregation, options, counter, void 0, void 0);
  return counter.count;
}
var MAX_AGGREGATION_DILATION = 100;
var DILATION_ITERATIONS = 12;
function computeBubbleAggregationDilation(dataAggregation, aggregationOptions, maxRenderedItems) {
  let minDilation = 1;
  let maxDilation = 2;
  while (computeBubbleAggregationCount(maxDilation, dataAggregation, aggregationOptions) > maxRenderedItems && maxDilation < MAX_AGGREGATION_DILATION) {
    minDilation *= 2;
    maxDilation *= 2;
  }
  for (let i = 0; i < DILATION_ITERATIONS; i += 1) {
    const dilation = (maxDilation + minDilation) / 2;
    const count = computeBubbleAggregationCount(dilation, dataAggregation, aggregationOptions);
    if (count > maxRenderedItems) {
      minDilation = dilation;
    } else {
      maxDilation = dilation;
    }
  }
  return minDilation;
}
function computeBubbleAggregationData(dilation, dataAggregation, options) {
  const groupedAggregation = [];
  const singleDatumIndices = [];
  computeBubbleAggregationCountIndices(
    dilation,
    dataAggregation,
    options,
    void 0,
    groupedAggregation,
    singleDatumIndices
  );
  return { groupedAggregation, singleDatumIndices };
}

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker = class extends SeriesMarker {
  constructor() {
    super(...arguments);
    this.maxSize = 30;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], BubbleSeriesMarker.prototype, "maxSize", 2);
__decorateClass([
  Property,
  SceneArrayChangeDetection()
], BubbleSeriesMarker.prototype, "domain", 2);
var BubbleSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "top";
  }
};
__decorateClass([
  Property
], BubbleSeriesLabel.prototype, "placement", 2);
var BubbleSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.label = new BubbleSeriesLabel();
    this.tooltip = makeSeriesTooltip();
    this.maxRenderedItems = Infinity;
    // No validation. Not a part of the options contract.
    this.marker = new BubbleSeriesMarker();
  }
};
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "title", 2);
__decorateClass([
  ProxyProperty("marker.shape")
], BubbleSeriesProperties.prototype, "shape", 2);
__decorateClass([
  ProxyProperty("marker.size")
], BubbleSeriesProperties.prototype, "size", 2);
__decorateClass([
  ProxyProperty("marker.maxSize")
], BubbleSeriesProperties.prototype, "maxSize", 2);
__decorateClass([
  ProxyProperty("marker.domain")
], BubbleSeriesProperties.prototype, "domain", 2);
__decorateClass([
  ProxyProperty("marker.fillGradientDefaults")
], BubbleSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillPatternDefaults")
], BubbleSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillImageDefaults")
], BubbleSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fill")
], BubbleSeriesProperties.prototype, "fill", 2);
__decorateClass([
  ProxyProperty("marker.fillOpacity")
], BubbleSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  ProxyProperty("marker.stroke")
], BubbleSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  ProxyProperty("marker.strokeWidth")
], BubbleSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  ProxyProperty("marker.strokeOpacity")
], BubbleSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  ProxyProperty("marker.lineDash")
], BubbleSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  ProxyProperty("marker.lineDashOffset")
], BubbleSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  ProxyProperty("marker.itemStyler")
], BubbleSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "maxRenderedItems", 2);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleScatterSeriesNodeEvent = class extends CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.sizeKey = series.properties.sizeKey;
  }
};
var BubbleSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: {
        ...DEFAULT_CARTESIAN_DIRECTION_KEYS,
        label: ["labelKey"],
        size: ["sizeKey"]
      },
      propertyNames: {
        ...DEFAULT_CARTESIAN_DIRECTION_NAMES,
        label: ["labelName"],
        size: ["sizeName"]
      },
      categoryKey: void 0,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        label: resetLabelFn,
        datum: resetMarkerFn
      },
      usesPlacedLabels: true,
      clipFocusBox: false
    });
    this.NodeEvent = BubbleScatterSeriesNodeEvent;
    this.properties = new BubbleSeriesProperties();
    this.dataAggregation = void 0;
    this.sizeScale = new LinearScale();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (this.data == null || !this.visible)
      return;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const sizeScaleType = this.sizeScale.type;
    const { xKey, yKey, sizeKey, xFilterKey, yFilterKey, sizeFilterKey, labelKey, marker } = this.properties;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty(yKey, yScaleType, { id: `yValue` }),
        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],
        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],
        ...sizeKey ? [valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` })] : [],
        ...labelKey ? [valueProperty(labelKey, "category", { id: `labelValue` })] : []
      ]
    });
    this.dataAggregation = this.aggregateData(dataModel, processedData);
    const sizeKeyIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
    const mutableMarkerDomain = marker.domain ? [marker.domain[0], marker.domain[1]] : void 0;
    this.sizeScale.domain = mutableMarkerDomain ?? (sizeKeyIdx == null ? void 0 : processedData.domain.values[sizeKeyIdx]) ?? [];
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue2, pixelSize, index) {
    const { properties, sizeScale } = this;
    const { size, sizeKey } = properties;
    const x = this.axes["x" /* X */].scale.convert(xValue2);
    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;
    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
    const r = 0.5 * sizeValue * pixelSize;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize, index) {
    const { properties, sizeScale } = this;
    const { size, sizeKey } = properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;
    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
    const r = 0.5 * sizeValue * pixelSize;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const dataValues = {
      ["x" /* X */]: "xValue",
      ["y" /* Y */]: "yValue"
    };
    const id = dataValues[direction];
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if (dataDef?.def.type === "value" && dataDef?.def.valueType === "category") {
      return domain;
    }
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossId = dataValues[crossDirection];
    const ext = this.domainForClippedRange(direction, [id], crossId);
    return fixNumericExtent(extent(ext));
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange("y" /* Y */, ["yValue"], "xValue", visibleRange);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const { dataAggregation, axes } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (dataAggregation == null || xAxis == null || yAxis == null) {
      return this.countVisibleItems("xValue", ["yValue"], xVisibleRange, yVisibleRange, minVisibleItems);
    }
    const aggregationOptions = this.aggregationOptions(xAxis, yAxis, xVisibleRange, yVisibleRange ?? [0, 1]);
    return computeBubbleAggregationCount(0, dataAggregation, aggregationOptions);
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type === "grouped")
      return;
    if (processedData.input.count <= this.properties.maxRenderedItems)
      return;
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (xAxis == null || yAxis == null)
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    if (!ContinuousScale.is(xScale) || !ContinuousScale.is(yScale))
      return;
    const { sizeScale, properties } = this;
    const { sizeKey } = properties;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const sizeValues = sizeKey ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const xDomain = dataModel.getDomain(this, `xValue`, "value", processedData);
    const yDomain = dataModel.getDomain(this, `yValue`, "value", processedData);
    const sizeDomain = sizeKey ? sizeScale.domain : [0, 0];
    return aggregateBubbleData(
      xScale.type,
      yScale.type,
      xValues,
      yValues,
      sizeValues,
      xDomain,
      yDomain,
      sizeDomain
    );
  }
  aggregationOptions(xAxis, yAxis, xVisibleRange = xAxis.visibleRange, yVisibleRange = yAxis.visibleRange) {
    const { sizeKey, marker } = this.properties;
    const xRange = Math.abs(xAxis.range[1] - xAxis.range[0]);
    const yRange = Math.abs(yAxis.range[1] - yAxis.range[0]);
    const minSize = marker.size;
    const maxSize = sizeKey ? marker.maxSize : minSize;
    return { xRange, yRange, minSize, maxSize, xVisibleRange, yVisibleRange };
  }
  createNodeData() {
    const { axes, dataModel, processedData, sizeScale, visible } = this;
    const {
      xKey,
      yKey,
      sizeKey,
      xFilterKey,
      yFilterKey,
      sizeFilterKey,
      labelKey,
      xName,
      yName,
      sizeName,
      labelName,
      label,
      marker,
      maxRenderedItems
    } = this.properties;
    const { enabled: labelEnabled, placement } = label;
    const anchor = Marker.anchor(marker.shape);
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!(dataModel && processedData && visible && xAxis && yAxis)) {
      return;
    }
    const xDataValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yDataValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const sizeDataValues = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, `xFilterValue`, processedData) : void 0;
    const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const sizeFilterDataValues = sizeFilterKey != null ? dataModel.resolveColumnById(this, `sizeFilterValue`, processedData) : void 0;
    let labelTextDomain;
    if (labelKey) {
      labelTextDomain = [];
    } else if (sizeKey) {
      labelTextDomain = dataModel.getDomain(this, `sizeValue`, "value", processedData);
    } else {
      labelTextDomain = [];
    }
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    sizeScale.range = [marker.size, marker.maxSize];
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: label });
    const rawData = processedData.dataSources.get(this.id);
    if (rawData == null)
      return;
    const padding2 = expandLabelPadding(label);
    const handleDatum = (datumIndex, count, dilation) => {
      const datum = rawData[datumIndex];
      const xDatum = xDataValues[datumIndex];
      const yDatum = yDataValues[datumIndex];
      const sizeValue = sizeDataValues?.[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      let selected;
      if (xFilterDataValues != null && yFilterDataValues != null) {
        selected = xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum;
        if (sizeFilterDataValues != null) {
          selected && (selected = sizeFilterDataValues[datumIndex] === sizeValue);
        }
      }
      let nodeLabel;
      if (labelEnabled) {
        let labelTextValue;
        let labelTextKey;
        let labelTextProperty;
        if (labelKey && labelDataValues) {
          labelTextValue = labelDataValues[datumIndex];
          labelTextKey = labelKey;
          labelTextProperty = "label";
        } else if (sizeKey) {
          labelTextValue = sizeValue;
          labelTextKey = sizeKey;
          labelTextProperty = "size";
        } else {
          labelTextValue = yDatum;
          labelTextKey = yKey;
          labelTextProperty = "y";
        }
        const labelText = this.getLabelText(
          labelTextValue,
          datum,
          labelTextKey,
          labelTextProperty,
          labelTextDomain,
          label,
          { value: labelTextValue, datum, xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName }
        );
        const size = textMeasurer.measureText(String(labelText));
        size.width += padding2.left + padding2.right;
        size.height += padding2.bottom + padding2.top;
        nodeLabel = { text: labelText, ...size };
      } else {
        nodeLabel = { text: "", width: 0, height: 0 };
      }
      const markerSize = sizeValue != null ? sizeScale.convert(sizeValue) : marker.size;
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        datum,
        datumIndex,
        xValue: xDatum,
        yValue: yDatum,
        sizeValue,
        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },
        point: { x, y, size: Math.sqrt(dilation) * markerSize },
        midPoint: { x, y },
        label: nodeLabel,
        anchor,
        placement,
        count,
        dilation,
        selected
      });
    };
    const { dataAggregation } = this;
    if (dataAggregation == null) {
      for (let datumIndex = 0; datumIndex < rawData.length; datumIndex++) {
        handleDatum(datumIndex, 1, 1);
      }
    } else {
      const aggregationOptions = this.aggregationOptions(xAxis, yAxis);
      const aggregationDilation = computeBubbleAggregationDilation(
        dataAggregation,
        aggregationOptions,
        maxRenderedItems
      );
      const { groupedAggregation, singleDatumIndices } = computeBubbleAggregationData(
        aggregationDilation,
        dataAggregation,
        aggregationOptions
      );
      for (const { datumIndex, count, dilation } of groupedAggregation) {
        handleDatum(datumIndex, count, dilation);
      }
      for (const datumIndex of singleDatumIndices) {
        handleDatum(datumIndex, 1, 1);
      }
    }
    return {
      itemId: yKey,
      nodeData,
      labelData: labelEnabled ? nodeData : [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    if (!this.isLabelEnabled())
      return [];
    return this.contextNodeData?.labelData ?? [];
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const { sizeKey } = this.properties;
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    const data = this.properties.marker.enabled ? nodeData : [];
    let getId;
    if (sizeKey) {
      getId = (datum) => createDatumId([datum.xValue, datum.yValue, datum.sizeValue, datum.label.text]);
    }
    return datumSelection.update(data, void 0, getId);
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    this.sizeScale.range = [marker.size, marker.maxSize];
    const fillBBox = this.getShapeFillBBox();
    const aggregated = this.dataAggregation != null;
    const params = { xKey, yKey, sizeKey, labelKey };
    datumSelection.each((node, datum, index) => {
      const { count, dilation } = datum;
      const style2 = this.getMarkerStyle(marker, datum, params, isHighlight);
      style2.fillOpacity = (1 - (1 - (style2.fillOpacity ?? 1)) ** count) / Math.sqrt(dilation);
      this.applyMarkerStyle(style2, node, datum.point, fillBBox, { selected: datum.selected });
      node.zIndex = aggregated ? [-count, index] : 0;
    });
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
  }
  updatePlacedLabelData(labelData) {
    this.labelSelection.update(
      labelData.map((v) => ({
        ...v.datum,
        point: {
          x: v.x,
          y: v.y,
          size: v.datum.point.size
        }
      })),
      (text2) => {
        text2.pointerEvents = 1 /* None */;
      }
    );
    this.updateLabelNodes({ labelSelection: this.labelSelection });
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    opts.labelSelection.each((text2, datum) => {
      const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
      const style2 = getLabelStyles(
        this,
        datum,
        this.properties,
        this.properties.label,
        highlighted,
        highlightState
      );
      text2.text = datum.label.text;
      text2.fill = style2.color;
      text2.x = datum.point?.x ?? 0;
      text2.y = datum.point?.y ?? 0;
      text2.fontStyle = style2.fontStyle;
      text2.fontWeight = style2.fontWeight;
      text2.fontSize = style2.fontSize;
      text2.fontFamily = style2.fontFamily;
      text2.textAlign = "left";
      text2.textBaseline = "top";
      text2.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
      text2.setBoxing(style2);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties, ctx } = this;
    const { formatManager } = ctx;
    const {
      xKey,
      xName,
      yKey,
      yName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      title,
      tooltip,
      marker,
      legendItemName
    } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    const nodeDatum = this.contextNodeData?.nodeData[datumIndex];
    if (xValue2 == null || nodeDatum == null)
      return;
    const data = [];
    if (this.isLabelEnabled() && labelKey != null) {
      const value = dataModel.resolveColumnById(this, `labelValue`, processedData)[datumIndex];
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value,
        datum,
        seriesId,
        legendItemName,
        key: labelKey,
        source: "tooltip",
        property: "label",
        domain: [],
        boundSeries: this.getFormatterContext("label")
      });
      data.push({ label: labelName, fallbackLabel: labelKey, value: content ?? formatValue(value) });
    }
    data.push(
      {
        label: xName,
        fallbackLabel: xKey,
        value: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName)
      },
      {
        label: yName,
        fallbackLabel: yKey,
        value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
      }
    );
    if (sizeKey != null) {
      const value = dataModel.resolveColumnById(this, `sizeValue`, processedData)[datumIndex];
      const domain = dataModel.getDomain(this, `sizeValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value,
        datum,
        seriesId,
        legendItemName,
        key: sizeKey,
        source: "tooltip",
        property: "size",
        boundSeries: this.getFormatterContext("size"),
        domain,
        fractionDigits: void 0
      });
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: content ?? formatValue(value) });
    }
    const activeStyle = this.getMarkerStyle(
      marker,
      { datum, datumIndex },
      { xKey, yKey, sizeKey, labelKey, highlighted: true },
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yKey,
        xKey,
        xName,
        yKey,
        yName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const marker = this.getMarkerStyle(this.properties.marker, {}, void 0, false, void 0, void 0, false);
    return {
      marker
    };
  }
  getLegendData() {
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, title } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol()
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    markerScaleInAnimation(this, this.ctx.animationManager, datumSelection);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Marker();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    return this.getMarkerStyle(marker, datum, { xKey, yKey, sizeKey, labelKey }, false);
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
  hasItemStylers() {
    const { itemStyler, marker, label } = this.properties;
    return !!(itemStyler ?? marker.itemStyler ?? label.itemStyler);
  }
};
BubbleSeries.className = "BubbleSeries";
BubbleSeries.type = "bubble";

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bubble",
  moduleFactory: (ctx) => new BubbleSeries(ctx),
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      maxSize: 30,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      maxRenderedItems: 1e4,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewBubbleSeriesModule = {
  type: "series",
  name: "bubble",
  chartType: "cartesian",
  options: bubbleSeriesOptionsDef,
  create: (ctx) => new BubbleSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.areaPlot = false;
    this.aggregation = "sum";
    this.shadow = new DropShadow();
    this.label = new Label();
    this.tooltip = makeSeriesTooltip();
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke3, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "areaPlot", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "bins", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "aggregation", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "binCount", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount = 10;
var HistogramSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: void 0,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      datumSelectionGarbageCollection: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new HistogramSeriesProperties();
    this.calculatedBins = [];
  }
  // During processData phase, used to unify different ways of the user specifying
  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
  deriveBins(xDomain) {
    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount).ticks;
    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
    const [firstBinEnd] = binStarts;
    const expandStartToBin = (n) => [n, n + binSize];
    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
  }
  calculateNiceBins(domain, binCount) {
    const startGuess = Math.floor(domain[0]);
    const stop = domain[1];
    const segments = binCount || 1;
    const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);
    return this.getBins(start2, stop, binSize, segments);
  }
  getBins(start2, stop, step, count) {
    const bins = [];
    const precision = this.calculatePrecision(step);
    for (let i = 0; i < count; i++) {
      const a = Math.round((start2 + i * step) * precision) / precision;
      let b = Math.round((start2 + (i + 1) * step) * precision) / precision;
      if (i === count - 1) {
        b = Math.max(b, stop);
      }
      bins[i] = [a, b];
    }
    return bins;
  }
  calculatePrecision(step) {
    let precision = 10;
    if (isFinite(step) && step > 0) {
      while (step < 1) {
        precision *= 10;
        step *= 10;
      }
    }
    return precision;
  }
  calculateNiceStart(a, b, segments) {
    const binSize = Math.abs(b - a) / segments;
    const order = Math.floor(Math.log10(binSize));
    const magnitude = Math.pow(10, order);
    const start2 = Math.floor(a / magnitude) * magnitude;
    return {
      start: start2,
      binSize
    };
  }
  async processData(dataController) {
    if (!this.visible) {
      this.processedData = void 0;
      this.animationState.transition("updateData");
    }
    const { xKey, yKey, areaPlot, aggregation } = this.properties;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });
    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];
    if (yKey) {
      let aggProp = groupCount("groupAgg");
      if (aggregation === "count") {
      } else if (aggregation === "sum") {
        aggProp = groupSum("groupAgg");
      } else if (aggregation === "mean") {
        aggProp = groupAverage("groupAgg");
      }
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);
    } else {
      props.push(rowCountProperty("count"));
      let aggProp = groupCount("groupAgg");
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(aggProp);
    }
    const groupByFn = (dataSet) => {
      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
      if (xExtent.length === 0) {
        dataSet.domain.groups = [];
        return () => [];
      }
      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);
      const binCount = bins.length;
      this.calculatedBins = [...bins];
      return (keys) => {
        let xValue2 = keys[0];
        if (isDate(xValue2)) {
          xValue2 = xValue2.getTime();
        }
        if (!isNumber(xValue2))
          return [];
        for (let i = 0; i < binCount; i++) {
          const nextBin = bins[i];
          if (xValue2 >= nextBin[0] && xValue2 < nextBin[1]) {
            return nextBin;
          }
          if (i === binCount - 1 && xValue2 <= nextBin[1]) {
            return nextBin;
          }
        }
        return [];
      };
    };
    if (!this.ctx.animationManager.isSkipped() && this.processedData) {
      props.push(diff(this.id, this.processedData, false));
    }
    await this.requestDataModel(dataController, this.data, {
      props,
      groupByFn
    });
    this.animationState.transition("updateData");
  }
  xCoordinateRange() {
    return [NaN, NaN];
  }
  yCoordinateRange() {
    return [NaN, NaN];
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.calculatedBins.length)
      return [];
    const yDomain = dataModel.getDomain(this, `groupAgg`, "aggregate", processedData);
    const xDomainMin = this.calculatedBins?.[0][0];
    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];
    if (direction === "x" /* X */) {
      return fixNumericExtent([xDomainMin, xDomainMax]);
    }
    return fixNumericExtent(yDomain);
  }
  getSeriesRange(_direction, [r0, r1]) {
    const { dataModel, processedData } = this;
    if (!dataModel || processedData?.type !== "grouped")
      return [NaN, NaN];
    const xScale = this.axes["x" /* X */].scale;
    const yMin = 0;
    let yMax = -Infinity;
    processedData.groups.forEach(({ keys, aggregation }) => {
      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
      const [xDomainMin, xDomainMax] = keys;
      const [x0, x1] = findMinMax([xScale.convert(xDomainMin), xScale.convert(xDomainMax)]);
      if (x1 >= r0 && x0 <= r1) {
        const total = negativeAgg + positiveAgg;
        yMax = Math.max(yMax, total);
      }
    });
    if (yMin > yMax)
      return [NaN, NaN];
    return [yMin, yMax];
  }
  frequency(group) {
    return group.datumIndices.reduce((acc, datumIndices) => acc + datumIndices.length, 0);
  }
  createNodeData() {
    const { axes, processedData, dataModel } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !dataModel) {
      return;
    }
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const { xKey, yKey, xName, yName, label } = this.properties;
    const nodeData = [];
    const context = {
      itemId: this.properties.yKey ?? this.id,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      animationValid: true,
      visible: this.visible
    };
    if (!this.visible || processedData == null || processedData.type !== "grouped") {
      return context;
    }
    processedData.groups.forEach((group, groupIndex) => {
      const { keys, aggregation } = group;
      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
      const frequency = this.frequency(group);
      const domain = keys;
      const [xDomainMin, xDomainMax] = domain;
      const datum = [...dataModel.forEachDatum(this, processedData, group)];
      const xMinPx = xScale.convert(xDomainMin);
      const xMaxPx = xScale.convert(xDomainMax);
      const total = negativeAgg + positiveAgg;
      const yZeroPx = yScale.convert(0);
      const yMaxPx = yScale.convert(total);
      const w = Math.abs(xMaxPx - xMinPx);
      const h = Math.abs(yMaxPx - yZeroPx);
      const x = Math.min(xMinPx, xMaxPx);
      const y = Math.min(yZeroPx, yMaxPx);
      let selectionDatumLabel = void 0;
      if (label.enabled && total !== 0) {
        selectionDatumLabel = {
          x: x + w / 2,
          y: y + h / 2,
          text: this.getLabelText(
            total,
            datum,
            yKey,
            "y",
            [],
            label,
            { value: total, datum, xKey, yKey, xName, yName }
          )
        };
      }
      const nodeMidPoint = {
        x: x + w / 2,
        y: y + h / 2
      };
      const yAxisReversed = yAxis.isReversed();
      nodeData.push({
        series: this,
        datumIndex: groupIndex,
        datum,
        // required by SeriesNodeDatum, but might not make sense here
        // since each selection is an aggregation of multiple data.
        aggregatedValue: total,
        frequency,
        domain,
        yKey,
        xKey,
        x,
        y,
        xValue: xMinPx,
        yValue: yMaxPx,
        width: w,
        height: h,
        midPoint: nodeMidPoint,
        topLeftCornerRadius: !yAxisReversed,
        topRightCornerRadius: !yAxisReversed,
        bottomRightCornerRadius: yAxisReversed,
        bottomLeftCornerRadius: yAxisReversed,
        label: selectionDatumLabel,
        crisp: true
      });
    });
    nodeData.sort((a, b) => a.x - b.x);
    return context;
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    return datumSelection.update(nodeData, void 0, (datum) => datum.domain.join("_"));
  }
  getItemStyle(isHighlight, datum) {
    const { properties } = this;
    const highlightStyle = this.getHighlightStyle(isHighlight, datum?.datumIndex);
    return getShapeStyle(
      mergeDefaults(highlightStyle, properties.getStyle()),
      properties.fillGradientDefaults,
      properties.fillPatternDefaults,
      properties.fillImageDefaults
    );
  }
  updateDatumNodes(opts) {
    const { isHighlight } = opts;
    const { shadow } = this.properties;
    const fillBBox = this.getShapeFillBBox();
    opts.datumSelection.each((rect, datum) => {
      const style2 = this.getItemStyle(isHighlight, datum);
      const { cornerRadius = 0 } = style2;
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius } = datum;
      applyShapeStyle(rect, style2, fillBBox);
      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
      rect.visible = datum.height > 0;
    });
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = 1 /* None */;
      text2.textAlign = "center";
      text2.textBaseline = "middle";
    });
  }
  updateLabelNodes(opts) {
    const labelEnabled = this.isLabelEnabled();
    opts.labelSelection.each((text2, datum) => {
      const style2 = getLabelStyles(this, datum, this.properties, this.properties.label);
      const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color2 } = style2;
      if (enabled && labelEnabled && datum?.label) {
        text2.text = datum.label.text;
        text2.x = datum.label.x;
        text2.y = datum.label.y;
        text2.fontStyle = fontStyle;
        text2.fontWeight = fontWeight;
        text2.fontFamily = fontFamily;
        text2.fontSize = fontSize;
        text2.fill = color2;
        text2.visible = true;
        text2.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
        text2.setBoxing(style2);
      } else {
        text2.visible = false;
      }
    });
  }
  initQuadTree(quadtree) {
    const { value: childNode } = this.contentGroup.children().next();
    if (childNode instanceof Group) {
      addHitTestersToQuadtree(quadtree, childNode.children());
    }
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      axes,
      properties,
      ctx: { localeManager }
    } = this;
    const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || processedData?.type !== "grouped" || !xAxis || !yAxis) {
      return;
    }
    const group = processedData.groups[datumIndex];
    const { aggregation, keys } = group;
    const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
    const frequency = this.frequency(group);
    const domain = keys;
    const [rangeMin, rangeMax] = domain;
    const aggregatedValue = negativeAgg + positiveAgg;
    const datum = {
      data: [...dataModel.forEachDatum(this, processedData, group)],
      aggregatedValue,
      frequency,
      domain
    };
    const data = [
      {
        label: xName,
        fallbackLabel: xKey,
        value: `${this.getAxisValueText(xAxis, "tooltip", rangeMin, datum, xKey, legendItemName)} - ${this.getAxisValueText(xAxis, "tooltip", rangeMax, datum, xKey, legendItemName)}`
      },
      {
        label: localeManager.t("seriesHistogramTooltipFrequency"),
        value: this.getAxisValueText(yAxis, "tooltip", frequency, datum, yKey, legendItemName)
      }
    ];
    if (yKey != null) {
      let label;
      switch (properties.aggregation) {
        case "sum":
          label = localeManager.t("seriesHistogramTooltipSum", { yName: yName ?? yKey });
          break;
        case "mean":
          label = localeManager.t("seriesHistogramTooltipMean", { yName: yName ?? yKey });
          break;
        case "count":
          label = localeManager.t("seriesHistogramTooltipCount", { yName: yName ?? yKey });
          break;
      }
      data.push({
        label,
        value: this.getAxisValueText(yAxis, "tooltip", aggregatedValue, datum, yKey, legendItemName)
      });
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        // HistogramSeries is an outlier since it's callbacks don't use TDatum.
        xName,
        yKey,
        // HistogramSeries is an outlier since it's callbacks don't use TDatum.
        yName,
        xRange: [rangeMin, rangeMax],
        frequency,
        ...this.getItemStyle(false)
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      fillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults4,
      fillPatternDefaults: fillPatternDefaults4,
      fillImageDefaults: fillImageDefaults4
    } = this.properties;
    return {
      marker: getShapeStyle(
        {
          fill: fill ?? "rgba(0, 0, 0, 0)",
          stroke: stroke3 ?? "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults4,
        fillPatternDefaults4,
        fillImageDefaults4
      )
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { xKey: itemId, yName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: yName ?? itemId ?? "Frequency"
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetDatumAnimation(data);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds(this, this.contextNodeData?.nodeData[datumIndex]);
  }
  hasItemStylers() {
    return this.properties.label.itemStyler != null;
  }
};
HistogramSeries.className = "HistogramSeries";
HistogramSeries.type = "histogram";

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "histogram",
  moduleFactory: (ctx) => new HistogramSeries(ctx),
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      strokeWidth: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "chartBackgroundColor" }
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewHistogramSeriesModule = {
  type: "series",
  name: "histogram",
  chartType: "cartesian",
  enterprise: true,
  options: histogramSeriesOptionsDef,
  create: (ctx) => new HistogramSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = makeSeriesTooltip();
    this.connectMissingData = false;
    this.sparklineMode = false;
  }
};
__decorateClass([
  Property
], LineSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "connectMissingData", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "sparklineMode", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;
var memoizedAggregateLineData2 = simpleMemorize2(aggregateLineData);
var LineSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        datum: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new LineSeriesProperties();
    this.dataAggregationFilters = void 0;
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : "main-category";
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 0 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stacked = stackCount > 1 || normalizedTo != null;
    const common = { invalidValue: null };
    if (connectMissingData && stacked) {
      common.invalidValue = 0;
    }
    if (stacked && !visible) {
      common.forceValue = 0;
    }
    const props = [];
    if (!isContinuousX || stacked) {
      props.push(keyProperty(xKey, xScaleType, { id: "xKey" }));
    }
    props.push(
      valueProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, {
        id: `yValueRaw`,
        ...common,
        invalidValue: void 0
      })
    );
    if (yFilterKey != null) {
      props.push(valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" }));
    }
    if (stacked) {
      const ids = [
        `line-stack-${groupIndex}-yValues`,
        `line-stack-${groupIndex}-yValues-trailing`,
        `line-stack-${groupIndex}-yValues-marker`
      ];
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: ids[0] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "window-trailing",
          "current",
          { id: `yValueStart`, ...common, groupId: ids[1] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: ids[2] },
          yScaleType
        )
      );
      if (isDefined(normalizedTo)) {
        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo));
      }
    }
    if (animationEnabled) {
      props.push(animationValidation(isContinuousX ? ["xValue"] : void 0));
      if (this.processedData) {
        props.push(diff(this.id, this.processedData));
      }
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: stacked,
      groupByData: !stacked
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue2, pixelSize) {
    const { marker } = this.properties;
    const x = this.axes["x" /* X */].scale.convert(xValue2);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const { marker } = this.properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === "x" /* X */) {
      const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
      if (xDef?.def.type === "value" && xDef.def.valueType === "category") {
        return domain;
      }
      return fixNumericExtent(extent(domain));
    }
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    const yExtent = this.domainForClippedRange("y" /* Y */, [yKey], "xValue");
    return fixNumericExtent(yExtent);
  }
  getSeriesRange(_direction, visibleRange) {
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    return this.domainForVisibleRange("y" /* Y */, [yKey], "xValue", visibleRange);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    return this.countVisibleItems("xValue", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable(processedData))
      return;
    const xAxis = this.axes["x" /* X */];
    if (xAxis == null)
      return;
    const { scale: scale2 } = xAxis;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
    return memoizedAggregateLineData2(scale2.type, xValues, yValues, domain);
  }
  createNodeData() {
    const { dataModel, processedData, axes, dataAggregationFilters } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const {
      xKey,
      yKey,
      yFilterKey,
      xName,
      yName,
      marker,
      label,
      connectMissingData,
      interpolation,
      legendItemName
    } = this.properties;
    const stacked = this.dataModel?.hasColumnById(this, `yValueEnd`);
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const size = marker.enabled ? marker.size : 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValueEnd`, processedData) : void 0;
    const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, `yValueCumulative`, processedData) : yValues;
    const selectionValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterRaw`, processedData) : void 0;
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const capDefaults = {
      lengthRatioMultiplier: this.properties.marker.getDiameter(),
      lengthMax: Infinity
    };
    const nodeData = [];
    const spanPoints = [];
    const handleDatum = (datumIndex) => {
      const datum = rawData[datumIndex];
      const xDatum = xValues[datumIndex];
      const yDatum = yValues[datumIndex];
      const yEndDatum = yEndValues?.[datumIndex];
      const selected = selectionValues?.[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yCumulativeValues[datumIndex]) + yOffset;
      if (!Number.isFinite(x))
        return;
      if (yDatum != null) {
        const labelText = label.enabled ? this.getLabelText(yDatum, datum, yKey, "y", yDomain, label, {
          value: yDatum,
          datum,
          xKey,
          yKey,
          xName,
          yName,
          legendItemName
        }) : void 0;
        nodeData.push({
          series: this,
          datum,
          datumIndex,
          yKey,
          xKey,
          point: { x, y, size },
          midPoint: { x, y },
          cumulativeValue: yEndDatum,
          yValue: yDatum,
          xValue: xDatum,
          capDefaults,
          labelText,
          selected
        });
      }
      const currentSpanPoints = spanPoints[spanPoints.length - 1];
      if (yDatum != null) {
        const spanPoint = {
          point: { x, y },
          xDatum,
          yDatum
        };
        if (Array.isArray(currentSpanPoints)) {
          currentSpanPoints.push(spanPoint);
        } else if (currentSpanPoints != null) {
          currentSpanPoints.skip += 1;
          spanPoints.push([spanPoint]);
        } else {
          spanPoints.push([spanPoint]);
        }
      } else if (!connectMissingData) {
        if (Array.isArray(currentSpanPoints) || currentSpanPoints == null) {
          spanPoints.push({ skip: 0 });
        } else {
          currentSpanPoints.skip += 1;
        }
      }
    };
    const [r0, r1] = xScale.range;
    const range4 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range4);
    const indices = dataAggregationFilter?.indices;
    let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, indices);
    start2 = Math.max(start2 - 1, 0);
    end2 = Math.min(end2 + 1, indices?.length ?? xValues.length);
    if (processedData.input.count < 1e3) {
      start2 = 0;
      end2 = processedData.input.count;
    }
    for (let i = start2; i < end2; i += 1) {
      handleDatum(indices?.[i] ?? i);
    }
    const strokeSpans = spanPoints.flatMap((p) => {
      return Array.isArray(p) ? interpolatePoints(p, interpolation) : [];
    });
    const strokeData = { itemId: yKey, spans: strokeSpans };
    const crossFiltering = selectionValues?.some((selectionValue, index) => selectionValue === yValues[index]) ?? false;
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      strokeData,
      scales: this.calculateScaling(),
      visible: this.visible,
      crossFiltering
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const {
      paths: [lineNode],
      visible,
      animationEnabled
    } = opts;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    const { strokeWidth, stroke: stroke3, strokeOpacity, lineDash, lineDashOffset, opacity } = mergeDefaults(
      this.getHighlightStyle(),
      this.properties
    );
    lineNode.setProperties({
      fill: void 0,
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      opacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity: strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),
      lineDash,
      lineDashOffset
    });
    if (!animationEnabled) {
      lineNode.visible = visible;
    }
    updateClipPath(this, lineNode);
  }
  updateDatumSelection(opts) {
    let { nodeData } = opts;
    const { datumSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    nodeData = markersEnabled ? nodeData : [];
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    return datumSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yKey, marker, stroke: stroke3, strokeWidth, strokeOpacity } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const applyTranslation = this.ctx.animationManager.isSkipped();
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((node, datum) => {
      const { xValue: xValue2, yValue } = datum;
      const params = datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain);
      const style2 = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
        stroke: stroke3,
        strokeWidth,
        strokeOpacity
      });
      this.applyMarkerStyle(style2, node, datum.point, fillBBox, {
        applyTranslation,
        selected: datum.selected
      });
    });
    if (!isHighlight) {
      marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
  }
  updateLabelNodes(opts) {
    const { isHighlight = false } = opts;
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    opts.labelSelection.each((text2, datum) => {
      const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
      const style2 = getLabelStyles(
        this,
        datum,
        this.properties,
        this.properties.label,
        highlighted,
        highlightState
      );
      const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color2 } = style2;
      if (enabled && datum?.labelText) {
        text2.fontStyle = fontStyle;
        text2.fontWeight = fontWeight;
        text2.fontSize = fontSize;
        text2.fontFamily = fontFamily;
        text2.textAlign = "center";
        text2.textBaseline = "bottom";
        text2.text = datum.labelText;
        text2.x = datum.point.x;
        text2.y = datum.point.y - 10;
        text2.fill = color2;
        text2.visible = true;
        text2.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
        text2.setBoxing(style2);
      } else {
        text2.visible = false;
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const params = datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain);
    const format = this.getMarkerStyle(
      this.properties.marker,
      { datumIndex, datum },
      params,
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        ...format,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const color0 = "rgba(0, 0, 0, 0)";
    const { stroke: stroke3, strokeOpacity, strokeWidth, lineDash, marker } = this.properties;
    const markerStyle = this.getMarkerStyle(
      marker,
      {},
      void 0,
      false,
      {
        size: marker.size,
        fill: marker.fill ?? color0,
        stroke: marker.stroke ?? stroke3 ?? color0
      },
      void 0,
      false
    );
    return {
      marker: {
        ...markerStyle,
        enabled: marker.enabled
      },
      line: {
        stroke: stroke3 ?? color0,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, title, legendItemName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        legendItemName,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: legendItemName ?? title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  updatePaths(opts) {
    this.updateLinePaths(opts.paths, opts.contextData);
  }
  updateLinePaths(paths, contextData) {
    const spans = contextData.strokeData.spans;
    const [lineNode] = paths;
    lineNode.path.clear();
    plotLinePathStroke(lineNode, spans);
    lineNode.markDirty("LineSeries");
  }
  animateEmptyUpdateReady(animationData) {
    const { datumSelection, labelSelection, annotationSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateLinePaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([datumSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, datumSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateLinePaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const {
      datumSelection,
      labelSelection: labelSelections,
      annotationSelections,
      contextData,
      paths,
      previousContextData
    } = animationData;
    const [path] = paths;
    if (contextData.visible === false && previousContextData?.visible === false)
      return;
    this.resetDatumAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateLinePaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", datumSelection);
      pathFadeInAnimation(this, "path_properties", animationManager, "add", path);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareLinePathAnimation(
      contextData,
      previousContextData,
      this.processedData?.reduced?.diff?.[this.id]
    );
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    fromToMotion(this.id, "path_properties", animationManager, [path], fns.stroke.pathProperties);
    if (fns.status === "added") {
      this.updateLinePaths(paths, contextData);
    } else if (fns.status === "removed") {
      this.updateLinePaths(paths, previousContextData);
    } else {
      pathMotion(this.id, "path_update", animationManager, [path], fns.stroke.path);
    }
    if (fns.hasMotion) {
      markerFadeInAnimation(this, animationManager, void 0, datumSelection);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0.1 };
  }
  nodeFactory() {
    return new Marker();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey } = this.properties;
    const { xValue: xValue2, yValue } = datum;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    return this.getMarkerStyle(
      this.properties.marker,
      datum,
      datumStylerProperties(xValue2, yValue, xKey, yKey, xDomain, yDomain),
      true
    );
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
LineSeries.className = "LineSeries";
LineSeries.type = "line";

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "line",
  moduleFactory: (ctx) => new LineSeries(ctx),
  stackable: true,
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      stroke: SAFE_STROKE_FILL_OPERATION,
      strokeWidth: 2,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      interpolation: {
        type: "linear"
      },
      marker: {
        shape: "circle",
        size: 7,
        strokeWidth: { $isUserOption: ["./stroke", 1, 0] },
        fill: { $palette: "fill" },
        stroke: { $palette: "stroke" },
        // @ts-expect-error undocumented option
        fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
        fillPatternDefaults: FILL_PATTERN_DEFAULTS,
        fillImageDefaults: FILL_IMAGE_DEFAULTS
      },
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewLineSeriesModule = {
  type: "series",
  name: "line",
  chartType: "cartesian",
  options: lineSeriesOptionsDef,
  create: (ctx) => new LineSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var ScatterSeries = class extends BubbleSeries {
};
ScatterSeries.className = "ScatterSeries";
ScatterSeries.type = "scatter";

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "scatter",
  moduleFactory: (ctx) => new ScatterSeries(ctx),
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      maxRenderedItems: 1e4,
      label: {
        ...LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] },
        position: {
          anchorTo: { $path: ["/tooltip/position/anchorTo", "node"] }
        }
      },
      highlight: multiSeriesHighlightStyle()
    }
  }
};
var NewScatterSeriesModule = {
  type: "series",
  name: "scatter",
  chartType: "cartesian",
  options: scatterSeriesOptionsDef,
  create: (ctx) => new ScatterSeries(ctx)
};

// packages/ag-charts-community/src/scene/sectorBox.ts
var SectorBox = class _SectorBox {
  constructor(startAngle, endAngle, innerRadius, outerRadius) {
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.innerRadius = innerRadius;
    this.outerRadius = outerRadius;
  }
  clone() {
    const { startAngle, endAngle, innerRadius, outerRadius } = this;
    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);
  }
  equals(other) {
    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;
  }
  [interpolate](other, d) {
    return new _SectorBox(
      this.startAngle * (1 - d) + other.startAngle * d,
      this.endAngle * (1 - d) + other.endAngle * d,
      this.innerRadius * (1 - d) + other.innerRadius * d,
      this.outerRadius * (1 - d) + other.outerRadius * d
    );
  }
};

// packages/ag-charts-community/src/scene/util/sector.ts
function sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {
  let x0 = Infinity;
  let y0 = Infinity;
  let x1 = -Infinity;
  let y1 = -Infinity;
  const addPoint = (x, y) => {
    x0 = Math.min(x, x0);
    y0 = Math.min(y, y0);
    x1 = Math.max(x, x1);
    y1 = Math.max(y, y1);
  };
  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));
  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));
  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));
  if (isBetweenAngles(0, startAngle, endAngle)) {
    addPoint(outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {
    addPoint(0, outerRadius);
  }
  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {
    addPoint(-outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {
    addPoint(0, -outerRadius);
  }
  return new BBox(x0, y0, x1 - x0, y1 - y0);
}
function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const { innerRadius, outerRadius } = sector;
  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  const startAngle = normalizeAngle180(sector.startAngle);
  const endAngle = normalizeAngle180(sector.endAngle);
  const angle2 = Math.atan2(y, x);
  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  if (isNaN(cx) || isNaN(cy)) {
    return 0;
  }
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return 0;
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  let intersections = 0;
  [i1x, i2x].forEach((x) => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x + y0;
    const adjacent = x - cx;
    const opposite = y - cy;
    const angle2 = Math.atan2(opposite, adjacent);
    if (isBetweenAngles(angle2, startAngle, endAngle)) {
      intersections++;
    }
  });
  return intersections;
}
function lineCollidesSector(line, sector) {
  const { startAngle, endAngle, innerRadius, outerRadius } = sector;
  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };
  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };
  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };
  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };
  return segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerStart.x,
    outerStart.y,
    innerStart.x,
    innerStart.y
  ) || segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerEnd.x,
    outerEnd.y,
    innerEnd.x,
    innerEnd.y
  ) || arcIntersections(
    0,
    0,
    outerRadius,
    startAngle,
    endAngle,
    true,
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y
  );
}
function boxCollidesSector(box, sector) {
  const topLeft = { x: box.x, y: box.y };
  const topRight = { x: box.x + box.width, y: box.y };
  const bottomLeft = { x: box.x, y: box.y + box.height };
  const bottomRight = { x: box.x + box.width, y: box.y + box.height };
  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);
}
function radiiScalingFactor(r, sweep, a, b) {
  if (a === 0 && b === 0)
    return 0;
  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;
  if (fs1 < 0)
    return 1;
  let start2 = 0;
  let end2 = 1;
  for (let i = 0; i < 8; i += 1) {
    const s = (start2 + end2) / 2;
    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;
    if (fs < 0) {
      start2 = s;
    } else {
      end2 = s;
    }
  }
  return start2;
}
var delta2 = 1e-6;
function clockwiseAngle(angle2, relativeToStartAngle) {
  if (angleBetween(angle2, relativeToStartAngle) < delta2) {
    return relativeToStartAngle;
  } else {
    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;
  }
}
function clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {
  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;
  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);
  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);
  endAngle = startAngle + sweepAngle;
  return { startAngle, endAngle };
}
function arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {
  const sinA = Math.sin(clipAngle);
  const cosA = Math.cos(clipAngle);
  const c = cx ** 2 + cy ** 2 - r ** 2;
  let p0x;
  let p0y;
  let p1x;
  let p1y;
  if (cosA > 0.5) {
    const tanA = sinA / cosA;
    const a = 1 + tanA ** 2;
    const b = -2 * (cx + cy * tanA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const x0 = (-b + Math.sqrt(d)) / (2 * a);
    const x1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = x0;
    p0y = x0 * tanA;
    p1x = x1;
    p1y = x1 * tanA;
  } else {
    const cotA = cosA / sinA;
    const a = 1 + cotA ** 2;
    const b = -2 * (cy + cx * cotA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const y0 = (-b + Math.sqrt(d)) / (2 * a);
    const y1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = y0 * cotA;
    p0y = y0;
    p1x = y1 * cotA;
    p1y = y1;
  }
  const normalisedX = cosA;
  const normalisedY = sinA;
  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;
  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;
  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;
  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}
function arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {
  const d = Math.hypot(cx, cy);
  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);
  const d2 = d - d1;
  const theta = Math.atan2(cy, cx);
  const deltaTheta = Math.acos(-d2 / r);
  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);
  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}

// packages/ag-charts-community/src/scene/shape/sector.ts
var Arc = class {
  constructor(cx, cy, r, a0, a1) {
    this.cx = cx;
    this.cy = cy;
    this.r = r;
    this.a0 = a0;
    this.a1 = a1;
    if (this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  isValid() {
    return Number.isFinite(this.a0) && Number.isFinite(this.a1);
  }
  pointAt(a) {
    return {
      x: this.cx + this.r * Math.cos(a),
      y: this.cy + this.r * Math.sin(a)
    };
  }
  clipStart(a) {
    if (a == null || !this.isValid() || a < this.a0)
      return;
    this.a0 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  clipEnd(a) {
    if (a == null || !this.isValid() || a > this.a1)
      return;
    this.a1 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
};
var Sector = class extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.innerRadius = 10;
    this.outerRadius = 20;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clipSector = void 0;
    this.concentricEdgeInset = 0;
    this.radialEdgeInset = 0;
    this.startOuterCornerRadius = 0;
    this.endOuterCornerRadius = 0;
    this.startInnerCornerRadius = 0;
    this.endInnerCornerRadius = 0;
  }
  set inset(value) {
    this.concentricEdgeInset = value;
    this.radialEdgeInset = value;
  }
  set cornerRadius(value) {
    this.startOuterCornerRadius = value;
    this.endOuterCornerRadius = value;
    this.startInnerCornerRadius = value;
    this.endInnerCornerRadius = value;
  }
  computeBBox() {
    return sectorBox(this).translate(this.centerX, this.centerY);
  }
  normalizedRadii() {
    const { concentricEdgeInset } = this;
    let { innerRadius, outerRadius } = this;
    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;
    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);
    return { innerRadius, outerRadius };
  }
  normalizedClipSector() {
    const { clipSector } = this;
    if (clipSector == null)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);
    return new SectorBox(
      Math.max(startAngle, clipAngles.startAngle),
      Math.min(endAngle, clipAngles.endAngle),
      Math.max(innerRadius, clipSector.innerRadius),
      Math.min(outerRadius, clipSector.outerRadius)
    );
  }
  getAngleOffset(radius) {
    return radius > 0 ? this.radialEdgeInset / radius : 0;
  }
  arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {
    if (r <= 0)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    if (inner && innerRadius <= 0)
      return;
    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);
    const angle2 = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;
    const radius = inner ? innerRadius + r : outerRadius - r;
    const cx = radius * Math.cos(angle2);
    const cy = radius * Math.sin(angle2);
    if (clipSector != null) {
      const delta4 = 1e-6;
      if (!start2 && !(angle2 >= startAngle - delta4 && angle2 <= clipSector.endAngle - delta4))
        return;
      if (start2 && !(angle2 >= clipSector.startAngle + delta4 && angle2 <= endAngle - delta4))
        return;
      if (inner && radius < clipSector.innerRadius - delta4)
        return;
      if (!inner && radius > clipSector.outerRadius + delta4)
        return;
    }
    const arc = new Arc(cx, cy, r, a0, a1);
    if (clipSector != null) {
      if (inner) {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
      } else {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
      }
      let circleClipStart;
      let circleClipEnd;
      if (start2) {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
      } else {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
      }
      arc.clipStart(circleClipStart);
      arc.clipEnd(circleClipEnd);
      if (circleClipStart != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start2) {
          innerArc?.clipStart(theta2);
        } else {
          outerArc.clipEnd(theta2);
        }
      }
      if (circleClipEnd != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start2) {
          outerArc.clipStart(theta2);
        } else {
          innerArc?.clipEnd(theta2);
        }
      }
    }
    if (clipSector != null) {
      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);
      if (!isPointInSector(x2, y2, clipSector))
        return;
    }
    const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);
    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);
    const radialArc = inner ? innerArc : outerArc;
    if (start2) {
      radialArc?.clipStart(theta);
    } else {
      radialArc?.clipEnd(theta);
    }
    return arc;
  }
  updatePath() {
    const delta4 = 1e-6;
    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;
    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    const sweepAngle = endAngle - startAngle;
    const fullPie = sweepAngle >= 2 * Math.PI - delta4;
    path.clear();
    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {
      return;
    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {
      return;
    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {
      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > concentricEdgeInset) {
        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      }
      path.closePath();
      return;
    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
      path.closePath();
      return;
    }
    const innerAngleOffset = this.getAngleOffset(innerRadius);
    const outerAngleOffset = this.getAngleOffset(outerRadius);
    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;
    if (outerAngleExceeded)
      return;
    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;
    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;
    const radialLength = outerRadius - innerRadius;
    const maxRadialLength = Math.max(
      startOuterCornerRadius,
      startInnerCornerRadius,
      endOuterCornerRadius,
      endInnerCornerRadius
    );
    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;
    startOuterCornerRadius *= initialScalingFactor;
    endOuterCornerRadius *= initialScalingFactor;
    startInnerCornerRadius *= initialScalingFactor;
    endInnerCornerRadius *= initialScalingFactor;
    const outerScalingFactor = radiiScalingFactor(
      outerRadius,
      sweepAngle - 2 * outerAngleOffset,
      -startOuterCornerRadius,
      -endOuterCornerRadius
    );
    startOuterCornerRadius *= outerScalingFactor;
    endOuterCornerRadius *= outerScalingFactor;
    if (!innerAngleExceeded && hasInnerSweep) {
      const innerScalingFactor = radiiScalingFactor(
        innerRadius,
        sweepAngle - 2 * innerAngleOffset,
        startInnerCornerRadius,
        endInnerCornerRadius
      );
      startInnerCornerRadius *= innerScalingFactor;
      endInnerCornerRadius *= innerScalingFactor;
    } else {
      startInnerCornerRadius = 0;
      endInnerCornerRadius = 0;
    }
    const maxCombinedRadialLength = Math.max(
      startOuterCornerRadius + startInnerCornerRadius,
      endOuterCornerRadius + endInnerCornerRadius
    );
    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;
    startOuterCornerRadius *= edgesScalingFactor;
    endOuterCornerRadius *= edgesScalingFactor;
    startInnerCornerRadius *= edgesScalingFactor;
    endInnerCornerRadius *= edgesScalingFactor;
    let startOuterCornerRadiusAngleSweep = 0;
    let endOuterCornerRadiusAngleSweep = 0;
    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);
    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);
    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta4) {
      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);
    } else {
      startOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);
      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);
    }
    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta4) {
      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);
    } else {
      endOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);
      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);
    }
    const startInnerCornerRadiusAngleSweep = Math.asin(
      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)
    );
    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));
    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;
    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);
    const outerArc = new Arc(
      0,
      0,
      outerArcRadius,
      startAngle + outerArcRadiusOffset,
      endAngle - outerArcRadiusOffset
    );
    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;
    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);
    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;
    if (clipSector != null) {
      outerArc.clipStart(clipSector.startAngle);
      outerArc.clipEnd(clipSector.endAngle);
      innerArc?.clipStart(clipSector.startAngle);
      innerArc?.clipEnd(clipSector.endAngle);
    }
    const startOuterArc = this.arc(
      startOuterCornerRadius,
      startOuterCornerRadiusAngleSweep,
      startAngle - Math.PI * 0.5,
      startAngle + startOuterCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      true,
      false
    );
    const endOuterArc = this.arc(
      endOuterCornerRadius,
      endOuterCornerRadiusAngleSweep,
      endAngle - endOuterCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      outerArc,
      innerArc,
      false,
      false
    );
    const endInnerArc = this.arc(
      endInnerCornerRadius,
      endInnerCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      false,
      true
    );
    const startInnerArc = this.arc(
      startInnerCornerRadius,
      startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI * 1.5,
      outerArc,
      innerArc,
      true,
      true
    );
    if (innerAngleExceeded) {
      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;
      let r;
      if (x > 0 && x < outerRadius) {
        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);
      } else {
        r = radialEdgeInset;
      }
      r = Math.max(r, innerRadius);
      const midAngle = startAngle + sweepAngle * 0.5;
      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {
    } else {
      const midAngle = startAngle + sweepAngle / 2;
      const cx = innerRadius * Math.cos(midAngle);
      const cy = innerRadius * Math.sin(midAngle);
      path.moveTo(centerX + cx, centerY + cy);
    }
    if (startOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = startOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (outerArc.isValid()) {
      const { r, a0, a1 } = outerArc;
      path.arc(centerX, centerY, r, a0, a1);
    }
    if (endOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = endOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (!innerAngleExceeded) {
      if (endInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = endInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
      if (innerArc?.isValid() === true) {
        const { r, a0, a1 } = innerArc;
        path.arc(centerX, centerY, r, a1, a0, true);
      }
      if (startInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = startInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
    }
    path.closePath();
  }
  isPointInPath(x, y) {
    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;
    return isPointInSector(x - this.centerX, y - this.centerY, {
      startAngle,
      endAngle,
      innerRadius: Math.min(innerRadius, outerRadius),
      outerRadius: Math.max(innerRadius, outerRadius)
    });
  }
};
Sector.className = "Sector";
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "centerX", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "centerY", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "innerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "outerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startAngle", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endAngle", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: (lhs, rhs) => lhs.equals(rhs) })
], Sector.prototype, "clipSector", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "concentricEdgeInset", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "radialEdgeInset", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startOuterCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endOuterCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startInnerCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endInnerCornerRadius", 2);

// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Property
], DonutTitle.prototype, "showInLegend", 2);
var DonutInnerLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.spacing = 2;
  }
  set(properties, _reset) {
    return super.set(properties);
  }
};
__decorateClass([
  Property
], DonutInnerLabel.prototype, "text", 2);
__decorateClass([
  Property
], DonutInnerLabel.prototype, "spacing", 2);
var DonutInnerCircle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "transparent";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Property
], DonutInnerCircle.prototype, "fill", 2);
__decorateClass([
  Property
], DonutInnerCircle.prototype, "fillOpacity", 2);
var DonutSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var DonutSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Property
], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Property
], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
var DonutSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
var DonutSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.defaultColorRange = [];
    this.defaultPatternFills = [];
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = 0;
    this.hideZeroValueSectorsInLegend = false;
    this.innerLabels = new PropertiesArray(DonutInnerLabel);
    this.title = new DonutTitle();
    this.innerCircle = new DonutInnerCircle();
    this.shadow = new DropShadow();
    this.calloutLabel = new DonutSeriesCalloutLabel();
    this.sectorLabel = new DonutSeriesSectorLabel();
    this.calloutLine = new DonutSeriesCalloutLine();
    this.tooltip = makeSeriesTooltip();
  }
};
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "defaultPatternFills", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "hideZeroValueSectorsInLegend", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];
  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];
  const rotation = Math.PI / -2 + toRadians(rotationDegrees);
  const phase = initialLoad ? "initial" : "update";
  const scaleToNewRadius = ({ radius }) => {
    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };
  };
  const scaleToOldRadius = ({ radius }) => {
    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };
  };
  const fromFn = (sect, datum, status, { prevFromProps }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = sect;
    let { fill, stroke: stroke3 } = datum.sectorFormat;
    if (status === "updated" && sect.previousDatum == null) {
      status = "added";
    }
    if (status === "unknown" || status === "added" && !prevFromProps) {
      startAngle = rotation;
      endAngle = rotation;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else if (status === "added" && prevFromProps) {
      startAngle = prevFromProps.endAngle ?? rotation;
      endAngle = prevFromProps.endAngle ?? rotation;
      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;
      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;
    }
    if (status === "added" && !initialLoad) {
      const radii = scaleToOldRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    if (status === "updated") {
      fill = sect.fill ?? fill;
      stroke3 = (typeof sect.stroke === "string" ? sect.stroke : void 0) ?? stroke3;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke: stroke3, phase };
  };
  const toFn = (_sect, datum, status, { prevLive }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = datum;
    const { stroke: stroke3, fill } = datum.sectorFormat;
    if (status === "removed" && prevLive) {
      startAngle = prevLive.datum?.endAngle;
      endAngle = prevLive.datum?.endAngle;
    } else if (status === "removed" && !prevLive) {
      startAngle = rotation;
      endAngle = rotation;
    }
    if (status === "removed") {
      const radii = scaleToNewRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    return { startAngle, endAngle, outerRadius, innerRadius, stroke: stroke3, fill };
  };
  const innerCircleFromFn = (node, _) => {
    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };
  };
  const innerCircleToFn = (_, datum) => {
    return { size: datum.radius ?? 0 };
  };
  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };
}
function resetPieSelectionsFn(_node, datum) {
  return {
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    stroke: datum.sectorFormat.stroke
  };
}
function pickByMatchingAngle(series, point) {
  const dy2 = point.y - series.centerY;
  const dx2 = point.x - series.centerX;
  const angle2 = Math.atan2(dy2, dx2);
  const sectors = series.getItemNodes();
  for (const sector of sectors) {
    if (sector.datum.missing === true)
      continue;
    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {
      const radius = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      let distance2 = 0;
      if (radius < sector.innerRadius) {
        distance2 = sector.innerRadius - radius;
      } else if (radius > sector.outerRadius) {
        distance2 = radius - sector.outerRadius;
      }
      return { datum: sector.datum, distance: distance2 };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/polar/polarZIndexMap.ts
var PolarZIndexMap = /* @__PURE__ */ ((PolarZIndexMap3) => {
  PolarZIndexMap3[PolarZIndexMap3["BACKGROUND"] = 0] = "BACKGROUND";
  PolarZIndexMap3[PolarZIndexMap3["FOREGROUND"] = 1] = "FOREGROUND";
  PolarZIndexMap3[PolarZIndexMap3["HIGHLIGHT"] = 2] = "HIGHLIGHT";
  PolarZIndexMap3[PolarZIndexMap3["LABEL"] = 3] = "LABEL";
  return PolarZIndexMap3;
})(PolarZIndexMap || {});

// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var DEFAULT_POLAR_DIRECTION_KEYS = {
  ["angle" /* Angle */]: ["angleKey"],
  ["radius" /* Radius */]: ["radiusKey"]
};
var DEFAULT_POLAR_DIRECTION_NAMES = {
  ["angle" /* Angle */]: ["angleName"],
  ["radius" /* Radius */]: ["radiusName"]
};
var PolarSeries = class extends DataModelSeries {
  constructor({
    categoryKey,
    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
    canHaveAxes = false,
    animationResetFns,
    ...opts
  }) {
    super({
      ...opts,
      categoryKey,
      pickModes,
      canHaveAxes
    });
    this.directions = ["angle" /* Angle */, "radius" /* Radius */];
    this.itemGroup = this.contentGroup.appendChild(new Group());
    this.nodeData = [];
    this.itemSelection = Selection.select(
      this.itemGroup,
      () => this.nodeFactory(),
      false
    );
    this.labelSelection = Selection.select(
      this.labelGroup,
      () => this.labelFactory(),
      false
    );
    this.highlightSelection = Selection.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */
    this.centerX = 0;
    this.centerY = 0;
    /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */
    this.radius = 0;
    this.animationResetFns = animationResetFns;
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getItemNodes() {
    return [...this.itemGroup.children()];
  }
  getNodeData() {
    return this.nodeData;
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [zIndex, 1 /* FOREGROUND */];
    this.highlightGroup.zIndex = [zIndex, 2 /* HIGHLIGHT */];
    this.labelGroup.zIndex = [zIndex, 3 /* LABEL */];
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  labelFactory() {
    const text2 = new Text();
    text2.pointerEvents = 1 /* None */;
    return text2;
  }
  addChartEventListeners() {
    this.cleanup.register(
      this.ctx.eventsHub.on("legend:item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.eventsHub.on("legend:item-double-click", (event) => this.onLegendItemDoubleClick(event))
    );
  }
  getInnerRadius() {
    return 0;
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  getShapeFillBBox() {
    const outerRadius = this.radius;
    return {
      series: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2),
      axis: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2)
    };
  }
  resetAllAnimation() {
    const { item, label } = this.animationResetFns ?? {};
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (item) {
      resetMotion([this.itemSelection, this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.labelSelection], label);
    }
    this.itemSelection.cleanup();
    this.labelSelection.cleanup();
    this.highlightSelection.cleanup();
  }
  animateEmptyUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateWaitingUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateReadyHighlight(_data) {
    const { item } = this.animationResetFns ?? {};
    if (item) {
      resetMotion([this.highlightSelection], item);
    }
  }
  animateReadyHighlightMarkers(_data) {
  }
  animateReadyResize(_data) {
    this.resetAllAnimation();
  }
  animateClearingUpdateEmpty(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  computeFocusBounds(opts) {
    const datum = this.getNodeData()?.[opts.datumIndex];
    if (datum !== void 0) {
      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];
    }
    return void 0;
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  isSeriesHighlighted(highlightedDatum, legendItemValues) {
    const { series, legendItemName: activeLegendItemName, itemId } = highlightedDatum ?? {};
    const legendItemName = legendItemValues?.[itemId];
    return series === this || legendItemName != null && legendItemName === activeLegendItemName;
  }
};

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var PieDonutSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var DonutSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      propertyKeys: {
        ...DEFAULT_POLAR_DIRECTION_KEYS,
        sectorLabel: ["sectorLabelKey"],
        calloutLabel: ["calloutLabelKey"]
      },
      propertyNames: {
        ...DEFAULT_POLAR_DIRECTION_NAMES,
        sectorLabel: ["sectorLabelName"],
        calloutLabel: ["calloutLabelName"]
      },
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new DonutSeriesProperties();
    this.phantomNodeData = void 0;
    this.backgroundGroup = new TranslatableGroup({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this.noVisibleData = false;
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    this.phantomGroup = this.backgroundGroup.appendChild(new Group({ name: "phantom" }));
    this.phantomSelection = Selection.select(
      this.phantomGroup,
      () => this.nodeFactory(),
      false
    );
    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: "pieCalloutLabels" }));
    this.calloutLabelSelection = new Selection(
      this.calloutLabelGroup,
      Group
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: "innerLabels" }));
    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);
    this.innerCircleSelection = Selection.select(
      this.innerCircleGroup,
      () => new Marker({ shape: "circle" })
    );
    this.surroundingRadius = void 0;
    this.NodeEvent = PieDonutSeriesNodeEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);
    this.phantomGroup.opacity = 0.2;
    this.innerLabelsGroup.pointerEvents = 1 /* None */;
  }
  get calloutNodeData() {
    return this.phantomNodeData ?? this.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.backgroundGroup.zIndex = [0 /* BACKGROUND */, zIndex];
  }
  nodeFactory() {
    const sector = new Sector();
    sector.miterLimit = 1e9;
    return sector;
  }
  getSeriesDomain(direction) {
    if (direction === "angle" /* Angle */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const {
      visible,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const processor = () => (value, index) => {
      if (visible && legendManager.getItemEnabled({ seriesId, itemId: index })) {
        return value;
      }
      return 0;
    };
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const extraKeyProps = [];
    const extraProps = [];
    if (legendItemKey) {
      extraKeyProps.push(keyProperty(legendItemKey, "category", { id: `legendItemKey` }));
    } else if (calloutLabelKey) {
      extraKeyProps.push(keyProperty(calloutLabelKey, "category", { id: `calloutLabelKey` }));
    } else if (sectorLabelKey) {
      extraKeyProps.push(keyProperty(sectorLabelKey, "category", { id: `sectorLabelKey` }));
    }
    const radiusScaleType = this.radiusScale.type;
    const angleScaleType = this.angleScale.type;
    if (radiusKey) {
      extraProps.push(
        rangedValueProperty(radiusKey, {
          id: "radiusValue",
          min: this.properties.radiusMin ?? 0,
          max: this.properties.radiusMax,
          missingValue: this.properties.radiusMax ?? 1,
          processor
        }),
        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw`, processor }),
        // Raw value pass-through.
        normalisePropertyTo("radiusValue", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)
      );
    }
    if (calloutLabelKey) {
      extraProps.push(valueProperty(calloutLabelKey, "category", { id: `calloutLabelValue` }));
    }
    if (sectorLabelKey) {
      extraProps.push(valueProperty(sectorLabelKey, "category", { id: `sectorLabelValue` }));
    }
    if (legendItemKey) {
      extraProps.push(valueProperty(legendItemKey, "category", { id: `legendItemValue` }));
    }
    if (angleFilterKey) {
      extraProps.push(
        accumulativeValueProperty(angleFilterKey, angleScaleType, {
          id: `angleFilterValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),
        normalisePropertyTo("angleFilterValue", [0, 1], 0, 0)
      );
    }
    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {
      extraProps.push(diff(this.id, this.processedData));
    }
    extraProps.push(animationValidation());
    await this.requestDataModel(dataController, this.data, {
      props: [
        ...extraKeyProps,
        accumulativeValueProperty(angleKey, angleScaleType, {
          id: `angleValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("angleValue", [0, 1], 0, 0),
        ...extraProps
      ]
    });
    for (const valueDef of this.processedData?.defs?.values ?? []) {
      const { id, missing, property } = valueDef;
      const missCount = getMissCount(this, missing);
      if (id !== "angleRaw" && missCount > 0) {
        logger_exports.warnOnce(
          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
        );
      }
    }
    this.animationState.transition("updateData");
  }
  maybeRefreshNodeData() {
    if (!this.nodeDataRefresh)
      return;
    const { nodeData = [], phantomNodeData } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.phantomNodeData = phantomNodeData;
    this.nodeDataRefresh = false;
  }
  getProcessedDataValues(dataModel, processedData) {
    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);
    const angleRawValues = dataModel.resolveColumnById(this, `angleRaw`, processedData);
    const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterValue`, processedData) : void 0;
    const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterRaw`, processedData) : void 0;
    const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusValue`, processedData) : void 0;
    const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusRaw`, processedData) : void 0;
    const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, `calloutLabelValue`, processedData) : void 0;
    const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, `sectorLabelValue`, processedData) : void 0;
    const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, `legendItemValue`, processedData) : void 0;
    return {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      calloutLabelValues,
      sectorLabelValues,
      legendItemValues
    };
  }
  createNodeData() {
    const {
      id: seriesId,
      processedData,
      dataModel,
      angleScale,
      ctx: { legendManager },
      visible
    } = this;
    const { rotation, innerRadiusRatio } = this.properties;
    if (!dataModel || processedData?.type !== "ungrouped")
      return;
    const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
    const {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      legendItemValues
    } = processedDataValues;
    const useFilterAngles = angleFilterRawValues?.some((filterRawValue, index) => {
      return filterRawValue > angleRawValues[index];
    }) ?? false;
    let currentStart = 0;
    let sum2 = 0;
    const nodes = [];
    const phantomNodes = angleFilterRawValues != null ? [] : void 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const invalidData = processedData.invalidData?.get(this.id);
    rawData.forEach((datum, datumIndex) => {
      if (invalidData?.[datumIndex] === true)
        return;
      const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];
      const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      sum2 += currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = angleRawValues[datumIndex];
      const radiusRaw = radiusValues?.[datumIndex] ?? 1;
      const radius = radiusRaw * crossFilterScale;
      const radiusValue = radiusRawValues?.[datumIndex];
      const legendItemValue = legendItemValues?.[datumIndex];
      const nodeLabels = this.getLabels(datumIndex, datum, midAngle, span, processedDataValues);
      const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
      const node = {
        itemId: datumIndex,
        series: this,
        datum,
        datumIndex,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0),
        sectorFormat,
        radiusValue,
        legendItemValue,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        focusable: true,
        ...nodeLabels
      };
      nodes.push(node);
      if (phantomNodes != null) {
        phantomNodes.push({
          ...node,
          radius: 1,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(1), 0),
          focusable: false
        });
      }
    });
    this.zerosumOuterRing.visible = sum2 === 0;
    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
    return {
      itemId: seriesId,
      nodeData: nodes,
      labelData: nodes,
      phantomNodeData: phantomNodes
    };
  }
  getLabelContent(datumIndex, datum, values) {
    const { id: seriesId, ctx, properties } = this;
    const { formatManager } = ctx;
    const { calloutLabel, sectorLabel, calloutLabelKey, sectorLabelKey, legendItemKey } = properties;
    const calloutLabelValue = values.calloutLabelValues?.[datumIndex];
    const sectorLabelValue = values.sectorLabelValues?.[datumIndex];
    const legendItemValue = values.legendItemValues?.[datumIndex];
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {
      callout: void 0,
      sector: void 0,
      legendItem: void 0
    };
    if (calloutLabelKey) {
      result.callout = this.getLabelText(
        calloutLabelValue,
        datum,
        calloutLabelKey,
        "calloutLabel",
        [],
        calloutLabel,
        { ...labelFormatterParams, value: calloutLabelValue }
      );
    }
    if (sectorLabelKey) {
      result.sector = this.getLabelText(
        sectorLabelValue,
        datum,
        sectorLabelKey,
        "sectorLabel",
        [],
        sectorLabel,
        { ...labelFormatterParams, value: sectorLabelValue }
      );
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value: legendItemValue,
        datum,
        seriesId,
        legendItemName: void 0,
        key: legendItemKey,
        source: "legend-label",
        property: "legendItem",
        domain: [],
        boundSeries: this.getFormatterContext("legendItem")
      }) ?? legendItemValue;
    }
    return result;
  }
  getLabels(datumIndex, datum, midAngle, span, values) {
    const { properties } = this;
    const { calloutLabel, sectorLabel, legendItemKey } = properties;
    const formats = this.getLabelContent(datumIndex, datum, values);
    const result = {};
    if (calloutLabel.enabled && formats.callout && span >= toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = {
        ...this.getTextAlignment(midAngle),
        text: formats.callout,
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      };
    }
    if (sectorLabel.enabled && formats.sector) {
      result.sectorLabel = { text: formats.sector };
    }
    if (legendItemKey && formats.legendItem) {
      result.legendItem = { key: legendItemKey, text: formats.legendItem };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "top" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -0.75 * Math.PI;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = modulus(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getNodeFill(fill, defaultColorRange, defaultPatternFill) {
    return getShapeFill(
      fill,
      {
        type: "gradient",
        bounds: "series",
        colorStops: defaultColorRange.map((color2) => ({ color: color2 })),
        gradient: "radial",
        rotation: 0,
        reverse: true
      },
      {
        type: "pattern",
        pattern: "forward-slanted-lines",
        fill: defaultPatternFill,
        fillOpacity: 1,
        backgroundFill: "none",
        backgroundFillOpacity: 1,
        stroke: defaultPatternFill,
        strokeOpacity: 1,
        strokeWidth: 4,
        rotation: 0
      },
      {
        type: "image",
        backgroundFill: defaultPatternFill,
        backgroundFillOpacity: 1,
        fit: "contain",
        repeat: "no-repeat",
        rotation: 0
      }
    );
  }
  getFillParams(fill, innerRadius, outerRadius) {
    if (!isGradientFill(fill) || fill.bounds === "item")
      return;
    return {
      centerX: 0,
      centerY: 0,
      innerRadius,
      outerRadius
    };
  }
  getSectorFormat(datum, datumIndex, isHighlight, nodeDatum, legendItemValues, activeHighlight) {
    const {
      angleKey,
      radiusKey,
      calloutLabelKey,
      sectorLabelKey,
      legendItemKey,
      fills,
      strokes,
      defaultColorRange,
      defaultPatternFills,
      itemStyler
    } = this.properties;
    const defaultStroke = strokes[datumIndex % strokes.length];
    const defaultFill = fills[datumIndex % fills.length];
    const {
      fill,
      fillOpacity,
      stroke: stroke3,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity
    } = mergeDefaults(
      this.getHighlightStyle(isHighlight, nodeDatum?.datumIndex, legendItemValues),
      {
        fill: defaultFill,
        stroke: defaultStroke
      },
      this.properties
    );
    const defaultColors = defaultColorRange[datumIndex % defaultColorRange.length];
    const defaultPatternFill = defaultPatternFills[datumIndex % defaultPatternFills.length];
    const sectorFill = fill ?? "black";
    let format;
    if (itemStyler) {
      format = this.cachedDatumCallback(
        this.getDatumId(datumIndex) + (isHighlight ? "-highlight" : "-hide"),
        () => this.callWithContext(itemStyler, {
          datum,
          angleKey,
          radiusKey,
          calloutLabelKey,
          sectorLabelKey,
          legendItemKey,
          fill: this.getNodeFill(sectorFill, defaultColors, defaultPatternFill),
          fillOpacity,
          stroke: stroke3,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          cornerRadius,
          highlighted: isHighlight,
          highlightState: this.getHighlightStateString(
            activeHighlight ?? this.ctx.highlightManager?.getActiveHighlight(),
            isHighlight,
            datumIndex
          ),
          seriesId: this.id
        })
      );
    }
    return {
      fill: this.getNodeFill(format?.fill ?? sectorFill, defaultColors, defaultPatternFill),
      fillOpacity: format?.fillOpacity ?? fillOpacity,
      stroke: format?.stroke ?? stroke3,
      strokeWidth: format?.strokeWidth ?? strokeWidth,
      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
      lineDash: format?.lineDash ?? lineDash,
      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
      cornerRadius: format?.cornerRadius ?? cornerRadius,
      opacity
    };
  }
  getInnerRadius() {
    const { radius } = this;
    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    const { outerRadiusRatio, outerRadiusOffset } = this.properties;
    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [this.getInnerRadius(), this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    const setRadii = (d) => ({
      ...d,
      innerRadius: Math.max(this.radiusScale.convert(0), 0),
      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
    });
    this.nodeData = this.nodeData.map(setRadii);
    this.phantomNodeData = this.phantomNodeData?.map(setRadii);
  }
  getTitleTranslationY() {
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = this.properties.title?.spacing ?? 0;
    const titleOffset = 2 + spacing;
    const dy2 = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy2;
  }
  update({ seriesRect }) {
    const { title } = this.properties;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width,
      seriesRectHeight: seriesRect?.height
    };
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    this.maybeRefreshNodeData();
    this.updateTitleNodes();
    this.updateRadiusScale(resize);
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    this.backgroundGroup.translationX = this.centerX;
    this.backgroundGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    if (title) {
      const dy2 = this.getTitleTranslationY();
      title.node.y = isFinite(dy2) ? dy2 : 0;
      const titleBox = title.node.getBBox(false);
      title.node.visible = title.enabled && isFinite(dy2) && !this.bboxIntersectsSurroundingSeries(titleBox);
    }
    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
      circle.fillOpacity = 0;
      circle.stroke = this.properties.calloutLabel.color;
      circle.strokeWidth = 1;
      circle.strokeOpacity = 1;
    }
    this.updateNodeMidPoint();
    this.updateSelections();
    this.updateNodes(seriesRect);
  }
  updateTitleNodes() {
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        this.labelGroup?.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        this.labelGroup?.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    const setMidPoint = (d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    };
    this.nodeData.forEach(setMidPoint);
    this.phantomNodeData?.forEach(setMidPoint);
  }
  updateSelections() {
    this.updateGroupSelection();
    this.updateInnerCircleSelection();
  }
  updateGroupSelection() {
    const {
      itemSelection,
      highlightSelection,
      phantomSelection,
      calloutLabelSelection,
      labelSelection,
      innerLabelsSelection
    } = this;
    const highlightedNodeData = this.nodeData.map((datum) => ({
      ...datum,
      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
      // between normal and highlighted cases.
      sectorFormat: { ...datum.sectorFormat }
    }));
    const update = (selection, nodeData) => {
      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum.datumIndex));
      if (this.ctx.animationManager.isSkipped()) {
        selection.cleanup();
      }
    };
    update(itemSelection, this.nodeData);
    update(highlightSelection, highlightedNodeData);
    update(phantomSelection, this.phantomNodeData ?? []);
    calloutLabelSelection.update(this.calloutNodeData, (group) => {
      const line = new Line();
      line.tag = 0 /* Callout */;
      line.pointerEvents = 1 /* None */;
      group.appendChild(line);
      const text2 = new Text();
      text2.tag = 1 /* Label */;
      text2.pointerEvents = 1 /* None */;
      group.appendChild(text2);
    });
    labelSelection.update(this.nodeData);
    innerLabelsSelection.update(this.properties.innerLabels, (node) => {
      node.pointerEvents = 1 /* None */;
    });
  }
  updateInnerCircleSelection() {
    const { innerCircle } = this.properties;
    let radius = 0;
    const innerRadius = this.getInnerRadius();
    if (innerRadius > 0) {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
    const datums = innerCircle ? [{ radius }] : [];
    this.innerCircleSelection.update(datums);
  }
  updateNodes(seriesRect) {
    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
    const { visible, dataModel, processedData } = this;
    this.backgroundGroup.visible = visible;
    this.contentGroup.visible = visible;
    if (!dataModel || !processedData)
      return;
    const { legendItemValues } = this.getProcessedDataValues(dataModel, processedData);
    const seriesHighlighted = this.isSeriesHighlighted(highlightedDatum, legendItemValues);
    this.highlightGroup.visible = visible && seriesHighlighted;
    this.labelGroup.visible = visible;
    this.innerCircleSelection.each((node, { radius }) => {
      node.setProperties({
        fill: this.getNodeFill(this.properties.innerCircle?.fill, ["black"], "black"),
        opacity: this.properties.innerCircle?.fillOpacity,
        size: radius
      });
    });
    const innerRadius = this.radiusScale.range[0];
    const outerRadius = this.radiusScale.range[1];
    const fillBBox = this.getShapeFillBBox();
    const animationDisabled = this.ctx.animationManager.isSkipped();
    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
      const format = this.getSectorFormat(
        datum.datum,
        datum.itemId,
        isDatumHighlighted,
        datum,
        legendItemValues,
        highlightedDatum
      );
      datum.sectorFormat.fill = format.fill;
      datum.sectorFormat.stroke = format.stroke;
      if (animationDisabled) {
        sector.startAngle = datum.startAngle;
        sector.endAngle = datum.endAngle;
        sector.innerRadius = datum.innerRadius;
        sector.outerRadius = datum.outerRadius;
      }
      if (isDatumHighlighted || animationDisabled) {
        sector.fill = format.fill;
        sector.stroke = format.stroke;
      }
      const fillParams = this.getFillParams(format.fill, innerRadius, outerRadius);
      applyShapeStyle(sector, format, fillBBox, fillParams);
      sector.cornerRadius = format.cornerRadius;
      sector.fillShadow = this.properties.shadow;
      const inset = Math.max(
        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,
        0
      );
      sector.inset = inset;
      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
    };
    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.highlightSelection.each((node, datum, index) => {
      updateSectorFn(node, datum, index, true);
      node.visible = datum.itemId === highlightedDatum?.itemId;
    });
    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.updateCalloutLineNodes();
    this.updateCalloutLabelNodes(seriesRect);
    this.updateSectorLabelNodes();
    this.updateInnerLabelNodes();
    this.updateZerosumRings();
    this.animationState.transition("update");
  }
  updateCalloutLineNodes() {
    const {
      calloutLine: { length: calloutLength, strokeWidth, colors },
      strokes
    } = this.properties;
    const calloutStrokeWidth = strokeWidth;
    const calloutColors = isStringFillArray(colors) ? colors ?? this.properties.strokes : strokes;
    const { offset } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line) => {
      const datum = line.closestDatum();
      const { calloutLabel: label, outerRadius, datumIndex } = datum;
      if (label?.text && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[datumIndex % calloutColors.length];
        line.strokeOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx2 = cx - x2;
          const dy2 = cy - y2;
          const length2 = Math.sqrt(Math.pow(dx2, 2) + Math.pow(dy2, 2));
          const paddedLength = length2 - offset;
          if (paddedLength > 0) {
            x2 = x2 + dx2 * paddedLength / length2;
            y2 = y2 + dy2 * paddedLength / length2;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text2, box, seriesRect) {
    const seriesLeft = -this.centerX;
    const seriesRight = seriesLeft + seriesRect.width;
    const seriesTop = -this.centerY;
    const seriesBottom = seriesTop + seriesRect.height;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text2.length : Math.floor(text2.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x, y: box.y },
      { x: box.x + box.width, y: box.y },
      { x: box.x + box.width, y: box.y + box.height },
      { x: box.x, y: box.y + box.height }
    ];
    const sur2 = surroundingRadius ** 2;
    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.calloutNodeData;
    const data = fullData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const params = { angleKey: this.properties.angleKey };
    const getTextBBox = (datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return BBox.zero.clone();
      const style2 = getLabelStyles(this, datum, params, calloutLabel);
      const padding2 = expandLabelPadding(style2);
      const labelRadius = datum.outerRadius + calloutLine.length + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const textAlign = label.collisionTextAlign ?? label.textAlign;
      const textBaseline = label.textBaseline;
      return Text.computeBBox(
        label.text,
        x,
        y,
        { font: this.properties.calloutLabel, textAlign, textBaseline },
        false
      ).grow(padding2);
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        next.calloutLabel.collisionOffsetY = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text2) => {
      const datum = text2.closestDatum();
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label?.text || outerRadius === 0 || label.hidden) {
        text2.visible = false;
        return;
      }
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const isHighlight = false;
      const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
      const style2 = getLabelStyles(
        this,
        datum,
        this.properties,
        calloutLabel,
        isHighlight,
        highlightState
      );
      const labelRadius = outerRadius + calloutLine.length + calloutLabel.offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align2 = {
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(style2);
      tempTextNode.setAlign(align2);
      tempTextNode.setBoxing(style2);
      const box = tempTextNode.getBBox(false);
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text2.text = displayText;
      text2.x = x;
      text2.y = y;
      text2.setFont(style2);
      text2.setAlign(align2);
      text2.setBoxing(style2);
      text2.fill = style2.color;
      text2.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
      text2.visible = visible;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset, maxCollisionOffset, minSpacing } = calloutLabel;
    if (!calloutLabel.avoidCollisions) {
      return null;
    }
    this.maybeRefreshNodeData();
    this.updateRadiusScale(false);
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text2 = new Text();
    let titleBox;
    const { title } = this.properties;
    if (title?.text && title.enabled) {
      const dy2 = this.getTitleTranslationY();
      if (isFinite(dy2)) {
        text2.text = title.text;
        text2.x = 0;
        text2.y = dy2;
        text2.setFont(title);
        text2.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        });
        titleBox = text2.getBBox(false);
        textBoxes.push(titleBox);
      }
    }
    const params = { angleKey: this.properties.angleKey };
    this.calloutNodeData.forEach((datum) => {
      const label = datum.calloutLabel;
      if (!label || datum.outerRadius === 0) {
        return null;
      }
      const style2 = getLabelStyles(this, datum, params, calloutLabel);
      const labelRadius = datum.outerRadius + calloutLength + offset;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      text2.text = label.text;
      text2.x = x;
      text2.y = y;
      text2.setFont(style2);
      text2.setAlign({
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      });
      text2.setBoxing(style2);
      const box = text2.getBBox(false);
      label.box = box;
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      if (titleBox) {
        const seriesTop = -this.centerY;
        const titleCleanArea = new BBox(
          titleBox.x - minSpacing,
          seriesTop,
          titleBox.width + 2 * minSpacing,
          titleBox.y + titleBox.height + minSpacing - seriesTop
        );
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
          label.text,
          box,
          seriesRect
        );
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  updateSectorLabelNodes() {
    const { properties } = this;
    const { positionOffset, positionRatio } = this.properties.sectorLabel;
    const innerRadius = this.radiusScale.convert(0);
    const shouldPutTextInCenter = innerRadius <= 0 && // is donut?
    this.ctx.legendManager.getData(this.id)?.filter((d) => d.enabled).length === 1;
    const align2 = { textAlign: "center", textBaseline: "middle" };
    const updateSectorLabel = (text2, datum) => {
      const { outerRadius, startAngle, endAngle } = datum;
      let isTextVisible = false;
      if (datum.sectorLabel && outerRadius !== 0) {
        const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
        const isHighlight = false;
        const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
        const style2 = getLabelStyles(
          this,
          datum,
          properties,
          properties.sectorLabel,
          isHighlight,
          highlightState
        );
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text2.fill = style2.color;
        text2.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
        text2.text = datum.sectorLabel.text;
        if (shouldPutTextInCenter) {
          text2.x = 0;
          text2.y = 0;
        } else {
          text2.x = datum.midCos * labelRadius;
          text2.y = datum.midSin * labelRadius;
        }
        text2.setFont(style2);
        text2.setAlign(align2);
        text2.setBoxing(style2);
        const bbox = text2.getBBox(false);
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text2.visible = isTextVisible;
    };
    this.labelSelection.each(updateSectorLabel);
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text2, datum) => {
      const { fontStyle, fontWeight, fontSize, fontFamily, color: color2 } = datum;
      text2.fontStyle = fontStyle;
      text2.fontWeight = fontWeight;
      text2.fontSize = fontSize;
      text2.fontFamily = fontFamily;
      text2.text = datum.text;
      text2.x = 0;
      text2.y = 0;
      text2.fill = color2;
      text2.textAlign = "center";
      text2.textBaseline = "alphabetic";
      textBBoxes.push(text2.getBBox());
      margins.push(datum.spacing);
    });
    const getMarginTop = (index) => index === 0 ? 0 : margins[index];
    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
    const totalWidth = textBBoxes.reduce((max, bbox) => max < bbox.width ? bbox.width : max, 0);
    const totalHeight = textBBoxes.reduce(
      (sum2, bbox, i) => sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i),
      0
    );
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text2, _datum, index) => {
      text2.visible = labelsVisible;
      if (Array.isArray(text2.text)) {
        text2.y = textBottoms[index] - textBBoxes[index].height;
      } else {
        text2.y = textBottoms[index];
      }
    });
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
    this.zerosumInnerRing.size = this.getInnerRadius() * 2;
  }
  pickNodeClosestDatum(point) {
    return pickByMatchingAngle(this, point);
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      properties,
      ctx: { formatManager }
    } = this;
    const {
      legendItemKey,
      calloutLabelKey,
      calloutLabelName,
      sectorLabelKey,
      sectorLabelName,
      angleKey,
      angleName,
      radiusKey,
      radiusName,
      tooltip
    } = properties;
    const title = this.properties.title.node.getPlainText();
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
    const { angleRawValues } = processedDataValues;
    const angleRawValue = angleRawValues[datumIndex];
    const labelValues = this.getLabelContent(datumIndex, datum, processedDataValues);
    const label = labelValues.legendItem ?? labelValues.callout ?? labelValues.sector ?? angleName;
    const domain = dataModel.getDomain(this, `angleRaw`, "value", processedData);
    const angleContent = formatManager.format(this.callWithContext.bind(this), {
      type: "number",
      value: angleRawValue,
      datum,
      seriesId,
      legendItemName: void 0,
      key: angleKey,
      source: "tooltip",
      property: "angle",
      domain,
      boundSeries: this.getFormatterContext("angle"),
      fractionDigits: void 0
    }) ?? formatValue(angleRawValue, 3);
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(datumIndex),
        data: [{ label, fallbackLabel: angleKey, value: angleContent }]
      },
      {
        seriesId,
        datum,
        title: angleName,
        legendItemKey,
        calloutLabelKey,
        calloutLabelName,
        sectorLabelKey,
        sectorLabelName,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        ...this.getSectorFormat(datum, datumIndex, false)
      }
    );
  }
  legendItemSymbol(datumIndex) {
    const datum = this.processedData?.dataSources.get(this.id)?.[datumIndex];
    const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
    const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties;
    let { fill } = sectorFormat;
    const { stroke: stroke3 } = sectorFormat;
    if (isGradientFill(fill)) {
      fill = { ...fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return {
      marker: {
        fill,
        stroke: stroke3,
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      }
    };
  }
  getLegendData(legendType) {
    const {
      visible,
      processedData,
      dataModel,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    if (!dataModel || !processedData || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
      return [];
    }
    const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
    const { angleRawValues } = processedDataValues;
    const titleText = this.properties.title?.showInLegend && this.properties.title.text;
    const legendData = [];
    const hideZeros = this.properties.hideZeroValueSectorsInLegend;
    const rawData = processedData.dataSources.get(this.id);
    const invalidData = processedData.invalidData?.get(this.id);
    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {
      const datum = rawData?.[datumIndex];
      const angleRawValue = angleRawValues[datumIndex];
      if (invalidData?.[datumIndex] === true || hideZeros && angleRawValue === 0) {
        continue;
      }
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabelContent(datumIndex, datum, processedDataValues);
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.callout !== void 0) {
        labelParts.push(labels.callout);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sector !== void 0) {
        labelParts.push(labels.sector);
      }
      if (labelParts.length === 0)
        continue;
      legendData.push({
        legendType: "category",
        id: seriesId,
        datum,
        itemId: datumIndex,
        seriesId,
        hideToggleOtherSeries: true,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        label: {
          text: labelParts.join(" - ")
        },
        symbol: this.legendItemSymbol(datumIndex),
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,
        hideInLegend: !showInLegend
      });
    }
    return legendData;
  }
  // Used for grid
  setLegendState(enabledItems) {
    const {
      id: seriesId,
      ctx: { legendManager, updateService }
    } = this;
    enabledItems.forEach((enabled, itemId) => legendManager.toggleItem(enabled, seriesId, itemId));
    legendManager.update();
    updateService.update(5 /* SERIES_UPDATE */);
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [this.itemSelection, this.highlightSelection, this.phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const dataDiff = processedData?.reduced?.diff?.[this.id];
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;
    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;
    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const noVisibleData = !this.nodeData.some((n) => n.enabled);
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex),
      dataDiff
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    if (this.noVisibleData !== noVisibleData) {
      this.noVisibleData = noVisibleData;
      seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    }
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumId(datumIndex) {
    return `${datumIndex}`;
  }
  hasItemStylers() {
    const { itemStyler, calloutLabel, sectorLabel } = this.properties;
    return (itemStyler ?? calloutLabel.itemStyler ?? sectorLabel.itemStyler) != null;
  }
};
DonutSeries.className = "DonutSeries";
DonutSeries.type = "donut";

// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts
var donutTheme = {
  series: {
    title: {
      enabled: true,
      fontWeight: { $ref: "fontWeight" },
      fontSize: { $rem: FONT_SIZE_RATIO.LARGE },
      fontFamily: { $ref: "fontFamily" },
      color: { $ref: "subtleTextColor" },
      spacing: 5
    },
    calloutLabel: {
      ...LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" },
      offset: 3,
      minAngle: 1e-3
    },
    sectorLabel: {
      ...LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontWeight: { $ref: "fontWeight" },
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      color: { $ref: "chartBackgroundColor" },
      positionOffset: 0,
      positionRatio: 0.5
    },
    calloutLine: {
      length: 10,
      strokeWidth: 2,
      colors: {
        $map: [
          {
            $if: [
              {
                $or: [
                  { $isGradient: { $value: "$1" } },
                  { $isPattern: { $value: "$1" } },
                  { $isImage: { $value: "$1" } }
                ]
              },
              { $path: ["../../strokes/$index", { $ref: "foregroundColor" }] },
              { $value: "$1" }
            ]
          },
          {
            $if: [
              { $eq: [{ $path: "../strokeWidth" }, 0] },
              { $path: "../fills" },
              { $path: "../strokes" }
            ]
          }
        ]
      }
    },
    fills: { $palette: "fills" },
    strokes: { $palette: "strokes" },
    // @ts-expect-error undocumented option
    defaultColorRange: { $palette: "gradients" },
    defaultPatternFills: SAFE_FILLS_OPERATION,
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: { $isUserOption: ["./strokes/0", 2, 0] },
    lineDash: [0],
    lineDashOffset: 0,
    rotation: 0,
    sectorSpacing: 1,
    innerRadiusRatio: {
      $if: [{ $eq: [{ $path: ["./innerRadiusOffset", void 0] }, void 0] }, 0.7, void 0]
    },
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    },
    innerLabels: {
      $apply: {
        ...LABEL_BOXING_DEFAULTS,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" },
        spacing: 2
      }
    },
    highlight: singleSeriesHighlightStyle()
  },
  legend: { enabled: true }
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var DonutSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["polar"],
  identifier: "donut",
  moduleFactory: (ctx) => new DonutSeries(ctx),
  themeTemplate: donutTheme
};
var NewDonutSeriesModule = {
  type: "series",
  name: "donut",
  chartType: "polar",
  options: donutSeriesOptionsDef,
  create: (ctx) => new DonutSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeries = class extends DonutSeries {
};
PieSeries.className = "PieSeries";
PieSeries.type = "pie";

// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts
var pieTheme = {
  series: {
    title: {
      enabled: true,
      fontWeight: { $ref: "fontWeight" },
      fontSize: { $rem: FONT_SIZE_RATIO.LARGE },
      fontFamily: { $ref: "fontFamily" },
      color: { $ref: "subtleTextColor" },
      spacing: 5
    },
    calloutLabel: {
      ...LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" },
      offset: 3,
      minAngle: 1e-3
    },
    sectorLabel: {
      ...LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontWeight: { $ref: "fontWeight" },
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      color: { $ref: "chartBackgroundColor" },
      positionOffset: 0,
      positionRatio: 0.5
    },
    calloutLine: {
      length: 10,
      strokeWidth: 2,
      colors: {
        $map: [
          {
            $if: [
              {
                $or: [
                  { $isGradient: { $value: "$1" } },
                  { $isPattern: { $value: "$1" } },
                  { $isImage: { $value: "$1" } }
                ]
              },
              { $path: ["../../strokes/$index", { $ref: "foregroundColor" }] },
              { $value: "$1" }
            ]
          },
          {
            $if: [
              { $eq: [{ $path: "../strokeWidth" }, 0] },
              { $path: "../fills" },
              { $path: "../strokes" }
            ]
          }
        ]
      }
    },
    fills: { $palette: "fills" },
    strokes: { $palette: "strokes" },
    // @ts-expect-error undocumented option
    defaultColorRange: { $palette: "gradients" },
    defaultPatternFills: SAFE_FILLS_OPERATION,
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: { $isUserOption: ["./strokes/0", 2, 0] },
    lineDash: [0],
    lineDashOffset: 0,
    rotation: 0,
    sectorSpacing: 1,
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    },
    highlight: multiSeriesHighlightStyle()
  },
  legend: { enabled: true }
};

// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var PieSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["polar"],
  identifier: "pie",
  moduleFactory: (ctx) => new PieSeries(ctx),
  themeTemplate: pieTheme
};
var NewPieSeriesModule = {
  type: "series",
  name: "pie",
  chartType: "polar",
  options: pieSeriesOptionsDef,
  create: (ctx) => new PieSeries(ctx)
};

// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts
function registerInbuiltModules() {
  moduleRegistry.register(
    BackgroundModule,
    SeriesAreaModule,
    CommunityLegendModule,
    LocaleModule,
    AreaSeriesModule,
    BarSeriesModule,
    BubbleSeriesModule,
    LineSeriesModule,
    ScatterSeriesModule,
    DonutSeriesModule,
    PieSeriesModule,
    HistogramSeriesModule
  );
  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis, UnitTimeAxis]) {
    axisRegistry.register(AxisConstructor.type, {
      moduleFactory: (ctx) => new AxisConstructor(ctx)
    });
  }
}

// packages/ag-charts-community/src/chart/factory/setupModules.ts
function setupModules() {
  for (const m of moduleRegistry.modules) {
    if (m.packageType === "enterprise" && !verifyIfModuleExpected(m)) {
      logger_exports.errorOnce("Unexpected enterprise module registered: " + m.identifier);
    }
    if (m.type === "root" && m.themeTemplate) {
      for (const chartType of m.chartTypes) {
        chartDefaults.set(chartType, m.themeTemplate);
      }
    }
    if (m.type === "series") {
      if (m.chartTypes.length > 1) {
        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);
      }
      seriesRegistry.register(m.identifier, m);
    }
    if (m.type === "series-option" && m.themeTemplate) {
      for (const seriesType of m.seriesTypes) {
        seriesRegistry.setThemeTemplate(seriesType, m.themeTemplate);
      }
    }
    if (m.type === "axis-option" && m.themeTemplate) {
      for (const axisType of m.axisTypes) {
        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);
        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);
        axisRegistry.setThemeTemplate(axisType, theme);
      }
    }
    if (m.type === "axis") {
      axisRegistry.register(m.identifier, m);
    }
    if (m.type === "legend") {
      legendRegistry.register(m.identifier, m);
    }
  }
  if (moduleRegistry.hasEnterpriseModules()) {
    const expectedButUnused = getUnusedExpectedModules();
    if (expectedButUnused.length > 0) {
      logger_exports.errorOnce("Enterprise modules expected but not registered: ", expectedButUnused);
    }
  }
}

// packages/ag-charts-community/src/api/preset/presetUtils.ts
var IGNORED_PROP = Symbol("IGNORED_PROP");
function pickProps(opts, values) {
  const out = {};
  for (const key of Object.keys(values)) {
    const value = values[key];
    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {
      out[key] = value;
    }
  }
  return out;
}

// packages/ag-charts-community/src/api/preset/gauge.ts
function tooltipOptions(opts) {
  const { enabled, mode, showArrow, range: range4, position, pagination, delay, wrapping, interaction, renderer, ...rest } = opts;
  const seriesTooltipOptions = pickProps(opts, {
    enabled,
    showArrow,
    range: range4,
    position,
    interaction,
    renderer,
    ...rest
  });
  const chartTooltipOptions = pickProps(opts, {
    enabled: IGNORED_PROP,
    showArrow: IGNORED_PROP,
    range: IGNORED_PROP,
    position: IGNORED_PROP,
    mode,
    pagination,
    delay,
    wrapping,
    ...rest
  });
  return { chartTooltipOptions, seriesTooltipOptions };
}
function radialGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    width: width2,
    type,
    cursor,
    nodeClickRange,
    tooltip = {},
    value,
    scale: scale2 = {},
    startAngle,
    endAngle,
    // eslint-disable-next-line sonarjs/deprecation
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    needle,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  } = opts;
  const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    tooltip: chartTooltipOptions,
    width: width2
  });
  const seriesOpts = pickProps(opts, {
    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,
    startAngle,
    endAngle,
    scale: scale2,
    type,
    cursor,
    context,
    nodeClickRange,
    tooltip: seriesTooltipOptions,
    value,
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  });
  return {
    ...chartOpts,
    series: [seriesOpts]
  };
}
function linearGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    width: width2,
    type,
    cursor,
    nodeClickRange,
    tooltip = {},
    value,
    scale: scale2 = {},
    direction = "vertical",
    thickness,
    // eslint-disable-next-line sonarjs/deprecation
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  } = opts;
  const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    context,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    subtitle,
    theme,
    title,
    tooltip: chartTooltipOptions,
    width: width2
  });
  const seriesOpts = pickProps(opts, {
    scale: scale2,
    type,
    cursor,
    context,
    nodeClickRange,
    tooltip: seriesTooltipOptions,
    value,
    direction,
    thickness,
    highlightStyle,
    highlight: highlight5,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  });
  return {
    ...chartOpts,
    series: [seriesOpts]
  };
}
function applyThemeDefaults(opts, presetTheme) {
  if (presetTheme == null)
    return opts;
  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;
  opts = mergeDefaults(opts, gaugeTheme);
  if (opts.targets != null && targetsTheme != null) {
    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);
  }
  return opts;
}
function gauge(opts, presetTheme) {
  switch (opts.type) {
    case "radial-gauge":
      return radialGaugeOptions(applyThemeDefaults(opts, presetTheme));
    case "linear-gauge":
      return linearGaugeOptions(applyThemeDefaults(opts, presetTheme));
    default:
      return {};
  }
}

// packages/ag-charts-community/src/api/preset/priceVolumePresetTheme.ts
var stroke = {
  stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var handle = {
  fill: DEFAULT_ANNOTATION_HANDLE_FILL
};
var axisLabel = {
  color: "white",
  fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var lineText = {
  color: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var font = {
  color: DEFAULT_TEXT_ANNOTATION_COLOR,
  fontSize: { $rem: FONT_SIZE_RATIO.LARGE },
  fontFamily: { $ref: "fontFamily" }
};
var measurerStatistics = {
  ...font,
  fontSize: { $ref: "fontSize" },
  color: DEFAULT_ANNOTATION_STATISTICS_COLOR,
  fill: DEFAULT_ANNOTATION_STATISTICS_FILL,
  stroke: DEFAULT_ANNOTATION_STATISTICS_STROKE,
  strokeWidth: 1,
  divider: {
    stroke: DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
    strokeWidth: 1,
    strokeOpacity: 0.5
  }
};
var measurer = {
  ...stroke,
  background: {
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    fillOpacity: 0.2
  },
  handle: { ...handle },
  text: { ...lineText },
  statistics: { ...measurerStatistics }
};
var annotationsTheme = {
  // Lines
  line: {
    ...stroke,
    handle: { ...handle },
    text: { ...lineText }
  },
  "horizontal-line": {
    ...stroke,
    handle: { ...handle },
    axisLabel: { ...axisLabel },
    text: { ...lineText }
  },
  "vertical-line": {
    ...stroke,
    handle: { ...handle },
    axisLabel: { ...axisLabel },
    text: { ...lineText }
  },
  // Channels
  "disjoint-channel": {
    ...stroke,
    background: {
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2
    },
    handle: { ...handle },
    text: { ...lineText }
  },
  "parallel-channel": {
    ...stroke,
    background: {
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2
    },
    handle: { ...handle },
    text: { ...lineText }
  },
  // Fibonnaccis
  "fibonacci-retracement": {
    ...stroke,
    strokes: DEFAULT_FIBONACCI_STROKES,
    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    handle: { ...handle },
    text: { ...lineText, position: "center" },
    label: {
      ...font,
      color: void 0,
      fontSize: { $rem: FONT_SIZE_RATIO.SMALLER }
    }
  },
  "fibonacci-retracement-trend-based": {
    ...stroke,
    strokes: DEFAULT_FIBONACCI_STROKES,
    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    handle: { ...handle },
    text: { ...lineText, position: "center" },
    label: {
      ...font,
      color: void 0,
      fontSize: { $rem: FONT_SIZE_RATIO.SMALLER }
    }
  },
  // Texts
  callout: {
    ...stroke,
    ...font,
    color: { $ref: "textColor" },
    handle: { ...handle },
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    fillOpacity: 0.2
  },
  comment: {
    ...font,
    color: "white",
    fontWeight: 700,
    handle: { ...handle },
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
  },
  note: {
    ...font,
    color: DEFAULT_TEXTBOX_COLOR,
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    stroke: { $ref: "chartBackgroundColor" },
    strokeWidth: 1,
    strokeOpacity: 1,
    handle: { ...handle },
    background: {
      fill: DEFAULT_TEXTBOX_FILL,
      stroke: DEFAULT_TEXTBOX_STROKE,
      strokeWidth: 1
    }
  },
  text: {
    ...font,
    handle: { ...handle }
  },
  // Shapes
  arrow: {
    ...stroke,
    handle: { ...handle },
    text: { ...lineText }
  },
  "arrow-up": {
    fill: { $palette: "up.fill" },
    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }
  },
  "arrow-down": {
    fill: { $palette: "down.fill" },
    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }
  },
  // Measurers
  "date-range": {
    ...measurer
  },
  "price-range": {
    ...measurer
  },
  "date-price-range": {
    ...measurer
  },
  "quick-date-price-range": {
    up: {
      ...stroke,
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2,
      handle: { ...handle },
      statistics: {
        ...measurerStatistics,
        color: "#fff",
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    },
    down: {
      ...stroke,
      stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
      fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
      fillOpacity: 0.2,
      handle: {
        ...handle,
        stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE
      },
      statistics: {
        ...measurerStatistics,
        color: "#fff",
        fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    }
  },
  axesButtons: {
    enabled: true
  }
};

// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
var chartTypes3 = ["ohlc", "line", "step-line", "hlc", "high-low", "candlestick", "hollow-candlestick"];
var toolbarButtons = [
  {
    icon: "trend-line-drawing",
    tooltip: "toolbarAnnotationsLineAnnotations",
    value: "line-menu"
  },
  {
    icon: "fibonacci-retracement-drawing",
    tooltip: "toolbarAnnotationsFibonacciAnnotations",
    value: "fibonacci-menu"
  },
  {
    icon: "text-annotation",
    tooltip: "toolbarAnnotationsTextAnnotations",
    value: "text-menu"
  },
  {
    icon: "arrow-drawing",
    tooltip: "toolbarAnnotationsShapeAnnotations",
    value: "shape-menu"
  },
  {
    icon: "measurer-drawing",
    tooltip: "toolbarAnnotationsMeasurerAnnotations",
    value: "measurer-menu"
  },
  {
    icon: "delete",
    tooltip: "toolbarAnnotationsClearAll",
    value: "clear"
  }
];
function priceVolume(opts, _presetTheme, getTheme) {
  const {
    dateKey = "date",
    highKey = "high",
    openKey = "open",
    lowKey = "low",
    closeKey = "close",
    volumeKey = "volume",
    chartType = "candlestick",
    navigator = false,
    volume = true,
    rangeButtons = true,
    statusBar = true,
    toolbar: toolbar2 = true,
    zoom = true,
    sync = false,
    theme,
    data,
    formatter: formatter2,
    ...unusedOpts
  } = opts;
  const priceSeries = createPriceSeries(chartType, dateKey, highKey, lowKey, openKey, closeKey);
  const volumeSeries = createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey);
  const miniChart = volume ? {
    miniChart: {
      enabled: navigator,
      series: [
        {
          type: "line",
          xKey: dateKey,
          yKey: volumeKey,
          stroke: SAFE_STROKE_FILL_OPERATION,
          marker: { enabled: false }
        }
      ]
    },
    height: 40,
    minHandle: {
      height: 46
    },
    maxHandle: {
      height: 46
    }
  } : null;
  const navigatorOpts = {
    navigator: {
      enabled: navigator,
      ...miniChart
    }
  };
  const annotationOpts = {
    annotations: {
      enabled: toolbar2,
      optionsToolbar: {
        enabled: toolbar2
      },
      // @ts-expect-error undocumented option
      snap: true,
      toolbar: {
        enabled: toolbar2,
        buttons: toolbarButtons,
        padding: 0
      },
      data,
      xKey: dateKey,
      volumeKey: volume ? volumeKey : void 0
    }
  };
  const statusBarOpts = statusBar ? {
    statusBar: {
      enabled: true,
      data,
      highKey,
      openKey,
      lowKey,
      closeKey,
      volumeKey: volume ? volumeKey : void 0
    }
  } : null;
  const zoomOpts = {
    zoom: {
      enabled: zoom,
      autoScaling: {
        enabled: true
      },
      // @ts-expect-error undocumented option
      enableIndependentAxes: true
    }
  };
  const toolbarOpts = {
    ranges: {
      enabled: rangeButtons
    }
  };
  const syncGroup = sync ? {
    sync: {
      enabled: sync,
      nodeInteraction: true,
      zoom: true
    }
  } : null;
  const volumeAxis = volume ? [
    {
      type: "number",
      position: "left",
      keys: [volumeKey],
      label: { enabled: false },
      crosshair: { enabled: false },
      gridLine: { enabled: false },
      nice: false,
      // @ts-expect-error undocumented option
      layoutConstraints: {
        stacked: false,
        width: 20,
        unit: "percent",
        align: "end"
      }
    }
  ] : [];
  return {
    theme: {
      baseTheme: typeof theme === "string" ? theme : "ag-financial",
      ...mergeDefaults(typeof theme === "object" ? theme : null, {
        overrides: {
          common: {
            title: { padding: 4 },
            padding: {
              top: 6,
              right: 8,
              bottom: 6
            },
            chartToolbar: {
              enabled: toolbar2
            },
            annotations: { ...annotationsTheme },
            axes: {
              number: {
                interval: { maxSpacing: 45 },
                label: { format: ".2f" }
              }
            }
          },
          bar: {
            series: {
              fillOpacity: 0.5
            }
          },
          line: {
            series: {
              marker: { enabled: false },
              ...inlineSwitch(chartType, {
                hlc: {
                  stroke: { $palette: "altNeutral.stroke" },
                  strokeWidth: 2
                },
                line: {
                  stroke: { $palette: "neutral.stroke" }
                },
                "step-line": {
                  stroke: { $palette: "neutral.stroke" },
                  interpolation: { type: "step" }
                }
              })
            }
          },
          candlestick: {
            series: {
              ...inlineSwitch(chartType, {
                "hollow-candlestick": {
                  item: {
                    up: { fill: "transparent" }
                  }
                }
              })
            }
          },
          "range-area": {
            series: {
              fillOpacity: 0.3,
              strokeWidth: 2
            }
          }
        }
      })
    },
    animation: { enabled: false },
    legend: { enabled: false },
    series: [...volumeSeries, ...priceSeries],
    axes: [
      {
        type: "number",
        position: "right",
        keys: [openKey, closeKey, highKey, lowKey],
        crosshair: {
          enabled: true,
          snap: false
        },
        // @ts-expect-error undocumented option
        layoutConstraints: {
          stacked: false,
          width: 100,
          unit: "percent",
          align: "start"
        }
      },
      ...volumeAxis,
      {
        type: "ordinal-time",
        position: "bottom",
        line: {
          enabled: false
        },
        label: {
          enabled: true
        },
        crosshair: {
          enabled: true
        }
      }
    ],
    tooltip: { enabled: false },
    data,
    formatter: formatter2,
    ...annotationOpts,
    ...navigatorOpts,
    ...statusBarOpts,
    ...zoomOpts,
    ...toolbarOpts,
    ...syncGroup,
    ...unusedOpts
  };
}
function createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey) {
  if (!volume)
    return [];
  return [
    {
      type: "bar",
      xKey: "date",
      yKey: volumeKey,
      tooltip: { enabled: false },
      itemStyler({ datum }) {
        const { up, down } = getTheme().palette;
        return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };
      },
      // @ts-expect-error undocumented option
      focusPriority: 1,
      highlight: { enabled: false }
    }
  ];
}
var RANGE_AREA_TYPE = "range-area";
function createPriceSeries(chartType, xKey, highKey, lowKey, openKey, closeKey) {
  const keys = {
    xKey,
    openKey,
    closeKey,
    highKey,
    lowKey
  };
  const singleKeys = {
    xKey,
    yKey: closeKey
  };
  const common = {
    pickOutsideVisibleMinorAxis: true
  };
  switch (chartType ?? "candlestick") {
    case "ohlc":
      return createPriceSeriesOHLC(common, keys);
    case "line":
    case "step-line":
      return createPriceSeriesLine(common, singleKeys);
    case "hlc":
      return createPriceSeriesHLC(common, singleKeys, keys);
    case "high-low":
      return createPriceSeriesHighLow(common, keys);
    case "candlestick":
    case "hollow-candlestick":
      return createPriceSeriesCandlestick(common, keys);
    default:
      logger_exports.warnOnce(`unknown chart type: ${chartType}; expected one of: ${chartTypes3.join(", ")}`);
      return createPriceSeriesCandlestick(common, keys);
  }
}
function createPriceSeriesOHLC(common, keys) {
  return [
    {
      type: "ohlc",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...keys
    }
  ];
}
function createPriceSeriesLine(common, singleKeys) {
  return [
    {
      type: "line",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...singleKeys
    }
  ];
}
function createPriceSeriesHLC(common, singleKeys, { xKey, highKey, closeKey, lowKey }) {
  return [
    {
      type: RANGE_AREA_TYPE,
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      xKey,
      yHighKey: highKey,
      yLowKey: closeKey,
      fill: PALETTE_UP_FILL,
      stroke: PALETTE_UP_STROKE
    },
    {
      type: RANGE_AREA_TYPE,
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      xKey,
      yHighKey: closeKey,
      yLowKey: lowKey,
      fill: PALETTE_DOWN_FILL,
      stroke: PALETTE_DOWN_STROKE
    },
    {
      type: "line",
      ...common,
      ...singleKeys
    }
  ];
}
function createPriceSeriesHighLow(common, { xKey, highKey, lowKey }) {
  return [
    {
      type: "range-bar",
      ...common,
      xKey,
      yHighKey: highKey,
      yLowKey: lowKey,
      fill: PALETTE_NEUTRAL_FILL,
      stroke: PALETTE_NEUTRAL_STROKE,
      tooltip: {
        range: "nearest"
      },
      // @ts-expect-error undocumented option
      focusPriority: 0
    }
  ];
}
function createPriceSeriesCandlestick(common, keys) {
  return [
    {
      type: "candlestick",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...keys
    }
  ];
}
function inlineSwitch(caseName, switchCases) {
  return switchCases[caseName] ?? switchCases.default;
}

// packages/ag-charts-community/src/api/preset/sparkline.ts
var commonAxisProperties = {
  title: {
    enabled: false
  },
  label: {
    enabled: false
  },
  line: {
    enabled: false
  },
  gridLine: {
    enabled: false
  },
  crosshair: {
    enabled: false,
    stroke: DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
    lineDash: [0],
    label: {
      enabled: false
    }
  }
};
var numericAxisProperties = {
  ...commonAxisProperties,
  nice: false
};
var chartTooltipDefaults = {
  mode: "compact",
  position: {
    anchorTo: "node",
    placement: ["right", "left"]
  },
  showArrow: false
};
var barGridLineDefaults = {
  style: [{ stroke: { $ref: "gridLineColor" } }],
  width: 2
};
var barAxisDefaults = {
  number: {
    gridLine: barGridLineDefaults
  },
  time: {
    gridLine: barGridLineDefaults
  },
  category: {
    gridLine: barGridLineDefaults
  }
};
var SPARKLINE_THEME = {
  overrides: {
    common: {
      animation: { enabled: false },
      contextMenu: { enabled: false },
      keyboard: { enabled: false },
      background: { visible: false },
      navigator: {
        enabled: false
      },
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      axes: {
        number: {
          ...numericAxisProperties,
          interval: {
            values: [0]
          }
        },
        log: {
          ...numericAxisProperties
        },
        time: {
          ...numericAxisProperties
        },
        category: {
          ...commonAxisProperties
        }
      }
    },
    bar: {
      series: {
        crisp: false,
        label: {
          placement: "inside-end",
          padding: 4
        },
        // @ts-expect-error undocumented option
        sparklineMode: true
      },
      tooltip: {
        ...chartTooltipDefaults,
        position: {
          ...chartTooltipDefaults.position,
          anchorTo: "pointer"
        },
        range: "nearest"
      },
      axes: barAxisDefaults
    },
    line: {
      seriesArea: {
        padding: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2
        }
      },
      series: {
        // @ts-expect-error undocumented option
        sparklineMode: true,
        strokeWidth: 1,
        marker: {
          enabled: false,
          size: 3
        }
      },
      tooltip: chartTooltipDefaults
    },
    area: {
      seriesArea: {
        padding: {
          top: 1,
          right: 0,
          bottom: 1,
          left: 0
        }
      },
      series: {
        strokeWidth: 1,
        fillOpacity: 0.4
      },
      tooltip: chartTooltipDefaults
    }
  }
};
var setInitialBaseTheme = simpleMemorize(createInitialBaseTheme);
function createInitialBaseTheme(baseTheme, initialBaseTheme) {
  if (typeof baseTheme === "string") {
    return {
      ...initialBaseTheme,
      baseTheme
    };
  }
  if (baseTheme != null) {
    return {
      ...baseTheme,
      // @ts-expect-error internal implementation
      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)
    };
  }
  return initialBaseTheme;
}
function sparklineDataPreset(data) {
  if (Array.isArray(data) && data.length !== 0) {
    const firstItem = data.find((v) => v != null);
    if (typeof firstItem === "number") {
      const mappedData = data.map((y, x) => ({ x, y }));
      return { data: mappedData, series: [{ xKey: "x", yKey: "y" }], datumKey: "y" };
    } else if (Array.isArray(firstItem)) {
      const mappedData = data.map((datum) => ({ x: datum?.[0], y: datum?.[1], datum }));
      return { data: mappedData, series: [{ xKey: "x", yKey: "y" }], datumKey: "datum" };
    }
  } else if (data?.length === 0) {
    return { data, series: [{ xKey: "x", yKey: "y" }], datumKey: "y" };
  }
  return { data };
}
function axisPreset(opts) {
  switch (opts?.type) {
    case "number": {
      const { type, min, max, reverse } = opts;
      return pickProps(opts, {
        type,
        reverse,
        min,
        max
      });
    }
    case "time": {
      const { type, min, max, reverse } = opts;
      return pickProps(opts, {
        type,
        reverse,
        min,
        max
      });
    }
    case "category":
    default: {
      const { paddingInner, paddingOuter, reverse } = opts ?? {};
      return pickProps(
        { ...opts, type: "category" },
        {
          type: "category",
          reverse,
          paddingInner,
          paddingOuter
        }
      );
    }
  }
}
function gridLinePreset(opts, defaultEnabled, sparkOpts) {
  const gridLineOpts = {};
  if (opts?.stroke != null) {
    gridLineOpts.style = [{ stroke: opts?.stroke }];
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (opts?.strokeWidth != null) {
    gridLineOpts.width = opts?.strokeWidth;
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (sparkOpts.type === "bar" && sparkOpts.direction !== "horizontal") {
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (opts?.visible != null) {
    gridLineOpts.enabled = opts.visible;
  }
  gridLineOpts.enabled ?? (gridLineOpts.enabled = defaultEnabled);
  return gridLineOpts;
}
var tooltipRendererFn = simpleMemorize((context, tooltip, datumKey) => {
  return (params) => {
    const xValue2 = params.datum[params.xKey];
    const yValue = params.datum[params.yKey];
    const datum = datumKey != null ? params.datum[datumKey] : params.datum;
    const userContent = tooltip?.renderer?.({ context, datum, xValue: xValue2, yValue });
    if (typeof userContent === "string")
      return userContent;
    const content = userContent?.content ?? yValue.toFixed(2);
    return userContent?.title ? {
      heading: void 0,
      title: void 0,
      data: [{ label: userContent.title, value: content }]
    } : {
      heading: void 0,
      title: content,
      data: []
    };
  };
});
function sparkline(opts) {
  const {
    background,
    container,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    width: width2,
    theme: baseTheme,
    data: baseData,
    crosshair,
    axis,
    min,
    max,
    tooltip,
    context,
    styleNonce,
    ...optsRest
  } = opts;
  const chartOpts = pickProps(opts, {
    background,
    container,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding: padding2,
    width: width2,
    styleNonce,
    tooltip: IGNORED_PROP,
    context: IGNORED_PROP,
    data: IGNORED_PROP,
    crosshair: IGNORED_PROP,
    axis: IGNORED_PROP,
    min: IGNORED_PROP,
    max: IGNORED_PROP,
    theme: IGNORED_PROP
  });
  const { data, series: [seriesOverrides] = [], datumKey } = sparklineDataPreset(baseData);
  const seriesOptions = optsRest;
  if (seriesOverrides != null)
    Object.assign(seriesOptions, seriesOverrides);
  seriesOptions.tooltip = {
    ...tooltip,
    renderer: tooltipRendererFn(context, tooltip, datumKey)
  };
  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);
  chartOpts.data = data;
  chartOpts.series = [seriesOptions];
  const swapAxes = seriesOptions.type !== "bar" || seriesOptions.direction !== "horizontal";
  const [xAxisPosition, yAxisPosition] = swapAxes ? ["bottom", "left"] : ["left", "bottom"];
  const xAxis = {
    ...axisPreset(axis),
    position: xAxisPosition,
    ...pickProps(opts, { crosshair })
  };
  const yAxis = {
    type: "number",
    gridLine: gridLinePreset(axis, false, opts),
    position: yAxisPosition,
    ...pickProps(opts, { min, max })
  };
  chartOpts.axes = swapAxes ? [yAxis, xAxis] : [xAxis, yAxis];
  return chartOpts;
}

// packages/ag-charts-community/src/api/preset/presetModules.ts
var priceVolumeOptionsDef = {
  chartType: union("candlestick", "hollow-candlestick", "ohlc", "line", "step-line", "hlc", "high-low"),
  dateKey: string,
  openKey: string,
  highKey: string,
  lowKey: string,
  closeKey: string,
  volumeKey: string,
  navigator: boolean,
  volume: boolean,
  rangeButtons: boolean,
  statusBar: boolean,
  toolbar: boolean,
  zoom: boolean,
  sync: boolean,
  // Valid pass-through options
  theme: defined,
  container: defined,
  width: defined,
  height: defined,
  minWidth: defined,
  minHeight: defined,
  listeners: defined,
  initialState: defined,
  title: defined,
  data: array,
  formatter: defined
};
var commonGaugeOptions = {
  // Valid pass-through options
  theme: defined,
  container: defined,
  animation: defined,
  background: defined,
  contextMenu: defined,
  context: () => true,
  listeners: defined,
  locale: defined,
  width: defined,
  height: defined,
  minWidth: defined,
  minHeight: defined,
  title: defined,
  subtitle: defined,
  footnote: defined,
  padding: defined,
  tooltip: {
    ...tooltipOptionsDefs,
    ...commonChartOptionsDefs.tooltip
  }
};
commonGaugeOptions.overrideDevicePixelRatio = undocumented(positiveNumber);
var commonSparklineOmit = [
  "showInLegend",
  "showInMiniChart",
  "grouped",
  "stacked",
  "stackGroup",
  "tooltip",
  "listeners",
  "errorBar",
  "xKey",
  "yKey",
  "type"
];
var commonSparklineAxisOptionsDef = {
  visible: boolean,
  reverse: boolean,
  stroke: color,
  strokeWidth: positiveNumber
};
var commonSparklineOptionsDef = {
  context: () => true,
  tooltip: defined,
  theme: defined,
  background: defined,
  container: defined,
  width: defined,
  height: defined,
  minWidth: defined,
  minHeight: defined,
  padding: defined,
  listeners: defined,
  locale: defined,
  data: defined,
  styleNonce: string,
  axis: typeUnion(
    {
      number: {
        ...commonSparklineAxisOptionsDef,
        min: and(number, lessThan("max")),
        max: and(number, greaterThan("min"))
      },
      category: {
        ...commonSparklineAxisOptionsDef,
        paddingInner: ratio,
        paddingOuter: ratio
      },
      time: {
        ...commonSparklineAxisOptionsDef,
        min: and(or(number, date), lessThan("max")),
        max: and(or(number, date), greaterThan("min"))
      }
    },
    "axis options",
    "category"
    // AG-14799 - Contrary to the AgSparklineAxisOptions interface, type is optional and defaults to 'category'.
  ),
  min: and(number, lessThan("max")),
  max: and(number, greaterThan("min")),
  crosshair: {
    enabled: boolean,
    snap: boolean,
    ...strokeOptionsDef,
    ...lineDashOptionsDef
  },
  xKey: string,
  yKey: string
};
var PriceVolumePresetModule = {
  type: "preset",
  name: "price-volume",
  enterprise: true,
  options: priceVolumeOptionsDef,
  create: priceVolume
};
var GaugePresetModule = {
  type: "preset",
  name: "gauge-preset",
  enterprise: true,
  options: typeUnion(
    {
      "linear-gauge": {
        ...without(linearGaugeSeriesOptionsDef, ["type"]),
        ...commonGaugeOptions
      },
      "radial-gauge": {
        ...without(radialGaugeSeriesOptionsDef, ["type"]),
        ...commonGaugeOptions
      }
    },
    "gauge options"
  ),
  create: gauge
};
var SparklinePresetModule = {
  type: "preset",
  name: "sparkline",
  options: typeUnion(
    {
      area: {
        ...commonSparklineOptionsDef,
        ...without(areaSeriesOptionsDef, commonSparklineOmit)
      },
      bar: {
        ...commonSparklineOptionsDef,
        ...without(barSeriesOptionsDef, commonSparklineOmit)
      },
      line: {
        ...commonSparklineOptionsDef,
        ...without(lineSeriesOptionsDef, commonSparklineOmit)
      }
    },
    "sparkline options"
  ),
  create: sparkline,
  processData: sparklineDataPreset
};

// packages/ag-charts-community/src/chart/cartesianChart.ts
var directions = ["top", "right", "bottom", "left"];
var _CartesianChart = class _CartesianChart extends Chart {
  constructor(options, resources) {
    super(options, resources);
    // TODO should come from theme
    /** Integrated Charts feature state - not used in Standalone Charts. */
    this.paired = true;
    this.lastUpdateClipRect = void 0;
    this.lastLayoutWidth = NaN;
    this.lastLayoutHeight = NaN;
  }
  onAxisChange(newValue, oldValue) {
    super.onAxisChange(newValue, oldValue);
    this.syncAxisChanges(newValue, oldValue);
    if (this.ctx != null) {
      this.ctx.zoomManager.updateAxes(newValue);
    }
  }
  destroySeries(series) {
    super.destroySeries(series);
    this.lastLayoutWidth = NaN;
    this.lastLayoutHeight = NaN;
  }
  getChartType() {
    return "cartesian";
  }
  setRootClipRects(clipRect) {
    const { seriesRoot, annotationRoot } = this;
    seriesRoot.setClipRect(clipRect);
    annotationRoot.setClipRect(clipRect);
  }
  async processData() {
    await super.processData();
    if (this.syncStatus === "init") {
      this.syncStatus = "domains-calculated";
    }
    this.ctx.updateService.dispatchProcessData({ series: { shouldFlipXY: this.shouldFlipXY() } });
  }
  async processDomains() {
    await super.processDomains();
    for (const axis of this.axes) {
      const syncedDomain = await this.getSyncedDomain(axis);
      if (syncedDomain != null) {
        axis.setDomains(syncedDomain);
      }
    }
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot } = this;
    const { clipSeries, seriesRect, visible } = this.updateAxes(ctx.layoutBox);
    this.seriesRoot.visible = visible;
    this.seriesRect = seriesRect;
    this.animationRect = ctx.layoutBox;
    const { x, y } = seriesRect;
    if (ctx.width !== this.lastLayoutWidth || ctx.height !== this.lastLayoutHeight) {
      for (const group of [seriesRoot, annotationRoot]) {
        group.translationX = Math.floor(x);
        group.translationY = Math.floor(y);
      }
    } else {
      const { translationX, translationY } = seriesRoot;
      staticFromToMotion(
        this.id,
        "seriesRect",
        this.ctx.animationManager,
        [seriesRoot, annotationRoot],
        { translationX, translationY },
        { translationX: Math.floor(x), translationY: Math.floor(y) },
        { phase: "update" }
      );
    }
    this.lastLayoutWidth = ctx.width;
    this.lastLayoutHeight = ctx.height;
    const seriesArea = this.modulesManager.getModule("seriesArea");
    const seriesPaddedRect = seriesRect.clone().grow(seriesArea.getPadding());
    const clipRect = seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;
    const { lastUpdateClipRect } = this;
    this.lastUpdateClipRect = clipRect;
    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {
      this.ctx.animationManager.animate({
        id: this.id,
        groupId: "clip-rect",
        phase: "update",
        from: lastUpdateClipRect,
        to: seriesPaddedRect,
        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),
        onComplete: () => this.setRootClipRects(clipRect)
      });
    } else {
      this.setRootClipRects(clipRect);
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      axes: this.axes.map((axis) => axis.getLayoutState()),
      series: {
        visible,
        rect: seriesRect,
        paddedRect: seriesPaddedRect
      },
      clipSeries
    });
  }
  updateAxes(layoutBox) {
    const { clipSeries, seriesRect, overflows } = this.resolveAxesLayout(layoutBox);
    for (const axis of this.axes) {
      axis.update();
      axis.setCrossLinesVisible(!overflows);
      this.clipAxis(axis, seriesRect, layoutBox);
    }
    return { clipSeries, seriesRect, visible: !overflows };
  }
  // Iteratively try to resolve axis widths - since X axis width affects Y axis range,
  // and vice-versa, we need to iteratively try and find a fit for the axes and their
  // ticks/labels.
  resolveAxesLayout(layoutBox) {
    let newState;
    let prevState;
    let iterations = 0;
    const maxIterations = 10;
    do {
      prevState = newState ?? this.getDefaultState();
      newState = this.updateAxesPass(new Map(prevState.axisAreaWidths), layoutBox.clone());
      if (iterations++ > maxIterations) {
        logger_exports.warn("Max iterations reached. Unable to stabilize axes layout.");
        break;
      }
    } while (!this.isLayoutStable(newState, prevState));
    this.lastAreaWidths = newState.axisAreaWidths;
    return newState;
  }
  updateAxesPass(axisAreaWidths, axisAreaBound) {
    const axisWidths = /* @__PURE__ */ new Map();
    const primaryTickCounts = {};
    let overflows = false;
    let clipSeries = false;
    for (const dir of directions) {
      const padding2 = this.modulesManager.getModule("seriesArea").getPadding()[dir];
      const axis = this.axes.findLast((a) => a.position === dir);
      if (axis) {
        axis.seriesAreaPadding = padding2;
      } else {
        axisAreaBound.shrink(padding2, dir);
      }
    }
    const totalWidth = (axisAreaWidths.get("left") ?? 0) + (axisAreaWidths.get("right") ?? 0);
    const totalHeight = (axisAreaWidths.get("top") ?? 0) + (axisAreaWidths.get("bottom") ?? 0);
    const crossLinePadding = this.buildCrossLinePadding(axisAreaWidths);
    const crossLineHPadding = crossLinePadding.left + crossLinePadding.right;
    const crossLineVPadding = crossLinePadding.top + crossLinePadding.bottom;
    if (axisAreaBound.width <= totalWidth + crossLineHPadding || axisAreaBound.height <= totalHeight + crossLineVPadding) {
      overflows = true;
    } else {
      axisAreaBound.shrink(crossLinePadding);
    }
    const { scene } = this.ctx;
    const seriesRect = axisAreaBound.clone().shrink(Object.fromEntries(axisAreaWidths));
    for (const axis of this.axes) {
      const { position = "left", direction } = axis;
      const isVertical = direction === "y" /* Y */;
      let axisWidth;
      this.sizeAxis(axis, seriesRect, position);
      if (axis.thickness == null) {
        const availableSize = getSize(isVertical, scene);
        axisWidth = availableSize * (axis.maxThicknessRatio ?? 1);
      } else {
        axisWidth = axis.thickness;
      }
      const { primaryTickCount, bbox } = axis.calculateLayout(
        axis.nice ? primaryTickCounts[direction] : void 0,
        { sizeLimit: axisWidth, padding: this.padding }
      );
      primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);
      clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
      if (axis.thickness == null) {
        axisWidth = Math.min(getSize(isVertical, bbox) ?? 0, axisWidth);
      }
      axisWidths.set(axis.id, Math.ceil(axisWidth));
    }
    const axisGroups = groupBy(this.axes, (axis) => axis.position ?? "left");
    const newAxisAreaWidths = /* @__PURE__ */ new Map();
    const axisOffsets = /* @__PURE__ */ new Map();
    for (const [position, axes] of entries(axisGroups)) {
      let currentOffset = getSize(position !== "left" && position !== "right", scene) % scene.pixelRatio;
      let totalAxisWidth = 0;
      for (const axis of axes ?? []) {
        axisOffsets.set(axis.id, currentOffset);
        const axisThickness = axisWidths.get(axis.id) ?? 0;
        totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);
        if (axis.layoutConstraints.stacked) {
          currentOffset += axisThickness + _CartesianChart.AxesPadding;
        }
      }
      newAxisAreaWidths.set(position, Math.ceil(totalAxisWidth));
    }
    for (const [position, axes] of entries(axisGroups)) {
      this.positionAxes({
        axes: axes ?? [],
        position,
        axisWidths,
        axisOffsets,
        axisAreaWidths: newAxisAreaWidths,
        axisBound: axisAreaBound,
        seriesRect
      });
    }
    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, overflows };
  }
  buildCrossLinePadding(axisAreaSize) {
    const crossLinePadding = { top: 0, right: 0, bottom: 0, left: 0 };
    this.axes.forEach((axis) => {
      const { position, label } = axis;
      axis.crossLines?.forEach((crossLine) => {
        var _a;
        if (crossLine instanceof CartesianCrossLine) {
          crossLine.position = position ?? "top";
          (_a = crossLine.label).parallel ?? (_a.parallel = label.parallel);
        }
        crossLine.calculatePadding?.(crossLinePadding);
      });
    });
    for (const [side, padding2 = 0] of entries(crossLinePadding)) {
      crossLinePadding[side] = Math.max(padding2 - (axisAreaSize.get(side) ?? 0), 0);
    }
    return crossLinePadding;
  }
  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
    const bound = dimension === "x" ? seriesRect.x : seriesRect.y;
    const size = dimension === "x" ? seriesRect.width : seriesRect.height;
    return direction === 1 ? Math.min(value, bound + size) : Math.max(value, bound);
  }
  async getSyncedDomain(axis) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    return await syncModule.getSyncedDomain(axis);
  }
  syncAxisChanges(newValue, oldValue) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    const removed = new Set(oldValue ?? []);
    for (const axis of newValue) {
      removed.delete(axis);
    }
    for (const removedAxis of removed) {
      syncModule.removeAxis(removedAxis);
    }
  }
  sizeAxis(axis, seriesRect, position) {
    const isNumberAxis = axis instanceof NumberAxis;
    const isLeftRight = position === "left" || position === "right";
    const { width: width2, height: height2 } = seriesRect;
    const maxEnd = isLeftRight ? height2 : width2;
    let start2 = 0;
    let end2 = maxEnd;
    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);
    const { width: axisWidth, unit, align: align2 } = axis.layoutConstraints;
    if (unit === "px") {
      end2 = start2 + axisWidth;
    } else {
      end2 = end2 * axisWidth / 100;
    }
    if (align2 === "end") {
      start2 = maxEnd - (end2 - start2);
      end2 = maxEnd;
    }
    if (isLeftRight) {
      if (isNumberAxis) {
        [start2, end2] = [end2, start2];
      } else {
        [min, max] = [1 - max, 1 - min];
      }
    }
    axis.range = [start2, end2];
    axis.visibleRange = [min, max];
    axis.gridLength = isLeftRight ? width2 : height2;
  }
  positionAxes(opts) {
    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;
    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;
    let mainDimension = "x";
    let minorDimension = "y";
    let direction = 1;
    if (position === "top" || position === "bottom") {
      mainDimension = "y";
      minorDimension = "x";
    }
    let axisBoundMainOffset = axisBound[mainDimension];
    if (position === "right" || position === "bottom") {
      direction = -1;
      axisBoundMainOffset += mainDimension === "x" ? axisBound.width : axisBound.height;
    }
    for (const axis of axes) {
      const minorOffset = axisAreaWidths.get(minorDimension === "x" ? "left" : "top") ?? 0;
      const axisThickness = axisWidths.get(axis.id) ?? 0;
      const axisOffset = axisOffsets.get(axis.id) ?? 0;
      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;
      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;
      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(
        seriesRect,
        axisBoundMainOffset + direction * (axisOffset + axisThickness),
        mainDimension,
        direction
      );
    }
  }
  shouldFlipXY() {
    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());
  }
  getDefaultState() {
    const axisAreaWidths = /* @__PURE__ */ new Map();
    if (this.lastAreaWidths) {
      for (const { position = "left" } of this.axes) {
        const areaWidth = this.lastAreaWidths.get(position);
        if (areaWidth != null) {
          axisAreaWidths.set(position, areaWidth);
        }
      }
    }
    return { axisAreaWidths, clipSeries: false, overflows: false };
  }
  isLayoutStable(newState, prevState) {
    if (prevState.overflows !== newState.overflows || prevState.clipSeries !== newState.clipSeries) {
      return false;
    }
    for (const key of newState.axisAreaWidths.keys()) {
      if (!prevState.axisAreaWidths.has(key)) {
        return false;
      }
    }
    for (const [p, w] of prevState.axisAreaWidths.entries()) {
      const otherW = newState.axisAreaWidths.get(p);
      if ((w != null || otherW != null) && w !== otherW) {
        return false;
      }
    }
    return true;
  }
  clipAxis(axis, seriesRect, layoutBBox) {
    const gridLinePadding = Math.ceil(axis.gridLine?.width ?? 0);
    const axisLinePadding = Math.ceil(axis.line?.width ?? 0);
    let { width: width2, height: height2 } = seriesRect;
    width2 += axis.direction === "x" /* X */ ? gridLinePadding : axisLinePadding;
    height2 += axis.direction === "y" /* Y */ ? gridLinePadding : axisLinePadding;
    axis.clipGrid(seriesRect.x, seriesRect.y, width2, height2);
    switch (axis.position) {
      case "left":
      case "right":
        axis.clipTickLines(
          layoutBBox.x,
          seriesRect.y - gridLinePadding,
          layoutBBox.width + gridLinePadding,
          seriesRect.height + gridLinePadding * 2
        );
        break;
      case "top":
      case "bottom":
        axis.clipTickLines(
          seriesRect.x - gridLinePadding,
          layoutBBox.y,
          seriesRect.width + gridLinePadding * 2,
          layoutBBox.height + gridLinePadding
        );
        break;
    }
  }
};
_CartesianChart.className = "CartesianChart";
_CartesianChart.type = "cartesian";
_CartesianChart.AxesPadding = 15;
var CartesianChart = _CartesianChart;
function getSize(isVertical, bounds) {
  return isVertical ? bounds?.width : bounds?.height;
}

// packages/ag-charts-community/src/chart/chartOptionsDefs.ts
var commonChartOptions = {
  mode: undocumented(union("integrated", "standalone")),
  container: htmlElement,
  context: () => true,
  theme: defined,
  series: array,
  annotations: defined,
  navigator: defined,
  initialState: {
    chartType: string,
    annotations: defined,
    legend: arrayOfDefs(
      {
        visible: boolean,
        seriesId: string,
        itemId: string,
        legendItemName: string
      },
      "legend state array"
    ),
    zoom: defined
  }
};
var cartesianChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  axes: arrayLength(2),
  data: array
};
var polarChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  axes: arrayLength(2),
  data: array
};
var topologyChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: array,
  topology: geoJson
};
var standaloneChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: array
};

// packages/ag-charts-community/src/chart/cartesianChartModule.ts
var histogramAxisTypes = /* @__PURE__ */ new Set(["number", "log", "time"]);
var validHistogramAxis = (axis) => isObject(axis) && !histogramAxisTypes.has(axis.type);
var CartesianChartModule = {
  type: "chart",
  name: "cartesian",
  options: cartesianChartOptionsDefs,
  detect: isAgCartesianChartOptions,
  create(options, resources) {
    return new CartesianChart(options, resources);
  },
  validate(options, optionsDefs2, path) {
    const additionalErrors = [];
    if (options?.series?.[0]?.type === "histogram") {
      if (options?.axes?.some(validHistogramAxis)) {
        additionalErrors.push(
          new ValidationError(
            "invalid",
            "only continuous axis types when histogram series is used",
            options.axes,
            path,
            "axes"
          )
        );
        options = without(options, ["axes"]);
      }
    }
    const result = validate(options, optionsDefs2, path);
    result.invalid.push(...additionalErrors);
    return result;
  }
};

// packages/ag-charts-community/src/chart/enterpriseChartModules.ts
var placeholderCreate = () => {
  throw new Error("Enterprise module placeholder cannot be initialised");
};
var StandaloneChartModule = {
  type: "chart",
  name: "standalone",
  placeholder: true,
  options: {},
  detect: isAgStandaloneChartOptions,
  create: placeholderCreate
};
var TopologyChartModule = {
  type: "chart",
  name: "topology",
  placeholder: true,
  options: {},
  detect: isAgTopologyChartOptions,
  create: placeholderCreate
};

// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis = class extends Axis {
  constructor() {
    super(...arguments);
    this.shape = "polygon";
    this.innerRadiusRatio = 0;
    this.defaultTickMinSpacing = 20;
  }
  layoutCrossLines() {
    const sideFlag = this.label.getSideFlag();
    const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    this.crossLines.forEach((crossLine) => {
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "angle" /* Angle */ : "radius" /* Radius */;
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.calculateLayout?.(crosslinesVisible, this.reverse);
    });
  }
  updatePosition() {
    super.updatePosition();
    const translationX = Math.floor(this.translation.x);
    const translationY = Math.floor(this.translation.y);
    this.tickLineGroup.translationX = translationX;
    this.tickLineGroup.translationY = translationY;
    this.tickLabelGroup.translationX = translationX;
    this.tickLabelGroup.translationY = translationY;
    this.crossLineRangeGroup.translationX = translationX;
    this.crossLineRangeGroup.translationY = translationY;
    this.crossLineLineGroup.translationX = translationX;
    this.crossLineLineGroup.translationY = translationY;
    this.crossLineLabelGroup.translationX = translationX;
    this.crossLineLabelGroup.translationY = translationY;
    this.tickLabelGroupSelection.each(resetAxisLabelSelectionFn());
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  computeRange() {
  }
  getAxisLinePoints() {
    return void 0;
  }
};
__decorateClass([
  Property
], PolarAxis.prototype, "shape", 2);
__decorateClass([
  Property
], PolarAxis.prototype, "innerRadiusRatio", 2);

// packages/ag-charts-community/src/chart/polarChart.ts
var PolarChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this.padding = new Padding(40);
    this.ctx.axisManager.axisGroup.zIndex = 8 /* AXIS_FOREGROUND */;
  }
  getChartType() {
    return "polar";
  }
  async performLayout(ctx) {
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone().shrink(this.modulesManager.getModule("seriesArea").getPadding());
    this.seriesRect = seriesRect;
    this.animationRect = seriesRect;
    this.seriesRoot.translationX = seriesRect.x;
    this.seriesRoot.translationY = seriesRect.y;
    await this.computeCircle(seriesRect);
    this.axes.forEach((axis) => axis.update());
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  updateAxes(seriesBox, cx, cy, radius) {
    const angleAxis = this.axes.find((axis) => axis.direction === "angle" /* Angle */);
    const radiusAxis = this.axes.find((axis) => axis.direction === "radius" /* Radius */);
    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))
      return;
    const angleScale = angleAxis.scale;
    const innerRadiusRatio = radiusAxis.innerRadiusRatio;
    angleAxis.innerRadiusRatio = innerRadiusRatio;
    angleAxis.computeRange();
    angleAxis.gridLength = radius;
    radiusAxis.gridAngles = angleScale.ticks({
      nice: angleAxis.nice,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    })?.ticks?.map((value) => angleScale.convert(value));
    radiusAxis.gridRange = angleAxis.range;
    radiusAxis.range = [radius, radius * innerRadiusRatio];
    [angleAxis, radiusAxis].forEach((axis) => {
      axis.translation.x = seriesBox.x + cx;
      axis.translation.y = seriesBox.y + cy;
      axis.calculateLayout();
    });
  }
  async computeCircle(seriesBox) {
    const polarSeries = this.series.filter(isPolarSeries);
    const polarAxes = this.axes.filter(isPolarAxis);
    const setSeriesCircle = (cx, cy, r) => {
      this.updateAxes(seriesBox, cx, cy, r);
      polarSeries.forEach((series) => {
        series.centerX = cx;
        series.centerY = cy;
        series.radius = r;
      });
      const pieSeries = polarSeries.filter((s) => s.type === "donut" || s.type === "pie");
      if (pieSeries.length > 1) {
        const innerRadii = pieSeries.map((series) => {
          const innerRadius = series.getInnerRadius();
          return { series, innerRadius };
        }).sort((a, b) => a.innerRadius - b.innerRadius);
        innerRadii.at(-1).series.surroundingRadius = void 0;
        for (let i = 0; i < innerRadii.length - 1; i++) {
          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
        }
      }
    };
    const centerX = seriesBox.width / 2;
    const centerY = seriesBox.height / 2;
    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
    let radius = initialRadius;
    setSeriesCircle(centerX, centerY, radius);
    const shake = async ({ hideWhenNecessary = false } = {}) => {
      const labelBoxes = [];
      for (const series of iterate(polarAxes, polarSeries)) {
        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);
        if (box) {
          labelBoxes.push(box);
        }
      }
      if (labelBoxes.length === 0) {
        setSeriesCircle(centerX, centerY, initialRadius);
        return;
      }
      const labelBox = BBox.merge(labelBoxes);
      const refined = this.refineCircle(labelBox, radius, seriesBox);
      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
      radius = refined.radius;
    };
    await shake();
    await shake();
    await shake();
    await shake({ hideWhenNecessary: true });
    await shake({ hideWhenNecessary: true });
    for (const series of iterate(polarAxes, polarSeries)) {
      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);
    }
    return { radius, centerX, centerY };
  }
  refineCircle(labelsBox, radius, seriesBox) {
    const minCircleRatio = 0.5;
    const circleLeft = -radius;
    const circleTop = -radius;
    const circleRight = radius;
    const circleBottom = radius;
    let padLeft = Math.max(0, circleLeft - labelsBox.x);
    let padTop = Math.max(0, circleTop - labelsBox.y);
    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
    padLeft = padRight = Math.max(padLeft, padRight);
    padTop = padBottom = Math.max(padTop, padBottom);
    const availCircleWidth = seriesBox.width - padLeft - padRight;
    const availCircleHeight = seriesBox.height - padTop - padBottom;
    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
    if (newRadius < minRadius) {
      newRadius = minRadius;
      const horizontalPadding = padLeft + padRight;
      const verticalPadding = padTop + padBottom;
      if (2 * newRadius + verticalPadding > seriesBox.height) {
        const padHeight = seriesBox.height - 2 * newRadius;
        if (Math.min(padTop, padBottom) * 2 > padHeight) {
          padTop = padHeight / 2;
          padBottom = padHeight / 2;
        } else if (padTop > padBottom) {
          padTop = padHeight - padBottom;
        } else {
          padBottom = padHeight - padTop;
        }
      }
      if (2 * newRadius + horizontalPadding > seriesBox.width) {
        const padWidth = seriesBox.width - 2 * newRadius;
        if (Math.min(padLeft, padRight) * 2 > padWidth) {
          padLeft = padWidth / 2;
          padRight = padWidth / 2;
        } else if (padLeft > padRight) {
          padLeft = padWidth - padRight;
        } else {
          padRight = padWidth - padLeft;
        }
      }
    }
    const newWidth = padLeft + 2 * newRadius + padRight;
    const newHeight = padTop + 2 * newRadius + padBottom;
    return {
      centerX: (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
      centerY: (seriesBox.height - newHeight) / 2 + padTop + newRadius,
      radius: newRadius
    };
  }
};
PolarChart.className = "PolarChart";
PolarChart.type = "polar";
function isPolarSeries(series) {
  return series instanceof PolarSeries;
}
function isPolarAxis(axis) {
  return axis instanceof PolarAxis;
}

// packages/ag-charts-community/src/chart/polarChartModule.ts
var PolarChartModule = {
  type: "chart",
  name: "polar",
  options: polarChartOptionsDefs,
  detect: isAgPolarChartOptions,
  create(options, resources) {
    return new PolarChart(options, resources);
  },
  validate(options, optionsDefs2, path) {
    const additionalErrors = [];
    const baseType = options?.series?.[0]?.type;
    if (baseType === "pie" || baseType === "donut") {
      if (options?.axes) {
        additionalErrors.push(new UnknownError([], options.axes, path, "axes"));
        options = without(options, ["axes"]);
      }
    }
    const result = validate(options, optionsDefs2, path);
    result.invalid.push(...additionalErrors);
    return result;
  }
};

// packages/ag-charts-community/src/main-modules.ts
var AllCartesianCommunityModules = [
  CartesianChartModule,
  NumberAxisModule,
  LogAxisModule,
  TimeAxisModule,
  CategoryAxisModule,
  GroupedCategoryAxisModule,
  UnitTimeAxisModule,
  NewAreaSeriesModule,
  NewBarSeriesModule,
  NewBubbleSeriesModule,
  NewHistogramSeriesModule,
  NewLineSeriesModule,
  NewScatterSeriesModule
];
var AllPolarCommunityModules = [PolarChartModule, NewDonutSeriesModule, NewPieSeriesModule];
var AllCommunityModules = [
  ...AllCartesianCommunityModules,
  ...AllPolarCommunityModules,
  // Enterprise placeholders
  StandaloneChartModule,
  TopologyChartModule,
  // Presets
  PriceVolumePresetModule,
  GaugePresetModule,
  SparklinePresetModule
];

// packages/ag-charts-community/src/util/pool.ts
var CLEANUP_TIMEOUT_MS = 1e3;
var _Pool = class _Pool {
  constructor(name, buildItem, releaseItem, destroyItem, maxPoolSize, cleanupTimeMs = CLEANUP_TIMEOUT_MS) {
    this.name = name;
    this.buildItem = buildItem;
    this.releaseItem = releaseItem;
    this.destroyItem = destroyItem;
    this.maxPoolSize = maxPoolSize;
    this.cleanupTimeMs = cleanupTimeMs;
    this.freePool = [];
    this.busyPool = /* @__PURE__ */ new Set();
  }
  static getPool(name, buildItem, releaseItem, destroyItem, maxPoolSize) {
    if (!this.pools.has(name)) {
      this.pools.set(name, new _Pool(name, buildItem, releaseItem, destroyItem, maxPoolSize));
    }
    return this.pools.get(name);
  }
  isFull() {
    return this.freePool.length + this.busyPool.size >= this.maxPoolSize;
  }
  hasFree() {
    return this.freePool.length > 0;
  }
  obtain(params) {
    if (!this.hasFree() && this.isFull()) {
      throw new Error("AG Charts - pool exhausted");
    }
    let nextFree = this.freePool.pop();
    if (nextFree == null) {
      nextFree = this.buildItem(params);
      _Pool.debug(() => [
        `Pool[name=${this.name}]: Created instance (${this.freePool.length} / ${this.busyPool.size + 1} / ${this.maxPoolSize})`,
        nextFree
      ]);
    } else {
      _Pool.debug(() => [
        `Pool[name=${this.name}]: Re-used instance (${this.freePool.length} / ${this.busyPool.size + 1} / ${this.maxPoolSize})`,
        nextFree
      ]);
    }
    this.busyPool.add(nextFree);
    return { item: nextFree, release: () => this.release(nextFree) };
  }
  obtainFree() {
    const nextFree = this.freePool.pop();
    if (nextFree == null) {
      throw new Error("AG Charts - pool has no free instances");
    }
    _Pool.debug(() => [
      `Pool[name=${this.name}]: Re-used instance (${this.freePool.length} / ${this.busyPool.size + 1} / ${this.maxPoolSize})`,
      nextFree
    ]);
    this.busyPool.add(nextFree);
    return { item: nextFree, release: () => this.release(nextFree) };
  }
  release(item) {
    if (!this.busyPool.has(item)) {
      throw new Error("AG Charts - cannot free item from pool which is not tracked as busy.");
    }
    _Pool.debug(() => [
      `Pool[name=${this.name}]: Releasing instance (${this.freePool.length} / ${this.busyPool.size} / ${this.maxPoolSize})`,
      item
    ]);
    this.releaseItem(item);
    this.busyPool.delete(item);
    this.freePool.push(item);
    _Pool.debug(() => [
      `Pool[name=${this.name}]: Returned instance to free pool (${this.freePool.length} / ${this.busyPool.size} / ${this.maxPoolSize})`,
      item
    ]);
    const now = Date.now();
    const earliestClean = now + this.cleanupTimeMs * 0.5;
    if (this.cleanPoolTimer && (this.cleanPoolDue ?? Infinity) < earliestClean) {
      clearTimeout(this.cleanPoolTimer);
      this.cleanPoolTimer = void 0;
    }
    if (!this.cleanPoolTimer) {
      this.cleanPoolDue = now + this.cleanupTimeMs;
      this.cleanPoolTimer = setTimeout(this.cleanPool.bind(this), this.cleanupTimeMs);
    }
  }
  cleanPool() {
    const itemsToFree = this.freePool.splice(0);
    for (const item of itemsToFree) {
      this.destroyItem(item);
    }
    _Pool.debug(() => [
      `Pool[name=${this.name}]: Cleaned pool of ${itemsToFree.length} items (${this.freePool.length} / ${this.busyPool.size} / ${this.maxPoolSize})`
    ]);
  }
  destroy() {
    this.cleanPool();
    for (const item of this.busyPool.values()) {
      this.destroyItem(item);
    }
    this.busyPool.clear();
  }
};
_Pool.pools = /* @__PURE__ */ new Map();
_Pool.debug = Debug.create(true, "pool");
var Pool = _Pool;

// packages/ag-charts-community/src/api/agCharts.ts
moduleRegistry_exports.registerMany(AllCommunityModules, VERSION);
var debug3 = Debug.create(true, "opts");
var AgCharts = class {
  static licenseCheck(options) {
    if (this.licenseChecked)
      return;
    this.licenseManager = enterpriseModule.licenseManager?.(options);
    this.licenseManager?.validateLicense();
    this.licenseChecked = true;
  }
  static getLicenseDetails(licenseKey) {
    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);
  }
  /**
   * Returns the `AgChartInstance` for a DOM node, if there is one.
   */
  static getInstance(element2) {
    return AgChartsInternal.getInstance(element2);
  }
  /**
   * Create a new `AgChartInstance` based upon the given configuration options.
   */
  static create(userOptions, optionsMetadata) {
    const apiStartTime = Debug.check("scene:stats", "scene:stats:verbose") ? performance.now() : void 0;
    return debug3.group("AgCharts.create()", () => {
      userOptions = Debug.inDevelopmentMode(() => deepFreeze(deepClone(userOptions))) ?? userOptions;
      this.licenseCheck(userOptions);
      const chart = AgChartsInternal.createOrUpdate({
        userOptions,
        licenseManager: this.licenseManager,
        optionsMetadata,
        apiStartTime
      });
      if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {
        enterpriseModule.injectWatermark?.(
          chart.chart.ctx.domManager,
          this.licenseManager.getWatermarkMessage()
        );
      }
      return chart;
    });
  }
  static createFinancialChart(options) {
    return debug3.group("AgCharts.createFinancialChart()", () => {
      return this.create(options, { presetType: "price-volume" });
    });
  }
  static createGauge(options) {
    return debug3.group("AgCharts.createGauge()", () => {
      return this.create(options, { presetType: "gauge-preset" });
    });
  }
  static __createSparkline(options) {
    return debug3.group("AgCharts.__createSparkline()", () => {
      const { pool, ...normalOptions } = options;
      return this.create(normalOptions, {
        presetType: "sparkline",
        pool: pool ?? true,
        domMode: "minimal",
        withDragInterpretation: false
      });
    });
  }
};
AgCharts.licenseChecked = false;
var _AgChartsInternal = class _AgChartsInternal {
  static getInstance(element2) {
    const chart = Chart.getInstance(element2);
    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;
  }
  static initialiseModules() {
    if (_AgChartsInternal.initialised)
      return;
    registerInbuiltModules();
    setupModules();
    _AgChartsInternal.initialised = true;
  }
  static createOrUpdate(opts) {
    let { proxy } = opts;
    const {
      userOptions,
      licenseManager,
      processedOverrides = proxy?.chart?.chartOptions.processedOverrides ?? {},
      specialOverrides = proxy?.chart?.chartOptions.specialOverrides ?? {},
      optionsMetadata = proxy?.chart?.chartOptions.optionMetadata ?? {},
      deltaOptions,
      data,
      stripSymbols = false,
      apiStartTime
    } = opts;
    const styles = enterpriseModule.styles != null ? [["ag-charts-enterprise", enterpriseModule.styles]] : [];
    _AgChartsInternal.initialiseModules();
    debug3(() => [">>> AgCharts.createOrUpdate() user options", deepClone(userOptions)]);
    const { presetType } = optionsMetadata;
    let mutableOptions = userOptions;
    if (AgCharts.optionsMutationFn && mutableOptions) {
      mutableOptions = AgCharts.optionsMutationFn(
        deepClone(mutableOptions, ChartOptions.OPTIONS_CLONE_OPTS_FAST),
        presetType
      );
      debug3(() => [">>> AgCharts.createOrUpdate() MUTATED user options", deepClone(mutableOptions)]);
    }
    const pool = this.getPool(optionsMetadata);
    let create = false;
    let poolResult;
    let chart = proxy?.chart;
    if (chart == null && pool?.hasFree()) {
      poolResult = pool.obtainFree();
      chart = poolResult.item;
    }
    const { document: document2, window: userWindow, styleContainer, ...options } = mutableOptions ?? {};
    const baseOptions = chart?.getChartOptions();
    const chartOptions = new ChartOptions(
      baseOptions,
      options,
      processedOverrides,
      {
        ...specialOverrides,
        document: document2,
        window: userWindow,
        styleContainer
      },
      optionsMetadata,
      deltaOptions,
      stripSymbols,
      apiStartTime
    );
    if (chart == null || moduleRegistry_exports.detectChartDefinition(chartOptions.processedOptions) !== moduleRegistry_exports.detectChartDefinition(chart.chartOptions.processedOptions)) {
      poolResult?.release();
      poolResult = this.getPool(chartOptions.optionMetadata)?.obtain(chartOptions);
      if (poolResult) {
        chart = poolResult.item;
      } else {
        create = true;
        chart = _AgChartsInternal.createChartInstance(chartOptions, chart);
      }
    }
    styles.forEach(([id, css]) => {
      chart.ctx.domManager.addStyles(id, css);
    });
    chart.ctx.fontManager.updateFonts(chartOptions.googleFonts);
    if (data != null) {
      chart.ctx.dataService.restoreData(data);
    }
    if (proxy == null) {
      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);
      proxy.releaseChart = poolResult?.release;
    } else if (poolResult || create) {
      proxy.releaseChart?.();
      proxy.chart = chart;
      proxy.releaseChart = poolResult?.release;
    }
    if (debug3.check() && typeof window !== "undefined") {
      window.agChartInstances ?? (window.agChartInstances = {});
      window.agChartInstances[chart.id] = chart;
    }
    chart.queuedUserOptions.push(chartOptions.userOptions);
    chart.queuedChartOptions.push(chartOptions);
    chart.requestFactoryUpdate((chartRef) => {
      debug3.group(">>>> Chart.applyOptions()", () => {
        chartRef.applyOptions(chartOptions);
        const queueIdx = chartRef.queuedUserOptions.indexOf(chartOptions.userOptions) + 1;
        chartRef.queuedUserOptions.splice(0, queueIdx);
        chartRef.queuedChartOptions.splice(0, queueIdx);
      });
    });
    return proxy;
  }
  static markRemovedProperties(node, _, modified = false) {
    if (typeof node !== "object")
      return modified;
    for (const key of Object.keys(node)) {
      const value = node[key];
      if (typeof value === "undefined") {
        Object.assign(node, { [key]: Symbol("UNSET") });
        modified || (modified = true);
      }
    }
    return modified;
  }
  static updateUserDelta(proxy, deltaOptions, apiStartTime) {
    deltaOptions = deepClone(deltaOptions, ChartOptions.OPTIONS_CLONE_OPTS_FAST);
    const stripSymbols = jsonWalk(
      deltaOptions,
      _AgChartsInternal.markRemovedProperties,
      /* @__PURE__ */ new Set(["data"]),
      void 0,
      void 0,
      false
    );
    debug3(() => [">>> AgCharts.updateUserDelta() user delta", deepClone(deltaOptions)]);
    _AgChartsInternal.createOrUpdate({
      proxy,
      deltaOptions,
      stripSymbols,
      apiStartTime
    });
  }
  static createChartInstance(options, oldChart) {
    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });
    const chartDef = moduleRegistry_exports.detectChartDefinition(options.processedOptions);
    return chartDef.create(options, transferableResource);
  }
  static getPool(optionMetadata) {
    if (optionMetadata.pool !== true)
      return;
    return Pool.getPool(
      optionMetadata.presetType ?? "default",
      this.createChartInstance,
      this.detachAndClear,
      this.destroy,
      Infinity
      // AG-13480 - Prevent Grid exhausting pool during sorting.
    );
  }
};
_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);
_AgChartsInternal.initialised = false;
_AgChartsInternal.callbackApi = {
  caretaker: _AgChartsInternal.caretaker,
  create(userOptions, processedOverrides, specialOverrides, optionsMetadata, data) {
    return _AgChartsInternal.createOrUpdate({
      userOptions,
      processedOverrides,
      specialOverrides,
      optionsMetadata,
      data
    });
  },
  update(opts, chart, specialOverrides, apiStartTime) {
    return _AgChartsInternal.createOrUpdate({
      userOptions: opts,
      proxy: chart,
      specialOverrides,
      apiStartTime
    });
  },
  updateUserDelta(chart, deltaOptions, apiStartTime) {
    return _AgChartsInternal.updateUserDelta(chart, deltaOptions, apiStartTime);
  }
};
_AgChartsInternal.detachAndClear = (chart) => chart.detachAndClear();
_AgChartsInternal.destroy = (chart) => chart.destroy();
var AgChartsInternal = _AgChartsInternal;

// packages/ag-charts-community/src/integrated-charts-scene.ts
var integrated_charts_scene_exports = {};
__export(integrated_charts_scene_exports, {
  Arc: () => Arc2,
  BBox: () => BBox,
  Caption: () => Caption,
  CategoryScale: () => CategoryScale,
  Group: () => Group,
  Line: () => Line,
  LinearScale: () => LinearScale,
  Marker: () => Marker,
  Path: () => Path,
  RadialColumnShape: () => RadialColumnShape,
  Rect: () => Rect,
  Scene: () => Scene,
  Sector: () => Sector,
  Shape: () => Shape,
  TranslatableGroup: () => TranslatableGroup,
  getRadialColumnWidth: () => getRadialColumnWidth,
  toRadians: () => toRadians
});

// packages/ag-charts-community/src/scene/shape/arc.ts
var Arc2 = class extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 10;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.counterClockwise = false;
    this.type = 0 /* Open */;
  }
  get fullPie() {
    return isNumberEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));
  }
  updatePath() {
    const path = this.path;
    path.clear();
    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
    if (this.type === 1 /* Chord */) {
      path.closePath();
    } else if (this.type === 2 /* Round */ && !this.fullPie) {
      path.lineTo(this.centerX, this.centerY);
      path.closePath();
    }
  }
  computeBBox() {
    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);
  }
  isPointInPath(x, y) {
    const bbox = this.getBBox();
    return this.type !== 0 /* Open */ && bbox.containsPoint(x, y) && this.path.isPointInPath(x, y);
  }
};
Arc2.className = "Arc";
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "centerX", 2);
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "centerY", 2);
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "radius", 2);
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "startAngle", 2);
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "endAngle", 2);
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "counterClockwise", 2);
__decorateClass([
  SceneChangeDetection()
], Arc2.prototype, "type", 2);

// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts
function rotatePoint(x, y, rotation) {
  const radius = Math.sqrt(x ** 2 + y ** 2);
  const angle2 = Math.atan2(y, x);
  const rotated = angle2 + rotation;
  return {
    x: Math.cos(rotated) * radius,
    y: Math.sin(rotated) * radius
  };
}
var RadialColumnShape = class extends Path {
  constructor() {
    super(...arguments);
    this.isBeveled = true;
    this.columnWidth = 0;
    this.startAngle = 0;
    this.endAngle = 0;
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.axisInnerRadius = 0;
    this.axisOuterRadius = 0;
    this.isRadiusAxisReversed = false;
  }
  set cornerRadius(_value) {
  }
  computeBBox() {
    const { innerRadius, outerRadius, columnWidth } = this;
    const rotation = this.getRotation();
    const left = -columnWidth / 2;
    const right = columnWidth / 2;
    const top = -outerRadius;
    const bottom = -innerRadius;
    let x0 = Infinity;
    let y0 = Infinity;
    let x1 = -Infinity;
    let y1 = -Infinity;
    for (let i = 0; i < 4; i += 1) {
      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);
      x0 = Math.min(x, x0);
      y0 = Math.min(y, y0);
      x1 = Math.max(x, x1);
      y1 = Math.max(y, y1);
    }
    return new BBox(x0, y0, x1 - x0, y1 - y0);
  }
  getRotation() {
    const { startAngle, endAngle } = this;
    const midAngle = angleBetween(startAngle, endAngle);
    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);
  }
  updatePath() {
    const { isBeveled } = this;
    if (isBeveled) {
      this.updateBeveledPath();
    } else {
      this.updateRectangularPath();
    }
    this.checkPathDirty();
  }
  updateRectangularPath() {
    const { columnWidth, innerRadius, outerRadius, path } = this;
    const left = -columnWidth / 2;
    const right = columnWidth / 2;
    const top = -outerRadius;
    const bottom = -innerRadius;
    const rotation = this.getRotation();
    const points = [
      [left, bottom],
      [left, top],
      [right, top],
      [right, bottom]
    ].map(([x, y]) => rotatePoint(x, y, rotation));
    path.clear(true);
    path.moveTo(points[0].x, points[0].y);
    path.lineTo(points[1].x, points[1].y);
    path.lineTo(points[2].x, points[2].y);
    path.lineTo(points[3].x, points[3].y);
    path.closePath();
  }
  updateBeveledPath() {
    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;
    const isStackBottom = isNumberEqual(innerRadius, axisInnerRadius);
    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);
    const pointRotation = this.getRotation();
    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);
    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);
    const getTriangleLeg = (hypotenuse, otherLeg) => {
      if (otherLeg > hypotenuse) {
        return 0;
      }
      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);
    };
    const compare = (value, otherValue, lessThan2) => lessThan2 ? value < otherValue : value > otherValue;
    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;
    let left = -columnWidth / 2;
    let right = columnWidth / 2;
    const top = -outerRadius;
    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);
    const hasBottomIntersection = compare(
      axisOuterRadius,
      getTriangleHypotenuse(innerRadius, columnWidth / 2),
      !isRadiusAxisReversed
    );
    if (hasBottomIntersection) {
      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);
      left = -bottomIntersectionX;
      right = bottomIntersectionX;
    }
    path.clear(true);
    const bottomLeftPt = rotate2(left, bottom);
    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);
    const isEmpty = isNumberEqual(innerRadius, outerRadius);
    const hasSideIntersection = compare(
      axisOuterRadius,
      getTriangleHypotenuse(outerRadius, columnWidth / 2),
      !isRadiusAxisReversed
    );
    if (isEmpty && shouldConnectBottomCircle) {
      path.arc(
        0,
        0,
        innerRadius,
        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,
        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,
        false
      );
    } else if (hasSideIntersection) {
      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);
      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);
      if (!hasBottomIntersection) {
        const topLeftPt = rotate2(left, sideIntersectionY);
        path.lineTo(topLeftPt.x, topLeftPt.y);
      }
      path.arc(
        0,
        0,
        axisOuterRadius,
        Math.atan2(sideIntersectionY, left) + pointRotation,
        Math.atan2(top, -topIntersectionX) + pointRotation,
        false
      );
      if (!isNumberEqual(topIntersectionX, 0)) {
        const topRightBevelPt = rotate2(topIntersectionX, top);
        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);
      }
      path.arc(
        0,
        0,
        axisOuterRadius,
        Math.atan2(top, topIntersectionX) + pointRotation,
        Math.atan2(sideIntersectionY, right) + pointRotation,
        false
      );
    } else {
      const topLeftPt = rotate2(left, top);
      const topRightPt = rotate2(right, top);
      path.lineTo(topLeftPt.x, topLeftPt.y);
      path.lineTo(topRightPt.x, topRightPt.y);
    }
    const bottomRightPt = rotate2(right, bottom);
    path.lineTo(bottomRightPt.x, bottomRightPt.y);
    if (shouldConnectBottomCircle) {
      path.arc(
        0,
        0,
        innerRadius,
        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,
        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,
        true
      );
    } else {
      const rotatedBottomLeftPt = rotate2(left, bottom);
      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);
    }
    path.closePath();
  }
};
RadialColumnShape.className = "RadialColumnShape";
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "isBeveled", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "columnWidth", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "startAngle", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "endAngle", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "outerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "innerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "axisInnerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "axisOuterRadius", 2);
__decorateClass([
  SceneChangeDetection()
], RadialColumnShape.prototype, "isRadiusAxisReversed", 2);
function getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {
  const rotation = angleBetween(startAngle, endAngle);
  const pad2 = rotation * (1 - columnWidthRatio) / 2;
  startAngle += pad2;
  endAngle -= pad2;
  if (rotation < 1e-3) {
    return 2 * axisOuterRadius * maxColumnWidthRatio;
  }
  if (rotation >= 2 * Math.PI) {
    const midAngle = startAngle + rotation / 2;
    startAngle = midAngle - Math.PI;
    endAngle = midAngle + Math.PI;
  }
  const startX = axisOuterRadius * Math.cos(startAngle);
  const startY = axisOuterRadius * Math.sin(startAngle);
  const endX = axisOuterRadius * Math.cos(endAngle);
  const endY = axisOuterRadius * Math.sin(endAngle);
  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));
  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;
  return Math.max(1, Math.min(maxWidth, colWidth));
}

// packages/ag-charts-community/src/integrated-charts-theme.ts
var integrated_charts_theme_exports = {};
__export(integrated_charts_theme_exports, {
  ChartTheme: () => ChartTheme,
  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,
  DEFAULT_ANNOTATION_STATISTICS_COLOR: () => DEFAULT_ANNOTATION_STATISTICS_COLOR,
  DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
  DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
  DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
  DEFAULT_ANNOTATION_STATISTICS_FILL: () => DEFAULT_ANNOTATION_STATISTICS_FILL,
  DEFAULT_ANNOTATION_STATISTICS_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_STROKE,
  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,
  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,
  DEFAULT_FIBONACCI_STROKES: () => DEFAULT_FIBONACCI_STROKES,
  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,
  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,
  DEFAULT_SEPARATION_LINES_COLOUR: () => DEFAULT_SEPARATION_LINES_COLOUR,
  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,
  DEFAULT_SPARKLINE_CROSSHAIR_STROKE: () => DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,
  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,
  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,
  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,
  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,
  IS_DARK_THEME: () => IS_DARK_THEME,
  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,
  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,
  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,
  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,
  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,
  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,
  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,
  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,
  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,
  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,
  PALETTE_UP_FILL: () => PALETTE_UP_FILL,
  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,
  getChartTheme: () => getChartTheme,
  resolveOperation: () => resolveOperation,
  themeNames: () => themeNames,
  themeSymbols: () => symbols_exports,
  themes: () => themes
});
var themeNames = Object.keys(themes);
function resolveOperation(operation) {
  const params = ChartTheme.getDefaultPublicParameters();
  const palette = ChartTheme.getDefaultColors();
  const graph = new OptionsGraph({ line: { operation } }, { series: [{ type: "line" }] }, params, palette);
  const resolved = graph.resolve();
  return resolved.operation;
}

// packages/ag-charts-community/src/integrated-charts-util.ts
var integrated_charts_util_exports = {};
__export(integrated_charts_util_exports, {
  Color: () => Color,
  interpolateColor: () => interpolateColor
});

// packages/ag-charts-community/src/util/time-interop.ts
function createTimeInterval(unit, step, epoch, utc) {
  return {
    unit,
    step,
    epoch,
    utc,
    every(count) {
      return createTimeInterval(this.unit, (this.step ?? 1) * count, this.epoch, this.utc);
    }
  };
}
var cachedInstances = {};
function getTimeInterval(unit, step = 1, epoch, utc = false) {
  logger_exports.warnOnce("time import is deprecated, use object notation instead");
  const key = `${unit}:${step}:${epoch?.getTime() ?? 0}:${utc}`;
  let instance = cachedInstances[key];
  if (instance == null) {
    instance = createTimeInterval(unit, step, epoch, utc);
    cachedInstances[key] = instance;
  }
  return instance;
}
var time2 = {
  get millisecond() {
    return getTimeInterval("millisecond");
  },
  get second() {
    return getTimeInterval("second");
  },
  get minute() {
    return getTimeInterval("minute");
  },
  get hour() {
    return getTimeInterval("hour");
  },
  get day() {
    return getTimeInterval("day");
  },
  get monday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 5));
  },
  get tuesday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 6));
  },
  get wednesday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 7));
  },
  get thursday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 1));
  },
  get friday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 2));
  },
  get saturday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 3));
  },
  get sunday() {
    return getTimeInterval("day", 7, new Date(1970, 0, 4));
  },
  get month() {
    return getTimeInterval("month");
  },
  get year() {
    return getTimeInterval("year");
  },
  get utcMillisecond() {
    return getTimeInterval("millisecond", 1, void 0, true);
  },
  get utcSecond() {
    return getTimeInterval("second", 1, void 0, true);
  },
  get utcMinute() {
    return getTimeInterval("minute", 1, void 0, true);
  },
  get utcHour() {
    return getTimeInterval("hour", 1, void 0, true);
  },
  get utcDay() {
    return getTimeInterval("day", 1, void 0, true);
  },
  get utcMonth() {
    return getTimeInterval("month", 1, void 0, true);
  },
  get utcYear() {
    return getTimeInterval("year", 1, void 0, true);
  }
};

// packages/ag-charts-community/src/module-support.ts
var module_support_exports = {};
__export(module_support_exports, {
  AGGREGATION_INDEX_X_MAX: () => AGGREGATION_INDEX_X_MAX,
  AGGREGATION_INDEX_X_MIN: () => AGGREGATION_INDEX_X_MIN,
  AGGREGATION_INDEX_Y_MAX: () => AGGREGATION_INDEX_Y_MAX,
  AGGREGATION_INDEX_Y_MIN: () => AGGREGATION_INDEX_Y_MIN,
  AGGREGATION_SPAN: () => AGGREGATION_SPAN,
  AbstractBarSeries: () => AbstractBarSeries,
  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,
  ActionOnSet: () => ActionOnSet,
  AnchoredPopover: () => AnchoredPopover,
  Animation: () => Animation,
  AnimationManager: () => AnimationManager,
  Arc: () => Arc2,
  Axis: () => Axis,
  AxisGroupZIndexMap: () => AxisGroupZIndexMap,
  AxisInterval: () => AxisInterval,
  AxisLabel: () => AxisLabel,
  AxisTick: () => AxisTick,
  AxisTickGenerator: () => AxisTickGenerator,
  BASE_FONT_SIZE: () => BASE_FONT_SIZE,
  BBox: () => BBox,
  Background: () => Background,
  BackgroundModule: () => BackgroundModule,
  BandScale: () => BandScale,
  BarSeries: () => BarSeries,
  BarSeriesModule: () => BarSeriesModule,
  BaseModuleInstance: () => BaseModuleInstance,
  BaseProperties: () => BaseProperties,
  BaseToolbar: () => BaseToolbar,
  Border: () => Border,
  ButtonWidget: () => ButtonWidget,
  CachedTextMeasurer: () => CachedTextMeasurer,
  CachedTextMeasurerPool: () => CachedTextMeasurerPool,
  CallbackCache: () => CallbackCache,
  Caption: () => Caption,
  CartesianAxis: () => CartesianAxis,
  CartesianSeries: () => CartesianSeries,
  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,
  CartesianSeriesProperties: () => CartesianSeriesProperties,
  CategoryAxis: () => CategoryAxis,
  CategoryScale: () => CategoryScale,
  ChangeDetectableProperties: () => ChangeDetectableProperties,
  Chart: () => Chart,
  ChartAxisDirection: () => ChartAxisDirection,
  ChartOptions: () => ChartOptions,
  ChartUpdateType: () => ChartUpdateType,
  CollapseMode: () => CollapseMode,
  Color: () => Color,
  ColorScale: () => ColorScale,
  ConicGradient: () => ConicGradient,
  ContextMenuBuiltins: () => ContextMenuBuiltins,
  ContextMenuRegistry: () => ContextMenuRegistry,
  ContinuousScale: () => ContinuousScale,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,
  DEFAULT_POLAR_DIRECTION_KEYS: () => DEFAULT_POLAR_DIRECTION_KEYS,
  DEFAULT_POLAR_DIRECTION_NAMES: () => DEFAULT_POLAR_DIRECTION_NAMES,
  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,
  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,
  DIRECTION_SWAP_AXES: () => DIRECTION_SWAP_AXES,
  DOMManager: () => DOMManager,
  DataController: () => DataController,
  DataModel: () => DataModel,
  DataModelSeries: () => DataModelSeries,
  DataService: () => DataService,
  Debug: () => Debug,
  Deprecated: () => Deprecated,
  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,
  DiscreteTimeAxis: () => DiscreteTimeAxis,
  DiscreteTimeScale: () => DiscreteTimeScale,
  DragInterpreter: () => DragInterpreter,
  DraggablePopover: () => DraggablePopover,
  DropShadow: () => DropShadow,
  ExtendedPath2D: () => ExtendedPath2D,
  FILL_GRADIENT_CONIC_DEFAULTS: () => FILL_GRADIENT_CONIC_DEFAULTS,
  FILL_GRADIENT_LINEAR_DEFAULTS: () => FILL_GRADIENT_LINEAR_DEFAULTS,
  FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS: () => FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS,
  FILL_GRADIENT_LINEAR_SHADED_DEFAULTS: () => FILL_GRADIENT_LINEAR_SHADED_DEFAULTS,
  FILL_GRADIENT_RADIAL_DEFAULTS: () => FILL_GRADIENT_RADIAL_DEFAULTS,
  FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS: () => FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
  FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS: () => FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS,
  FILL_GRADIENT_RADIAL_SERIES_DEFAULTS: () => FILL_GRADIENT_RADIAL_SERIES_DEFAULTS,
  FILL_IMAGE_DEFAULTS: () => FILL_IMAGE_DEFAULTS,
  FILL_PATTERN_DEFAULTS: () => FILL_PATTERN_DEFAULTS,
  FILL_PATTERN_HIERARCHY_DEFAULTS: () => FILL_PATTERN_HIERARCHY_DEFAULTS,
  FONT_SIZE: () => FONT_SIZE,
  FONT_SIZE_RATIO: () => FONT_SIZE_RATIO,
  FillGradientDefaults: () => FillGradientDefaults,
  FillImageDefaults: () => FillImageDefaults,
  FillPatternDefaults: () => FillPatternDefaults,
  FloatingToolbar: () => FloatingToolbar,
  FormatManager: () => FormatManager,
  Gradient: () => Gradient,
  Group: () => Group,
  GroupedCategoryAxis: () => GroupedCategoryAxis,
  HdpiCanvas: () => HdpiCanvas,
  HierarchyNode: () => HierarchyNode,
  HierarchySeries: () => HierarchySeries,
  HierarchySeriesProperties: () => HierarchySeriesProperties,
  HighlightManager: () => HighlightManager,
  HighlightProperties: () => HighlightProperties,
  HighlightState: () => HighlightState,
  HighlightStyle: () => HighlightStyle,
  Image: () => Image3,
  InteractionManager: () => InteractionManager,
  InteractionState: () => InteractionState,
  InterpolationProperties: () => InterpolationProperties,
  Invalidating: () => Invalidating,
  LABEL_BOXING_DEFAULTS: () => LABEL_BOXING_DEFAULTS,
  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,
  LEGEND_CONTAINER_THEME: () => LEGEND_CONTAINER_THEME,
  Label: () => Label,
  LayoutElement: () => LayoutElement,
  LayoutManager: () => LayoutManager,
  LegendMarkerLabel: () => LegendMarkerLabel,
  Line: () => Line,
  LineSeries: () => LineSeries,
  LineSeriesModule: () => LineSeriesModule,
  LinearGradient: () => LinearGradient,
  LinearScale: () => LinearScale,
  LogScale: () => LogScale,
  LonLatBBox: () => LonLatBBox,
  Marker: () => Marker,
  Menu: () => Menu,
  MenuItemWidget: () => MenuItemWidget,
  MenuWidget: () => MenuWidget,
  MercatorScale: () => MercatorScale,
  ModuleRegistry: () => moduleRegistry_exports,
  Motion: () => easing_exports,
  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,
  NativeWidget: () => NativeWidget,
  NewAreaSeriesModule: () => NewAreaSeriesModule,
  NewBarSeriesModule: () => NewBarSeriesModule,
  NewBubbleSeriesModule: () => NewBubbleSeriesModule,
  NewHistogramSeriesModule: () => NewHistogramSeriesModule,
  NewLineSeriesModule: () => NewLineSeriesModule,
  NewScatterSeriesModule: () => NewScatterSeriesModule,
  NiceMode: () => NiceMode,
  Node: () => Node2,
  NumberAxis: () => NumberAxis,
  ObserveChanges: () => ObserveChanges,
  OrdinalTimeScale: () => OrdinalTimeScale,
  PHASE_METADATA: () => PHASE_METADATA,
  PHASE_ORDER: () => PHASE_ORDER,
  PREV_NEXT_KEYS: () => PREV_NEXT_KEYS,
  Padding: () => Padding,
  ParallelStateMachine: () => ParallelStateMachine,
  Path: () => Path,
  PointerEvents: () => PointerEvents,
  PolarAxis: () => PolarAxis,
  PolarSeries: () => PolarSeries,
  PolarZIndexMap: () => PolarZIndexMap,
  Popover: () => Popover,
  PropertiesArray: () => PropertiesArray,
  Property: () => Property,
  ProxyInteractionService: () => ProxyInteractionService,
  ProxyOnWrite: () => ProxyOnWrite,
  ProxyProperty: () => ProxyProperty,
  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,
  QUICK_TRANSITION: () => QUICK_TRANSITION,
  QuadtreeNearest: () => QuadtreeNearest,
  RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD: () => RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD,
  RadialColumnShape: () => RadialColumnShape,
  Range: () => Range,
  Rect: () => Rect,
  RepeatType: () => RepeatType,
  Rotatable: () => Rotatable,
  RotatableGroup: () => RotatableGroup,
  RotatableText: () => RotatableText,
  SAFE_FILLS_OPERATION: () => SAFE_FILLS_OPERATION,
  SAFE_FILL_OPERATION: () => SAFE_FILL_OPERATION,
  SAFE_RANGE2_OPERATION: () => SAFE_RANGE2_OPERATION,
  SAFE_STROKE_FILL_OPERATION: () => SAFE_STROKE_FILL_OPERATION,
  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,
  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,
  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,
  Scalable: () => Scalable,
  ScalableGroup: () => ScalableGroup,
  ScaleAlignment: () => ScaleAlignment,
  Scene: () => Scene,
  SceneArrayChangeDetection: () => SceneArrayChangeDetection,
  SceneChangeDetection: () => SceneChangeDetection,
  SceneObjectChangeDetection: () => SceneObjectChangeDetection,
  SceneRefChangeDetection: () => SceneRefChangeDetection,
  Sector: () => Sector,
  SectorBox: () => SectorBox,
  Selection: () => Selection,
  Series: () => Series,
  SeriesContentZIndexMap: () => SeriesContentZIndexMap,
  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,
  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,
  SeriesMarker: () => SeriesMarker,
  SeriesNodeEvent: () => SeriesNodeEvent,
  SeriesNodePickMode: () => SeriesNodePickMode,
  SeriesProperties: () => SeriesProperties,
  SeriesTooltip: () => SeriesTooltip,
  SeriesZIndexMap: () => SeriesZIndexMap,
  Shape: () => Shape,
  SimpleTextMeasurer: () => SimpleTextMeasurer,
  SliderWidget: () => SliderWidget,
  StateMachine: () => StateMachine,
  StateMachineProperty: () => StateMachineProperty,
  StopProperties: () => StopProperties,
  SvgPath: () => SvgPath,
  TRIPLE_EQ: () => TRIPLE_EQ,
  Text: () => Text,
  TextUtils: () => TextUtils,
  TextWrapper: () => TextWrapper,
  ThemeConstants: () => constants_exports,
  ThemeSymbols: () => symbols_exports,
  TimeAxisParentLevel: () => TimeAxisParentLevel,
  TimeScale: () => TimeScale,
  Toolbar: () => Toolbar,
  ToolbarButtonProperties: () => ToolbarButtonProperties,
  ToolbarButtonWidget: () => ToolbarButtonWidget,
  ToolbarWidget: () => ToolbarWidget,
  Tooltip: () => Tooltip,
  TooltipManager: () => TooltipManager,
  TooltipPosition: () => TooltipPosition,
  Transformable: () => Transformable,
  TransformableGroup: () => TransformableGroup,
  TransformableText: () => TransformableText,
  Translatable: () => Translatable,
  TranslatableGroup: () => TranslatableGroup,
  TranslatableSvgPath: () => TranslatableSvgPath,
  UnitTimeScale: () => UnitTimeScale,
  UpdateService: () => UpdateService,
  Vec2: () => Vec2,
  Vec4: () => Vec4,
  WIDGET_HTML_EVENTS: () => WIDGET_HTML_EVENTS,
  Widget: () => Widget,
  WidgetEventUtil: () => WidgetEventUtil,
  ZIndexMap: () => ZIndexMap,
  ZoomManager: () => ZoomManager,
  accumulateGroup: () => accumulateGroup,
  accumulateStack: () => accumulateStack,
  accumulatedValue: () => accumulatedValue,
  accumulativeValueProperty: () => accumulativeValueProperty,
  addEscapeEventListener: () => addEscapeEventListener,
  addHitTestersToQuadtree: () => addHitTestersToQuadtree,
  addMouseCloseListener: () => addMouseCloseListener,
  addOverrideFocusVisibleEventListener: () => addOverrideFocusVisibleEventListener,
  addTouchCloseListener: () => addTouchCloseListener,
  adjustLabelPlacement: () => adjustLabelPlacement,
  aggregationDomain: () => aggregationDomain,
  aggregationIndexForXRatio: () => aggregationIndexForXRatio,
  aggregationRangeFittingPoints: () => aggregationRangeFittingPoints,
  aggregationXRatioForDatumIndex: () => aggregationXRatioForDatumIndex,
  aggregationXRatioForXValue: () => aggregationXRatioForXValue,
  angleBetween: () => angleBetween,
  angleCategoryAxisOptionsDefs: () => angleCategoryAxisOptionsDefs,
  angleNumberAxisOptionsDefs: () => angleNumberAxisOptionsDefs,
  angularPadding: () => angularPadding,
  animationValidation: () => animationValidation,
  annotationCalloutStylesDefs: () => annotationCalloutStylesDefs,
  annotationChannelStyleDefs: () => annotationChannelStyleDefs,
  annotationChannelTextDefs: () => annotationChannelTextDefs,
  annotationCommentStylesDefs: () => annotationCommentStylesDefs,
  annotationCrossLineStyleDefs: () => annotationCrossLineStyleDefs,
  annotationDisjointChannelStyleDefs: () => annotationDisjointChannelStyleDefs,
  annotationFibonacciStylesDefs: () => annotationFibonacciStylesDefs,
  annotationLineStyleDefs: () => annotationLineStyleDefs,
  annotationLineTextDefs: () => annotationLineTextDefs,
  annotationMeasurerStylesDefs: () => annotationMeasurerStylesDefs,
  annotationNoteStylesDefs: () => annotationNoteStylesDefs,
  annotationOptionsDef: () => annotationOptionsDef,
  annotationParallelChannelStyleDefs: () => annotationParallelChannelStyleDefs,
  annotationQuickMeasurerStylesDefs: () => annotationQuickMeasurerStylesDefs,
  annotationShapeStylesDefs: () => annotationShapeStylesDefs,
  annotationTextStylesDef: () => annotationTextStylesDef,
  applyShapeFillBBox: () => applyShapeFillBBox,
  applyShapeStyle: () => applyShapeStyle,
  areScalingEqual: () => areScalingEqual,
  area: () => area,
  autoSizedLabelOptionsDefs: () => autoSizedLabelOptionsDefs,
  bezier2DDistance: () => bezier2DDistance,
  bezier2DExtrema: () => bezier2DExtrema,
  boxPlotHighlightStyleOptionsDef: () => boxPlotHighlightStyleOptionsDef,
  boxPlotSeriesThemeableOptionsDef: () => boxPlotSeriesThemeableOptionsDef,
  boxPlotStyleOptionsDef: () => boxPlotStyleOptionsDef,
  buildDateFormatter: () => buildDateFormatter,
  buildResetPathFn: () => buildResetPathFn,
  calculateDataDiff: () => calculateDataDiff,
  calculateLabelTranslation: () => calculateLabelTranslation,
  calculatePlacement: () => calculatePlacement,
  callWithContext: () => callWithContext,
  candlestickSeriesThemeableOptionsDef: () => candlestickSeriesThemeableOptionsDef,
  cartesianAxisBandHighlightOptions: () => cartesianAxisBandHighlightOptions,
  cartesianAxisCrosshairOptions: () => cartesianAxisCrosshairOptions,
  cartesianAxisLabelOptionsDefs: () => cartesianAxisLabelOptionsDefs,
  cartesianAxisOptionsDefs: () => cartesianAxisOptionsDefs,
  cartesianChartOptionsDefs: () => cartesianChartOptionsDefs,
  cartesianCrossLineOptionsDefs: () => cartesianCrossLineOptionsDefs,
  cartesianNumericAxisLabel: () => cartesianNumericAxisLabel,
  cartesianTimeAxisLabel: () => cartesianTimeAxisLabel,
  cartesianTimeAxisParentLevel: () => cartesianTimeAxisParentLevel,
  checkCrisp: () => checkCrisp,
  chordSeriesThemeableOptionsDef: () => chordSeriesThemeableOptionsDef,
  clampArray: () => clampArray,
  clippedRoundRect: () => clippedRoundRect,
  collapsedStartingBarPosition: () => collapsedStartingBarPosition,
  commonAxisIntervalOptionsDefs: () => commonAxisIntervalOptionsDefs,
  commonAxisLabelOptionsDefs: () => commonAxisLabelOptionsDefs,
  commonAxisOptionsDefs: () => commonAxisOptionsDefs,
  commonChartOptionsDefs: () => commonChartOptionsDefs,
  commonCrossLineLabelOptionsDefs: () => commonCrossLineLabelOptionsDefs,
  commonCrossLineOptionsDefs: () => commonCrossLineOptionsDefs,
  commonSeriesOptionsDefs: () => commonSeriesOptionsDefs,
  commonSeriesThemeableOptionsDefs: () => commonSeriesThemeableOptionsDefs,
  compactAggregationIndices: () => compactAggregationIndices,
  compareDates: () => compareDates,
  computeBarFocusBounds: () => computeBarFocusBounds,
  computeMarkerFocusBounds: () => computeMarkerFocusBounds,
  coneFunnelSeriesThemeableOptionsDef: () => coneFunnelSeriesThemeableOptionsDef,
  continuousAxisOptions: () => continuousAxisOptions,
  countExpandingSearch: () => countExpandingSearch,
  createAggregationIndices: () => createAggregationIndices,
  createButton: () => createButton,
  createCheckbox: () => createCheckbox,
  createDatumId: () => createDatumId,
  createDeprecationWarning: () => createDeprecationWarning,
  createIcon: () => createIcon,
  createIdsGenerator: () => createIdsGenerator,
  createSelect: () => createSelect,
  createTextArea: () => createTextArea,
  dateToNumber: () => dateToNumber,
  dateTruncationForDomain: () => dateTruncationForDomain,
  datesSortOrder: () => datesSortOrder,
  datumKeys: () => datumKeys,
  datumStylerProperties: () => datumStylerProperties,
  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,
  deepClone: () => deepClone,
  deepFreeze: () => deepFreeze,
  diff: () => diff,
  discreteTimeAxisIntervalOptionsDefs: () => discreteTimeAxisIntervalOptionsDefs,
  drawCorner: () => drawCorner,
  drawMarkerUnitPolygon: () => drawMarkerUnitPolygon,
  durationDay: () => durationDay,
  durationHour: () => durationHour,
  durationMinute: () => durationMinute,
  durationMonth: () => durationMonth,
  durationSecond: () => durationSecond,
  durationWeek: () => durationWeek,
  durationYear: () => durationYear,
  easing: () => easing_exports,
  enterpriseModule: () => enterpriseModule,
  errorBarOptionsDefs: () => errorBarOptionsDefs,
  errorBarThemeableOptionsDefs: () => errorBarThemeableOptionsDefs,
  estimateTickCount: () => estimateTickCount,
  evaluateBezier: () => evaluateBezier,
  expandLegendPosition: () => expandLegendPosition,
  extent: () => extent,
  extractDecoratedProperties: () => extractDecoratedProperties,
  fillsOptionsDef: () => fillsOptionsDef,
  findMinMax: () => findMinMax,
  findQuadtreeMatch: () => findQuadtreeMatch,
  findRangeExtent: () => findRangeExtent,
  fixNumericExtent: () => fixNumericExtent,
  focusCursorAtEnd: () => focusCursorAtEnd,
  formatNumber: () => formatNumber,
  formatObjectValidator: () => formatObjectValidator,
  formatPercent: () => formatPercent,
  formatValue: () => formatValue,
  fromToMotion: () => fromToMotion,
  funnelSeriesThemeableOptionsDef: () => funnelSeriesThemeableOptionsDef,
  getAngleRatioRadians: () => getAngleRatioRadians,
  getColorStops: () => getColorStops,
  getCrossLineValue: () => getCrossLineValue,
  getDateTicksForInterval: () => getDateTicksForInterval,
  getDatumRefPoint: () => getDatumRefPoint,
  getElementBBox: () => getElementBBox,
  getIconClassNames: () => getIconClassNames,
  getLabelStyles: () => getLabelStyles,
  getLastFocus: () => getLastFocus,
  getMissCount: () => getMissCount,
  getPath: () => getPath,
  getPathComponents: () => getPathComponents,
  getRadialColumnWidth: () => getRadialColumnWidth,
  getSequentialColors: () => getSequentialColors,
  getShapeFill: () => getShapeFill,
  getShapeStyle: () => getShapeStyle,
  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,
  groupAverage: () => groupAverage,
  groupCount: () => groupCount,
  groupStackValueProperty: () => groupStackValueProperty,
  groupSum: () => groupSum,
  hasNoModifiers: () => hasNoModifiers,
  heatmapSeriesThemeableOptionsDef: () => heatmapSeriesThemeableOptionsDef,
  initMenuKeyNav: () => initMenuKeyNav,
  initRovingTabIndex: () => initRovingTabIndex,
  interpolatePoints: () => interpolatePoints,
  interpolationOptionsDefs: () => interpolationOptionsDefs,
  intervalCeil: () => intervalCeil,
  intervalEpoch: () => intervalEpoch,
  intervalExtent: () => intervalExtent,
  intervalFloor: () => intervalFloor,
  intervalHierarchy: () => intervalHierarchy,
  intervalMilliseconds: () => intervalMilliseconds,
  intervalNext: () => intervalNext,
  intervalPrevious: () => intervalPrevious,
  intervalRange: () => intervalRange,
  intervalRangeCount: () => intervalRangeCount,
  intervalRangeStartIndex: () => intervalRangeStartIndex,
  intervalStep: () => intervalStep,
  intervalUnit: () => intervalUnit,
  isAgStandaloneChartOptions: () => isAgStandaloneChartOptions,
  isAgTopologyChartOptions: () => isAgTopologyChartOptions,
  isBetweenAngles: () => isBetweenAngles,
  isButtonClickEvent: () => isButtonClickEvent,
  isChartAxisDirection: () => isChartAxisDirection,
  isContinuous: () => isContinuous,
  isDecoratedObject: () => isDecoratedObject,
  isDenseInterval: () => isDenseInterval,
  isGradientFill: () => isGradientFill,
  isGradientOrPatternFill: () => isGradientOrPatternFill,
  isImageFill: () => isImageFill,
  isInputPending: () => isInputPending,
  isObjectWithProperty: () => isObjectWithProperty,
  isObjectWithStringProperty: () => isObjectWithStringProperty,
  isPatternFill: () => isPatternFill,
  isProperties: () => isProperties,
  isScaleValid: () => isScaleValid,
  jsonApply: () => jsonApply,
  jsonDiff: () => jsonDiff,
  jsonPropertyCompare: () => jsonPropertyCompare,
  jsonWalk: () => jsonWalk,
  keyProperty: () => keyProperty,
  legendSymbolSvg: () => legendSymbolSvg,
  lineDistanceSquared: () => lineDistanceSquared,
  linearGaugeSeriesOptionsDef: () => linearGaugeSeriesOptionsDef,
  linearGaugeSeriesThemeableOptionsDef: () => linearGaugeSeriesThemeableOptionsDef,
  linearGaugeTargetOptionsDef: () => linearGaugeTargetOptionsDef,
  listDecoratedProperties: () => listDecoratedProperties,
  lowestGranularityForInterval: () => lowestGranularityForInterval,
  lowestGranularityUnitForTicks: () => lowestGranularityUnitForTicks,
  lowestGranularityUnitForValue: () => lowestGranularityUnitForValue,
  makeAccessibleClickListener: () => makeAccessibleClickListener,
  makeSeriesTooltip: () => makeSeriesTooltip,
  mapLineBackgroundSeriesThemeableOptionsDef: () => mapLineBackgroundSeriesThemeableOptionsDef,
  mapLineSeriesThemeableOptionsDef: () => mapLineSeriesThemeableOptionsDef,
  mapMarkerSeriesThemeableOptionsDef: () => mapMarkerSeriesThemeableOptionsDef,
  mapShapeBackgroundSeriesThemeableOptionsDef: () => mapShapeBackgroundSeriesThemeableOptionsDef,
  mapShapeSeriesThemeableOptionsDef: () => mapShapeSeriesThemeableOptionsDef,
  mapValues: () => mapValues,
  markerFadeInAnimation: () => markerFadeInAnimation,
  markerOptionsDefs: () => markerOptionsDefs,
  markerScaleInAnimation: () => markerScaleInAnimation,
  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,
  memo: () => memo,
  merge: () => merge,
  mergeArrayDefaults: () => mergeArrayDefaults,
  mergeDefaults: () => mergeDefaults,
  midpointStartingBarPosition: () => midpointStartingBarPosition,
  minimumTimeAxisDatumGranularity: () => minimumTimeAxisDatumGranularity,
  moduleRegistry: () => moduleRegistry,
  motion: () => motion,
  multiSeriesHighlightStyle: () => multiSeriesHighlightStyle,
  nearestSquared: () => nearestSquared,
  nearestSquaredInContainer: () => nearestSquaredInContainer,
  nextPowerOf2: () => nextPowerOf2,
  nightingaleSeriesThemeableOptionsDef: () => nightingaleSeriesThemeableOptionsDef,
  normaliseGroupTo: () => normaliseGroupTo,
  normalisePropertyTo: () => normalisePropertyTo,
  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,
  normalizeAngle180: () => normalizeAngle180,
  normalizeAngle360: () => normalizeAngle360,
  normalizeAngle360FromDegrees: () => normalizeAngle360FromDegrees,
  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,
  normalizeContinuousDomains: () => normalizeContinuousDomains,
  numberFormatValidator: () => numberFormatValidator,
  objectsEqual: () => objectsEqual,
  objectsEqualWith: () => objectsEqualWith,
  ohlcSeriesThemeableOptionsDef: () => ohlcSeriesThemeableOptionsDef,
  ordinalTimeAxisOptionsDefs: () => ordinalTimeAxisOptionsDefs,
  pairUpSpans: () => pairUpSpans,
  partialAssign: () => partialAssign,
  pathFadeInAnimation: () => pathFadeInAnimation,
  pathMotion: () => pathMotion,
  pathSwipeInAnimation: () => pathSwipeInAnimation,
  pick: () => pick,
  pickByMatchingAngle: () => pickByMatchingAngle,
  plotAreaPathFill: () => plotAreaPathFill,
  plotInterpolatedAreaSeriesFillSpans: () => plotInterpolatedAreaSeriesFillSpans,
  plotInterpolatedLinePathStroke: () => plotInterpolatedLinePathStroke,
  plotLinePathStroke: () => plotLinePathStroke,
  pointsEq: () => pointsEq,
  polarChartOptionsDefs: () => polarChartOptionsDefs,
  prepareAreaFillAnimationFns: () => prepareAreaFillAnimationFns,
  prepareAreaPathAnimation: () => prepareAreaPathAnimation,
  prepareAxisAnimationContext: () => prepareAxisAnimationContext,
  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,
  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,
  prepareLinePathAnimation: () => prepareLinePathAnimation,
  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,
  prepareLinePathStrokeAnimationFns: () => prepareLinePathStrokeAnimationFns,
  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,
  previousPowerOf2: () => previousPowerOf2,
  processedDataIsAnimatable: () => processedDataIsAnimatable,
  pyramidSeriesThemeableOptionsDef: () => pyramidSeriesThemeableOptionsDef,
  radarAreaSeriesThemeableOptionsDef: () => radarAreaSeriesThemeableOptionsDef,
  radarLineSeriesThemeableOptionsDef: () => radarLineSeriesThemeableOptionsDef,
  radialBarSeriesThemeableOptionsDef: () => radialBarSeriesThemeableOptionsDef,
  radialColumnSeriesThemeableOptionsDef: () => radialColumnSeriesThemeableOptionsDef,
  radialGaugeSeriesOptionsDef: () => radialGaugeSeriesOptionsDef,
  radialGaugeSeriesThemeableOptionsDef: () => radialGaugeSeriesThemeableOptionsDef,
  radialGaugeTargetOptionsDef: () => radialGaugeTargetOptionsDef,
  radiusCategoryAxisOptionsDefs: () => radiusCategoryAxisOptionsDefs,
  radiusNumberAxisOptionsDefs: () => radiusNumberAxisOptionsDefs,
  range: () => range,
  rangeAreaSeriesThemeableOptionsDef: () => rangeAreaSeriesThemeableOptionsDef,
  rangeBarSeriesThemeableOptionsDef: () => rangeBarSeriesThemeableOptionsDef,
  rangeValidator: () => rangeValidator2,
  rangedValueProperty: () => rangedValueProperty,
  resetAxisFillSelectionFn: () => resetAxisFillSelectionFn,
  resetAxisGroupFn: () => resetAxisGroupFn,
  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,
  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,
  resetBarSelectionsFn: () => resetBarSelectionsFn,
  resetLabelFn: () => resetLabelFn,
  resetMarkerFn: () => resetMarkerFn,
  resetMarkerPositionFn: () => resetMarkerPositionFn,
  resetMotion: () => resetMotion,
  resetPieSelectionsFn: () => resetPieSelectionsFn,
  rowCountProperty: () => rowCountProperty,
  sankeySeriesThemeableOptionsDef: () => sankeySeriesThemeableOptionsDef,
  scale: () => scale,
  sectorBox: () => sectorBox,
  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,
  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,
  seriesLabelOptionsDefs: () => seriesLabelOptionsDefs,
  setElementBBox: () => setElementBBox,
  setPath: () => setPath,
  shadowOptionsDefs: () => shadowOptionsDefs,
  shallowClone: () => shallowClone,
  simpleMemorize: () => simpleMemorize,
  simpleMemorize2: () => simpleMemorize2,
  singleSeriesHighlightStyle: () => singleSeriesHighlightStyle,
  solveBezier: () => solveBezier,
  sortAndUniqueDates: () => sortAndUniqueDates,
  splitBezier2D: () => splitBezier2D,
  standaloneChartOptionsDefs: () => standaloneChartOptionsDefs,
  staticFromToMotion: () => staticFromToMotion,
  stopPageScrolling: () => stopPageScrolling,
  sum: () => sum,
  sumValues: () => sumValues,
  sunburstSeriesThemeableOptionsDef: () => sunburstSeriesThemeableOptionsDef,
  textOrSegments: () => textOrSegments,
  tickFormat: () => tickFormat,
  timeInterval: () => timeInterval2,
  timeIntervalUnit: () => timeIntervalUnit,
  toDegrees: () => toDegrees,
  toRadians: () => toRadians,
  toolbarButtonOptionsDefs: () => toolbarButtonOptionsDefs,
  tooltipContentAriaLabel: () => tooltipContentAriaLabel,
  tooltipHtml: () => tooltipHtml,
  tooltipOptionsDefs: () => tooltipOptionsDefs,
  topologyChartOptionsDefs: () => topologyChartOptionsDefs,
  trailingAccumulatedValue: () => trailingAccumulatedValue,
  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,
  treemapSeriesThemeableOptionsDef: () => treemapSeriesThemeableOptionsDef,
  updateClipPath: () => updateClipPath,
  updateLabelNode: () => updateLabelNode,
  validateCrossLineValue: () => validateCrossLineValue,
  valueProperty: () => valueProperty,
  visibleRangeIndices: () => visibleRangeIndices,
  waterfallSeriesThemeableOptionsDef: () => waterfallSeriesThemeableOptionsDef,
  without: () => without
});

// packages/ag-charts-community/src/util/deprecation.ts
function createDeprecationWarning() {
  return (key, message) => {
    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(" ");
    logger_exports.warnOnce(msg);
  };
}
function Deprecated(message, opts) {
  const warnDeprecated = createDeprecationWarning();
  const def = opts?.default;
  return addTransformToInstanceProperty((_, key, value) => {
    if (value !== def) {
      warnDeprecated(key.toString(), message);
    }
    return value;
  });
}
function DeprecatedAndRenamedTo(newPropName, mapValue) {
  const warnDeprecated = createDeprecationWarning();
  return addTransformToInstanceProperty(
    (target, key, value) => {
      if (value !== target[newPropName]) {
        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
        setPath(target, newPropName, mapValue ? mapValue(value) : value);
      }
      return BREAK_TRANSFORM_CHAIN;
    },
    (target, key) => {
      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
      return getPath(target, newPropName);
    }
  );
}

// packages/ag-charts-community/src/util/vector.ts
var Vec2 = {
  add,
  angle,
  apply,
  equal,
  distance,
  distanceSquared,
  from: from2,
  gradient,
  intercept,
  intersectAtX,
  intersectAtY,
  length,
  lengthSquared,
  multiply,
  normalized,
  origin: origin2,
  required: required2,
  rotate,
  round: round2,
  sub
};
function add(a, b) {
  if (typeof b === "number") {
    return { x: a.x + b, y: a.y + b };
  }
  return { x: a.x + b.x, y: a.y + b.y };
}
function sub(a, b) {
  if (typeof b === "number") {
    return { x: a.x - b, y: a.y - b };
  }
  return { x: a.x - b.x, y: a.y - b.y };
}
function multiply(a, b) {
  if (typeof b === "number") {
    return { x: a.x * b, y: a.y * b };
  }
  return { x: a.x * b.x, y: a.y * b.y };
}
function length(a) {
  return Math.sqrt(a.x * a.x + a.y * a.y);
}
function lengthSquared(a) {
  return a.x * a.x + a.y * a.y;
}
function distance(a, b) {
  const d = sub(a, b);
  return Math.sqrt(d.x * d.x + d.y * d.y);
}
function distanceSquared(a, b) {
  const d = sub(a, b);
  return d.x * d.x + d.y * d.y;
}
function normalized(a) {
  const l = length(a);
  return { x: a.x / l, y: a.y / l };
}
function angle(a, b) {
  if (b == null)
    return Math.atan2(a.y, a.x);
  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);
}
function rotate(a, theta, b = origin2()) {
  const l = length(a);
  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };
}
function gradient(a, b, reflection) {
  const dx2 = b.x - a.x;
  const dy2 = reflection == null ? b.y - a.y : reflection - b.y - (reflection - a.y);
  return dy2 / dx2;
}
function intercept(a, gradient2, reflection) {
  const y = reflection == null ? a.y : reflection - a.y;
  return y - gradient2 * a.x;
}
function intersectAtY(gradient2, coefficient, y = 0, reflection) {
  return {
    x: gradient2 === Infinity ? Infinity : (y - coefficient) / gradient2,
    y: reflection == null ? y : reflection - y
  };
}
function intersectAtX(gradient2, coefficient, x = 0, reflection) {
  const y = gradient2 === Infinity ? Infinity : gradient2 * x + coefficient;
  return { x, y: reflection == null ? y : reflection - y };
}
function round2(a, decimals = 2) {
  return { x: roundTo(a.x, decimals), y: roundTo(a.y, decimals) };
}
function equal(a, b) {
  return a.x === b.x && a.y === b.y;
}
function from2(a, b) {
  if (typeof a === "number") {
    return { x: a, y: b };
  }
  if ("currentX" in a) {
    return { x: a.currentX, y: a.currentY };
  }
  if ("offsetWidth" in a) {
    return { x: a.offsetWidth, y: a.offsetHeight };
  }
  if ("width" in a) {
    return [
      { x: a.x, y: a.y },
      { x: a.x + a.width, y: a.y + a.height }
    ];
  }
  if ("x1" in a) {
    return [
      { x: a.x1, y: a.y1 },
      { x: a.x2, y: a.y2 }
    ];
  }
  throw new Error(`Values can not be converted into a vector: [${JSON.stringify(a)}] [${b}]`);
}
function apply(a, b) {
  a.x = b.x;
  a.y = b.y;
  return a;
}
function required2(a) {
  return { x: a?.x ?? 0, y: a?.y ?? 0 };
}
function origin2() {
  return { x: 0, y: 0 };
}

// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts
var _HierarchyNode = class _HierarchyNode {
  constructor(series, datumIndex, datum, sizeValue, colorValue, sumSize, depth, parent, children) {
    this.series = series;
    this.datumIndex = datumIndex;
    this.datum = datum;
    this.sizeValue = sizeValue;
    this.colorValue = colorValue;
    this.sumSize = sumSize;
    this.depth = depth;
    this.parent = parent;
    this.children = children;
    this.midPoint = { x: 0, y: 0 };
  }
  get hasChildren() {
    return this.children.length > 0;
  }
  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {
    if (order === _HierarchyNode.Walk.PreOrder) {
      callback2(this);
    }
    this.children.forEach((child) => {
      child.walk(callback2, order);
    });
    if (order === _HierarchyNode.Walk.PostOrder) {
      callback2(this);
    }
  }
  *[Symbol.iterator]() {
    yield this;
    for (const child of this.children) {
      yield* child;
    }
  }
};
_HierarchyNode.Walk = {
  PreOrder: 0,
  PostOrder: 1
};
var HierarchyNode = _HierarchyNode;
var HierarchySeries = class extends Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */]
    });
    this.colorDomain = [0, 0];
    this.maxDepth = 0;
    this.colorScale = new ColorScale();
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  processData() {
    const { NodeClass } = this;
    const { childrenKey, sizeKey, colorKey, colorRange } = this.properties;
    let maxDepth = 0;
    let minColor = Infinity;
    let maxColor = -Infinity;
    const createNode = (datum, indexPath, parent) => {
      const depth = parent.depth != null ? parent.depth + 1 : 0;
      const children = childrenKey != null ? datum[childrenKey] : void 0;
      const isLeaf = children == null || children.length === 0;
      let sizeValue = sizeKey != null ? datum[sizeKey] : void 0;
      if (Number.isFinite(sizeValue)) {
        sizeValue = Math.max(sizeValue, 0);
      } else {
        sizeValue = isLeaf ? 1 : 0;
      }
      const sumSize = sizeValue;
      maxDepth = Math.max(maxDepth, depth);
      const colorValue = colorKey != null ? datum[colorKey] : void 0;
      if (typeof colorValue === "number") {
        minColor = Math.min(minColor, colorValue);
        maxColor = Math.max(maxColor, colorValue);
      }
      return appendChildren(
        new NodeClass(this, indexPath, datum, sizeValue, colorValue, sumSize, depth, parent, []),
        children
      );
    };
    const appendChildren = (node, data) => {
      const { datumIndex } = node;
      data?.forEach((datum, childIndex) => {
        const child = createNode(datum, datumIndex.concat(childIndex), node);
        node.children.push(child);
        node.sumSize += child.sumSize;
      });
      return node;
    };
    const rootNode = appendChildren(
      new NodeClass(this, [], void 0, 0, void 0, 0, void 0, void 0, []),
      this.data
    );
    const colorDomain = [minColor, maxColor];
    this.colorScale.domain = minColor < maxColor ? [minColor, maxColor] : [0, 1];
    this.colorScale.range = colorRange ?? ["black"];
    this.colorScale.update();
    this.rootNode = rootNode;
    this.maxDepth = maxDepth;
    this.colorDomain = colorDomain;
  }
  update({ seriesRect }) {
    this.updateSelections();
    this.updateNodes();
    const animationData = this.getAnimationData();
    const resize = this.checkResize(seriesRect);
    if (resize) {
      this.animationState.transition("resize", animationData);
    }
    this.animationState.transition("update", animationData);
  }
  resetAllAnimation(_data) {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(_data) {
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  getAnimationData() {
    return {};
  }
  isProcessedDataAnimatable() {
    return true;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  dataCount() {
    return NaN;
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  getLegendData(legendType) {
    const { colorKey, colorRange } = this.properties;
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    return legendType === "gradient" && colorKey != null && colorRange != null ? [
      {
        legendType: "gradient",
        enabled: visible && legendManager.getItemEnabled({ seriesId }),
        seriesId,
        series: this.getFormatterContext("color"),
        colorRange,
        colorDomain: this.colorDomain
      }
    ] : [];
  }
  getDatumIdFromData(node) {
    return node.datumIndex.join(":");
  }
  getDatumId(node) {
    return this.getDatumIdFromData(node);
  }
  removeMeIndexPathForIndex(index) {
    return this.datumSelection.at(index + 1)?.datum.datumIndex ?? [];
  }
  removeMeIndexForIndexPath(indexPath) {
    for (const { index, datum } of this.datumSelection) {
      if (arraysEqual(datum.datumIndex, indexPath)) {
        return index - 1;
      }
    }
    return 0;
  }
  pickFocus(opts) {
    if (!this.rootNode?.children.length)
      return void 0;
    const index = clamp(0, opts.datumIndex - opts.datumIndexDelta, this.datumSelection.length - 1);
    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;
    let path = this.removeMeIndexPathForIndex(index);
    const currentNode = path.reduce((n, childIndex) => n.children[childIndex], this.rootNode);
    if (depthDelta > 0 && currentNode.hasChildren) {
      path = [...path, 0];
    } else if (depthDelta < 0 && path.length > 1) {
      path = path.slice(0, -1);
    } else if (depthDelta === 0 && childDelta !== 0) {
      const maxIndex = currentNode.parent.children.length - 1;
      path = path.slice();
      path[path.length - 1] = clamp(0, path[path.length - 1] + childDelta, maxIndex);
    }
    const nextNode = path.reduce((n, childIndex) => n.children[childIndex], this.rootNode);
    const bounds = this.computeFocusBounds(this.datumSelection.at(index + 1));
    if (bounds == null)
      return;
    return {
      datum: nextNode,
      datumIndex: this.removeMeIndexForIndexPath(path),
      otherIndex: nextNode.depth,
      bounds,
      clipFocusBox: true
    };
  }
  getDatumAriaText(datum, description) {
    if (!(datum instanceof this.NodeClass)) {
      logger_exports.error(`datum is not HierarchyNode: ${JSON.stringify(datum)}`);
      return;
    }
    return this.ctx.localeManager.t("ariaAnnounceHierarchyDatum", {
      level: (datum.depth ?? -1) + 1,
      count: datum.children.length,
      description
    });
  }
  getCategoryValue(_datumIndex) {
    return;
  }
  datumIndexForCategoryValue(_categoryValue) {
    return;
  }
};

// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts
var HierarchySeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.childrenKey = "children";
    this.fills = Object.values(DEFAULT_FILLS);
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.strokes = Object.values(DEFAULT_STROKES);
  }
};
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "childrenKey", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "fills", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Property
], HierarchySeriesProperties.prototype, "colorRange", 2);

// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts
var LonLatBBox = class _LonLatBBox {
  constructor(lon0, lat0, lon1, lat1) {
    this.lon0 = lon0;
    this.lat0 = lat0;
    this.lon1 = lon1;
    this.lat1 = lat1;
  }
  extend(lon0, lat0, lon1, lat1) {
    this.lon0 = Math.min(this.lon0, lon0);
    this.lat0 = Math.min(this.lat0, lat0);
    this.lon1 = Math.max(this.lon1, lon1);
    this.lat1 = Math.max(this.lat1, lat1);
    return this;
  }
  merge(other) {
    return this.extend(other.lon0, other.lat0, other.lon1, other.lat1);
  }
  static extend(into, lon0, lat0, lon1, lat1) {
    return into ? into.extend(lon0, lat0, lon1, lat1) : new _LonLatBBox(lon0, lat0, lon1, lat1);
  }
};

// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts
var radsInDeg = Math.PI / 180;
var lonX = (lon) => lon * radsInDeg;
var latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));
var xLon = (x) => x / radsInDeg;
var yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);
var MercatorScale = class _MercatorScale extends AbstractScale {
  constructor(domain, range4) {
    super();
    this.domain = domain;
    this.range = range4;
    this.type = "mercator";
    this.defaultTickCount = 0;
    this.bounds = _MercatorScale.bounds(domain);
  }
  static bounds(domain) {
    const [[lon0, lat0], [lon1, lat1]] = domain;
    const x0 = lonX(lon0);
    const y0 = latY(lat0);
    const x1 = lonX(lon1);
    const y1 = latY(lat1);
    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));
  }
  static fixedScale() {
    return new _MercatorScale(
      [
        [xLon(0), yLat(0)],
        [xLon(1), yLat(1)]
      ],
      [
        [0, 0],
        [1, 1]
      ]
    );
  }
  toDomain() {
    return;
  }
  normalizeDomains(...domains) {
    let x0 = -Infinity;
    let x1 = Infinity;
    let y0 = -Infinity;
    let y1 = Infinity;
    for (const domain of domains) {
      for (const [x, y] of domain) {
        x0 = Math.min(x, x0);
        x1 = Math.max(x, x1);
        y0 = Math.min(y, y0);
        y1 = Math.max(y, y1);
      }
    }
    return {
      domain: [
        [x0, y0],
        [x1, y1]
      ],
      animatable: true
    };
  }
  convert([lon, lat]) {
    const [[x0, y0], [x1, y1]] = this.range;
    const xScale = (x1 - x0) / this.bounds.width;
    const yScale = (y1 - y0) / this.bounds.height;
    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];
  }
  invert([x, y]) {
    const [[x0, y0], [x1, y1]] = this.range;
    const xScale = (x1 - x0) / this.bounds.width;
    const yScale = (y1 - y0) / this.bounds.height;
    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];
  }
};

// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts
var horizontalCrosslineTranslationDirections = {
  top: { xTranslationDirection: 0, yTranslationDirection: -1 },
  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },
  left: { xTranslationDirection: -1, yTranslationDirection: 0 },
  right: { xTranslationDirection: 1, yTranslationDirection: 0 },
  "top-left": { xTranslationDirection: 1, yTranslationDirection: -1 },
  "top-right": { xTranslationDirection: -1, yTranslationDirection: -1 },
  "bottom-left": { xTranslationDirection: 1, yTranslationDirection: 1 },
  "bottom-right": { xTranslationDirection: -1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  "inside-left": { xTranslationDirection: 1, yTranslationDirection: 0 },
  "inside-right": { xTranslationDirection: -1, yTranslationDirection: 0 },
  "inside-top": { xTranslationDirection: 0, yTranslationDirection: 1 },
  "inside-bottom": { xTranslationDirection: 0, yTranslationDirection: -1 },
  "inside-top-left": { xTranslationDirection: 1, yTranslationDirection: 1 },
  "inside-bottom-left": { xTranslationDirection: 1, yTranslationDirection: -1 },
  "inside-top-right": { xTranslationDirection: -1, yTranslationDirection: 1 },
  "inside-bottom-right": { xTranslationDirection: -1, yTranslationDirection: -1 }
};
var verticalCrossLineTranslationDirections = {
  top: { xTranslationDirection: 1, yTranslationDirection: 0 },
  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },
  left: { xTranslationDirection: 0, yTranslationDirection: -1 },
  right: { xTranslationDirection: 0, yTranslationDirection: 1 },
  "top-left": { xTranslationDirection: -1, yTranslationDirection: -1 },
  "top-right": { xTranslationDirection: -1, yTranslationDirection: 1 },
  "bottom-left": { xTranslationDirection: 1, yTranslationDirection: -1 },
  "bottom-right": { xTranslationDirection: 1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  "inside-left": { xTranslationDirection: 0, yTranslationDirection: 1 },
  "inside-right": { xTranslationDirection: 0, yTranslationDirection: -1 },
  "inside-top": { xTranslationDirection: -1, yTranslationDirection: 0 },
  "inside-bottom": { xTranslationDirection: 1, yTranslationDirection: 0 },
  "inside-top-left": { xTranslationDirection: -1, yTranslationDirection: 1 },
  "inside-bottom-left": { xTranslationDirection: 1, yTranslationDirection: 1 },
  "inside-top-right": { xTranslationDirection: -1, yTranslationDirection: -1 },
  "inside-bottom-right": { xTranslationDirection: 1, yTranslationDirection: -1 }
};
function calculateLabelTranslation({
  yDirection,
  padding: padding2 = 0,
  position = "top",
  bbox
}) {
  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;
  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];
  const xTranslation = xTranslationDirection * (padding2 + bbox.width / 2);
  const yTranslation = yTranslationDirection * (padding2 + bbox.height / 2);
  return {
    xTranslation,
    yTranslation
  };
}

// packages/ag-charts-community/src/dom/elements.ts
function createButton(options, attrs) {
  const button = createElement("button", getClassName("ag-charts-input ag-charts-button", attrs));
  if (options.label !== void 0) {
    button.append(options.label);
  } else {
    button.append(createIcon(options.icon));
    button.ariaLabel = options.altText;
  }
  button.addEventListener("click", options.onPress);
  setAttributes(button, attrs);
  return button;
}
function createCheckbox(options, attrs) {
  const checkbox = createElement("input", getClassName("ag-charts-input ag-charts-checkbox", attrs));
  checkbox.type = "checkbox";
  checkbox.checked = options.checked;
  checkbox.addEventListener("change", (event) => options.onChange(checkbox.checked, event));
  checkbox.addEventListener("keydown", (event) => {
    if (isButtonClickEvent(event)) {
      event.preventDefault();
      checkbox.click();
    }
  });
  setAttributes(checkbox, attrs);
  return checkbox;
}
function createSelect(options, attrs) {
  const select = createElement("select", getClassName("ag-charts-input ag-charts-select", attrs));
  select.append(
    ...options.options.map((option) => {
      const optionEl = createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.label;
      return optionEl;
    })
  );
  setAttribute(select, "data-preventdefault", false);
  select.value = options.value;
  select.addEventListener("change", (event) => options.onChange(select.value, event));
  setAttributes(select, attrs);
  return select;
}
function createTextArea(options, attrs) {
  const textArea = createElement("textarea", getClassName("ag-charts-input ag-charts-textarea", attrs));
  textArea.value = options.value;
  textArea.addEventListener("input", (event) => options.onChange(textArea.value, event));
  setAttributes(textArea, attrs);
  setAttribute(textArea, "data-preventdefault", false);
  return textArea;
}
function createIcon(icon) {
  const el = createElement("span", `ag-charts-icon ag-charts-icon-${icon}`);
  setAttribute(el, "aria-hidden", true);
  return el;
}
function getClassName(baseClass, attrs) {
  if (attrs == null)
    return baseClass;
  return `${baseClass} ${attrs.class}`;
}

// packages/ag-charts-community/src/scene/shape/svgPath.ts
var SvgPath = class extends Path {
  constructor(d = "") {
    super();
    this._d = "";
    this.d = d;
  }
  get d() {
    return this._d;
  }
  set d(d) {
    if (d === this._d)
      return;
    this._d = d;
    this.path.clear();
    this.path.appendSvg(d);
    this.checkPathDirty();
  }
};
var TranslatableSvgPath = class extends Translatable(SvgPath) {
  isPointInPath(x, y) {
    return super.isPointInPath(x - this.translationX, y - this.translationY);
  }
};

// packages/ag-charts-community/src/scene/image.ts
var Image3 = class extends Node2 {
  constructor(sourceImage) {
    super();
    this.sourceImage = sourceImage;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.opacity = 1;
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    const image = this.sourceImage;
    if (image) {
      ctx.globalAlpha = this.opacity;
      ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);
    }
    super.render(renderCtx);
  }
};
__decorateClass([
  SceneChangeDetection()
], Image3.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], Image3.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection()
], Image3.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection()
], Image3.prototype, "height", 2);
__decorateClass([
  SceneChangeDetection()
], Image3.prototype, "opacity", 2);

// packages/ag-charts-community/src/widget/exports.ts
var exports_exports = {};
__export(exports_exports, {
  ButtonWidget: () => ButtonWidget,
  MenuItemWidget: () => MenuItemWidget,
  MenuWidget: () => MenuWidget,
  NativeWidget: () => NativeWidget,
  SliderWidget: () => SliderWidget,
  ToolbarWidget: () => ToolbarWidget,
  WIDGET_HTML_EVENTS: () => WIDGET_HTML_EVENTS,
  Widget: () => Widget,
  WidgetEventUtil: () => WidgetEventUtil
});

// packages/ag-charts-community/src/widget/menuItemWidget.ts
var MenuItemWidget = class extends AbstractButtonWidget {
  constructor() {
    super(createElement("div"), "menuitem");
  }
};

// packages/ag-charts-community/src/widget/menuWidget.ts
var closeKeys = ["Escape", "ArrowLeft"];
var MenuWidget = class _MenuWidget extends RovingTabContainerWidget {
  constructor(orientation = "vertical") {
    super(orientation, "menu");
    this.closeSubMenu = (ev) => this.openSubMenu(ev, void 0);
  }
  destructor() {
    this.selfClose("2" /* DESTROY */);
  }
  addSeparator() {
    const sep = getDocument().createElement("div");
    setAttribute(sep, "role", "separator");
    this.elem.appendChild(sep);
    return sep;
  }
  onChildAdded(child) {
    super.onChildAdded(child);
    if (!child.hasPopup()) {
      child.addListener("mouseenter", this.closeSubMenu);
    }
  }
  onChildRemoved(child) {
    super.onChildRemoved(child);
    if (!child.hasPopup()) {
      child.removeListener("mouseenter", this.closeSubMenu);
    }
  }
  addSubMenu() {
    const subMenuButton = new MenuItemWidget();
    const subMenuId = createElementId();
    const subMenu = new _MenuWidget(this.orientation);
    const accessibleOpener = (ev) => {
      if (!subMenuButton.isDisabled()) {
        this.openSubMenu(ev, subMenu);
      }
    };
    const arrowRightOpener = (ev) => {
      if (hasNoModifiers(ev.sourceEvent) && ev.sourceEvent.code === "ArrowRight") {
        accessibleOpener(ev);
      }
    };
    subMenuButton.setAriaHasPopup("menu");
    subMenuButton.setAriaExpanded(false);
    subMenuButton.setAriaControls(subMenuId);
    subMenuButton.addListener("click", accessibleOpener);
    subMenuButton.addListener("mouseenter", accessibleOpener);
    subMenuButton.addListener("keydown", arrowRightOpener);
    subMenu.addListener("close-widget", () => subMenuButton.setAriaExpanded(false));
    subMenu.addListener("open-widget", () => subMenuButton.setAriaExpanded(true));
    subMenu.id = subMenuId;
    this.addChild(subMenuButton);
    return { subMenuButton, subMenu };
  }
  openSubMenu(ev, subMenu) {
    const { openScope } = this;
    if (!openScope)
      return;
    openScope.openSubMenu?.selfClose("4" /* SIDLING_OPENED */);
    subMenu?.open(ev);
    openScope.openSubMenu = subMenu;
  }
  open(event, opts) {
    if (this.openScope != null)
      return;
    this.openScope = {
      lastFocus: getLastFocus(event.sourceEvent),
      openSubMenu: void 0,
      abort: () => this.selfClose("1" /* ABORT */),
      close: () => this.selfClose("0" /* CLOSE */),
      removers: new CleanupRegistry()
    };
    const scope = this.openScope;
    const buttons2 = this.children.map((value) => value.getElement());
    setAttribute(scope.lastFocus, "aria-expanded", true);
    scope.removers.register(
      addMouseCloseListener(this.elem, scope.abort),
      addTouchCloseListener(this.elem, scope.abort),
      ...this.children.map((child) => addEscapeEventListener(child.getElement(), scope.close, closeKeys)),
      opts?.overrideFocusVisible && addOverrideFocusVisibleEventListener(this.elem, buttons2, opts.overrideFocusVisible)
    );
    this.internalListener?.dispatch("open-widget", this, { type: "open-widget" });
    this.children[0]?.focus({ preventScroll: true });
  }
  selfClose(mode) {
    if (this.openScope === void 0)
      return;
    const { lastFocus, removers, openSubMenu } = this.openScope;
    this.openScope = void 0;
    openSubMenu?.selfClose("3" /* PARENT_CLOSED */);
    setAttribute(lastFocus, "aria-expanded", false);
    if (mode === "0" /* CLOSE */) {
      lastFocus?.focus({ preventScroll: true });
    }
    removers.flush();
    this.internalListener?.dispatch("close-widget", this, { type: "close-widget" });
  }
  close() {
    this.selfClose("0" /* CLOSE */);
  }
};

// packages/ag-charts-community/src/components/popover/popover.ts
var canvasOverlay = "canvas-overlay";
var Popover = class extends BaseModuleInstance {
  constructor(ctx, id, options) {
    super();
    this.ctx = ctx;
    this.hideFns = [];
    this.moduleId = `popover-${id}`;
    if (options?.detached) {
      this.element = createElement("div");
    } else {
      this.element = ctx.domManager.addChild(canvasOverlay, this.moduleId);
    }
    this.element.setAttribute("role", "presentation");
    this.cleanup.register(() => ctx.domManager.removeChild(canvasOverlay, this.moduleId));
  }
  attachTo(popover) {
    if (this.element.parentElement)
      return;
    popover.element.append(this.element);
  }
  hide(opts) {
    const { lastFocus = this.lastFocus } = opts ?? {};
    if (this.element.children.length === 0)
      return;
    this.hideFns.forEach((fn) => fn());
    lastFocus?.focus();
    this.lastFocus = void 0;
  }
  removeChildren() {
    this.element.replaceChildren();
  }
  showWithChildren(children, options) {
    if (!this.element.parentElement) {
      throw new Error("Can not show popover that has not been attached to a parent.");
    }
    const popover = createElement("div", "ag-charts-popover");
    if (options.ariaLabel != null) {
      popover.setAttribute("aria-label", options.ariaLabel);
    }
    if (options.class != null) {
      popover.classList.add(options.class);
    }
    popover.replaceChildren(...children);
    this.element.replaceChildren(popover);
    this.hideFns.push(() => this.removeChildren());
    if (options.onHide) {
      this.hideFns.push(options.onHide);
    }
    if (options.initialFocus && options.sourceEvent) {
      const lastFocus = getLastFocus(options.sourceEvent);
      if (lastFocus !== void 0) {
        this.lastFocus = lastFocus;
        this.initialFocus = options.initialFocus;
      }
    }
    return popover;
  }
  getPopoverElement() {
    return this.element.firstElementChild;
  }
  updatePosition(position) {
    const popover = this.getPopoverElement();
    if (!popover)
      return;
    popover.style.setProperty("right", "unset");
    popover.style.setProperty("bottom", "unset");
    if (position.x != null)
      popover.style.setProperty("left", `${Math.floor(position.x)}px`);
    if (position.y != null)
      popover.style.setProperty("top", `${Math.floor(position.y)}px`);
    this.initialFocus?.focus();
    this.initialFocus = void 0;
  }
};

// packages/ag-charts-community/src/components/popover/anchoredPopover.ts
var AnchoredPopover = class extends Popover {
  setAnchor(anchor, fallbackAnchor) {
    this.anchor = anchor;
    this.fallbackAnchor = fallbackAnchor;
    this.updatePosition(anchor);
    this.repositionWithinBounds();
  }
  showWithChildren(children, options) {
    const anchor = options.anchor ?? this.anchor;
    const fallbackAnchor = options.fallbackAnchor ?? this.fallbackAnchor;
    const popover = super.showWithChildren(children, options);
    if (anchor) {
      this.setAnchor(anchor, fallbackAnchor);
    }
    getWindow().requestAnimationFrame(() => {
      this.repositionWithinBounds();
    });
    return popover;
  }
  repositionWithinBounds() {
    const { anchor, ctx, fallbackAnchor } = this;
    const popover = this.getPopoverElement();
    if (!anchor || !popover)
      return;
    const canvasRect = ctx.domManager.getBoundingClientRect();
    const { offsetWidth: width2, offsetHeight: height2 } = popover;
    let x = clamp(0, anchor.x, canvasRect.width - width2);
    let y = clamp(0, anchor.y, canvasRect.height - height2);
    if (x !== anchor.x && fallbackAnchor?.x != null) {
      x = clamp(0, fallbackAnchor.x - width2, canvasRect.width - width2);
    }
    if (y !== anchor.y && fallbackAnchor?.y != null) {
      y = clamp(0, fallbackAnchor.y - height2, canvasRect.height - height2);
    }
    this.updatePosition({ x, y });
  }
};

// packages/ag-charts-community/src/components/menu/menu.ts
var Menu = class extends AnchoredPopover {
  show(options) {
    const rows = options.items.map((item) => this.createRow(options, item));
    const popover = this.showWithChildren(rows, options);
    popover.classList.add("ag-charts-menu");
    popover.setAttribute("role", "menu");
    this.menuCloser = initMenuKeyNav({
      orientation: "vertical",
      menu: popover,
      buttons: rows,
      sourceEvent: options.sourceEvent,
      closeCallback: () => this.hide()
    });
    this.hideFns.push(() => {
      this.menuCloser?.finishClosing();
      this.menuCloser = void 0;
    });
  }
  createRow(options, item) {
    const { menuItemRole = "menuitem" } = options;
    const active = item.value === options.value;
    const row = createElement("div", "ag-charts-menu__row");
    row.setAttribute("role", menuItemRole);
    if (menuItemRole === "menuitemradio") {
      row.setAttribute("aria-checked", (options.value === item.value).toString());
    }
    if (typeof item.value === "string") {
      row.dataset.popoverId = item.value;
    }
    row.classList.toggle(`ag-charts-menu__row--active`, active);
    if (item.icon != null) {
      const icon = createElement("span", `ag-charts-menu__icon ${getIconClassNames(item.icon)}`);
      row.appendChild(icon);
    }
    const strokeWidthVisible = item.strokeWidth != null;
    if (strokeWidthVisible) {
      row.classList.toggle(`ag-charts-menu__row--stroke-width-visible`, strokeWidthVisible);
      row.style.setProperty("--strokeWidth", strokeWidthVisible ? `${item.strokeWidth}px` : null);
    }
    if (item.label != null) {
      const label = createElement("span", "ag-charts-menu__label");
      label.textContent = this.ctx.localeManager.t(item.label);
      row.appendChild(label);
    }
    if ("altText" in item) {
      row.ariaLabel = this.ctx.localeManager.t(item.altText);
    }
    const select = () => {
      options.onPress?.(item);
    };
    const onclick = (e) => {
      if (isButtonClickEvent(e)) {
        select();
        e.preventDefault();
        e.stopPropagation();
      }
    };
    row.addEventListener("keydown", onclick);
    row.addEventListener("click", onclick);
    row.addEventListener("mousemove", () => {
      row.focus({ preventScroll: true });
    });
    return row;
  }
};

// packages/ag-charts-community/src/components/popover/draggablePopover.ts
var DraggablePopover = class extends Popover {
  constructor() {
    super(...arguments);
    this.dragged = false;
  }
  setDragHandle(dragHandle) {
    dragHandle.addListener("drag-start", (event) => {
      dragHandle.addClass(this.dragHandleDraggingClass);
      this.onDragStart(event);
    });
    dragHandle.addListener("drag-move", this.onDragMove.bind(this));
    dragHandle.addListener("drag-end", () => {
      dragHandle.removeClass(this.dragHandleDraggingClass);
      this.onDragEnd.bind(this);
    });
  }
  onDragStart(event) {
    const popover = this.getPopoverElement();
    if (!popover)
      return;
    event.sourceEvent.preventDefault();
    this.dragged = true;
    this.dragStartState = {
      client: Vec2.from(event.clientX, event.clientY),
      position: Vec2.from(
        Number(popover.style.getPropertyValue("left").replace("px", "")),
        Number(popover.style.getPropertyValue("top").replace("px", ""))
      )
    };
  }
  onDragMove(event) {
    const { dragStartState } = this;
    const popover = this.getPopoverElement();
    if (!dragStartState || !popover)
      return;
    const offset = Vec2.sub(Vec2.from(event.clientX, event.clientY), dragStartState.client);
    const position = Vec2.add(dragStartState.position, offset);
    const bounds = this.ctx.domManager.getBoundingClientRect();
    const partialPosition = {};
    if (position.x >= 0 && position.x + popover.offsetWidth <= bounds.width) {
      partialPosition.x = position.x;
    }
    if (position.y >= 0 && position.y + popover.offsetHeight <= bounds.height) {
      partialPosition.y = position.y;
    }
    this.updatePosition(partialPosition);
  }
  onDragEnd() {
    this.dragStartState = void 0;
  }
};

// packages/ag-charts-community/src/components/toolbar/toolbarButtonProperties.ts
var ToolbarButtonProperties = class extends BaseProperties {
};
__decorateClass([
  Property
], ToolbarButtonProperties.prototype, "icon", 2);
__decorateClass([
  Property
], ToolbarButtonProperties.prototype, "label", 2);
__decorateClass([
  Property
], ToolbarButtonProperties.prototype, "ariaLabel", 2);
__decorateClass([
  Property
], ToolbarButtonProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/components/toolbar/toolbarButtonWidget.ts
var ToolbarButtonWidget = class extends ButtonWidget {
  constructor(localeManager) {
    super();
    this.localeManager = localeManager;
  }
  update(options) {
    const { localeManager } = this;
    if (options.tooltip) {
      this.elem.title = localeManager.t(options.tooltip);
    }
    let innerHTML = "";
    if (options.icon != null) {
      innerHTML = `<span class="${getIconClassNames(options.icon)} ag-charts-toolbar__icon"></span>`;
    }
    if (options.label != null) {
      const label = localeManager.t(options.label);
      innerHTML = `${innerHTML}<span class="ag-charts-toolbar__label">${label}</span>`;
    }
    this.elem.innerHTML = innerHTML;
  }
  setChecked(checked) {
    setAttribute(this.elem, "aria-checked", checked);
  }
};

// packages/ag-charts-community/src/components/toolbar/toolbar.ts
var BUTTON_ACTIVE_CLASS = "ag-charts-toolbar__button--active";
var BaseToolbar = class extends ToolbarWidget {
  constructor({ eventsHub, localeManager }, ariaLabelId, orientation) {
    super(orientation);
    this.ariaLabelId = ariaLabelId;
    this.horizontalSpacing = 10;
    this.verticalSpacing = 10;
    this.events = new Listeners();
    this.hasPrefix = false;
    this.buttonWidgets = [];
    this.updateAriaLabel = () => this.setAriaLabel(this.localeManager.t(this.ariaLabelId));
    this.eventsHub = eventsHub;
    this.localeManager = localeManager;
    this.addClass("ag-charts-toolbar");
    this.toggleClass("ag-charts-toolbar--horizontal", orientation === "horizontal");
    this.toggleClass("ag-charts-toolbar--vertical", orientation === "vertical");
    this.eventsHub.on("locale:change", this.updateAriaLabel);
    this.updateAriaLabel();
  }
  setAriaLabelId(ariaLabelId) {
    this.ariaLabelId = ariaLabelId;
    this.updateAriaLabel();
  }
  addToolbarListener(eventType, handler) {
    return this.events.addListener(eventType, handler);
  }
  clearButtons() {
    for (const button of this.buttonWidgets) {
      button.destroy();
    }
    this.buttonWidgets.splice(0);
  }
  updateButtons(buttons2) {
    const { buttonWidgets } = this;
    for (const [index, button] of buttons2.entries()) {
      const buttonWidget = this.buttonWidgets.at(index) ?? this.createButton(index, button);
      buttonWidget.update(button);
    }
    for (let index = buttons2.length; index < buttonWidgets.length; index++) {
      const button = this.buttonWidgets.at(index);
      button?.destroy();
    }
    this.buttonWidgets.splice(buttons2.length);
    this.refreshButtonClasses();
  }
  updateButtonByIndex(index, button) {
    this.buttonWidgets.at(index)?.update(button);
  }
  clearActiveButton() {
    for (const button of this.buttonWidgets) {
      button.toggleClass(BUTTON_ACTIVE_CLASS, false);
    }
  }
  toggleActiveButtonByIndex(index) {
    if (index === -1)
      return;
    for (const [buttonIndex, button] of this.buttonWidgets.entries()) {
      button.toggleClass(BUTTON_ACTIVE_CLASS, index != null && index === buttonIndex);
    }
  }
  toggleButtonEnabledByIndex(index, enabled) {
    if (index === -1)
      return;
    this.buttonWidgets.at(index)?.setEnabled(enabled);
  }
  toggleSwitchCheckedByIndex(index, checked) {
    if (index === -1)
      return;
    this.buttonWidgets.at(index)?.setChecked(checked);
  }
  getButtonBounds() {
    return this.buttonWidgets.map((buttonWidget) => this.getButtonWidgetBounds(buttonWidget));
  }
  setButtonHiddenByIndex(index, hidden) {
    this.buttonWidgets.at(index)?.setHidden(hidden);
  }
  getButtonWidgetBounds(buttonWidget) {
    const parent = this.getBounds();
    const bounds = buttonWidget.getBounds();
    return new BBox(bounds.x + parent.x, bounds.y + parent.y, bounds.width, bounds.height);
  }
  refreshButtonClasses() {
    const { buttonWidgets, hasPrefix } = this;
    let first2;
    let last;
    let section;
    for (const [index, buttonWidget] of buttonWidgets.entries()) {
      first2 = !hasPrefix && index === 0 || section != buttonWidget.section;
      last = index === buttonWidgets.length - 1 || buttonWidget.section != buttonWidgets.at(index + 1)?.section;
      buttonWidget.toggleClass("ag-charts-toolbar__button--first", first2);
      buttonWidget.toggleClass("ag-charts-toolbar__button--last", last);
      buttonWidget.toggleClass("ag-charts-toolbar__button--gap", index > 0 && first2);
      section = buttonWidget.section;
    }
  }
  createButton(index, button) {
    const buttonWidget = this.createButtonWidget();
    buttonWidget.addClass("ag-charts-toolbar__button");
    buttonWidget.addListener("click", (event) => {
      const buttonOptions = { index, ...button instanceof BaseProperties ? button.toJson() : button };
      const buttonBounds = this.getButtonWidgetBounds(buttonWidget);
      this.events.dispatch("button-pressed", { event, button: buttonOptions, buttonBounds });
    });
    buttonWidget.addListener("focus", () => {
      this.events.dispatch("button-focused", { button: { index } });
    });
    if (button.section) {
      buttonWidget.section = button.section;
    }
    this.buttonWidgets.push(buttonWidget);
    this.addChild(buttonWidget);
    return buttonWidget;
  }
};
var Toolbar = class extends BaseToolbar {
  createButtonWidget() {
    return new ToolbarButtonWidget(this.localeManager);
  }
};

// packages/ag-charts-community/src/components/toolbar/floatingToolbar.ts
var FloatingToolbarPopover = class extends DraggablePopover {
  constructor(ctx, id, onPopoverMoved) {
    super(ctx, id);
    this.onPopoverMoved = onPopoverMoved;
    this.dragHandleDraggingClass = "ag-charts-floating-toolbar__drag-handle--dragging";
  }
  show(children, options = {}) {
    this.showWithChildren(children, {
      ...options,
      class: "ag-charts-floating-toolbar"
    });
  }
  hide() {
    this.dragged = false;
    super.hide();
  }
  getBounds() {
    const element2 = this.getPopoverElement();
    return new BBox(
      element2?.offsetLeft ?? 0,
      element2?.offsetTop ?? 0,
      element2?.offsetWidth ?? 0,
      element2?.offsetHeight ?? 0
    );
  }
  hasBeenDragged() {
    return this.dragged;
  }
  setAnchor(anchor, horizontalSpacing, verticalSpacing) {
    const element2 = this.getPopoverElement();
    if (!element2)
      return;
    const position = anchor.position ?? "above";
    const { offsetWidth: width2, offsetHeight: height2 } = element2;
    let top = anchor.y - height2 - verticalSpacing;
    let left = anchor.x - width2 / 2;
    if (position === "below") {
      top = anchor.y + verticalSpacing;
    } else if (position === "right") {
      top = anchor.y - height2 / 2;
      left = anchor.x + horizontalSpacing;
    } else if (position === "above-left") {
      left = anchor.x;
    }
    this.updatePosition({ x: left, y: top });
  }
  ignorePointerEvents() {
    const element2 = this.getPopoverElement();
    if (element2)
      element2.style.pointerEvents = "none";
  }
  capturePointerEvents() {
    const element2 = this.getPopoverElement();
    if (element2)
      element2.style.pointerEvents = "unset";
  }
  updatePosition(position) {
    const bounds = this.getBounds();
    const canvasRect = this.ctx.domManager.getBoundingClientRect();
    position.x = Math.floor(clamp(0, position.x, canvasRect.width - bounds.width));
    position.y = Math.floor(clamp(0, position.y, canvasRect.height - bounds.height));
    super.updatePosition(position);
    this.onPopoverMoved();
  }
};
var FloatingToolbar = class extends BaseToolbar {
  constructor(ctx, ariaLabelId, id) {
    super(ctx, ariaLabelId, "horizontal");
    this.hasPrefix = true;
    this.popover = new FloatingToolbarPopover(ctx, id, this.onPopoverMoved.bind(this));
    this.dragHandle = new DragHandleWidget(ctx.localeManager.t("toolbarAnnotationsDragHandle"));
    this.popover.setDragHandle(this.dragHandle);
  }
  destroy() {
    super.destroy();
    this.popover.destroy();
  }
  show(options = {}) {
    this.popover.show([this.dragHandle.getElement(), this.getElement()], options);
  }
  hide() {
    this.popover.hide();
  }
  setAnchor(anchor) {
    this.popover.setAnchor(anchor, this.horizontalSpacing, this.verticalSpacing);
  }
  hasBeenDragged() {
    return this.popover.hasBeenDragged();
  }
  ignorePointerEvents() {
    this.popover.ignorePointerEvents();
  }
  capturePointerEvents() {
    this.popover.capturePointerEvents();
  }
  onPopoverMoved() {
    const popoverBounds = this.popover.getBounds();
    if (this.popoverBounds?.equals(popoverBounds))
      return;
    this.popoverBounds = popoverBounds.clone();
    const buttonBounds = this.getButtonBounds();
    this.events.dispatch("toolbar-moved", { popoverBounds, buttonBounds });
  }
  getButtonWidgetBounds(buttonWidget) {
    const popoverBounds = this.popover.getBounds();
    const bounds = super.getButtonWidgetBounds(buttonWidget);
    const dragHandleBounds = this.dragHandle.getBounds();
    return new BBox(
      bounds.x + popoverBounds.x - dragHandleBounds.width,
      bounds.y + popoverBounds.y,
      bounds.width,
      bounds.height
    );
  }
};
var DragHandleWidget = class extends NativeWidget {
  constructor(title) {
    super(createElement("div", "ag-charts-floating-toolbar__drag-handle"));
    const icon = new NativeWidget(
      createElement("span", `${getIconClassNames("drag-handle")} ag-charts-toolbar__icon`)
    );
    icon.setAriaHidden(true);
    this.addChild(icon);
    this.elem.title = title;
  }
};

// packages/ag-charts-community/src/module-support.ts
var motion = { ...fromToMotion_exports, ...resetMotion_exports };

// packages/ag-charts-community/src/main.ts
var AgChartsCommunityModule = {
  VERSION,
  _Scene: integrated_charts_scene_exports,
  _Theme: integrated_charts_theme_exports,
  _Util: integrated_charts_util_exports,
  create: AgCharts.create.bind(AgCharts),
  createSparkline: AgCharts.__createSparkline.bind(AgCharts),
  setup: registerInbuiltModules,
  isEnterprise: false
};

// packages/ag-charts-enterprise/dist/package/main.esm.mjs
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __decorateClass2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};
var MD5 = class {
  constructor() {
    this.ieCompatibility = false;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(x, k) {
    let a = x[0], b = x[1], c = x[2], d = x[3];
    a = this.ff(a, b, c, d, k[0], 7, -680876936);
    d = this.ff(d, a, b, c, k[1], 12, -389564586);
    c = this.ff(c, d, a, b, k[2], 17, 606105819);
    b = this.ff(b, c, d, a, k[3], 22, -1044525330);
    a = this.ff(a, b, c, d, k[4], 7, -176418897);
    d = this.ff(d, a, b, c, k[5], 12, 1200080426);
    c = this.ff(c, d, a, b, k[6], 17, -1473231341);
    b = this.ff(b, c, d, a, k[7], 22, -45705983);
    a = this.ff(a, b, c, d, k[8], 7, 1770035416);
    d = this.ff(d, a, b, c, k[9], 12, -1958414417);
    c = this.ff(c, d, a, b, k[10], 17, -42063);
    b = this.ff(b, c, d, a, k[11], 22, -1990404162);
    a = this.ff(a, b, c, d, k[12], 7, 1804603682);
    d = this.ff(d, a, b, c, k[13], 12, -40341101);
    c = this.ff(c, d, a, b, k[14], 17, -1502002290);
    b = this.ff(b, c, d, a, k[15], 22, 1236535329);
    a = this.gg(a, b, c, d, k[1], 5, -165796510);
    d = this.gg(d, a, b, c, k[6], 9, -1069501632);
    c = this.gg(c, d, a, b, k[11], 14, 643717713);
    b = this.gg(b, c, d, a, k[0], 20, -373897302);
    a = this.gg(a, b, c, d, k[5], 5, -701558691);
    d = this.gg(d, a, b, c, k[10], 9, 38016083);
    c = this.gg(c, d, a, b, k[15], 14, -660478335);
    b = this.gg(b, c, d, a, k[4], 20, -405537848);
    a = this.gg(a, b, c, d, k[9], 5, 568446438);
    d = this.gg(d, a, b, c, k[14], 9, -1019803690);
    c = this.gg(c, d, a, b, k[3], 14, -187363961);
    b = this.gg(b, c, d, a, k[8], 20, 1163531501);
    a = this.gg(a, b, c, d, k[13], 5, -1444681467);
    d = this.gg(d, a, b, c, k[2], 9, -51403784);
    c = this.gg(c, d, a, b, k[7], 14, 1735328473);
    b = this.gg(b, c, d, a, k[12], 20, -1926607734);
    a = this.hh(a, b, c, d, k[5], 4, -378558);
    d = this.hh(d, a, b, c, k[8], 11, -2022574463);
    c = this.hh(c, d, a, b, k[11], 16, 1839030562);
    b = this.hh(b, c, d, a, k[14], 23, -35309556);
    a = this.hh(a, b, c, d, k[1], 4, -1530992060);
    d = this.hh(d, a, b, c, k[4], 11, 1272893353);
    c = this.hh(c, d, a, b, k[7], 16, -155497632);
    b = this.hh(b, c, d, a, k[10], 23, -1094730640);
    a = this.hh(a, b, c, d, k[13], 4, 681279174);
    d = this.hh(d, a, b, c, k[0], 11, -358537222);
    c = this.hh(c, d, a, b, k[3], 16, -722521979);
    b = this.hh(b, c, d, a, k[6], 23, 76029189);
    a = this.hh(a, b, c, d, k[9], 4, -640364487);
    d = this.hh(d, a, b, c, k[12], 11, -421815835);
    c = this.hh(c, d, a, b, k[15], 16, 530742520);
    b = this.hh(b, c, d, a, k[2], 23, -995338651);
    a = this.ii(a, b, c, d, k[0], 6, -198630844);
    d = this.ii(d, a, b, c, k[7], 10, 1126891415);
    c = this.ii(c, d, a, b, k[14], 15, -1416354905);
    b = this.ii(b, c, d, a, k[5], 21, -57434055);
    a = this.ii(a, b, c, d, k[12], 6, 1700485571);
    d = this.ii(d, a, b, c, k[3], 10, -1894986606);
    c = this.ii(c, d, a, b, k[10], 15, -1051523);
    b = this.ii(b, c, d, a, k[1], 21, -2054922799);
    a = this.ii(a, b, c, d, k[8], 6, 1873313359);
    d = this.ii(d, a, b, c, k[15], 10, -30611744);
    c = this.ii(c, d, a, b, k[6], 15, -1560198380);
    b = this.ii(b, c, d, a, k[13], 21, 1309151649);
    a = this.ii(a, b, c, d, k[4], 6, -145523070);
    d = this.ii(d, a, b, c, k[11], 10, -1120210379);
    c = this.ii(c, d, a, b, k[2], 15, 718787259);
    b = this.ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = this.add32(a, x[0]);
    x[1] = this.add32(b, x[1]);
    x[2] = this.add32(c, x[2]);
    x[3] = this.add32(d, x[3]);
  }
  cmn(q, a, b, x, s, t) {
    a = this.add32(this.add32(a, q), this.add32(x, t));
    return this.add32(a << s | a >>> 32 - s, b);
  }
  ff(a, b, c, d, x, s, t) {
    return this.cmn(b & c | ~b & d, a, b, x, s, t);
  }
  gg(a, b, c, d, x, s, t) {
    return this.cmn(b & d | c & ~d, a, b, x, s, t);
  }
  hh(a, b, c, d, x, s, t) {
    return this.cmn(b ^ c ^ d, a, b, x, s, t);
  }
  ii(a, b, c, d, x, s, t) {
    return this.cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  md51(s) {
    const n = s.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= s.length; i += 64) {
      this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < s.length; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }
    tail[i >> 2] |= 128 << (i % 4 << 3);
    if (i > 55) {
      this.md5cycle(state, tail);
      for (i = 0; i < 16; i++) {
        tail[i] = 0;
      }
    }
    tail[14] = n * 8;
    this.md5cycle(state, tail);
    return state;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(s) {
    const md5blks = [];
    for (let i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }
  rhex(n) {
    const hex_chr = "0123456789abcdef".split("");
    let s = "", j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
    }
    return s;
  }
  hex(x) {
    for (let i = 0; i < x.length; i++) {
      x[i] = this.rhex(x[i]);
    }
    return x.join("");
  }
  md5(s) {
    return this.hex(this.md51(s));
  }
  add32(a, b) {
    return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(a, b) {
    return a + b & 4294967295;
  }
  add32Compat(x, y) {
    const lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
};
function missingOrEmpty(value) {
  return value == null || value.length === 0;
}
var LICENSE_TYPES = {
  "01": "GRID",
  "02": "CHARTS",
  "0102": "BOTH"
};
var LICENSING_HELP_URL = "https://www.ag-grid.com/charts/licensing/";
var _LicenseManager = class _LicenseManager2 {
  constructor(document2) {
    this.watermarkMessage = void 0;
    this.totalMessageLength = 124;
    this.document = document2;
    this.md5 = new MD5();
    this.md5.init();
  }
  validateLicense() {
    const licenseDetails = this.getLicenseDetails(_LicenseManager2.licenseKey, _LicenseManager2.gridContext);
    const currentLicenseName = `AG ${licenseDetails.currentLicenseType === "BOTH" ? "Grid and " : ""}Charts Enterprise`;
    let suppliedLicenseName = "";
    if (licenseDetails.suppliedLicenseType === "BOTH") {
      suppliedLicenseName = "AG Grid and AG Charts Enterprise";
    } else if (licenseDetails.suppliedLicenseType === "GRID") {
      suppliedLicenseName = "AG Grid Enterprise";
    } else if (licenseDetails.suppliedLicenseType !== void 0) {
      suppliedLicenseName = "AG Charts Enterprise";
    }
    if (licenseDetails.missing) {
      if (!this.isWebsiteUrl() || this.isForceWatermark()) {
        this.outputMissingLicenseKey(currentLicenseName);
      }
    } else if (licenseDetails.expired) {
      const gridReleaseDate = _LicenseManager2.getChartsReleaseDate();
      const formattedReleaseDate = _LicenseManager2.formatDate(gridReleaseDate);
      this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, suppliedLicenseName);
    } else if (!licenseDetails.valid) {
      this.outputInvalidLicenseKey(
        !!licenseDetails.incorrectLicenseType,
        currentLicenseName,
        suppliedLicenseName
      );
    } else if (licenseDetails.isTrial && licenseDetails.trialExpired) {
      this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);
    }
  }
  static extractExpiry(license) {
    const restrictionHashed = license.substring(license.lastIndexOf("_") + 1, license.length);
    return new Date(parseInt(_LicenseManager2.decode(restrictionHashed), 10));
  }
  static extractLicenseComponents(licenseKey) {
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    if (licenseKey.length <= 32) {
      return { md5: null, license: licenseKey, version: null, isTrial: null };
    }
    const hashStart = cleanedLicenseKey.length - 32;
    const md5 = cleanedLicenseKey.substring(hashStart);
    const license = cleanedLicenseKey.substring(0, hashStart);
    const [version, isTrial, type] = _LicenseManager2.extractBracketedInformation(cleanedLicenseKey);
    return { md5, license, version, isTrial, type };
  }
  getLicenseDetails(licenseKey, gridContext = false) {
    const currentLicenseType = "CHARTS";
    if (missingOrEmpty(licenseKey)) {
      return {
        licenseKey,
        valid: false,
        missing: true,
        currentLicenseType
      };
    }
    const chartsReleaseDate = _LicenseManager2.getChartsReleaseDate();
    const { md5, license, version, isTrial, type } = _LicenseManager2.extractLicenseComponents(licenseKey);
    let valid = md5 === this.md5.md5(license) && licenseKey.indexOf("For_Trialing_ag-Grid_Only") === -1;
    let trialExpired = void 0;
    let expired = void 0;
    let expiry = null;
    let incorrectLicenseType = false;
    let suppliedLicenseType = void 0;
    function handleTrial() {
      const now = /* @__PURE__ */ new Date();
      trialExpired = expiry < now;
      expired = void 0;
    }
    if (valid) {
      expiry = _LicenseManager2.extractExpiry(license);
      valid = !isNaN(expiry.getTime());
      if (valid) {
        expired = chartsReleaseDate > expiry;
        switch (version) {
          case "legacy":
          case "2": {
            valid = false;
            break;
          }
          case "3": {
            if (missingOrEmpty(type)) {
              valid = false;
            } else {
              suppliedLicenseType = type;
              if (type !== LICENSE_TYPES["02"] && type !== LICENSE_TYPES["0102"]) {
                valid = false;
                incorrectLicenseType = true;
              } else if (isTrial) {
                handleTrial();
              }
            }
          }
        }
      }
    }
    if (!valid) {
      return {
        licenseKey,
        valid,
        incorrectLicenseType,
        currentLicenseType,
        suppliedLicenseType
      };
    }
    return {
      licenseKey,
      valid,
      expiry: _LicenseManager2.formatDate(expiry),
      expired,
      version,
      isTrial,
      trialExpired,
      invalidLicenseTypeForCombo: gridContext ? suppliedLicenseType !== "BOTH" : void 0,
      incorrectLicenseType,
      currentLicenseType,
      suppliedLicenseType
    };
  }
  isDisplayWatermark() {
    return this.isForceWatermark() || !this.isLocalhost() && !this.isE2ETest() && !this.isWebsiteUrl() && !missingOrEmpty(this.watermarkMessage);
  }
  getWatermarkMessage() {
    return this.watermarkMessage ?? "";
  }
  getHostname() {
    if (!this.document) {
      return "localhost";
    }
    const win = this.document.defaultView ?? window;
    if (!win) {
      return "localhost";
    }
    const loc = win.location;
    const { hostname = "" } = loc;
    return hostname;
  }
  isForceWatermark() {
    if (!this.document) {
      return false;
    }
    const win = this.document?.defaultView ?? typeof window != "undefined" ? window : void 0;
    if (!win) {
      return false;
    }
    const { pathname } = win.location;
    return pathname ? pathname.indexOf("forceWatermark") !== -1 : false;
  }
  isWebsiteUrl() {
    const hostname = this.getHostname();
    return /^((?:[\w-]+\.)?ag-grid\.com)$/.exec(hostname) !== null;
  }
  isLocalhost() {
    const hostname = this.getHostname();
    return /^(?:127\.0\.0\.1|localhost)$/.exec(hostname) !== null;
  }
  isE2ETest() {
    const hostname = this.getHostname();
    return /^(?:172\.17\.0\.1|host\.docker\.internal)$/.exec(hostname) !== null;
  }
  static formatDate(date2) {
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const day = date2.getDate();
    const monthIndex = date2.getMonth();
    const year = date2.getFullYear();
    return day + " " + monthNames[monthIndex] + " " + year;
  }
  static getChartsReleaseDate() {
    return new Date(parseInt(_LicenseManager2.decode(_LicenseManager2.RELEASE_INFORMATION), 10));
  }
  static decode(input) {
    const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let t = "";
    let n, r, i;
    let s, o, u, a;
    let f = 0;
    const e = input.replace(/[^A-Za-z0-9+/=]/g, "");
    while (f < e.length) {
      s = keystr.indexOf(e.charAt(f++));
      o = keystr.indexOf(e.charAt(f++));
      u = keystr.indexOf(e.charAt(f++));
      a = keystr.indexOf(e.charAt(f++));
      n = s << 2 | o >> 4;
      r = (o & 15) << 4 | u >> 2;
      i = (u & 3) << 6 | a;
      t = t + String.fromCharCode(n);
      if (u != 64) {
        t = t + String.fromCharCode(r);
      }
      if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }
    t = _LicenseManager2.utf8_decode(t);
    return t;
  }
  static utf8_decode(input) {
    input = input.replace(/rn/g, "n");
    let t = "";
    for (let n = 0; n < input.length; n++) {
      const r = input.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);
        t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);
        t += String.fromCharCode(r >> 6 & 63 | 128);
        t += String.fromCharCode(r & 63 | 128);
      }
    }
    return t;
  }
  static setGridContext(gridContext = false) {
    _LicenseManager2.gridContext = gridContext;
  }
  static setLicenseKey(licenseKey) {
    _LicenseManager2.licenseKey = licenseKey;
  }
  static extractBracketedInformation(licenseKey) {
    if (!licenseKey.includes("[")) {
      return ["legacy", false, void 0];
    }
    const matches = licenseKey.match(/\[(.*?)\]/g).map((match) => match.replace("[", "").replace("]", ""));
    if (!matches || matches.length === 0) {
      return ["legacy", false, void 0];
    }
    const isTrial = matches.filter((match) => match === "TRIAL").length === 1;
    const rawVersion = matches.filter((match) => match.startsWith("v"))[0];
    const version = rawVersion ? rawVersion.replace("v", "") : "legacy";
    const type = LICENSE_TYPES[matches.filter((match) => LICENSE_TYPES[match])[0]];
    return [version, isTrial, type];
  }
  centerPadAndOutput(input) {
    const paddingRequired = this.totalMessageLength - input.length;
    console.error(input.padStart(paddingRequired / 2 + input.length, "*").padEnd(this.totalMessageLength, "*"));
  }
  padAndOutput(input, padding2 = "*", terminateWithPadding = "") {
    console.error(
      input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding2) + terminateWithPadding
    );
  }
  outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {
    if (!_LicenseManager2.gridContext) {
      if (incorrectLicenseType) {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Incompatible License Key ");
        this.padAndOutput(
          `* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`,
          " ",
          "*"
        );
        this.padAndOutput(`* To troubleshoot your license key visit ${LICENSING_HELP_URL}.`, " ", "*");
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      } else {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Invalid License Key ");
        this.padAndOutput(`* Your license key is not valid.`, " ", "*");
        this.padAndOutput(`* To troubleshoot your license key visit ${LICENSING_HELP_URL}.`, " ", "*");
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      }
    }
    this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {
    if (!_LicenseManager2.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Trial Period Expired. ");
      this.padAndOutput(
        `* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput("* Please email info@ag-grid.com to purchase a license.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey(currentLicenseName) {
    if (!_LicenseManager2.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" License Key Not Found ");
      this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, " ", "*");
      this.padAndOutput(
        "* If you want to hide the watermark please email info@ag-grid.com for a trial license key.",
        " ",
        "*"
      );
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "For Trial Use Only";
  }
  outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName) {
    if (!_LicenseManager2.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Incompatible Software Version ");
      this.padAndOutput(
        `* Your license key works with versions of ${currentLicenseName} released before ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, " ", "*");
      this.padAndOutput("* Please contact info@ag-grid.com to renew your license key.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "License Expired";
  }
};
_LicenseManager.RELEASE_INFORMATION = "MTc1NTc2ODUyOTgxNw==";
_LicenseManager.gridContext = false;
var LicenseManager = _LicenseManager;
function loopSymmetrically(items, step, iterator) {
  const loop = (start2, end2, loopStep, loopIterator) => {
    let prev = items[0];
    for (let i = start2; loopStep > 0 ? i <= end2 : i > end2; i += loopStep) {
      const curr = items[i];
      if (loopIterator(prev, curr))
        return true;
      prev = curr;
    }
    return false;
  };
  const midIndex = Math.floor(items.length / 2);
  if (loop(step, midIndex, step, iterator))
    return true;
  return loop(items.length - step, midIndex, -step, iterator);
}
var { AxisInterval: AxisInterval2, Property: Property2 } = module_support_exports;
var AngleAxisInterval = class extends AxisInterval2 {
};
__decorateClass2([
  Property2
], AngleAxisInterval.prototype, "minSpacing", 2);
var { BaseProperties: BaseProperties2, ChartAxisDirection: ChartAxisDirection2, Property: Property22, Group: Group4, FONT_SIZE: FONT_SIZE2 } = module_support_exports;
var PolarCrossLineLabel = class extends BaseProperties2 {
  constructor() {
    super(...arguments);
    this.fontSize = FONT_SIZE2.LARGE;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
  }
};
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "enabled", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "text", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "fontSize", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "padding", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "color", 2);
__decorateClass2([
  Property22
], PolarCrossLineLabel.prototype, "parallel", 2);
var PolarCrossLine = class extends BaseProperties2 {
  constructor() {
    super(...arguments);
    this.id = createId(this);
    this.defaultColorRange = [];
    this.shape = "polygon";
    this.label = new PolarCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = ChartAxisDirection2.Angle;
    this.axisInnerRadius = 0;
    this.axisOuterRadius = 0;
    this.lineGroup = new Group4({ name: this.id });
    this.rangeGroup = new Group4({ name: this.id });
    this.labelGroup = new Group4({ name: this.id });
    this._isRange = void 0;
  }
  assignCrossLineGroup(isRange, crossLineRange) {
    if (isRange !== this._isRange) {
      if (isRange) {
        this.rangeGroup.appendChild(crossLineRange);
      } else {
        this.lineGroup.appendChild(crossLineRange);
      }
    }
    this._isRange = isRange;
  }
  setSectorNodeProps(node) {
    node.fill = this.fill;
    node.fillOpacity = this.fillOpacity ?? 1;
    node.stroke = this.stroke;
    node.strokeOpacity = this.strokeOpacity ?? 1;
    node.strokeWidth = this.strokeWidth ?? 1;
    node.lineDash = this.lineDash;
  }
  setLabelNodeProps(node, x, y, baseline, rotation) {
    const { label } = this;
    node.x = x;
    node.y = y;
    node.text = label.text;
    node.textAlign = "center";
    node.textBaseline = baseline;
    node.rotation = rotation;
    node.rotationCenterX = x;
    node.rotationCenterY = y;
    node.fill = label.color;
    node.fontFamily = label.fontFamily;
    node.fontSize = label.fontSize;
    node.fontStyle = label.fontStyle;
    node.visible = true;
  }
};
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "enabled", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "type", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "range", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "value", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "defaultColorRange", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "fill", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "fillOpacity", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "stroke", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "strokeWidth", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "lineDash", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "shape", 2);
__decorateClass2([
  Property22
], PolarCrossLine.prototype, "label", 2);
var {
  ChartAxisDirection: ChartAxisDirection22,
  getCrossLineValue: getCrossLineValue2,
  validateCrossLineValue: validateCrossLineValue2,
  normalizeAngle360: normalizeAngle3602,
  Group: Group22,
  Path: Path2,
  Sector: Sector2,
  RotatableText: RotatableText2,
  ContinuousScale: ContinuousScale2
} = module_support_exports;
var AngleCrossLine = class extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection22.Angle;
    this.polygonNode = new Path2();
    this.sectorNode = new Sector2();
    this.lineNode = new Path2();
    this.crossLineRange = new Group22();
    this.labelNode = new RotatableText2();
    this.ticks = [];
    this.crossLineRange.append(this.polygonNode);
    this.crossLineRange.append(this.sectorNode);
    this.crossLineRange.append(this.lineNode);
    this.labelGroup.append(this.labelNode);
  }
  visibilityCheck() {
    if (!ContinuousScale2.is(this.scale)) {
      return true;
    }
    const [d0, d1] = this.scale.domain;
    const value = getCrossLineValue2(this);
    if (this.type === "range") {
      const [start2, end2] = value;
      return start2 >= d0 && start2 <= d1 && end2 >= start2 && end2 <= d1;
    } else {
      return value >= d0 && value <= d1;
    }
  }
  update(visible) {
    const { scale: scale2 } = this;
    if (!scale2 || !validateCrossLineValue2(this, scale2) || !this.visibilityCheck()) {
      this.rangeGroup.visible = false;
      this.lineGroup.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.rangeGroup.visible = visible;
    this.lineGroup.visible = visible;
    this.labelGroup.visible = visible;
    this.updateLineNode(visible);
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
  }
  updateLineNode(visible) {
    const { scale: scale2, type, value, lineNode: line } = this;
    if (!visible || type !== "line" || !scale2) {
      line.visible = false;
      return;
    }
    const angle2 = scale2.convert(value);
    if (isNaN(angle2)) {
      line.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    line.visible = true;
    line.stroke = this.stroke;
    line.strokeOpacity = this.strokeOpacity ?? 1;
    line.strokeWidth = this.strokeWidth ?? 1;
    line.fill = void 0;
    line.lineDash = this.lineDash;
    const x = axisOuterRadius * Math.cos(angle2);
    const y = axisOuterRadius * Math.sin(angle2);
    const x0 = axisInnerRadius * Math.cos(angle2);
    const y0 = axisInnerRadius * Math.sin(angle2);
    line.path.clear(true);
    line.path.moveTo(x0, y0);
    line.path.lineTo(x, y);
    this.assignCrossLineGroup(false, this.crossLineRange);
  }
  updatePolygonNode(visible) {
    const { polygonNode: polygon, range: range22, scale: scale2, shape, type, ticks } = this;
    if (!visible || type !== "range" || shape !== "polygon" || !scale2 || !range22) {
      polygon.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const startIndex = ticks.indexOf(range22[0]);
    const endIndex = ticks.indexOf(range22[1]);
    const stops = startIndex <= endIndex ? ticks.slice(startIndex, endIndex + 1) : ticks.slice(startIndex).concat(ticks.slice(0, endIndex + 1));
    const angles = stops.map((value) => scale2.convert(value));
    polygon.visible = true;
    this.setSectorNodeProps(polygon);
    const { path } = polygon;
    path.clear(true);
    angles.forEach((angle2, index) => {
      const x = axisOuterRadius * Math.cos(angle2);
      const y = axisOuterRadius * Math.sin(angle2);
      if (index === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (axisInnerRadius === 0) {
      path.lineTo(0, 0);
    } else {
      angles.slice().reverse().forEach((angle2) => {
        const x = axisInnerRadius * Math.cos(angle2);
        const y = axisInnerRadius * Math.sin(angle2);
        path.lineTo(x, y);
      });
    }
    polygon.path.closePath();
    this.assignCrossLineGroup(true, this.crossLineRange);
  }
  updateSectorNode(visible) {
    const { sectorNode: sector, range: range22, scale: scale2, shape, type } = this;
    if (!visible || type !== "range" || shape !== "circle" || !scale2 || !range22) {
      sector.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const angles = range22.map((value) => scale2.convert(value));
    const step = scale2.step ?? 0;
    const padding2 = scale2 instanceof module_support_exports.BandScale ? step / 2 : 0;
    sector.visible = true;
    this.setSectorNodeProps(sector);
    sector.centerX = 0;
    sector.centerY = 0;
    sector.innerRadius = axisInnerRadius;
    sector.outerRadius = axisOuterRadius;
    sector.startAngle = angles[0] - padding2;
    sector.endAngle = angles[1] + padding2;
    this.assignCrossLineGroup(true, this.crossLineRange);
  }
  updateLabelNode(visible) {
    const { label, labelNode: node, range: range22, scale: scale2, type, ticks } = this;
    if (!visible || label.enabled === false || !label.text || !scale2 || type === "range" && !range22) {
      node.visible = false;
      return;
    }
    node.visible = true;
    const { axisInnerRadius, axisOuterRadius } = this;
    let labelX;
    let labelY;
    let rotation;
    let textBaseline;
    if (type === "line") {
      const angle2 = normalizeAngle3602(scale2.convert(this.value));
      const angle270 = 1.5 * Math.PI;
      const isRightSide = isNumberEqual(angle2, angle270) || angle2 > angle270 || angle2 < Math.PI / 2;
      const midX = (axisInnerRadius + axisOuterRadius) / 2 * Math.cos(angle2);
      const midY = (axisInnerRadius + axisOuterRadius) / 2 * Math.sin(angle2);
      labelX = midX + label.padding * Math.cos(angle2 + Math.PI / 2);
      labelY = midY + label.padding * Math.sin(angle2 + Math.PI / 2);
      textBaseline = isRightSide ? "top" : "bottom";
      rotation = isRightSide ? angle2 : angle2 - Math.PI;
    } else {
      const [startAngle, endAngle] = range22.map((value) => normalizeAngle3602(scale2.convert(value)));
      let angle2 = (startAngle + endAngle) / 2;
      if (startAngle > endAngle) {
        angle2 -= Math.PI;
      }
      angle2 = normalizeAngle3602(angle2);
      const isBottomSide = (isNumberEqual(angle2, 0) || angle2 > 0) && angle2 < Math.PI;
      let distance2;
      if (this.shape === "circle" || ticks.length < 3) {
        distance2 = axisOuterRadius - label.padding;
      } else {
        distance2 = axisOuterRadius * Math.cos(Math.PI / ticks.length) - label.padding;
      }
      labelX = distance2 * Math.cos(angle2);
      labelY = distance2 * Math.sin(angle2);
      textBaseline = isBottomSide ? "bottom" : "top";
      rotation = isBottomSide ? angle2 - Math.PI / 2 : angle2 + Math.PI / 2;
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
};
AngleCrossLine.className = "AngleCrossLine";
var {
  ChartAxisDirection: ChartAxisDirection3,
  TextWrapper: TextWrapper2,
  TextUtils: TextUtils2,
  Property: Property3,
  toRadians: toRadians2,
  normalizeAngle360: normalizeAngle36022,
  normalizeAngle360Inclusive: normalizeAngle360Inclusive2,
  Path: Path22,
  RotatableText: RotatableText22,
  Transformable: Transformable2,
  BBox: BBox2,
  Selection: Selection2,
  Line: Line2
} = module_support_exports;
var AngleAxisLabel = class extends module_support_exports.AxisLabel {
  constructor() {
    super(...arguments);
    this.orientation = "fixed";
  }
};
__decorateClass2([
  Property3
], AngleAxisLabel.prototype, "orientation", 2);
var AngleAxis = class extends module_support_exports.PolarAxis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.startAngle = 0;
    this.endAngle = void 0;
    this.tickLineGroupSelection = Selection2.select(
      this.tickLineGroup,
      Line2,
      false
    );
    this.gridLineGroupSelection = Selection2.select(
      this.gridLineGroup,
      Line2,
      false
    );
    this.labelData = [];
    this.tickData = [];
    this.radiusLineGroup = this.axisGroup.appendChild(new module_support_exports.TransformableGroup());
    this.radiusLine = this.radiusLineGroup.appendChild(new Path22());
    this.includeInvisibleDomains = true;
  }
  get direction() {
    return ChartAxisDirection3.Angle;
  }
  createLabel() {
    return new AngleAxisLabel();
  }
  calculateRotations() {
    const rotation = toRadians2(this.startAngle);
    const parallelFlipRotation = normalizeAngle36022(rotation);
    const regularFlipRotation = normalizeAngle36022(rotation - Math.PI / 2);
    return { rotation, parallelFlipRotation, regularFlipRotation };
  }
  calculateTickLayout(domain) {
    const { nice, scale: scale2 } = this;
    const ticksParams = {
      nice,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    };
    const niceDomain = nice ? scale2.niceDomain(ticksParams, domain) : domain;
    const tickData = this.generateAngleTicks(niceDomain);
    this.tickData = tickData;
    const ticks = tickData.map((t) => t.value);
    const fractionDigits = ticks.reduce(
      (f, t) => Math.max(typeof t === "number" ? countFractionDigits(t) : 0, f),
      0
    );
    return {
      niceDomain,
      tickDomain: niceDomain,
      ticks,
      rawTickCount: void 0,
      fractionDigits,
      timeInterval: void 0,
      bbox: this.getBBox()
    };
  }
  update() {
    super.update();
    this.updateRadiusLine();
    this.updateGridLines();
    this.updateTickLines();
  }
  normalizedAngles() {
    const startAngle = normalizeAngle36022(-Math.PI / 2 + toRadians2(this.startAngle));
    const sweep = this.endAngle != null ? normalizeAngle360Inclusive2(toRadians2(this.endAngle) - toRadians2(this.startAngle)) : 2 * Math.PI;
    const endAngle = startAngle + sweep;
    return [startAngle, endAngle];
  }
  computeRange() {
    this.range = this.normalizedAngles();
  }
  updateSelections() {
    const data = this.tickData;
    this.gridLineGroupSelection.update(this.gridLength && this.gridLine.enabled ? data : []);
    this.tickLineGroupSelection.update(this.tick.enabled ? data : []);
    this.tickLabelGroupSelection.update(this.label.enabled ? data : []);
    this.gridLineGroupSelection.cleanup();
    this.tickLineGroupSelection.cleanup();
    this.tickLabelGroupSelection.cleanup();
  }
  updatePosition() {
    super.updatePosition();
    const { translation, radiusLineGroup } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    radiusLineGroup.translationX = translationX;
    radiusLineGroup.translationY = translationY;
  }
  updateRadiusLine() {
    const node = this.radiusLine;
    const { path } = node;
    path.clear(true);
    const { points, closePath } = this.getAxisLinePoints();
    points.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
      if (arc) {
        path.arc(x, y, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (closePath) {
      path.closePath();
    }
    node.visible = this.line.enabled;
    node.stroke = this.line.stroke;
    node.strokeWidth = this.line.width;
    node.fill = void 0;
  }
  getAxisLinePoints() {
    const { scale: scale2, shape, gridLength: radius } = this;
    const [startAngle, endAngle] = this.range;
    const isFullCircle = isNumberEqual(endAngle - startAngle, 2 * Math.PI);
    const points = [];
    if (shape === "circle") {
      if (isFullCircle) {
        points.push(
          { x: radius, y: 0, moveTo: true },
          {
            x: 0,
            y: 0,
            radius,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            arc: true,
            moveTo: false
          }
        );
      } else {
        points.push(
          {
            x: radius * Math.cos(startAngle),
            y: radius * Math.sin(startAngle),
            moveTo: true
          },
          {
            x: 0,
            y: 0,
            radius,
            startAngle: normalizeAngle36022(startAngle),
            endAngle: normalizeAngle36022(endAngle),
            arc: true,
            moveTo: false
          }
        );
      }
    } else if (shape === "polygon") {
      const angles = scale2.ticks({
        nice: this.nice,
        interval: void 0,
        tickCount: void 0,
        minTickCount: 0,
        maxTickCount: Infinity
      })?.ticks?.map((value) => scale2.convert(value));
      if (angles && angles.length > 2) {
        angles.forEach((angle2, i) => {
          const x = radius * Math.cos(angle2);
          const y = radius * Math.sin(angle2);
          const moveTo = i === 0;
          points.push({ x, y, moveTo });
        });
      }
    }
    return { points, closePath: isFullCircle };
  }
  updateGridLines() {
    const {
      scale: scale2,
      gridLength: radius,
      gridLine: { style: style2, width: width2 },
      innerRadiusRatio
    } = this;
    if (!(style2 && radius > 0)) {
      return;
    }
    const innerRadius = radius * innerRadiusRatio;
    const styleCount = style2.length;
    this.gridLineGroupSelection.each((line, datum, index) => {
      const { value } = datum;
      const { stroke: stroke22, lineDash } = style2[index % styleCount];
      const angle2 = scale2.convert(value);
      line.x1 = innerRadius * Math.cos(angle2);
      line.y1 = innerRadius * Math.sin(angle2);
      line.x2 = radius * Math.cos(angle2);
      line.y2 = radius * Math.sin(angle2);
      line.stroke = stroke22;
      line.strokeWidth = width2;
      line.lineDash = lineDash;
      line.fill = void 0;
    });
    this.gridLineGroupSelection.cleanup();
  }
  updateLabels() {
    const { label, tickLabelGroupSelection } = this;
    tickLabelGroupSelection.each((node, _, index) => {
      const labelDatum = this.labelData[index];
      if (!labelDatum || labelDatum.hidden) {
        node.visible = false;
        return;
      }
      node.text = labelDatum.text;
      node.setFont(label);
      node.fill = label.color;
      node.x = labelDatum.x;
      node.y = labelDatum.y;
      node.setAlign(labelDatum);
      node.setBoxing(label);
      node.visible = true;
      if (labelDatum.rotation) {
        node.rotation = labelDatum.rotation;
        node.rotationCenterX = labelDatum.x;
        node.rotationCenterY = labelDatum.y;
      } else {
        node.rotation = 0;
      }
    });
  }
  updateTickLines() {
    const { scale: scale2, gridLength: radius, tick, tickLineGroupSelection } = this;
    tickLineGroupSelection.each((line, datum) => {
      const { value } = datum;
      const angle2 = scale2.convert(value);
      const cos = Math.cos(angle2);
      const sin = Math.sin(angle2);
      line.x1 = radius * cos;
      line.y1 = radius * sin;
      line.x2 = (radius + tick.size) * cos;
      line.y2 = (radius + tick.size) * sin;
      line.stroke = tick.stroke;
      line.strokeWidth = tick.width;
    });
  }
  createLabelNodeData(ticks, options, seriesRect) {
    const { label, gridLength: radius, scale: scale2, tick } = this;
    if (!label.enabled) {
      return [];
    }
    const tempText2 = new RotatableText22();
    const seriesLeft = seriesRect.x - this.translation.x;
    const seriesRight = seriesRect.x + seriesRect.width - this.translation.x;
    const { fractionDigits } = this.layout.label;
    const axisTickFormatter = this.tickFormatter(this.scale.domain, this.tickData, false, fractionDigits);
    const labelData = ticks.map((datum, index) => {
      const { value } = datum;
      const distance2 = radius + label.spacing + tick.size;
      const angle2 = scale2.convert(value);
      const cos = Math.cos(angle2);
      const sin = Math.sin(angle2);
      const x = distance2 * cos;
      const y = distance2 * sin;
      const { textAlign, textBaseline } = this.getLabelAlign(angle2);
      const isLastTickOverFirst = index === ticks.length - 1 && value !== ticks[0] && isNumberEqual(normalizeAngle36022(angle2), normalizeAngle36022(scale2.convert(ticks[0])));
      const rotation = this.getLabelRotation(angle2);
      let text2 = axisTickFormatter(value, index);
      tempText2.text = text2;
      tempText2.x = x;
      tempText2.y = y;
      tempText2.setFont(label);
      tempText2.textAlign = textAlign;
      tempText2.textBaseline = textBaseline;
      tempText2.rotation = rotation;
      if (rotation) {
        tempText2.rotationCenterX = x;
        tempText2.rotationCenterY = y;
      }
      let box = rotation ? Transformable2.toCanvas(tempText2) : tempText2.getBBox();
      if (box && options.hideWhenNecessary && !rotation) {
        const overflowLeft = seriesLeft - box.x;
        const overflowRight = box.x + box.width - seriesRight;
        const pixelError = 1;
        if (overflowLeft > pixelError || overflowRight > pixelError) {
          const availWidth = box.width - Math.max(overflowLeft, overflowRight);
          text2 = TextWrapper2.wrapText(text2, { maxWidth: availWidth, font: label, textWrap: "never" });
          if (text2 === TextUtils2.EllipsisChar) {
            text2 = "";
          }
          tempText2.text = text2;
          box = tempText2.getBBox();
        }
      }
      return {
        text: text2,
        x,
        y,
        textAlign,
        textBaseline,
        hidden: text2 === "" || datum.hidden || isLastTickOverFirst,
        rotation,
        box
      };
    });
    if (label.avoidCollisions) {
      this.avoidLabelCollisions(labelData);
    }
    return labelData;
  }
  computeLabelsBBox(options, seriesRect) {
    this.labelData = this.createLabelNodeData(this.tickData, options, seriesRect);
    const textBoxes = this.labelData.map(({ box }) => box).filter((box) => box != null);
    if (!this.label.enabled || textBoxes.length === 0) {
      return null;
    }
    return BBox2.merge(textBoxes);
  }
  getLabelOrientation() {
    const { label } = this;
    return label instanceof AngleAxisLabel ? label.orientation : "fixed";
  }
  getLabelRotation(tickAngle) {
    let rotation = toRadians2(this.label.rotation ?? 0);
    tickAngle = normalizeAngle36022(tickAngle);
    const orientation = this.getLabelOrientation();
    if (orientation === "parallel") {
      rotation += tickAngle;
      if (tickAngle >= 0 && tickAngle < Math.PI) {
        rotation -= Math.PI / 2;
      } else {
        rotation += Math.PI / 2;
      }
    } else if (orientation === "perpendicular") {
      rotation += tickAngle;
      if (tickAngle >= Math.PI / 2 && tickAngle < 1.5 * Math.PI) {
        rotation += Math.PI;
      }
    }
    return rotation;
  }
  getLabelAlign(tickAngle) {
    const cos = Math.cos(tickAngle);
    const sin = Math.sin(tickAngle);
    let textAlign;
    let textBaseline;
    const orientation = this.getLabelOrientation();
    const isCos0 = isNumberEqual(cos, 0);
    const isSin0 = isNumberEqual(sin, 0);
    const isCos1 = isNumberEqual(cos, 1);
    const isSinMinus1 = isNumberEqual(sin, -1);
    const isCosPositive = cos > 0 && !isCos0;
    const isSinPositive = sin > 0 && !isSin0;
    if (orientation === "parallel") {
      textAlign = "center";
      textBaseline = isCos1 && isSin0 || isSinPositive ? "top" : "bottom";
    } else if (orientation === "perpendicular") {
      textAlign = isSinMinus1 || isCosPositive ? "left" : "right";
      textBaseline = "middle";
    } else {
      textAlign = "right";
      if (isCos0) {
        textAlign = "center";
      } else if (isCosPositive) {
        textAlign = "left";
      }
      textBaseline = "bottom";
      if (isSin0) {
        textBaseline = "middle";
      } else if (isSinPositive) {
        textBaseline = "top";
      }
    }
    return { textAlign, textBaseline };
  }
  updateCrossLines() {
    const { shape, gridLength: radius, innerRadiusRatio } = this;
    this.crossLines.forEach((crossLine) => {
      if (crossLine instanceof AngleCrossLine) {
        crossLine.ticks = this.tickData.map((t) => t.value);
        crossLine.shape = shape;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines();
  }
};
AngleAxis.CrossLineConstructor = AngleCrossLine;
__decorateClass2([
  Property3
], AngleAxis.prototype, "startAngle", 2);
__decorateClass2([
  Property3
], AngleAxis.prototype, "endAngle", 2);
var { Property: Property4, CategoryScale: CategoryScale2 } = module_support_exports;
var AngleCategoryAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new CategoryScale2());
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
    this.interval = new AngleAxisInterval();
  }
  hasDefinedDomain() {
    return false;
  }
  generateAngleTicks(domain) {
    const { scale: scale2, gridLength: radius } = this;
    const { values, minSpacing } = this.interval;
    const tickParams = {
      nice: this.nice,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    };
    const ticks = values ?? scale2.ticks(tickParams, domain)?.ticks ?? [];
    if (ticks.length < 2 || minSpacing == null) {
      return ticks.map((value) => {
        return { value, visible: true };
      });
    }
    const startTick = ticks[0];
    const startAngle = scale2.convert(startTick);
    const startX = radius * Math.cos(startAngle);
    const startY = radius * Math.sin(startAngle);
    for (let step = 1; step < ticks.length - 1; step++) {
      const nextTick = ticks[step];
      const nextAngle = scale2.convert(nextTick);
      if (nextAngle - startAngle > Math.PI) {
        break;
      }
      const nextX = radius * Math.cos(nextAngle);
      const nextY = radius * Math.sin(nextAngle);
      const spacing = Math.sqrt((nextX - startX) ** 2 + (nextY - startY) ** 2);
      if (spacing > minSpacing) {
        const visibleTicks = /* @__PURE__ */ new Set([startTick]);
        loopSymmetrically(ticks, step, (_, next) => {
          visibleTicks.add(next);
        });
        return ticks.map((value) => {
          const visible = visibleTicks.has(value);
          return { value, visible };
        });
      }
    }
    return [{ value: startTick, visible: true }];
  }
  avoidLabelCollisions(labelData) {
    const { minSpacing } = this.label;
    if (labelData.length < 3)
      return;
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      } else if (minSpacing == null) {
        return prev.box.collidesBBox(next.box);
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    const visibleLabels = /* @__PURE__ */ new Set([firstLabel]);
    const lastLabelIsOverFirst = isNumberEqual(firstLabel.x, lastLabel.x) && isNumberEqual(firstLabel.y, lastLabel.y);
    const maxStep = Math.floor(labelData.length / 2);
    for (let step = 1; step <= maxStep; step++) {
      const labels = lastLabelIsOverFirst ? labelData.slice(0, -1) : labelData;
      const collisionDetected = loopSymmetrically(labels, step, labelsCollide);
      if (!collisionDetected) {
        loopSymmetrically(labels, step, (_, next) => {
          visibleLabels.add(next);
        });
        break;
      }
    }
    labelData.forEach((datum) => {
      if (!visibleLabels.has(datum)) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
  tickFormatParams() {
    return { type: "category" };
  }
  datumFormatParams(value, params) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    return { type: "category", value, datum, seriesId, legendItemName, key, source, property, domain, boundSeries };
  }
};
AngleCategoryAxis.className = "AngleCategoryAxis";
AngleCategoryAxis.type = "angle-category";
__decorateClass2([
  Property4
], AngleCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass2([
  Property4
], AngleCategoryAxis.prototype, "paddingInner", 2);
__decorateClass2([
  Property4
], AngleCategoryAxis.prototype, "interval", 2);
var AngleCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-category",
  moduleFactory: (ctx) => new AngleCategoryAxis(ctx)
};
var { range: range3, isDenseInterval: isDenseInterval2, LinearScale: LinearScale2 } = module_support_exports;
var LinearAngleScale = class _LinearAngleScale extends LinearScale2 {
  constructor() {
    super(...arguments);
    this.arcLength = 0;
  }
  static getNiceStepAndTickCount(ticks, domain) {
    const [start2, stop] = domain;
    let step = LinearScale2.getTickStep(start2, stop, ticks);
    const maxTickCount = isNaN(ticks.maxTickCount) ? Infinity : ticks.maxTickCount;
    const expectedTickCount = Math.abs(stop - start2) / step;
    let niceTickCount = Math.pow(2, Math.ceil(Math.log(expectedTickCount) / Math.log(2)));
    if (niceTickCount > maxTickCount) {
      niceTickCount /= 2;
      step *= 2;
    }
    return { count: niceTickCount, step };
  }
  ticks(ticks, domain = this.domain) {
    const { arcLength } = this;
    if (!domain || domain.length < 2 || domain.some((d) => !isFinite(d)) || arcLength <= 0) {
      return { ticks: [], count: 0 };
    }
    const { nice, interval } = ticks;
    const [d0, d1] = domain;
    if (interval) {
      const step2 = Math.abs(interval);
      const availableRange = this.getPixelRange();
      if (!isDenseInterval2((d1 - d0) / step2, availableRange)) {
        return range3(d0, d1, step2);
      }
    }
    let step;
    if (nice && this.hasNiceRange()) {
      const linearNiceDomain = super.niceDomain(ticks, domain);
      step = _LinearAngleScale.getNiceStepAndTickCount(ticks, linearNiceDomain).step;
    } else {
      step = LinearScale2.getTickStep(d0, d1, ticks);
    }
    return range3(d0, d1, step);
  }
  hasNiceRange() {
    const sortedRange = this.range.slice().sort((a, b) => a - b);
    const niceRanges = [Math.PI, 2 * Math.PI];
    return niceRanges.some((r) => isNumberEqual(r, sortedRange[1] - sortedRange[0]));
  }
  niceDomain(ticks, domain = this.domain) {
    const linearNiceDomain = super.niceDomain(ticks, domain);
    if (!this.hasNiceRange())
      return linearNiceDomain;
    const reversed = linearNiceDomain[0] > linearNiceDomain[1];
    const start2 = reversed ? linearNiceDomain[1] : linearNiceDomain[0];
    const { step, count } = _LinearAngleScale.getNiceStepAndTickCount(ticks, linearNiceDomain);
    const s = 1 / step;
    const stop = step >= 1 ? Math.ceil(start2 / step + count) * step : Math.ceil((start2 + count * step) * s) / s;
    return reversed ? [stop, start2] : [start2, stop];
  }
  getPixelRange() {
    return this.arcLength;
  }
};
var { Property: Property5, angleBetween: angleBetween2, normalisedExtentWithMetadata: normalisedExtentWithMetadata2, findMinMax: findMinMax2 } = module_support_exports;
var AngleNumberAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearAngleScale());
    this.shape = "circle";
    this.interval = new AngleAxisInterval();
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent3, clipped } = normalisedExtentWithMetadata2(d, min, max);
    return { domain: extent3, clipped };
  }
  updateScale() {
    super.updateScale();
    this.scale.arcLength = this.getRangeArcLength();
  }
  getRangeArcLength() {
    const { range: requestedRange } = this;
    const min = Math.min(...requestedRange);
    const max = Math.max(...requestedRange);
    const rotation = angleBetween2(min, max) || 2 * Math.PI;
    const radius = this.gridLength;
    return rotation * radius;
  }
  generateAngleTicks(domain) {
    const { scale: scale2, range: requestedRange, nice } = this;
    const { values, step, minSpacing, maxSpacing } = this.interval;
    let rawTicks;
    if (values == null) {
      const { arcLength } = scale2;
      const minTickCount = maxSpacing ? Math.floor(arcLength / maxSpacing) : 1;
      const maxTickCount = minSpacing ? Math.floor(arcLength / minSpacing) : Infinity;
      const preferredTickCount = Math.floor(4 / Math.PI * Math.abs(requestedRange[0] - requestedRange[1]));
      const tickCount = Math.max(minTickCount, Math.min(maxTickCount, preferredTickCount));
      const tickParams = {
        nice,
        interval: step,
        tickCount,
        minTickCount,
        maxTickCount
      };
      rawTicks = scale2.ticks(tickParams, domain)?.ticks ?? [];
    } else {
      const [d0, d1] = findMinMax2(domain.map(Number));
      rawTicks = values.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);
    }
    return rawTicks.map((value) => ({ value, visible: true }));
  }
  avoidLabelCollisions(labelData) {
    const { minSpacing } = this.label;
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      } else if (minSpacing == null) {
        return prev.box.collidesBBox(next.box);
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    if (firstLabel !== lastLabel && isNumberEqual(firstLabel.x, lastLabel.x) && isNumberEqual(firstLabel.y, lastLabel.y)) {
      lastLabel.hidden = true;
    }
    for (let step = 1; step < labelData.length; step *= 2) {
      let collisionDetected = false;
      for (let i = step; i < labelData.length; i += step) {
        const next = labelData[i];
        const prev = labelData[i - step];
        if (labelsCollide(prev, next)) {
          collisionDetected = true;
          break;
        }
      }
      if (!collisionDetected) {
        labelData.forEach((datum, i) => {
          if (i % step > 0) {
            datum.hidden = true;
            datum.box = void 0;
          }
        });
        return;
      }
    }
    labelData.forEach((datum, i) => {
      if (i > 0) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
  tickFormatParams(_domain, _ticks, fractionDigits) {
    return { type: "number", fractionDigits };
  }
  datumFormatParams(value, params, fractionDigits) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    return {
      type: "number",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      fractionDigits
    };
  }
};
AngleNumberAxis.className = "AngleNumberAxis";
AngleNumberAxis.type = "angle-number";
__decorateClass2([
  Property5
], AngleNumberAxis.prototype, "min", 2);
__decorateClass2([
  Property5
], AngleNumberAxis.prototype, "max", 2);
__decorateClass2([
  Property5
], AngleNumberAxis.prototype, "interval", 2);
var AngleNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-number",
  moduleFactory: (ctx) => new AngleNumberAxis(ctx)
};
var {
  OrdinalTimeScale: OrdinalTimeScale2,
  Property: Property6,
  TimeAxisParentLevel: TimeAxisParentLevel2,
  lowestGranularityUnitForTicks: lowestGranularityUnitForTicks2,
  lowestGranularityUnitForValue: lowestGranularityUnitForValue2,
  minimumTimeAxisDatumGranularity: minimumTimeAxisDatumGranularity2,
  dateTruncationForDomain: dateTruncationForDomain2,
  intervalUnit: intervalUnit2,
  intervalStep: intervalStep2,
  intervalEpoch: intervalEpoch2,
  intervalMilliseconds: intervalMilliseconds2
} = module_support_exports;
var OrdinalTimeAxis = class extends module_support_exports.DiscreteTimeAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new OrdinalTimeScale2());
    this.parentLevel = new TimeAxisParentLevel2();
    this.minimumTimeGranularity = void 0;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  processData() {
    super.processData();
    const { boundSeries, direction } = this;
    this.minimumTimeGranularity = minimumTimeAxisDatumGranularity2(boundSeries, direction, void 0, void 0);
  }
  tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
    timeInterval3 ?? (timeInterval3 = lowestGranularityUnitForTicks2(ticks));
    const truncateDate = dateTruncationForDomain2(domain);
    const unit = intervalUnit2(timeInterval3);
    const step = intervalStep2(timeInterval3);
    const epoch = intervalEpoch2(timeInterval3);
    return { type: "date", unit, step, epoch, truncateDate };
  }
  datumFormatParams(value, params, _fractionDigits, timeInterval3, style2) {
    if (typeof value === "number")
      value = new Date(value);
    if (timeInterval3 == null) {
      const { minimumTimeGranularity } = this;
      const datumGranularity = lowestGranularityUnitForValue2(value);
      if (minimumTimeGranularity != null && intervalMilliseconds2(minimumTimeGranularity) < intervalMilliseconds2(datumGranularity)) {
        timeInterval3 = minimumTimeGranularity;
      } else {
        timeInterval3 = datumGranularity;
      }
    }
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    const unit = intervalUnit2(timeInterval3);
    const step = intervalStep2(timeInterval3);
    const epoch = intervalEpoch2(timeInterval3);
    return {
      type: "date",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      unit,
      step,
      epoch,
      style: style2
    };
  }
};
OrdinalTimeAxis.className = "OrdinalTimeAxis";
OrdinalTimeAxis.type = "ordinal-time";
__decorateClass2([
  Property6
], OrdinalTimeAxis.prototype, "parentLevel", 2);
var OrdinalTimeAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "ordinal-time",
  moduleFactory: (ctx) => new OrdinalTimeAxis(ctx)
};
var {
  ChartAxisDirection: ChartAxisDirection4,
  Property: Property7,
  validateCrossLineValue: validateCrossLineValue22,
  normalizeAngle360FromDegrees: normalizeAngle360FromDegrees2,
  Group: Group32,
  Path: Path3,
  Sector: Sector22,
  RotatableText: RotatableText3
} = module_support_exports;
var RadiusCrossLineLabel = class extends PolarCrossLineLabel {
  constructor() {
    super(...arguments);
    this.positionAngle = void 0;
  }
};
__decorateClass2([
  Property7
], RadiusCrossLineLabel.prototype, "positionAngle", 2);
var RadiusCrossLine = class extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection4.Radius;
    this.label = new RadiusCrossLineLabel();
    this.polygonNode = new Path3();
    this.sectorNode = new Sector22();
    this.crossLineRange = new Group32();
    this.labelNode = new RotatableText3();
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.crossLineRange.append(this.polygonNode);
    this.crossLineRange.append(this.sectorNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale: scale2 } = this;
    if (!scale2 || !validateCrossLineValue22(this, scale2)) {
      this.rangeGroup.visible = false;
      this.lineGroup.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.updateRadii();
    const { innerRadius, outerRadius } = this;
    visible && (visible = innerRadius >= this.axisInnerRadius && outerRadius <= this.axisOuterRadius);
    this.rangeGroup.visible = visible;
    this.lineGroup.visible = visible;
    this.labelGroup.visible = visible;
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
    this.assignCrossLineGroup(this.type === "range", this.crossLineRange);
  }
  updateRadii() {
    const { range: range22, scale: scale2, type, axisInnerRadius, axisOuterRadius } = this;
    if (!scale2)
      return { innerRadius: 0, outerRadius: 0 };
    const getRadius = (value) => axisOuterRadius + axisInnerRadius - value;
    let outerRadius, innerRadius;
    if (type === "line") {
      outerRadius = getRadius(scale2.convert(this.value));
      innerRadius = outerRadius;
    } else {
      const bandwidth = Math.abs(scale2?.bandwidth ?? 0);
      const convertedRange = range22.map((r) => scale2.convert(r));
      outerRadius = getRadius(Math.max(...convertedRange));
      innerRadius = getRadius(Math.min(...convertedRange)) + bandwidth;
    }
    this.outerRadius = outerRadius;
    this.innerRadius = innerRadius;
  }
  drawPolygon(radius, angles, polygon) {
    angles.forEach((angle2, index) => {
      const x = radius * Math.cos(angle2);
      const y = radius * Math.sin(angle2);
      if (index === 0) {
        polygon.path.moveTo(x, y);
      } else {
        polygon.path.lineTo(x, y);
      }
    });
    polygon.path.closePath();
  }
  updatePolygonNode(visible) {
    const { gridAngles, polygonNode: polygon, scale: scale2, shape, type, innerRadius, outerRadius } = this;
    if (!visible || shape !== "polygon" || !scale2 || !gridAngles) {
      polygon.visible = false;
      return;
    }
    polygon.visible = true;
    const padding2 = this.getPadding();
    polygon.path.clear(true);
    this.drawPolygon(outerRadius - padding2, gridAngles, polygon);
    const reversedAngles = gridAngles.slice().reverse();
    const innerPolygonRadius = type === "line" ? outerRadius - padding2 : innerRadius + padding2;
    this.drawPolygon(innerPolygonRadius, reversedAngles, polygon);
    this.setSectorNodeProps(polygon);
  }
  updateSectorNode(visible) {
    const { axisInnerRadius, axisOuterRadius, scale: scale2, sectorNode: sector, shape, innerRadius, outerRadius } = this;
    if (!visible || shape !== "circle" || !scale2) {
      sector.visible = false;
      return;
    }
    sector.visible = true;
    sector.startAngle = 0;
    sector.endAngle = 2 * Math.PI;
    const padding2 = this.getPadding();
    const r0 = clamp(axisInnerRadius, innerRadius + padding2, axisOuterRadius);
    const r1 = clamp(axisInnerRadius, outerRadius - padding2, axisOuterRadius);
    sector.innerRadius = Math.min(r0, r1);
    sector.outerRadius = Math.max(r0, r1);
    this.setSectorNodeProps(sector);
  }
  updateLabelNode(visible) {
    const { innerRadius, label, labelNode: node, scale: scale2, shape, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale2) {
      node.visible = false;
      return;
    }
    const angle2 = normalizeAngle360FromDegrees2((label.positionAngle ?? 0) - 90);
    const isBottomSide = (isNumberEqual(angle2, 0) || angle2 > 0) && angle2 < Math.PI;
    const rotation = isBottomSide ? angle2 - Math.PI / 2 : angle2 + Math.PI / 2;
    let distance2;
    const angles = this.gridAngles ?? [];
    if (type === "line") {
      distance2 = innerRadius + label.padding;
    } else if (shape === "circle" || angles.length < 3) {
      distance2 = innerRadius - label.padding;
    } else {
      distance2 = innerRadius * Math.cos(Math.PI / angles.length) - label.padding;
    }
    const labelX = distance2 * Math.cos(angle2);
    const labelY = distance2 * Math.sin(angle2);
    let textBaseline;
    if (type === "line") {
      textBaseline = isBottomSide ? "top" : "bottom";
    } else {
      textBaseline = isBottomSide ? "bottom" : "top";
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
  getPadding() {
    const { scale: scale2 } = this;
    if (!scale2)
      return 0;
    const bandwidth = Math.abs(scale2.bandwidth ?? 0);
    const step = Math.abs(scale2.step ?? 0);
    return scale2 instanceof module_support_exports.BandScale ? (step - bandwidth) / 2 : 0;
  }
};
RadiusCrossLine.className = "RadiusCrossLine";
var {
  ChartAxisDirection: ChartAxisDirection5,
  ZIndexMap: ZIndexMap2,
  Property: Property8,
  normalizeAngle360: normalizeAngle3603,
  toRadians: toRadians22,
  Caption: Caption2,
  Group: Group42,
  TransformableGroup: TransformableGroup2,
  Path: Path4,
  Line: Line22,
  Selection: Selection22,
  AxisTickGenerator: AxisTickGenerator2,
  AxisGroupZIndexMap: AxisGroupZIndexMap2
} = module_support_exports;
var RadiusAxisLabel = class extends module_support_exports.AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass2([
  Property8
], RadiusAxisLabel.prototype, "autoRotate", 2);
__decorateClass2([
  Property8
], RadiusAxisLabel.prototype, "autoRotateAngle", 2);
var RadiusAxis = class extends module_support_exports.PolarAxis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.positionAngle = 0;
    this.gridLineGroupSelection = Selection22.select(
      this.gridLineGroup,
      Line22,
      false
    );
    this.tickGenerator = new AxisTickGenerator2(this);
    this.generatedTicks = void 0;
    this.headingLabelGroup = this.axisGroup.appendChild(
      new TransformableGroup2({ name: `${this.id}-Axis-heading` })
    );
    this.lineNodeGroup = this.axisGroup.appendChild(
      new TransformableGroup2({ name: `${this.id}-Axis-line` })
    );
    this.lineNode = this.lineNodeGroup.appendChild(
      new Line22({
        name: `${this.id}-Axis-line`,
        zIndex: AxisGroupZIndexMap2.AxisLine
      })
    );
    this.gridPathGroup = this.gridGroup.appendChild(
      new Group42({
        name: `${this.id}-gridPaths`,
        zIndex: ZIndexMap2.AXIS_GRID
      })
    );
    this.gridPathSelection = Selection22.select(this.gridPathGroup, Path4);
    this.headingLabelGroup.appendChild(this.title.caption.node);
    this.cleanup.register(this.title.caption.registerInteraction(this.moduleCtx, "afterend"));
  }
  get direction() {
    return ChartAxisDirection5.Radius;
  }
  getAxisTransform() {
    const maxRadius = this.scale.range[0];
    const { translation, positionAngle, innerRadiusRatio } = this;
    const innerRadius = maxRadius * innerRadiusRatio;
    const rotation = toRadians22(positionAngle);
    return {
      translationX: translation.x,
      translationY: translation.y - maxRadius - innerRadius,
      rotation,
      rotationCenterX: 0,
      rotationCenterY: maxRadius + innerRadius
    };
  }
  update() {
    super.update();
    this.updateTitle();
    this.updateGridLines();
    const { enabled, stroke: stroke22, width: width2 } = this.line;
    this.lineNode.setProperties({
      stroke: stroke22,
      strokeWidth: enabled ? width2 : 0,
      x1: 0,
      y1: this.range[0],
      x2: 0,
      y2: this.range[1]
    });
  }
  updatePosition() {
    super.updatePosition();
    const axisTransform = this.getAxisTransform();
    this.tickLineGroup.setProperties(axisTransform);
    this.tickLabelGroup.setProperties(axisTransform);
    this.lineNodeGroup.setProperties(axisTransform);
    this.headingLabelGroup.setProperties(axisTransform);
  }
  calculateRotations() {
    const rotation = 0;
    const parallelFlipRotation = 0;
    const regularFlipRotation = -Math.PI / 2;
    return { rotation, parallelFlipRotation, regularFlipRotation };
  }
  calculateTickLayout(domain, niceMode, _visibleRange) {
    const parallelFlipRotation = 0;
    const regularFlipRotation = -Math.PI / 2;
    const visibleRange = [0, 1];
    const sideFlag = this.label.getSideFlag();
    const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);
    const { range: range22, reverse, defaultTickMinSpacing } = this;
    const tickGenerationResult = this.tickGenerator.generateTicks({
      domain,
      range: range22,
      reverse,
      niceMode,
      visibleRange,
      primaryTickCount: void 0,
      defaultTickMinSpacing,
      parallelFlipRotation,
      regularFlipRotation,
      labelX,
      sideFlag,
      sizeLimit: void 0,
      removeOverflowLabels: false
    });
    const { tickData } = tickGenerationResult;
    const { ticks, rawTicks, rawTickCount, tickDomain, fractionDigits, niceDomain = domain } = tickData;
    const labels = ticks.map((d) => this.getTickLabelProps(d, tickGenerationResult));
    this.generatedTicks = { ticks, labels };
    return { ticks: rawTicks, tickDomain, niceDomain, rawTickCount, fractionDigits, timeInterval: void 0 };
  }
  updateSelections() {
    const { generatedTicks } = this;
    if (!generatedTicks)
      return;
    const { ticks, labels } = generatedTicks;
    this.gridLineGroupSelection.update(this.gridLength ? ticks : []);
    this.tickLabelGroupSelection.update(labels);
    this.gridPathSelection.update(this.gridLine.enabled ? this.prepareGridPathTickData(ticks) : []);
    this.gridLineGroupSelection.cleanup();
    this.tickLabelGroupSelection.cleanup();
    this.gridPathSelection.cleanup();
  }
  // TODO - abstract out
  updateLabels() {
    if (!this.label.enabled)
      return;
    const axisLabelPositionFn = module_support_exports.resetAxisLabelSelectionFn();
    this.tickLabelGroupSelection.each((node, datum) => {
      node.fill = datum.color;
      node.text = datum.text;
      node.textBaseline = datum.textBaseline;
      node.textAlign = datum.textAlign ?? "center";
      node.setFont(datum);
      node.setBoxing(datum);
      node.setProperties(axisLabelPositionFn(node, datum));
    });
  }
  updateGridLines() {
    const {
      gridLine: { style: style2, width: width2 },
      shape,
      generatedTicks
    } = this;
    if (!style2 || !generatedTicks) {
      return;
    }
    const styleCount = style2.length;
    const setStyle = (node, index) => {
      const { stroke: stroke22, lineDash } = style2[index % styleCount];
      node.stroke = stroke22;
      node.strokeWidth = width2;
      node.lineDash = lineDash;
      node.fill = void 0;
    };
    const [startAngle, endAngle] = this.gridRange ?? [0, 2 * Math.PI];
    const isFullCircle = isNumberEqual(endAngle - startAngle, 2 * Math.PI);
    const drawCircleShape = (node, value) => {
      const { path } = node;
      path.clear(true);
      const radius = this.getTickRadius(value);
      if (isFullCircle) {
        path.moveTo(radius, 0);
        path.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        path.moveTo(radius * Math.cos(startAngle), radius * Math.sin(startAngle));
        path.arc(0, 0, radius, normalizeAngle3603(startAngle), normalizeAngle3603(endAngle));
      }
      if (isFullCircle) {
        path.closePath();
      }
    };
    const drawPolygonShape = (node, value) => {
      const { path } = node;
      const angles = this.gridAngles;
      path.clear(true);
      if (!angles || angles.length < 3) {
        return;
      }
      const radius = this.getTickRadius(value);
      angles.forEach((angle2, idx) => {
        const x = radius * Math.cos(angle2);
        const y = radius * Math.sin(angle2);
        if (idx === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        angles.forEach((innerAngle, innerIdx) => {
          const x2 = radius * Math.cos(innerAngle);
          const y2 = radius * Math.sin(innerAngle);
          if (innerIdx === 0) {
            path.moveTo(x2, y2);
          } else {
            path.lineTo(x2, y2);
          }
        });
        path.closePath();
      });
      path.closePath();
    };
    const drawFn = shape === "circle" ? drawCircleShape : drawPolygonShape;
    this.gridPathSelection.each((node, value, index) => {
      setStyle(node, index);
      drawFn(node, value);
    });
  }
  updateTitle() {
    const identityFormatter = (params) => params.defaultValue;
    const { title, range: requestedRange } = this;
    const { formatter: formatter2 = identityFormatter } = this.title;
    title.caption.enabled = title.enabled;
    title.caption.fontFamily = title.fontFamily;
    title.caption.fontSize = title.fontSize;
    title.caption.fontStyle = title.fontStyle;
    title.caption.fontWeight = title.fontWeight;
    title.caption.color = title.color;
    title.caption.wrapping = title.wrapping;
    let titleVisible = false;
    const titleNode = title.caption.node;
    if (title.enabled) {
      titleVisible = true;
      titleNode.rotation = Math.PI / 2;
      titleNode.x = Math.floor((requestedRange[0] + requestedRange[1]) / 2);
      titleNode.y = -Caption2.SMALL_PADDING;
      titleNode.textAlign = "center";
      titleNode.textBaseline = "bottom";
      titleNode.text = this.cachedCallWithContext(formatter2, this.getTitleFormatterParams(this.scale.domain));
    }
    titleNode.visible = titleVisible;
  }
  updateCrossLines() {
    this.crossLines.forEach((crossLine) => {
      if (crossLine instanceof RadiusCrossLine) {
        const { shape, gridAngles, range: range22, innerRadiusRatio } = this;
        const radius = range22[0];
        crossLine.shape = shape;
        crossLine.gridAngles = gridAngles;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines();
  }
  createLabel() {
    return new RadiusAxisLabel();
  }
  // TODO - abstract out (shared with cartesian axis)
  getTickLabelProps(datum, tickGenerationResult) {
    const { label } = this;
    const { rotation, textBaseline, textAlign } = tickGenerationResult;
    const range22 = this.scale.range;
    const text2 = datum.tickLabel ?? "";
    const sideFlag = label.getSideFlag();
    const labelX = sideFlag * (this.getTickSize() + label.spacing + this.seriesAreaPadding);
    const visible = text2 !== "" && text2 != null;
    const combinedRotation = rotation;
    return {
      ...this.getLabelStyles({ value: datum.tickLabel }),
      tickId: datum.tickId,
      rotation: combinedRotation,
      text: text2,
      textAlign,
      textBaseline,
      visible,
      x: labelX,
      y: datum.translation,
      rotationCenterX: labelX,
      rotationCenterY: datum.translation,
      range: range22
    };
  }
};
RadiusAxis.CrossLineConstructor = RadiusCrossLine;
__decorateClass2([
  Property8
], RadiusAxis.prototype, "positionAngle", 2);
var { ProxyPropertyOnWrite: ProxyPropertyOnWrite2, Property: Property9, CategoryScale: CategoryScale22 } = module_support_exports;
var RadiusCategoryAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new CategoryScale22());
    this.shape = "circle";
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
    this.paddingOuter = 0;
  }
  hasDefinedDomain() {
    return false;
  }
  normaliseDataDomain(domain) {
    return { domain, clipped: false };
  }
  prepareGridPathTickData(data) {
    return data.slice().reverse();
  }
  getTickRadius(tickDatum) {
    const { scale: scale2, innerRadiusRatio } = this;
    const maxRadius = scale2.range[0];
    const minRadius = maxRadius * innerRadiusRatio;
    if (CategoryScale22.is(scale2)) {
      const ticks = scale2.domain;
      const index = ticks.length - 1 - ticks.indexOf(tickDatum.tick);
      return index === 0 ? minRadius : scale2.inset + scale2.step * (index - 0.5) + scale2.bandwidth / 2;
    } else {
      const tickRange = (maxRadius - minRadius) / scale2.domain.length;
      return maxRadius - tickDatum.translation + minRadius - tickRange / 2;
    }
  }
  tickFormatParams() {
    return { type: "category" };
  }
  datumFormatParams(value, params) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    return { type: "category", value, datum, seriesId, legendItemName, key, source, property, domain, boundSeries };
  }
};
RadiusCategoryAxis.className = "RadiusCategoryAxis";
RadiusCategoryAxis.type = "radius-category";
__decorateClass2([
  Property9
], RadiusCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass2([
  ProxyPropertyOnWrite2("scale", "paddingInner"),
  Property9
], RadiusCategoryAxis.prototype, "paddingInner", 2);
__decorateClass2([
  ProxyPropertyOnWrite2("scale", "paddingOuter"),
  Property9
], RadiusCategoryAxis.prototype, "paddingOuter", 2);
var RadiusCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-category",
  moduleFactory: (ctx) => new RadiusCategoryAxis(ctx)
};
var { Property: Property10, normalisedExtentWithMetadata: normalisedExtentWithMetadata22, LinearScale: LinearScale22 } = module_support_exports;
var RadiusNumberAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearScale22());
    this.shape = "polygon";
  }
  hasDefinedDomain() {
    const { min, max } = this;
    return min != null && max != null && min < max;
  }
  prepareGridPathTickData(data) {
    const { scale: scale2 } = this;
    const domainTop = scale2.domain[1];
    return data.filter(({ tick }) => tick !== domainTop).sort((a, b) => b.tick - a.tick);
  }
  getTickRadius(tickDatum) {
    const { scale: scale2 } = this;
    const maxRadius = scale2.range[0];
    const minRadius = maxRadius * this.innerRadiusRatio;
    return maxRadius - tickDatum.translation + minRadius;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent3, clipped } = normalisedExtentWithMetadata22(d, min, max);
    return { domain: extent3, clipped };
  }
  tickFormatParams(_domain, _ticks, fractionDigits) {
    return { type: "number", fractionDigits };
  }
  datumFormatParams(value, params, fractionDigits) {
    const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
    return {
      type: "number",
      value,
      datum,
      seriesId,
      legendItemName,
      key,
      source,
      property,
      domain,
      boundSeries,
      fractionDigits
    };
  }
};
RadiusNumberAxis.className = "RadiusNumberAxis";
RadiusNumberAxis.type = "radius-number";
__decorateClass2([
  Property10
], RadiusNumberAxis.prototype, "min", 2);
__decorateClass2([
  Property10
], RadiusNumberAxis.prototype, "max", 2);
var RadiusNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-number",
  moduleFactory: (ctx) => new RadiusNumberAxis(ctx)
};
var { ObserveChanges: ObserveChanges2, Property: Property11 } = module_support_exports;
var Animation2 = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    ctx.animationManager.skip(false);
    this.cleanup.register(() => {
      ctx.animationManager.skip(true);
    });
  }
};
__decorateClass2([
  ObserveChanges2((target, newValue) => {
    target.ctx.animationManager.skip(!newValue);
  }),
  Property11
], Animation2.prototype, "enabled", 2);
__decorateClass2([
  ObserveChanges2((target, newValue) => {
    target.ctx.animationManager.defaultDuration = newValue;
  }),
  Property11
], Animation2.prototype, "duration", 2);
var AnimationModule = {
  type: "root",
  optionsKey: "animation",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new Animation2(ctx),
  themeTemplate: {
    animation: {
      enabled: true
    }
  }
};
var textInputTemplate_default = '<div contenteditable="plaintext-only" class="ag-charts-text-input__textarea" tabindex="0"></div>';
var { focusCursorAtEnd: focusCursorAtEnd2 } = module_support_exports;
var moduleId = "text-input";
var canvasOverlay2 = "canvas-overlay";
var TextInput = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.layout = {
      getTextInputCoords: () => ({ x: 0, y: 0 }),
      getTextPosition: () => "center",
      alignment: "center",
      textAlign: "center"
    };
    this.visible = false;
    this.element = ctx.domManager.addChild(canvasOverlay2, moduleId);
    this.element.classList.add("ag-charts-text-input");
    this.cleanup.register(() => ctx.domManager.removeChild(canvasOverlay2, moduleId));
  }
  setKeyDownHandler(handler) {
    this.cleanup.register(attachListener(this.element, "keydown", handler));
  }
  show(opts) {
    this.element.innerHTML = textInputTemplate_default;
    const textArea = this.element.firstElementChild;
    setAttributes(textArea, {
      role: "textbox",
      // AG-15233
      "data-preventdefault": false
      // AG-13715
    });
    if (!textArea.isContentEditable) {
      textArea.contentEditable = "true";
    }
    textArea.setAttribute(
      "placeholder",
      this.ctx.localeManager.t(opts.placeholderText ?? "inputTextareaPlaceholder")
    );
    if (opts.styles?.placeholderColor) {
      textArea.style.setProperty("--placeholder-text-color", opts.styles?.placeholderColor);
    }
    textArea.innerText = opts.text ?? "";
    textArea.style.color = opts.styles?.color ?? "inherit";
    textArea.style.fontFamily = opts.styles?.fontFamily ?? "inherit";
    textArea.style.fontSize = opts.styles?.fontSize ? `${opts.styles.fontSize}px` : "inherit";
    textArea.style.fontStyle = opts.styles?.fontStyle ?? "inherit";
    textArea.style.fontWeight = typeof opts.styles?.fontWeight === "number" ? `${opts.styles.fontWeight}` : opts.styles?.fontWeight ?? "inherit";
    focusCursorAtEnd2(textArea);
    textArea.addEventListener("input", () => {
      this.updatePosition();
      opts.onChange?.(this.getValue(), this.getBBox());
    });
    textArea.addEventListener("click", (event) => {
      event.stopPropagation();
    });
    if (opts.layout) {
      this.layout = opts.layout;
      this.updatePosition();
    }
    opts.onChange?.(this.getValue(), this.getBBox());
    this.visible = true;
  }
  hide() {
    this.element.innerHTML = "";
    this.layout = {
      getTextInputCoords: () => ({ x: 0, y: 0 }),
      getTextPosition: () => "center",
      alignment: "center",
      textAlign: "center"
    };
    this.visible = false;
  }
  isVisible() {
    return this.visible;
  }
  updateColor(color6) {
    if (!this.element.firstElementChild)
      return;
    this.element.firstElementChild.style.color = color6;
  }
  updateFontSize(fontSize) {
    if (!this.element.firstElementChild)
      return;
    this.element.firstElementChild.style.fontSize = `${fontSize}px`;
    this.updatePosition();
    return this.getBBox();
  }
  getValue() {
    if (!this.element.firstElementChild)
      return;
    return this.element.firstElementChild.innerText.trim();
  }
  updatePosition() {
    const { element: element2 } = this;
    const textArea = element2.firstElementChild;
    if (!textArea)
      return;
    const sceneRect = this.ctx.domManager.getBoundingClientRect();
    const { width: width2, getTextInputCoords, getTextPosition, alignment, textAlign } = this.layout;
    element2.style.setProperty("width", width2 ? `${width2}px` : "unset");
    const textRect = textArea.getBoundingClientRect();
    const point = getTextInputCoords(textRect.height);
    let horizontalPosition = point.x;
    if (alignment === "center") {
      horizontalPosition -= (width2 ?? textRect.width) / 2;
    } else if (alignment === "right") {
      horizontalPosition -= width2 ?? textRect.width;
    }
    const position = getTextPosition();
    let verticalPosition = point.y;
    if (position === "center") {
      verticalPosition -= textRect.height / 2;
    } else if (position === "bottom") {
      verticalPosition -= textRect.height;
    }
    element2.style.setProperty("top", `${verticalPosition}px`);
    element2.style.setProperty("left", `${horizontalPosition}px`);
    element2.style.setProperty("max-width", `${sceneRect.width - horizontalPosition}px`);
    element2.style.setProperty("text-align", alignment);
    textArea.style.setProperty("text-align", textAlign);
  }
  getBBox() {
    const { left, top, width: width2, height: height2 } = this.element.getBoundingClientRect();
    return new module_support_exports.BBox(left, top, width2, height2);
  }
};
var { BaseProperties: BaseProperties22, Property: Property12 } = module_support_exports;
var AxesButtons = class extends BaseProperties22 {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.axes = "y";
  }
};
__decorateClass2([
  Property12
], AxesButtons.prototype, "enabled", 2);
__decorateClass2([
  Property12
], AxesButtons.prototype, "axes", 2);
var AnnotationType = /* @__PURE__ */ ((AnnotationType3) => {
  AnnotationType3["Line"] = "line";
  AnnotationType3["HorizontalLine"] = "horizontal-line";
  AnnotationType3["VerticalLine"] = "vertical-line";
  AnnotationType3["DisjointChannel"] = "disjoint-channel";
  AnnotationType3["ParallelChannel"] = "parallel-channel";
  AnnotationType3["FibonacciRetracement"] = "fibonacci-retracement";
  AnnotationType3["FibonacciRetracementTrendBased"] = "fibonacci-retracement-trend-based";
  AnnotationType3["Callout"] = "callout";
  AnnotationType3["Comment"] = "comment";
  AnnotationType3["Note"] = "note";
  AnnotationType3["Text"] = "text";
  AnnotationType3["Arrow"] = "arrow";
  AnnotationType3["ArrowUp"] = "arrow-up";
  AnnotationType3["ArrowDown"] = "arrow-down";
  AnnotationType3["DateRange"] = "date-range";
  AnnotationType3["PriceRange"] = "price-range";
  AnnotationType3["DatePriceRange"] = "date-price-range";
  AnnotationType3["QuickDatePriceRange"] = "quick-date-price-range";
  return AnnotationType3;
})(AnnotationType || {});
var ANNOTATION_TYPES = Object.values(AnnotationType);
function stringToAnnotationType(value) {
  for (const t of ANNOTATION_TYPES) {
    if (t === value)
      return t;
  }
}
var { BaseProperties: BaseProperties3, FONT_SIZE: FONT_SIZE22, Property: Property13 } = module_support_exports;
var PointProperties = class extends BaseProperties3 {
};
__decorateClass2([
  Property13
], PointProperties.prototype, "x", 2);
__decorateClass2([
  Property13
], PointProperties.prototype, "y", 2);
var ChannelAnnotationMiddleProperties = class extends Stroke(LineStyle(Visible(BaseProperties3))) {
};
var AxisLabelProperties = class extends Stroke(LineStyle(Fill(Label2(Font(BaseProperties3))))) {
  constructor() {
    super(...arguments);
    this.cornerRadius = 2;
  }
};
__decorateClass2([
  Property13
], AxisLabelProperties.prototype, "enabled", 2);
__decorateClass2([
  Property13
], AxisLabelProperties.prototype, "cornerRadius", 2);
var BackgroundProperties = class extends Fill(BaseProperties3) {
};
var HandleProperties = class extends Stroke(LineStyle(Fill(BaseProperties3))) {
};
var LineTextProperties = class extends Font(BaseProperties3) {
  constructor() {
    super(...arguments);
    this.label = "";
    this.position = "top";
    this.alignment = "left";
  }
};
__decorateClass2([
  Property13
], LineTextProperties.prototype, "label", 2);
__decorateClass2([
  Property13
], LineTextProperties.prototype, "position", 2);
__decorateClass2([
  Property13
], LineTextProperties.prototype, "alignment", 2);
var LabelTextProperties = class extends Font(BaseProperties3) {
};
var ChannelTextProperties = class extends Font(BaseProperties3) {
  constructor() {
    super(...arguments);
    this.label = "";
  }
};
__decorateClass2([
  Property13
], ChannelTextProperties.prototype, "label", 2);
__decorateClass2([
  Property13
], ChannelTextProperties.prototype, "position", 2);
__decorateClass2([
  Property13
], ChannelTextProperties.prototype, "alignment", 2);
function Annotation(Parent) {
  class AnnotationInternal extends Lockable(Visible(Parent)) {
    constructor() {
      super(...arguments);
      this.id = generateUUID();
    }
  }
  return AnnotationInternal;
}
function Line3(Parent) {
  class LineInternal extends Parent {
    constructor() {
      super(...arguments);
      this.start = new PointProperties();
      this.end = new PointProperties();
    }
  }
  __decorateClass2([
    Property13
  ], LineInternal.prototype, "start", 2);
  __decorateClass2([
    Property13
  ], LineInternal.prototype, "end", 2);
  return LineInternal;
}
function Point(Parent) {
  class PointInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], PointInternal.prototype, "x", 2);
  __decorateClass2([
    Property13
  ], PointInternal.prototype, "y", 2);
  return PointInternal;
}
function Value(Parent) {
  class ValueInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], ValueInternal.prototype, "value", 2);
  return ValueInternal;
}
function Background2(Parent) {
  class BackgroundInternal extends Parent {
    constructor() {
      super(...arguments);
      this.background = new BackgroundProperties();
    }
  }
  __decorateClass2([
    Property13
  ], BackgroundInternal.prototype, "background", 2);
  return BackgroundInternal;
}
function Handle(Parent) {
  class HandleInternal extends Parent {
    constructor() {
      super(...arguments);
      this.handle = new HandleProperties();
    }
  }
  __decorateClass2([
    Property13
  ], HandleInternal.prototype, "handle", 2);
  return HandleInternal;
}
function AxisLabel2(Parent) {
  class AxisLabelInternal extends Parent {
    constructor() {
      super(...arguments);
      this.axisLabel = new AxisLabelProperties();
    }
  }
  __decorateClass2([
    Property13
  ], AxisLabelInternal.prototype, "axisLabel", 2);
  return AxisLabelInternal;
}
function Label2(Parent) {
  class LabelInternal extends Parent {
    constructor() {
      super(...arguments);
      this.padding = void 0;
      this.textAlign = "center";
      this.formatter = void 0;
    }
    // TODO: making this generic causes issues with mixins sequence
  }
  __decorateClass2([
    Property13
  ], LabelInternal.prototype, "padding", 2);
  __decorateClass2([
    Property13
  ], LabelInternal.prototype, "textAlign", 2);
  __decorateClass2([
    Property13
  ], LabelInternal.prototype, "formatter", 2);
  return LabelInternal;
}
function Cappable(Parent) {
  class CappableInternal extends Parent {
  }
  return CappableInternal;
}
function Extendable(Parent) {
  class ExtendableInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], ExtendableInternal.prototype, "extendStart", 2);
  __decorateClass2([
    Property13
  ], ExtendableInternal.prototype, "extendEnd", 2);
  return ExtendableInternal;
}
function Lockable(Parent) {
  class LockableInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], LockableInternal.prototype, "locked", 2);
  return LockableInternal;
}
function Localisable(Parent) {
  class LocalisableInternal extends Parent {
    setLocaleManager(localeManager) {
      this.localeManager ?? (this.localeManager = localeManager);
    }
  }
  return LocalisableInternal;
}
function Visible(Parent) {
  class VisibleInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], VisibleInternal.prototype, "visible", 2);
  return VisibleInternal;
}
function Fill(Parent) {
  class FillInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], FillInternal.prototype, "fill", 2);
  __decorateClass2([
    Property13
  ], FillInternal.prototype, "fillOpacity", 2);
  return FillInternal;
}
function Stroke(Parent) {
  class StrokeInternal extends Parent {
  }
  __decorateClass2([
    Property13
  ], StrokeInternal.prototype, "stroke", 2);
  __decorateClass2([
    Property13
  ], StrokeInternal.prototype, "strokeOpacity", 2);
  __decorateClass2([
    Property13
  ], StrokeInternal.prototype, "strokeWidth", 2);
  return StrokeInternal;
}
function LineStyle(Parent) {
  class LineDashInternal extends Parent {
    constructor() {
      super(...arguments);
      this.lineCap = void 0;
      this.computedLineDash = void 0;
    }
  }
  __decorateClass2([
    Property13
  ], LineDashInternal.prototype, "lineDash", 2);
  __decorateClass2([
    Property13
  ], LineDashInternal.prototype, "lineDashOffset", 2);
  __decorateClass2([
    Property13
  ], LineDashInternal.prototype, "lineStyle", 2);
  return LineDashInternal;
}
function Font(Parent) {
  class FontInternal extends Parent {
    constructor() {
      super(...arguments);
      this.fontSize = FONT_SIZE22.SMALL;
      this.fontFamily = "Verdana, sans-serif";
    }
  }
  __decorateClass2([
    Property13
  ], FontInternal.prototype, "fontStyle", 2);
  __decorateClass2([
    Property13
  ], FontInternal.prototype, "fontWeight", 2);
  __decorateClass2([
    Property13
  ], FontInternal.prototype, "fontSize", 2);
  __decorateClass2([
    Property13
  ], FontInternal.prototype, "fontFamily", 2);
  __decorateClass2([
    Property13
  ], FontInternal.prototype, "color", 2);
  return FontInternal;
}
function getGrouping(d) {
  if (isNumber(d) || isString(d) || isDate(d)) {
    return { value: d, groupPercentage: 0 };
  }
  return d ?? { value: void 0, groupPercentage: 0 };
}
function getGroupingValue(d) {
  return getGrouping(d)?.value;
}
function convertLine(datum, context) {
  if (datum.start == null || datum.end == null)
    return;
  const start2 = convertPoint(datum.start, context);
  const end2 = convertPoint(datum.end, context);
  if (start2 == null || end2 == null)
    return;
  return { x1: start2.x, y1: start2.y, x2: end2.x, y2: end2.y };
}
function convertPoint(point, context) {
  const x = convert(point.x, context.xAxis);
  const y = convert(point.y, context.yAxis);
  return { x, y };
}
function convert(p, context) {
  if (p == null)
    return 0;
  const { value, groupPercentage } = getGrouping(p);
  const { scale: scale2, snapToGroup } = context;
  const width2 = scale2.bandwidth === 0 ? scale2.step ?? 0 : scale2.bandwidth ?? 0;
  const offset = snapToGroup ? width2 / 2 : width2 * groupPercentage;
  return scale2.convert(value) + offset;
}
function invertCoords(coords, context) {
  const x = invert(coords.x, context.xAxis);
  const y = invert(coords.y, context.yAxis);
  return { x, y };
}
function invert(n, context) {
  const { scale: scale2 } = context;
  if (context.continuous && scale2.step == null) {
    return context.scaleInvert(n);
  }
  const value = context.scaleInvertNearest(n);
  const width2 = scale2.bandwidth === 0 ? scale2.step : scale2.bandwidth ?? 0;
  const bandStart = scale2.convert(value);
  const bandEnd = bandStart + width2;
  const groupPercentage = bandStart === bandEnd ? 0 : (n - bandStart) / (bandEnd - bandStart);
  return { value, groupPercentage };
}
var { BaseProperties: BaseProperties4 } = module_support_exports;
var StartEndProperties = class extends Annotation(Line3(Handle(BaseProperties4))) {
  constructor() {
    super(...arguments);
    this.snapToAngle = 45;
  }
  getDefaultColor(_colorPickerType) {
    return void 0;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
};
var { Property: Property14 } = module_support_exports;
var TextualStartEndProperties = class extends Localisable(Label2(Font(StartEndProperties))) {
  constructor() {
    super(...arguments);
    this.text = "";
    this.position = "top";
    this.alignment = "left";
    this.placement = "inside";
    this.placeholderText = "inputTextareaPlaceholder";
  }
  getDefaultColor(_colorPickerType) {
    return this.color;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
  getPlaceholderColor() {
    return void 0;
  }
  getPadding() {
    const { padding: padding2 = 0 } = this;
    return {
      top: padding2,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  getText() {
    const isPlaceholder = this.text.length == 0;
    let text2 = this.text;
    if (isPlaceholder) {
      text2 = this.placeholderText ?? "";
      if (this.localeManager)
        text2 = this.localeManager.t(text2);
    }
    return {
      text: text2,
      isPlaceholder
    };
  }
  getTextInputCoords(context, _height) {
    return convertPoint(this.end, context);
  }
  getTextPosition() {
    return this.position;
  }
};
__decorateClass2([
  Property14
], TextualStartEndProperties.prototype, "text", 2);
var { Property: Property15, Color: Color2 } = module_support_exports;
var DEFAULT_CALLOUT_PADDING = {
  top: 6,
  right: 12,
  bottom: 9,
  left: 12
};
var CalloutProperties = class extends Fill(Stroke(TextualStartEndProperties)) {
  constructor() {
    super(...arguments);
    this.type = "callout";
    this.position = "bottom";
    this.alignment = "left";
  }
  static is(value) {
    return isObject(value) && value.type === "callout";
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fill;
      case `line-color`:
        return this.stroke;
      case `text-color`:
      default:
        return this.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
      case `text-color`:
      default:
        return void 0;
    }
  }
  getPlaceholderColor() {
    const { r, g, b } = Color2.fromString(this.color ?? "#888888");
    return new Color2(r, g, b, 0.66).toString();
  }
  getPadding() {
    const { padding: padding2 } = this;
    if (padding2 == null) {
      return { ...DEFAULT_CALLOUT_PADDING };
    }
    return {
      top: padding2,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  getTextInputCoords(context, height2) {
    const coords = super.getTextInputCoords(context, height2);
    const padding2 = this.getPadding();
    const paddingLeft = padding2.left ?? 0;
    const paddingBottom = padding2.bottom ?? 0;
    return {
      x: coords.x + paddingLeft,
      y: coords.y - paddingBottom
    };
  }
};
__decorateClass2([
  Property15
], CalloutProperties.prototype, "type", 2);
var { BaseProperties: BaseProperties5, Property: Property16 } = module_support_exports;
var TextualPointProperties = class extends Annotation(Point(Handle(Label2(Font(BaseProperties5))))) {
  constructor() {
    super(...arguments);
    this.text = "";
    this.position = "top";
    this.alignment = "left";
    this.placement = "inside";
    this.placeholderText = "inputTextareaPlaceholder";
  }
  getDefaultColor(_colorPickerType) {
    return this.color;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
  getPlaceholderColor() {
    return void 0;
  }
  getPadding() {
    const { padding: padding2 = 0 } = this;
    return {
      top: padding2,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  getText() {
    const isPlaceholder = this.text.length == 0;
    const text2 = !isPlaceholder ? this.text : this.placeholderText ?? "";
    return {
      text: text2,
      isPlaceholder
    };
  }
  getTextInputCoords(context, _height) {
    return convertPoint(this, context);
  }
  getTextPosition() {
    return this.position;
  }
};
__decorateClass2([
  Property16
], TextualPointProperties.prototype, "text", 2);
var { Property: Property17, Color: Color22 } = module_support_exports;
var DEFAULT_COMMENT_PADDING = {
  top: 8,
  right: 14,
  bottom: 8,
  left: 14
};
var CommentProperties = class extends Fill(Stroke(TextualPointProperties)) {
  constructor() {
    super(...arguments);
    this.type = "comment";
    this.position = "bottom";
    this.alignment = "left";
  }
  static is(value) {
    return isObject(value) && value.type === "comment";
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fill;
      case `line-color`:
        return this.stroke;
      case `text-color`:
      default:
        return this.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
      case `text-color`:
      default:
        return void 0;
    }
  }
  getPlaceholderColor() {
    const { r, g, b } = Color22.fromString(this.color ?? "#888888");
    return new Color22(r, g, b, 0.66).toString();
  }
  getPadding() {
    const { padding: padding2, fontSize } = this;
    if (padding2 == null) {
      return {
        top: Math.max(fontSize * 0.4, DEFAULT_COMMENT_PADDING.top),
        bottom: Math.max(fontSize * 0.4, DEFAULT_COMMENT_PADDING.bottom),
        left: Math.max(fontSize * 0.8, DEFAULT_COMMENT_PADDING.left),
        right: Math.max(fontSize * 0.8, DEFAULT_COMMENT_PADDING.right)
      };
    }
    return {
      top: padding2,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  getTextInputCoords(context, height2) {
    const coords = super.getTextInputCoords(context, height2);
    const padding2 = this.getPadding();
    return {
      x: coords.x + padding2.left,
      y: coords.y - padding2.bottom
    };
  }
};
__decorateClass2([
  Property17
], CommentProperties.prototype, "type", 2);
var { Vec2: Vec22 } = module_support_exports;
function getLineStyle(lineDash, lineStyle) {
  return lineDash ? "dashed" : lineStyle ?? "solid";
}
function getComputedLineDash(strokeWidth, styleType) {
  switch (styleType) {
    case "solid":
      return [];
    case "dashed":
      return [strokeWidth * 4, strokeWidth * 2];
    case "dotted":
      return [0, strokeWidth * 2];
  }
}
function getLineDash(lineDash, computedLineDash, lineStyle, strokeWidth) {
  const styleType = getLineStyle(lineDash, lineStyle);
  return computedLineDash ?? lineDash ?? getComputedLineDash(strokeWidth ?? 1, styleType);
}
function getLineCap(lineCap, lineDash, lineStyle) {
  const styleType = getLineStyle(lineDash, lineStyle);
  return lineCap ?? styleType === "dotted" ? "round" : void 0;
}
function boundsIntersections(coords, bounds) {
  const [p1, p2] = Vec22.from(coords);
  const reflection = bounds.height;
  const gradient2 = Vec22.gradient(p2, p1, reflection);
  const intercept2 = Vec22.intercept(p2, gradient2, reflection);
  const fallback = [
    { x: p1.x, y: reflection ?? 0 },
    { x: p1.x, y: reflection == null ? bounds.height : reflection - bounds.height }
  ];
  if (gradient2 === Infinity) {
    return fallback;
  }
  let points = [
    Vec22.intersectAtY(gradient2, intercept2, 0, reflection),
    Vec22.intersectAtY(gradient2, intercept2, bounds.height, reflection),
    Vec22.intersectAtX(gradient2, intercept2, 0, reflection),
    Vec22.intersectAtX(gradient2, intercept2, bounds.width, reflection)
  ];
  points = points.filter((p) => p.x >= bounds.x && p.x <= bounds.width && p.y >= bounds.y && p.y <= bounds.height).sort((a, b) => {
    if (a.x === b.x)
      return 0;
    return a.x < b.x ? -1 : 1;
  });
  if (points.length !== 2) {
    return fallback;
  }
  return points;
}
var { BaseProperties: BaseProperties6, Property: Property18 } = module_support_exports;
var MeasurerStatisticsDivider = class extends Stroke(BaseProperties6) {
};
var MeasurerStatistics = class extends Font(Fill(Stroke(BaseProperties6))) {
  constructor() {
    super(...arguments);
    this.divider = new MeasurerStatisticsDivider();
  }
};
__decorateClass2([
  Property18
], MeasurerStatistics.prototype, "divider", 2);
var MeasurerDirectionProperties = class extends Fill(Stroke(Handle(BaseProperties6))) {
  constructor() {
    super(...arguments);
    this.statistics = new MeasurerStatistics();
  }
};
__decorateClass2([
  Property18
], MeasurerDirectionProperties.prototype, "statistics", 2);
var MeasurerTypeProperties = class extends Localisable(Background2(Stroke(LineStyle(StartEndProperties)))) {
  constructor() {
    super(...arguments);
    this.direction = "both";
    this.hasDateRange = false;
    this.hasPriceRange = false;
    this.statistics = new MeasurerStatistics();
    this.getVolume = () => void 0;
    this.text = new LineTextProperties();
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fill;
      case `line-color`:
        return this.stroke;
      case `text-color`:
        return this.text.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
    }
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass2([
  Property18
], MeasurerTypeProperties.prototype, "statistics", 2);
__decorateClass2([
  Property18
], MeasurerTypeProperties.prototype, "text", 2);
function DateRange(Parent) {
  class DateRangeInternal extends Parent {
    constructor() {
      super(...arguments);
      this.hasDateRange = true;
    }
  }
  return DateRangeInternal;
}
function PriceRange(Parent) {
  class PriceRangeInternal extends Parent {
    constructor() {
      super(...arguments);
      this.hasPriceRange = true;
    }
  }
  return PriceRangeInternal;
}
var DateRangeProperties = class extends DateRange(MeasurerTypeProperties) {
  constructor() {
    super(...arguments);
    this.type = "date-range";
    this.direction = "horizontal";
  }
  static is(value) {
    return isObject(value) && value.type === "date-range";
  }
};
__decorateClass2([
  Property18
], DateRangeProperties.prototype, "type", 2);
__decorateClass2([
  Property18
], DateRangeProperties.prototype, "extendAbove", 2);
__decorateClass2([
  Property18
], DateRangeProperties.prototype, "extendBelow", 2);
var PriceRangeProperties = class extends PriceRange(MeasurerTypeProperties) {
  constructor() {
    super(...arguments);
    this.type = "price-range";
    this.direction = "vertical";
  }
  static is(value) {
    return isObject(value) && value.type === "price-range";
  }
};
__decorateClass2([
  Property18
], PriceRangeProperties.prototype, "type", 2);
__decorateClass2([
  Property18
], PriceRangeProperties.prototype, "extendLeft", 2);
__decorateClass2([
  Property18
], PriceRangeProperties.prototype, "extendRight", 2);
var DatePriceRangeProperties = class extends DateRange(PriceRange(MeasurerTypeProperties)) {
  constructor() {
    super(...arguments);
    this.type = "date-price-range";
    this.direction = "both";
  }
  static is(value) {
    return isObject(value) && value.type === "date-price-range";
  }
};
__decorateClass2([
  Property18
], DatePriceRangeProperties.prototype, "type", 2);
var QuickDatePriceRangeProperties = class extends DateRange(PriceRange(MeasurerTypeProperties)) {
  constructor() {
    super(...arguments);
    this.type = "quick-date-price-range";
    this.up = new MeasurerDirectionProperties();
    this.down = new MeasurerDirectionProperties();
    this.direction = "both";
  }
  static is(value) {
    return isObject(value) && value.type === "quick-date-price-range";
  }
};
__decorateClass2([
  Property18
], QuickDatePriceRangeProperties.prototype, "type", 2);
__decorateClass2([
  Property18
], QuickDatePriceRangeProperties.prototype, "up", 2);
__decorateClass2([
  Property18
], QuickDatePriceRangeProperties.prototype, "down", 2);
var { TextWrapper: TextWrapper22, CachedTextMeasurerPool: CachedTextMeasurerPool2, BBox: BBox22 } = module_support_exports;
var ANNOTATION_TEXT_LINE_HEIGHT = 1.38;
function getTextWrapOptions(options) {
  return {
    font: {
      fontFamily: options.fontFamily,
      fontSize: options.fontSize,
      fontStyle: options.fontStyle,
      fontWeight: options.fontWeight
    },
    textAlign: options.textAlign,
    textBaseline: options.position == "center" ? "middle" : options.position,
    lineHeight: ANNOTATION_TEXT_LINE_HEIGHT,
    avoidOrphans: false,
    textWrap: "always"
  };
}
function wrapText(options, text2, width2) {
  return width2 ? TextWrapper22.wrapText(text2, {
    ...getTextWrapOptions(options),
    maxWidth: width2
  }) : text2;
}
function measureAnnotationText(options, text2) {
  const textOptions = getTextWrapOptions(options);
  const { lineMetrics, width: width2 } = CachedTextMeasurerPool2.measureLines(text2, textOptions);
  const height2 = lineMetrics.length * (options.fontSize ?? 14) * ANNOTATION_TEXT_LINE_HEIGHT;
  return {
    width: width2,
    height: height2
  };
}
function getBBox(options, text2, coords, bbox) {
  let width2 = bbox?.width ?? 0;
  let height2 = bbox?.height ?? 0;
  if (!bbox) {
    const wrappedText = options.width != null ? wrapText(options, text2, options.width) : text2;
    ({ width: width2, height: height2 } = measureAnnotationText(options, wrappedText));
  }
  return new BBox22(coords.x, coords.y, width2, height2);
}
function updateTextNode(node, text2, isPlaceholder, config, { x, y }, textBaseline) {
  const { visible = true, fontFamily, fontSize = 14, fontStyle, fontWeight, textAlign } = config;
  const lineHeight = fontSize * ANNOTATION_TEXT_LINE_HEIGHT;
  textBaseline ?? (textBaseline = config.position == "center" ? "middle" : config.position);
  const fill = isPlaceholder ? config.getPlaceholderColor() : config.color;
  node.setProperties({
    x,
    y,
    visible,
    text: text2,
    fill,
    fontFamily,
    fontSize,
    fontStyle,
    fontWeight,
    textAlign,
    lineHeight,
    textBaseline
  });
}
var { BaseProperties: BaseProperties7, Property: Property19 } = module_support_exports;
var DEFAULT_NOTE_PADDING = 10;
var HANDLE_SIZE = 11;
var ICON_HEIGHT = 20;
var ICON_WIDTH = 22;
var ICON_SPACING = 10;
var LABEL_OFFSET = ICON_HEIGHT + ICON_SPACING;
var TOOLBAR_OFFSET = 34;
var NoteBackgroundProperties = class extends Fill(Stroke(BaseProperties7)) {
};
var NoteProperties = class extends Fill(Stroke(TextualPointProperties)) {
  constructor() {
    super(...arguments);
    this.type = "note";
    this.background = new NoteBackgroundProperties();
    this.position = "bottom";
    this.alignment = "center";
    this.width = 200;
  }
  static is(value) {
    return isObject(value) && value.type === "note";
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `line-color`:
        return this.fill;
      case `text-color`:
        return this.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `line-color`:
        return this.fillOpacity;
      case `text-color`:
        return void 0;
    }
  }
  getPadding() {
    const padding2 = this.padding ?? DEFAULT_NOTE_PADDING;
    return {
      top: padding2,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  getTextInputCoords(context, height2) {
    const { width: width2, text: text2 } = this;
    const textInputCoords = super.getTextInputCoords(context, height2);
    const padding2 = this.getPadding().top;
    const bbox = getBBox(this, text2, textInputCoords);
    bbox.x = clamp(width2 / 2, bbox.x, context.seriesRect.width - width2 / 2);
    const topY = bbox.y - LABEL_OFFSET - padding2 * 2;
    const bottomY = bbox.y + HANDLE_SIZE + padding2 * 2;
    const textHeight = Math.max(bbox.height, height2);
    if (topY - textHeight - TOOLBAR_OFFSET < 0) {
      bbox.y = bottomY;
      this.position = "top";
    } else {
      bbox.y = topY + padding2;
      this.position = "bottom";
    }
    return {
      x: bbox.x,
      y: bbox.y
    };
  }
};
__decorateClass2([
  Property19
], NoteProperties.prototype, "type", 2);
__decorateClass2([
  Property19
], NoteProperties.prototype, "background", 2);
var { BaseProperties: BaseProperties8 } = module_support_exports;
var PointProperties2 = class extends Annotation(Point(Handle(BaseProperties8))) {
  getDefaultColor(_colorPickerType) {
    return void 0;
  }
  getDefaultOpacity(_colorPickerType) {
    return void 0;
  }
};
var ShapePointProperties = class _ShapePointProperties extends Fill(PointProperties2) {
  constructor() {
    super(...arguments);
    this.size = 32;
  }
  static is(value) {
    return value instanceof _ShapePointProperties;
  }
  getDefaultColor(colorPickerType) {
    return colorPickerType === `fill-color` ? this.fill : void 0;
  }
  getDefaultOpacity(colorPickerType) {
    return colorPickerType === `fill-color` ? this.fillOpacity : void 0;
  }
};
var { BaseProperties: BaseProperties9, Property: Property20 } = module_support_exports;
var HorizontalLineProperties = class extends Annotation(Value(Handle(AxisLabel2(Stroke(LineStyle(BaseProperties9)))))) {
  constructor() {
    super(...arguments);
    this.direction = "horizontal";
    this.type = "horizontal-line";
    this.text = new LineTextProperties();
  }
  static is(value) {
    return isObject(value) && value.type === "horizontal-line";
  }
  getDefaultColor() {
    return this.stroke;
  }
  getDefaultOpacity() {
    return this.strokeOpacity;
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass2([
  Property20
], HorizontalLineProperties.prototype, "type", 2);
__decorateClass2([
  Property20
], HorizontalLineProperties.prototype, "text", 2);
var VerticalLineProperties = class extends Annotation(Value(Handle(AxisLabel2(Stroke(LineStyle(BaseProperties9)))))) {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
    this.type = "vertical-line";
    this.text = new LineTextProperties();
  }
  static is(value) {
    return isObject(value) && value.type === "vertical-line";
  }
  getDefaultColor() {
    return this.stroke;
  }
  getDefaultOpacity() {
    return this.strokeOpacity;
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass2([
  Property20
], VerticalLineProperties.prototype, "type", 2);
__decorateClass2([
  Property20
], VerticalLineProperties.prototype, "text", 2);
var { BaseProperties: BaseProperties10, Property: Property21 } = module_support_exports;
var DisjointChannelProperties = class extends Annotation(
  Background2(Line3(Handle(Extendable(Stroke(LineStyle(BaseProperties10))))))
) {
  constructor() {
    super(...arguments);
    this.type = "disjoint-channel";
    this.text = new ChannelTextProperties();
    this.snapToAngle = 45;
  }
  static is(value) {
    return isObject(value) && value.type === "disjoint-channel";
  }
  get bottom() {
    const bottom = {
      start: { x: this.start.x, y: this.start.y },
      end: { x: this.end.x, y: this.end.y }
    };
    if (typeof bottom.start.y === "number" && typeof bottom.end.y === "number") {
      bottom.start.y -= this.startHeight;
      bottom.end.y -= this.endHeight;
    } else {
      logger_exports.warnOnce(`Annotation [${this.type}] can only be used with a numeric y-axis.`);
    }
    return bottom;
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fill;
      case `line-color`:
        return this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
    }
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass2([
  Property21
], DisjointChannelProperties.prototype, "type", 2);
__decorateClass2([
  Property21
], DisjointChannelProperties.prototype, "startHeight", 2);
__decorateClass2([
  Property21
], DisjointChannelProperties.prototype, "endHeight", 2);
__decorateClass2([
  Property21
], DisjointChannelProperties.prototype, "text", 2);
var { Property: Property222 } = module_support_exports;
var LineTypeProperties = class extends Localisable(
  Cappable(Extendable(Stroke(LineStyle(StartEndProperties))))
) {
  constructor() {
    super(...arguments);
    this.text = new LineTextProperties();
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case "line-color":
        return this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
  getDefaultOpacity() {
    return this.strokeOpacity;
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass2([
  Property222
], LineTypeProperties.prototype, "text", 2);
var ArrowProperties = class extends LineTypeProperties {
  constructor() {
    super(...arguments);
    this.type = "arrow";
    this.endCap = "arrow";
  }
  static is(value) {
    return isObject(value) && value.type === "arrow";
  }
};
__decorateClass2([
  Property222
], ArrowProperties.prototype, "type", 2);
var LineProperties = class extends LineTypeProperties {
  constructor() {
    super(...arguments);
    this.type = "line";
  }
  static is(value) {
    return isObject(value) && value.type === "line";
  }
};
__decorateClass2([
  Property222
], LineProperties.prototype, "type", 2);
var { Property: Property23 } = module_support_exports;
var FibonacciProperties = class extends LineTypeProperties {
  constructor() {
    super(...arguments);
    this.label = new LabelTextProperties();
    this.reverse = false;
    this.showFill = true;
    this.isMultiColor = true;
    this.strokes = [];
    this.bands = 10;
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case "line-color":
        return this.rangeStroke ?? this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
};
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "label", 2);
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "reverse", 2);
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "showFill", 2);
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "isMultiColor", 2);
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "strokes", 2);
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "rangeStroke", 2);
__decorateClass2([
  Property23
], FibonacciProperties.prototype, "bands", 2);
var { Property: Property24 } = module_support_exports;
var FibonacciRetracementTrendBasedProperties = class extends FibonacciProperties {
  constructor() {
    super(...arguments);
    this.type = "fibonacci-retracement-trend-based";
    this.endRetracement = new PointProperties();
  }
  static is(value) {
    return isObject(value) && value.type === "fibonacci-retracement-trend-based";
  }
};
__decorateClass2([
  Property24
], FibonacciRetracementTrendBasedProperties.prototype, "type", 2);
__decorateClass2([
  Property24
], FibonacciRetracementTrendBasedProperties.prototype, "endRetracement", 2);
var { Property: Property25 } = module_support_exports;
var FibonacciRetracementProperties = class extends FibonacciProperties {
  constructor() {
    super(...arguments);
    this.type = "fibonacci-retracement";
  }
  static is(value) {
    return isObject(value) && value.type === "fibonacci-retracement";
  }
};
__decorateClass2([
  Property25
], FibonacciRetracementProperties.prototype, "type", 2);
var { BaseProperties: BaseProperties11, Property: Property26 } = module_support_exports;
var ParallelChannelProperties = class extends Annotation(
  Background2(Line3(Handle(Extendable(Stroke(LineStyle(BaseProperties11))))))
) {
  constructor() {
    super(...arguments);
    this.type = "parallel-channel";
    this.middle = new ChannelAnnotationMiddleProperties();
    this.text = new ChannelTextProperties();
    this.snapToAngle = 45;
  }
  static is(value) {
    return isObject(value) && value.type === "parallel-channel";
  }
  get bottom() {
    const bottom = {
      start: { x: this.start.x, y: this.start.y },
      end: { x: this.end.x, y: this.end.y }
    };
    if (typeof bottom.start.y === "number" && typeof bottom.end.y === "number") {
      bottom.start.y -= this.height;
      bottom.end.y -= this.height;
    } else {
      logger_exports.warnOnce(`Annotation [${this.type}] can only be used with a numeric y-axis.`);
    }
    return bottom;
  }
  getDefaultColor(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fill;
      case `line-color`:
        return this.stroke;
      case "text-color":
        return this.text.color;
    }
  }
  getDefaultOpacity(colorPickerType) {
    switch (colorPickerType) {
      case `fill-color`:
        return this.background.fillOpacity;
      case `line-color`:
        return this.strokeOpacity;
    }
  }
  getLineDash() {
    return getLineDash(this.lineDash, this.computedLineDash, this.lineStyle, this.strokeWidth);
  }
  getLineCap() {
    return getLineCap(this.lineCap, this.lineDash, this.lineStyle);
  }
};
__decorateClass2([
  Property26
], ParallelChannelProperties.prototype, "type", 2);
__decorateClass2([
  Property26
], ParallelChannelProperties.prototype, "height", 2);
__decorateClass2([
  Property26
], ParallelChannelProperties.prototype, "middle", 2);
__decorateClass2([
  Property26
], ParallelChannelProperties.prototype, "text", 2);
var { Property: Property27 } = module_support_exports;
var TextProperties = class extends TextualPointProperties {
  constructor() {
    super(...arguments);
    this.type = "text";
    this.position = "bottom";
  }
  static is(value) {
    return isObject(value) && value.type === "text";
  }
};
__decorateClass2([
  Property27
], TextProperties.prototype, "type", 2);
function isEphemeralType(datum) {
  return QuickDatePriceRangeProperties.is(datum);
}
function isLineType(datum) {
  return LineProperties.is(datum) || HorizontalLineProperties.is(datum) || VerticalLineProperties.is(datum) || ArrowProperties.is(datum) || isFibonacciType(datum);
}
function isChannelType(datum) {
  return DisjointChannelProperties.is(datum) || ParallelChannelProperties.is(datum);
}
function isFibonacciType(datum) {
  return FibonacciRetracementProperties.is(datum) || FibonacciRetracementTrendBasedProperties.is(datum);
}
function isTextType(datum) {
  return CalloutProperties.is(datum) || CommentProperties.is(datum) || NoteProperties.is(datum) || TextProperties.is(datum);
}
function isMeasurerType(datum) {
  return DateRangeProperties.is(datum) || PriceRangeProperties.is(datum) || DatePriceRangeProperties.is(datum) || QuickDatePriceRangeProperties.is(datum);
}
function hasFontSize(datum) {
  return isTextType(datum) && !NoteProperties.is(datum);
}
function hasLineStyle(datum) {
  return isLineType(datum) || isChannelType(datum) || isMeasurerType(datum) && !QuickDatePriceRangeProperties.is(datum);
}
function hasLineColor(datum) {
  return isLineType(datum) || isChannelType(datum) || isMeasurerType(datum) || CalloutProperties.is(datum) || NoteProperties.is(datum);
}
function hasIconColor(datum) {
  return NoteProperties.is(datum);
}
function hasFillColor(datum) {
  return isChannelType(datum) || isMeasurerType(datum) || CalloutProperties.is(datum) || CommentProperties.is(datum) || ShapePointProperties.is(datum);
}
function hasTextColor(datum) {
  return isTextType(datum) && !NoteProperties.is(datum);
}
function hasLineText(datum) {
  return (isLineType(datum) || isChannelType(datum) || isMeasurerType(datum)) && !isEphemeralType(datum) && isObject(datum.text);
}
function setFontSize(datum, fontSize) {
  if ("fontSize" in datum)
    datum.fontSize = fontSize;
  if (hasLineText(datum))
    datum.text.fontSize = fontSize;
}
function setLineStyle(datum, style2) {
  const strokeWidth = style2?.strokeWidth ?? datum.strokeWidth ?? 1;
  const lineType = style2?.type ?? datum.lineStyle;
  const lineStyle = lineType ?? getLineStyle(datum.lineDash, lineType);
  const computedLineDash = getComputedLineDash(strokeWidth, lineStyle);
  datum.strokeWidth = strokeWidth;
  datum.computedLineDash = computedLineDash;
  datum.lineStyle = lineStyle;
  datum.lineCap = lineStyle === "dotted" ? "round" : void 0;
}
function setColor(datum, colorPickerType, colorOpacity, color6, opacity, isMultiColor) {
  switch (colorPickerType) {
    case `fill-color`: {
      if ("fill" in datum)
        datum.fill = color6;
      if ("fillOpacity" in datum)
        datum.fillOpacity = opacity;
      if ("background" in datum) {
        datum.background.fill = color6;
        datum.background.fillOpacity = opacity;
      }
      break;
    }
    case `line-color`: {
      if ("axisLabel" in datum) {
        datum.axisLabel.fill = color6;
        datum.axisLabel.fillOpacity = opacity;
        datum.axisLabel.stroke = color6;
        datum.axisLabel.strokeOpacity = opacity;
      }
      if ("fill" in datum && "fillOpacity" in datum && hasIconColor(datum)) {
        datum.fill = color6;
        datum.fillOpacity = opacity;
      } else {
        if ("strokeOpacity" in datum)
          datum.strokeOpacity = opacity;
        if ("isMultiColor" in datum && "rangeStroke" in datum) {
          datum.isMultiColor = isMultiColor;
          datum.rangeStroke = color6;
        } else if ("stroke" in datum) {
          datum.stroke = color6;
        }
      }
      break;
    }
    case `text-color`: {
      if ("color" in datum)
        datum.color = colorOpacity;
      if (hasLineText(datum))
        datum.text.color = color6;
      break;
    }
  }
}
var { deepClone: deepClone2 } = module_support_exports;
var AnnotationDefaults = class {
  constructor() {
    this.mementoOriginatorKey = "annotation-defaults";
    this.colors = new Map(
      Object.values(AnnotationType).map((type) => [
        type,
        /* @__PURE__ */ new Map([
          ["line-color", void 0],
          ["fill-color", void 0],
          ["text-color", void 0]
        ])
      ])
    );
    this.fontSizes = /* @__PURE__ */ new Map([
      ["callout", void 0],
      ["comment", void 0],
      ["text", void 0],
      ["arrow", void 0],
      ["line", void 0],
      ["disjoint-channel", void 0],
      ["parallel-channel", void 0],
      ["date-range", void 0],
      ["price-range", void 0],
      ["date-price-range", void 0]
    ]);
    this.lineStyles = /* @__PURE__ */ new Map([
      ["line", void 0],
      ["horizontal-line", void 0],
      ["vertical-line", void 0],
      ["disjoint-channel", void 0],
      ["parallel-channel", void 0],
      ["arrow", void 0],
      ["date-range", void 0],
      ["price-range", void 0],
      ["date-price-range", void 0]
    ]);
    this.lineTextAlignments = /* @__PURE__ */ new Map([
      ["line", void 0],
      ["horizontal-line", void 0],
      ["vertical-line", void 0],
      ["disjoint-channel", void 0],
      ["parallel-channel", void 0],
      ["arrow", void 0],
      ["date-range", void 0],
      ["price-range", void 0],
      ["date-price-range", void 0]
    ]);
    this.lineTextPositions = /* @__PURE__ */ new Map([
      ["line", void 0],
      ["horizontal-line", void 0],
      ["vertical-line", void 0],
      ["disjoint-channel", void 0],
      ["parallel-channel", void 0],
      ["arrow", void 0],
      ["date-range", void 0],
      ["price-range", void 0],
      ["date-price-range", void 0]
    ]);
    this.fibonacciOptions = /* @__PURE__ */ new Map([
      [
        "fibonacci-retracement",
        {
          bands: void 0,
          reverse: void 0,
          showFill: void 0
        }
      ],
      [
        "fibonacci-retracement-trend-based",
        {
          bands: void 0,
          reverse: void 0,
          showFill: void 0
        }
      ]
    ]);
  }
  createMemento() {
    return {
      colors: deepClone2(this.colors),
      fontSizes: deepClone2(this.fontSizes),
      lineStyles: deepClone2(this.lineStyles),
      lineTextAlignments: deepClone2(this.lineTextAlignments),
      lineTextPositions: deepClone2(this.lineTextPositions),
      fibonacciOptions: deepClone2(this.fibonacciOptions)
    };
  }
  guardMemento(_blob) {
    return true;
  }
  restoreMemento(_version, _mementoVersion, blob) {
    this.colors = deepClone2(blob.colors);
    this.fontSizes = deepClone2(blob.fontSizes);
    this.lineStyles = deepClone2(blob.lineStyles);
    this.lineTextAlignments = deepClone2(blob.lineTextAlignments);
    this.lineTextPositions = deepClone2(blob.lineTextPositions);
    this.fibonacciOptions = deepClone2(blob.fibonacciOptions);
  }
  setDefaultColor(type, colorType, colorOpacity, color6, opacity, isMultiColor) {
    this.colors.get(type)?.set(colorType, [colorOpacity, color6, opacity, isMultiColor]);
  }
  setDefaultFontSize(type, fontSize) {
    this.fontSizes.set(type, fontSize);
  }
  setDefaultLineStyleType(type, lineStyleType) {
    const defaultStyle = this.lineStyles.get(type);
    if (defaultStyle) {
      defaultStyle.type = lineStyleType;
    } else {
      this.lineStyles.set(type, { type: lineStyleType });
    }
  }
  setDefaultLineStyleWidth(type, strokeWidth) {
    const defaultStyle = this.lineStyles.get(type);
    if (defaultStyle) {
      defaultStyle.strokeWidth = strokeWidth;
    } else {
      this.lineStyles.set(type, { strokeWidth });
    }
  }
  setDefaultLineTextAlignment(type, alignment) {
    this.lineTextAlignments.set(type, alignment);
  }
  setDefaultLineTextPosition(type, position) {
    this.lineTextPositions.set(type, position);
  }
  setDefaultFibonacciOptions(type, key, value) {
    if (type != "fibonacci-retracement" && type != "fibonacci-retracement-trend-based")
      return;
    const options = this.fibonacciOptions.get(type);
    options[key] = value;
    this.fibonacciOptions.set(type, options);
  }
  applyDefaults(datum) {
    for (const [annotationType, colors] of this.colors) {
      if (datum.type !== annotationType)
        continue;
      for (const [colorPickerType, [colorOpacity, color6, opacity, isMultiColor] = []] of colors) {
        if (colorOpacity && color6 && opacity != null && isMultiColor != null) {
          setColor(datum, colorPickerType, colorOpacity, color6, opacity, isMultiColor);
        }
      }
    }
    for (const [annotationType, size] of this.fontSizes) {
      if (datum.type !== annotationType || size == null)
        continue;
      setFontSize(datum, size);
    }
    for (const [annotationType, style2] of this.lineStyles) {
      if (datum.type !== annotationType || style2 == null)
        continue;
      setLineStyle(datum, style2);
    }
    for (const [annotationType, position] of this.lineTextPositions) {
      if (datum.type !== annotationType || position == null)
        continue;
      datum.text.position = position;
    }
    for (const [annotationType, alignment] of this.lineTextAlignments) {
      if (datum.type !== annotationType || alignment == null)
        continue;
      datum.text.alignment = alignment;
    }
    for (const [annotationType, options] of this.fibonacciOptions) {
      if (datum.type !== annotationType || options == null)
        continue;
      Object.keys(options).forEach((option) => {
        const value = options[option];
        if (value == null) {
          return;
        }
        datum.set({ [option]: value });
      });
    }
  }
};
var colorPickerTemplate_default = '<div class="ag-charts-color-picker__palette" role="slider" tabindex="0"></div><div class="ag-charts-color-picker__color-row" role="presentation"><button class="ag-charts-color-picker__multi-color-button" tabindex="0" type="button" role="switch"></button> <input class="ag-charts-color-picker__hue-input" tabindex="0" type="range" min="0" max="360" value="0"></div><input class="ag-charts-color-picker__alpha-input" tabindex="0" type="range" min="0" max="1" value="1" step="0.01"> <label class="ag-charts-color-picker__color-field" role="presentation"><span class="ag-charts-color-picker__color-label" aria-hidden="true"></span> <input class="ag-charts-color-picker__color-input" tabindex="0" value="#000"></label>';
var { Color: Color3 } = module_support_exports;
var getHsva = (input) => {
  try {
    const color6 = Color3.fromString(input);
    const [h, s, v] = color6.toHSB();
    return [h, s, v, color6.a];
  } catch {
    return;
  }
};
var ColorPicker = class extends module_support_exports.AnchoredPopover {
  constructor(ctx, options) {
    super(ctx, "color-picker", options);
    this.hasChanged = false;
    this.hideFns.push(() => {
      this.i18nUpdater = void 0;
      if (this.hasChanged)
        this.onChangeHide?.();
    });
    this.cleanup.register(this.ctx.eventsHub.on("locale:change", () => this.i18nUpdater?.()));
  }
  show(options) {
    this.hasChanged = false;
    this.onChangeHide = options.onChangeHide;
    const { element: element2, initialFocus } = this.createColorPicker(options);
    const popover = this.showWithChildren([element2], { initialFocus, ...options });
    popover.classList.add("ag-charts-color-picker");
    popover.setAttribute("role", "dialog");
  }
  createColorPicker(opts) {
    const { localeManager } = this.ctx;
    let isMultiColor = opts.isMultiColor ?? false;
    let [h, s, v, a] = getHsva(opts.color ?? "#f00") ?? [0, 1, 0.5, 1];
    a = opts.opacity ?? a;
    const colorPicker = createElement("div", "ag-charts-color-picker__content");
    colorPicker.innerHTML = colorPickerTemplate_default;
    colorPicker.ariaLabel = this.ctx.localeManager.t("ariaLabelColorPicker");
    const paletteInput = colorPicker.querySelector(".ag-charts-color-picker__palette");
    const hueInput = colorPicker.querySelector(".ag-charts-color-picker__hue-input");
    const multiColorButton = colorPicker.querySelector(
      ".ag-charts-color-picker__multi-color-button"
    );
    const alphaInput = colorPicker.querySelector(".ag-charts-color-picker__alpha-input");
    const colorInput = colorPicker.querySelector(".ag-charts-color-picker__color-input");
    const colorInputLabel = colorPicker.querySelector(".ag-charts-color-picker__color-label");
    const updatePaletteInputAriaValue = (first2) => {
      const key = { s: "ariaValueColorPalette", v: "ariaValueColorPaletteFirstV" }[first2];
      paletteInput.ariaValueText = localeManager.t(key, { s, v });
    };
    this.i18nUpdater = () => {
      paletteInput.ariaRoleDescription = localeManager.t("ariaRoleDescription2DSlider");
      paletteInput.ariaLabel = localeManager.t("ariaLabelColorPickerPalette");
      hueInput.ariaLabel = localeManager.t("ariaLabelColorPickerHue");
      multiColorButton.ariaLabel = localeManager.t("ariaLabelColorPickerMultiColor");
      alphaInput.ariaLabel = localeManager.t("ariaLabelColorPickerAlpha");
      colorInput.ariaLabel = localeManager.t("ariaLabelColor");
      updatePaletteInputAriaValue("s");
    };
    this.i18nUpdater();
    multiColorButton.classList.toggle(
      "ag-charts-color-picker__multi-color-button--hidden",
      !opts.hasMultiColorOption
    );
    const update = (trackChange = true) => {
      const color6 = Color3.fromHSB(h, s, v, a);
      const colorString = color6.toHexString();
      colorPicker.style.setProperty("--h", `${h}`);
      colorPicker.style.setProperty("--s", `${s}`);
      colorPicker.style.setProperty("--v", `${v}`);
      colorPicker.style.setProperty("--a", `${a}`);
      colorPicker.style.setProperty("--color", colorString.slice(0, 7));
      colorPicker.style.setProperty("--color-a", colorString);
      hueInput.value = `${h}`;
      alphaInput.value = `${a}`;
      alphaInput.classList.toggle("ag-charts-color-picker__alpha-input--opaque", a === 1);
      multiColorButton.classList.toggle("ag-charts-color-picker__multi-color-button--active", isMultiColor);
      colorInputLabel.classList.toggle("ag-charts-color-picker__color-label--multi-color", isMultiColor);
      if (document.activeElement !== colorInput) {
        multiColorButton.ariaChecked = isMultiColor.toString();
        colorInput.value = isMultiColor ? localeManager.t("ariaLabelColorPickerMultiColor") : colorString.toUpperCase();
      }
      if (trackChange || opts.color == null) {
        const plainColor = Color3.fromHSB(h, s, v, 1).toHexString();
        opts.onChange?.(colorString, plainColor, a, isMultiColor);
      }
      if (trackChange)
        this.hasChanged = true;
    };
    update(false);
    const preventDefault = (event) => event.preventDefault();
    const stopPropagation = (event) => event.stopPropagation();
    const beginPaletteInteraction = (e) => {
      e.preventDefault();
      const currentTarget = e.currentTarget;
      currentTarget.focus();
      const rect = currentTarget.getBoundingClientRect();
      const pointerMove = ({ clientX, clientY }) => {
        isMultiColor = false;
        s = Math.min(Math.max((clientX - rect.left) / rect.width, 0), 1);
        v = 1 - Math.min(Math.max((clientY - rect.top) / rect.height, 0), 1);
        update();
        updatePaletteInputAriaValue("s");
      };
      pointerMove(e);
      const pointerUp = attachListener(getWindow(), "pointermove", pointerMove);
      getWindow().addEventListener("pointerup", pointerUp, { once: true });
    };
    colorPicker.addEventListener("mousedown", stopPropagation);
    colorPicker.addEventListener("touchstart", stopPropagation);
    colorPicker.addEventListener("touchmove", stopPropagation);
    colorPicker.addEventListener("keydown", (e) => {
      e.stopPropagation();
      switch (e.key) {
        case "Enter":
        case "Escape":
          this.hide();
          break;
        default:
          return;
      }
      e.preventDefault();
    });
    paletteInput.addEventListener("pointerdown", beginPaletteInteraction);
    paletteInput.addEventListener("touchstart", preventDefault, { passive: false });
    paletteInput.addEventListener("touchmove", preventDefault, { passive: false });
    paletteInput.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") {
        s = clamp(0, s - 0.01, 1);
        updatePaletteInputAriaValue("s");
      } else if (e.key === "ArrowRight") {
        s = clamp(0, s + 0.01, 1);
        updatePaletteInputAriaValue("s");
      } else if (e.key === "ArrowUp") {
        v = clamp(0, v + 0.01, 1);
        updatePaletteInputAriaValue("v");
      } else if (e.key === "ArrowDown") {
        v = clamp(0, v - 0.01, 1);
        updatePaletteInputAriaValue("v");
      } else {
        return;
      }
      e.preventDefault();
      update();
    });
    paletteInput.addEventListener("focus", () => {
      updatePaletteInputAriaValue("s");
    });
    multiColorButton.addEventListener("click", () => {
      isMultiColor = !isMultiColor;
      update();
    });
    hueInput.addEventListener("input", (e) => {
      isMultiColor = false;
      h = e.currentTarget.valueAsNumber ?? 0;
      update();
    });
    alphaInput.addEventListener("input", (e) => {
      isMultiColor = false;
      a = e.currentTarget.valueAsNumber ?? 0;
      update();
    });
    colorInput.addEventListener("input", (e) => {
      isMultiColor = false;
      const hsva = getHsva(e.currentTarget.value);
      if (hsva == null)
        return;
      [h, s, v, a] = hsva;
      update();
    });
    colorInput.addEventListener("blur", () => update());
    colorInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.currentTarget.blur();
        update();
      }
    });
    return { element: colorPicker, initialFocus: paletteInput };
  }
};
function channelMenuItemVisible(scale2) {
  return !(scale2 instanceof module_support_exports.LogScale) && !(scale2 instanceof module_support_exports.BandScale);
}
var LINE_ANNOTATION_ITEMS = [
  {
    label: "toolbarAnnotationsTrendLine",
    icon: "trend-line-drawing",
    value: "line"
    /* Line */
  },
  {
    label: "toolbarAnnotationsHorizontalLine",
    icon: "horizontal-line-drawing",
    value: "horizontal-line"
    /* HorizontalLine */
  },
  {
    label: "toolbarAnnotationsVerticalLine",
    icon: "vertical-line-drawing",
    value: "vertical-line"
    /* VerticalLine */
  },
  {
    label: "toolbarAnnotationsParallelChannel",
    icon: "parallel-channel-drawing",
    value: "parallel-channel",
    visible: channelMenuItemVisible
  },
  {
    label: "toolbarAnnotationsDisjointChannel",
    icon: "disjoint-channel-drawing",
    value: "disjoint-channel",
    visible: channelMenuItemVisible
  }
];
var FIBONACCI_ANNOTATION_ITEMS = [
  {
    label: "toolbarAnnotationsFibonacciRetracement",
    icon: "fibonacci-retracement-drawing",
    value: "fibonacci-retracement"
    /* FibonacciRetracement */
  },
  {
    label: "toolbarAnnotationsFibonacciRetracementTrendBased",
    icon: "fibonacci-retracement-trend-based-drawing",
    value: "fibonacci-retracement-trend-based"
    /* FibonacciRetracementTrendBased */
  }
];
var FIBONACCI_RATIO_ITEMS = [
  { label: "Fibonacci - Extended", value: 10 },
  { label: "Fibonacci - 6 Band", value: 6 },
  { label: "Fibonacci - 4 Band", value: 4 }
];
var TEXT_ANNOTATION_ITEMS = [
  {
    label: "toolbarAnnotationsText",
    icon: "text-annotation",
    value: "text"
    /* Text */
  },
  {
    label: "toolbarAnnotationsComment",
    icon: "comment-annotation",
    value: "comment"
    /* Comment */
  },
  {
    label: "toolbarAnnotationsCallout",
    icon: "callout-annotation",
    value: "callout"
    /* Callout */
  },
  {
    label: "toolbarAnnotationsNote",
    icon: "note-annotation",
    value: "note"
    /* Note */
  }
];
var SHAPE_ANNOTATION_ITEMS = [
  {
    label: "toolbarAnnotationsArrow",
    icon: "arrow-drawing",
    value: "arrow"
    /* Arrow */
  },
  {
    label: "toolbarAnnotationsArrowUp",
    icon: "arrow-up-drawing",
    value: "arrow-up"
    /* ArrowUp */
  },
  {
    label: "toolbarAnnotationsArrowDown",
    icon: "arrow-down-drawing",
    value: "arrow-down"
    /* ArrowDown */
  }
];
var MEASURER_ANNOTATION_ITEMS = [
  {
    label: "toolbarAnnotationsQuickDatePriceRange",
    icon: "measurer-drawing",
    value: "quick-date-price-range"
    /* QuickDatePriceRange */
  },
  {
    label: "toolbarAnnotationsDateRange",
    icon: "date-range-drawing",
    value: "date-range"
    /* DateRange */
  },
  {
    label: "toolbarAnnotationsPriceRange",
    icon: "price-range-drawing",
    value: "price-range"
    /* PriceRange */
  },
  {
    label: "toolbarAnnotationsDatePriceRange",
    icon: "date-price-range-drawing",
    value: "date-price-range"
    /* DatePriceRange */
  }
];
var LINE_STROKE_WIDTH_ITEMS = [
  { strokeWidth: 1, label: "1", value: 1 },
  { strokeWidth: 2, label: "2", value: 2 },
  { strokeWidth: 3, label: "3", value: 3 },
  { strokeWidth: 4, label: "4", value: 4 },
  { strokeWidth: 8, label: "8", value: 8 }
];
var LINE_STYLE_TYPE_ITEMS = [
  { icon: "line-style-solid", altText: "iconAltTextLineStyleSolid", value: "solid" },
  { icon: "line-style-dashed", altText: "iconAltTextLineStyleDashed", value: "dashed" },
  { icon: "line-style-dotted", altText: "iconAltTextLineStyleDotted", value: "dotted" }
];
var TEXT_SIZE_ITEMS = [
  { label: "10", value: 10 },
  { label: "12", value: 12 },
  { label: "14", value: 14 },
  { label: "16", value: 16 },
  { label: "18", value: 18 },
  { label: "22", value: 22 },
  { label: "28", value: 28 },
  { label: "36", value: 36 },
  { label: "46", value: 46 }
];
var { Color: Color4, FloatingToolbar: FloatingToolbar2, Menu: Menu2, PropertiesArray: PropertiesArray2, ToolbarButtonProperties: ToolbarButtonProperties2, ToolbarButtonWidget: ToolbarButtonWidget2, Property: Property28 } = module_support_exports;
var AnnotationOptionsButtonProperties = class extends ToolbarButtonProperties2 {
  constructor() {
    super(...arguments);
    this.checkedOverrides = new ToolbarButtonProperties2();
  }
};
__decorateClass2([
  Property28
], AnnotationOptionsButtonProperties.prototype, "value", 2);
__decorateClass2([
  Property28
], AnnotationOptionsButtonProperties.prototype, "checkedOverrides", 2);
__decorateClass2([
  Property28
], AnnotationOptionsButtonProperties.prototype, "color", 2);
__decorateClass2([
  Property28
], AnnotationOptionsButtonProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property28
], AnnotationOptionsButtonProperties.prototype, "isMultiColor", 2);
var AnnotationOptionsButtonWidget = class extends ToolbarButtonWidget2 {
  update(options) {
    super.update(options);
    if (options.value === "line-stroke-width") {
      this.updateLineStrokeWidth(options);
    }
    if (options.value === "fill-color" || options.value === "line-color" || options.value === "text-color") {
      this.updateFillColor(options);
    }
  }
  updateFillColor(options) {
    const element2 = this.getElement();
    element2.classList.add("ag-charts-annotations__color-picker-button");
    element2.classList.toggle("ag-charts-annotations__color-picker-button--multi-color", options.isMultiColor);
    element2.style.setProperty("--color", options.color ?? null);
  }
  updateLineStrokeWidth(options) {
    const element2 = this.getElement();
    element2.classList.add("ag-charts-annotations__stroke-width-button");
    element2.style.setProperty("--stroke-width", `${options.strokeWidth}px`);
  }
};
var FloatingAnnotationOptionsToolbar = class extends FloatingToolbar2 {
  createButtonWidget() {
    return new AnnotationOptionsButtonWidget(this.localeManager);
  }
};
var AnnotationOptionsToolbar = class extends module_support_exports.BaseProperties {
  constructor(ctx, getActiveDatum) {
    super();
    this.ctx = ctx;
    this.getActiveDatum = getActiveDatum;
    this.enabled = true;
    this.buttons = new PropertiesArray2(AnnotationOptionsButtonProperties);
    this.cleanup = new CleanupRegistry();
    this.events = new EventEmitter();
    this.visibleButtons = [];
    this.toolbar = new FloatingAnnotationOptionsToolbar(
      this.ctx,
      "ariaLabelAnnotationOptionsToolbar",
      "annotation-options"
    );
    this.colorPicker = new ColorPicker(this.ctx);
    this.textSizeMenu = new Menu2(this.ctx, "text-size");
    this.lineStyleTypeMenu = new Menu2(this.ctx, "annotations-line-style-type");
    this.lineStrokeWidthMenu = new Menu2(this.ctx, "annotations-line-stroke-width");
    this.cleanup.register(
      this.toolbar.addToolbarListener("button-pressed", this.onButtonPress.bind(this)),
      this.toolbar.addToolbarListener("toolbar-moved", this.onToolbarMoved.bind(this)),
      ctx.widgets.seriesWidget.addListener("drag-start", this.onDragStart.bind(this)),
      ctx.widgets.seriesWidget.addListener("drag-end", this.onDragEnd.bind(this)),
      () => {
        this.colorPicker.destroy();
        this.toolbar.destroy();
      }
    );
  }
  onDragStart() {
    this.toolbar.ignorePointerEvents();
  }
  onDragEnd() {
    this.toolbar.capturePointerEvents();
  }
  destroy() {
    this.cleanup.flush();
  }
  show() {
    if (!this.enabled)
      return;
    this.toolbar.show();
  }
  hide() {
    this.toolbar.hide();
  }
  updateButtons(datum) {
    if (!this.enabled)
      return;
    const visible = {
      [
        "line-style-type"
        /* LineStyleType */
      ]: hasLineStyle(datum),
      [
        "line-stroke-width"
        /* LineStrokeWidth */
      ]: hasLineStyle(datum),
      [
        "line-color"
        /* LineColor */
      ]: hasLineColor(datum),
      [
        "text-color"
        /* TextColor */
      ]: hasTextColor(datum),
      [
        "fill-color"
        /* FillColor */
      ]: hasFillColor(datum),
      [
        "text-size"
        /* TextSize */
      ]: hasFontSize(datum),
      [
        "settings"
        /* Settings */
      ]: hasLineText(datum),
      [
        "lock"
        /* Lock */
      ]: true,
      [
        "delete"
        /* Delete */
      ]: true
    };
    this.visibleButtons = this.buttons.filter((button) => visible[button.value]);
    this.toolbar.clearButtons();
    this.toolbar.updateButtons(this.visibleButtons);
    this.refreshButtons(datum);
  }
  setAnchorScene(scene) {
    if (this.toolbar.hasBeenDragged())
      return;
    this.toolbar.setAnchor(scene.getAnchor());
  }
  hideOverlays() {
    this.toolbar.clearActiveButton();
    this.colorPicker.hide({ lastFocus: null });
    this.textSizeMenu.hide();
    this.lineStyleTypeMenu.hide();
    this.lineStrokeWidthMenu.hide();
    this.events.emit("hid-overlays", null);
  }
  clearActiveButton() {
    this.toolbar.clearActiveButton();
  }
  updateColors(datum) {
    this.updateColorPickerColor(
      "line-color",
      datum.getDefaultColor(
        "line-color"
        /* LineColor */
      ),
      datum.getDefaultOpacity(
        "line-color"
        /* LineColor */
      ),
      "isMultiColor" in datum && datum?.isMultiColor
    );
    this.updateColorPickerColor(
      "fill-color",
      datum.getDefaultColor(
        "fill-color"
        /* FillColor */
      ),
      datum.getDefaultOpacity(
        "fill-color"
        /* FillColor */
      ),
      "isMultiColor" in datum && datum?.isMultiColor
    );
    this.updateColorPickerColor(
      "text-color",
      datum.getDefaultColor(
        "text-color"
        /* TextColor */
      ),
      datum.getDefaultOpacity(
        "text-color"
        /* TextColor */
      ),
      "isMultiColor" in datum && datum?.isMultiColor
    );
  }
  updateColorPickerColor(colorPickerType, color6, opacity, isMultiColor) {
    if (color6 != null && opacity != null) {
      const { r, g, b } = Color4.fromString(color6);
      color6 = Color4.fromArray([r, g, b, opacity]).toHexString();
    }
    this.updateButtonByValue(colorPickerType, { color: color6, isMultiColor });
  }
  updateFontSize(fontSize) {
    this.updateButtonByValue("text-size", {
      label: fontSize != null ? String(fontSize) : void 0
    });
  }
  updateLineStyleType(item) {
    this.updateButtonByValue("line-style-type", {
      icon: item.icon
    });
  }
  updateStrokeWidth(item) {
    this.updateButtonByValue("line-stroke-width", {
      label: item.label,
      strokeWidth: item.value
    });
  }
  onButtonPress({
    event,
    button
  }) {
    const datum = this.getActiveDatum();
    if (!datum)
      return;
    this.hideOverlays();
    switch (button.value) {
      case "line-style-type": {
        const lineStyle = hasLineStyle(datum) ? getLineStyle(datum.lineDash, datum.lineStyle) : void 0;
        this.lineStyleTypeMenu.show({
          items: LINE_STYLE_TYPE_ITEMS,
          ariaLabel: this.ctx.localeManager.t("toolbarAnnotationsLineStyle"),
          value: lineStyle,
          sourceEvent: event.sourceEvent,
          onPress: (item) => this.onLineStyleTypeMenuPress(item, datum),
          class: "ag-charts-annotations__line-style-type-menu"
        });
        break;
      }
      case "line-stroke-width": {
        const strokeWidth = hasLineStyle(datum) ? datum.strokeWidth : void 0;
        this.lineStrokeWidthMenu.show({
          items: LINE_STROKE_WIDTH_ITEMS,
          ariaLabel: this.ctx.localeManager.t("toolbarAnnotationsLineStrokeWidth"),
          value: strokeWidth,
          sourceEvent: event.sourceEvent,
          onPress: (item) => this.onLineStrokeWidthMenuPress(item, datum),
          class: "ag-charts-annotations__line-stroke-width-menu"
        });
        break;
      }
      case "line-color":
      case "fill-color":
      case "text-color": {
        this.toolbar.toggleActiveButtonByIndex(button.index);
        this.colorPicker.show({
          color: datum?.getDefaultColor(button.value),
          opacity: datum?.getDefaultOpacity(button.value),
          sourceEvent: event.sourceEvent,
          hasMultiColorOption: "isMultiColor" in datum,
          isMultiColor: "isMultiColor" in datum && datum?.isMultiColor,
          onChange: datum != null ? this.onColorPickerChange.bind(this, button.value, datum) : void 0,
          onChangeHide: ((type) => {
            this.events.emit("saved-color", {
              type: datum.type,
              colorPickerType: button.value,
              color: datum.getDefaultColor(type)
            });
          }).bind(this, button.value)
        });
        break;
      }
      case "text-size": {
        const fontSize = isTextType(datum) ? datum.fontSize : void 0;
        this.textSizeMenu.show({
          items: TEXT_SIZE_ITEMS,
          ariaLabel: this.ctx.localeManager.t("toolbarAnnotationsTextSize"),
          value: fontSize,
          sourceEvent: event.sourceEvent,
          onPress: (item) => this.onTextSizeMenuPress(item, datum),
          class: "ag-charts-annotations__text-size-menu"
        });
        break;
      }
      case "delete": {
        this.events.emit("pressed-delete", null);
        break;
      }
      case "lock": {
        datum.locked = !datum.locked;
        this.refreshButtons(datum);
        this.events.emit("pressed-lock", null);
        break;
      }
      case "settings": {
        this.toolbar.toggleActiveButtonByIndex(button.index);
        this.events.emit("pressed-settings", event);
        break;
      }
    }
  }
  onToolbarMoved(event) {
    const { buttonBounds, popoverBounds } = event;
    const colorPickerAnchor = { x: popoverBounds.x, y: popoverBounds.y + popoverBounds.height + 4 };
    const colorPickerFallbackAnchor = { y: popoverBounds.y - 4 };
    this.colorPicker.setAnchor(colorPickerAnchor, colorPickerFallbackAnchor);
    for (const [index, bounds] of buttonBounds.entries()) {
      const button = this.visibleButtons.at(index);
      if (!button)
        continue;
      const anchor = { x: bounds.x, y: bounds.y + bounds.height - 1 };
      const fallbackAnchor = { y: bounds.y };
      switch (button.value) {
        case "line-stroke-width":
          this.lineStrokeWidthMenu.setAnchor(anchor, fallbackAnchor);
          break;
        case "line-style-type":
          this.lineStyleTypeMenu.setAnchor(anchor, fallbackAnchor);
          break;
        case "text-size":
          this.textSizeMenu.setAnchor(anchor, fallbackAnchor);
          break;
      }
    }
  }
  onColorPickerChange(colorPickerType, datum, colorOpacity, color6, opacity, isMultiColor) {
    this.events.emit("updated-color", {
      type: datum.type,
      colorPickerType,
      colorOpacity,
      color: color6,
      opacity,
      isMultiColor
    });
    this.updateColorPickerColor(colorPickerType, colorOpacity, opacity, isMultiColor);
  }
  onTextSizeMenuPress(item, datum) {
    if (!hasFontSize(datum))
      return;
    const fontSize = item.value;
    this.events.emit("updated-font-size", { type: datum.type, fontSize });
    this.textSizeMenu.hide();
    this.updateFontSize(fontSize);
  }
  onLineStyleTypeMenuPress(item, datum) {
    if (!hasLineStyle(datum))
      return;
    const type = item.value;
    this.events.emit("updated-line-style", { type: datum.type, lineStyleType: type });
    this.lineStyleTypeMenu.hide();
    this.updateLineStyleType(item);
  }
  onLineStrokeWidthMenuPress(item, datum) {
    if (!hasLineStyle(datum)) {
      return;
    }
    const strokeWidth = item.value;
    this.events.emit("updated-line-width", { type: datum.type, strokeWidth });
    this.lineStrokeWidthMenu.hide();
    this.updateStrokeWidth(item);
  }
  refreshButtons(datum) {
    const locked = datum.locked ?? false;
    for (const [index, button] of this.visibleButtons.entries()) {
      if (!button)
        continue;
      if (button.value === "lock") {
        this.toolbar.toggleSwitchCheckedByIndex(index, locked);
        this.updateButtonByIndex(index, locked ? button.checkedOverrides.toJson() : button.toJson());
      } else {
        this.toolbar.toggleButtonEnabledByIndex(index, !locked);
      }
    }
    if (hasFontSize(datum))
      this.updateFontSize(datum.fontSize);
    this.updateColors(datum);
    this.updateLineStyles(datum);
  }
  updateLineStyles(datum) {
    if (!hasLineStyle(datum))
      return;
    const strokeWidth = datum.strokeWidth ?? 1;
    const lineStyleType = getLineStyle(datum.lineDash, datum.lineStyle);
    this.updateStrokeWidth({
      strokeWidth,
      value: strokeWidth,
      label: String(strokeWidth)
    });
    this.updateLineStyleType(
      LINE_STYLE_TYPE_ITEMS.find((item) => item.value === lineStyleType) ?? LINE_STYLE_TYPE_ITEMS[0]
    );
  }
  updateButtonByValue(value, change) {
    const index = this.visibleButtons.findIndex((button) => button.value === value);
    if (index === -1)
      return;
    this.updateButtonByIndex(index, change);
  }
  updateButtonByIndex(index, change) {
    const button = this.visibleButtons.at(index);
    if (!button)
      return;
    this.toolbar.updateButtonByIndex(index, { ...button.toJson(), ...change, value: change.value ?? button.value });
  }
};
__decorateClass2([
  Property28
], AnnotationOptionsToolbar.prototype, "enabled", 2);
__decorateClass2([
  Property28
], AnnotationOptionsToolbar.prototype, "buttons", 2);
var { StateMachine: StateMachine2, StateMachineProperty: StateMachineProperty2, Vec2: Vec222, Debug: Debug2 } = module_support_exports;
var DragStateMachine = class extends StateMachine2 {
  constructor(ctx) {
    const actionKeyChange = ({ context }) => {
      this.node?.drag(this.datum, this.offset, context, this.snapping);
      ctx.update();
    };
    super("idle", {
      idle: {
        dragStart: {
          target: "dragging",
          action: ({ offset, context }) => {
            this.hasMoved = false;
            this.dragStart = offset;
            this.offset = offset;
            this.node?.dragStart(this.datum, offset, context);
          }
        }
      },
      dragging: {
        keyDown: actionKeyChange,
        keyUp: actionKeyChange,
        drag: ({ offset, context }) => {
          this.hasMoved = Vec222.lengthSquared(Vec222.sub(offset, this.dragStart)) > 0;
          this.offset = offset;
          this.node?.drag(this.datum, offset, context, this.snapping);
          ctx.update();
        },
        dragEnd: {
          target: StateMachine2.parent,
          action: () => {
            this.node?.stopDragging();
            if (this.hasMoved)
              ctx.recordAction("Move annotation");
            ctx.update();
          }
        }
      }
    });
    this.debug = Debug2.create(true, "annotations");
    this.hasMoved = false;
    this.snapping = false;
  }
};
__decorateClass2([
  StateMachineProperty2()
], DragStateMachine.prototype, "snapping", 2);
__decorateClass2([
  StateMachineProperty2()
], DragStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty2()
], DragStateMachine.prototype, "node", 2);
var { Property: Property29 } = module_support_exports;
var ArrowDownProperties = class extends ShapePointProperties {
  constructor() {
    super(...arguments);
    this.type = "arrow-down";
  }
  static is(value) {
    return isObject(value) && value.type === "arrow-down";
  }
};
__decorateClass2([
  Property29
], ArrowDownProperties.prototype, "type", 2);
var AnnotationShape = class extends module_support_exports.Marker {
  // Use exact method for this, rather than the Marker's high performance approximation.
  isPointInPath(x, y) {
    this.updatePathIfDirty();
    return this.path.closedPath && this.path.isPointInPath(x, y);
  }
};
var _Handle = class _Handle2 extends module_support_exports.Group {
  constructor() {
    super(...arguments);
    this.active = false;
    this.locked = false;
    this.visible = false;
    this.zIndex = 1;
  }
  drag(target) {
    const { handle: handle22, locked } = this;
    if (locked) {
      return { point: { x: handle22.x, y: handle22.y }, offset: { x: 0, y: 0 } };
    }
    return {
      point: target,
      offset: { x: target.x - handle22.x, y: target.y - handle22.y }
    };
  }
  toggleActive(active) {
    this.active = active;
    if (!active) {
      this.handle.strokeWidth = _Handle2.INACTIVE_STROKE_WIDTH;
    }
  }
  toggleHovered(hovered) {
    this.glow.visible = !this.locked && hovered;
    this.glow.dirtyPath = true;
  }
  toggleDragging(dragging) {
    if (this.locked)
      return;
    this.handle.visible = !dragging;
    this.glow.visible = this.glow.visible && !dragging;
    this.handle.dirtyPath = true;
    this.glow.dirtyPath = true;
  }
  toggleLocked(locked) {
    this.locked = locked;
  }
  getCursor() {
    return void 0;
  }
  containsPoint(x, y) {
    return this.handle.containsPoint(x, y);
  }
};
_Handle.INACTIVE_STROKE_WIDTH = 2;
var Handle2 = _Handle;
var _InvariantHandle = class _InvariantHandle2 extends Handle2 {
  constructor() {
    super();
    this.handle = new AnnotationShape({ shape: "circle" });
    this.glow = new AnnotationShape({ shape: "circle" });
    this.append([this.handle]);
    this.handle.size = _InvariantHandle2.HANDLE_SIZE;
    this.handle.strokeWidth = Handle2.INACTIVE_STROKE_WIDTH;
    this.handle.zIndex = 2;
  }
  update(styles) {
    this.handle.setProperties({ ...styles, strokeWidth: Handle2.INACTIVE_STROKE_WIDTH });
  }
  drag(target) {
    return { point: target, offset: { x: 0, y: 0 } };
  }
};
_InvariantHandle.HANDLE_SIZE = 7;
_InvariantHandle.GLOW_SIZE = 9;
var InvariantHandle = _InvariantHandle;
var _UnivariantHandle = class _UnivariantHandle2 extends Handle2 {
  constructor() {
    super();
    this.handle = new module_support_exports.Rect();
    this.glow = new module_support_exports.Rect();
    this.gradient = "horizontal";
    this.append([this.glow, this.handle]);
    this.handle.cornerRadius = _UnivariantHandle2.CORNER_RADIUS;
    this.handle.width = _UnivariantHandle2.HANDLE_SIZE;
    this.handle.height = _UnivariantHandle2.HANDLE_SIZE;
    this.handle.strokeWidth = Handle2.INACTIVE_STROKE_WIDTH;
    this.handle.zIndex = 2;
    this.glow.cornerRadius = _UnivariantHandle2.CORNER_RADIUS;
    this.glow.width = _UnivariantHandle2.GLOW_SIZE;
    this.glow.height = _UnivariantHandle2.GLOW_SIZE;
    this.glow.strokeWidth = 0;
    this.glow.fillOpacity = 0.2;
    this.glow.zIndex = 1;
    this.glow.visible = false;
  }
  toggleLocked(locked) {
    super.toggleLocked(locked);
    if (locked) {
      const offset = (_UnivariantHandle2.HANDLE_SIZE - InvariantHandle.HANDLE_SIZE) / 2;
      this.handle.cornerRadius = 1;
      this.handle.fill = this.handle.stroke;
      this.handle.strokeWidth = 0;
      this.handle.x += offset;
      this.handle.y += offset;
      this.handle.width = InvariantHandle.HANDLE_SIZE;
      this.handle.height = InvariantHandle.HANDLE_SIZE;
      this.glow.width = InvariantHandle.GLOW_SIZE;
      this.glow.height = InvariantHandle.GLOW_SIZE;
    } else {
      this.handle.cornerRadius = _UnivariantHandle2.CORNER_RADIUS;
      this.handle.width = _UnivariantHandle2.HANDLE_SIZE;
      this.handle.height = _UnivariantHandle2.HANDLE_SIZE;
      this.glow.width = _UnivariantHandle2.GLOW_SIZE;
      this.glow.height = _UnivariantHandle2.GLOW_SIZE;
      if (this.cachedStyles) {
        this.handle.setProperties(this.cachedStyles);
      }
    }
  }
  update(styles) {
    this.cachedStyles = { ...styles };
    if (!this.active) {
      delete styles.strokeWidth;
    }
    if (this.locked) {
      delete styles.fill;
      delete styles.strokeWidth;
      const offset = (_UnivariantHandle2.HANDLE_SIZE - InvariantHandle.HANDLE_SIZE) / 2;
      styles.x -= offset;
      styles.y -= offset;
      this.cachedStyles.x -= offset;
      this.cachedStyles.y -= offset;
    }
    this.handle.setProperties(styles);
    this.glow.setProperties({
      ...styles,
      x: (styles.x ?? this.glow.x) - 2,
      y: (styles.y ?? this.glow.y) - 2,
      strokeWidth: 0,
      fill: styles.stroke
    });
  }
  drag(target) {
    if (this.locked) {
      return { point: target, offset: { x: 0, y: 0 } };
    }
    if (this.gradient === "vertical") {
      return {
        point: { x: target.x, y: this.handle.y },
        offset: { x: target.x - this.handle.x, y: 0 }
      };
    }
    return {
      point: { x: this.handle.x, y: target.y },
      offset: { x: 0, y: target.y - this.handle.y }
    };
  }
  getCursor() {
    if (this.locked)
      return;
    return this.gradient === "vertical" ? "col-resize" : "row-resize";
  }
};
_UnivariantHandle.HANDLE_SIZE = 12;
_UnivariantHandle.GLOW_SIZE = 16;
_UnivariantHandle.CORNER_RADIUS = 4;
var UnivariantHandle = _UnivariantHandle;
var _DivariantHandle = class _DivariantHandle2 extends Handle2 {
  constructor() {
    super();
    this.handle = new AnnotationShape({ shape: "circle" });
    this.glow = new AnnotationShape({ shape: "circle" });
    this.append([this.glow, this.handle]);
    this.handle.size = _DivariantHandle2.HANDLE_SIZE;
    this.handle.strokeWidth = Handle2.INACTIVE_STROKE_WIDTH;
    this.handle.zIndex = 2;
    this.glow.size = _DivariantHandle2.GLOW_SIZE;
    this.glow.strokeWidth = 0;
    this.glow.fillOpacity = 0.2;
    this.glow.zIndex = 1;
    this.glow.visible = false;
  }
  toggleLocked(locked) {
    super.toggleLocked(locked);
    if (locked) {
      this.handle.fill = this.handle.stroke;
      this.handle.strokeWidth = 0;
      this.handle.size = InvariantHandle.HANDLE_SIZE;
      this.glow.size = InvariantHandle.GLOW_SIZE;
    } else {
      this.handle.size = _DivariantHandle2.HANDLE_SIZE;
      this.glow.size = _DivariantHandle2.GLOW_SIZE;
      if (this.cachedStyles) {
        this.handle.setProperties(this.cachedStyles);
      }
    }
  }
  update(styles) {
    this.cachedStyles = { ...styles };
    if (!this.active) {
      delete styles.strokeWidth;
    }
    if (this.locked) {
      delete styles.fill;
      delete styles.strokeWidth;
    }
    this.handle.setProperties(styles);
    this.glow.setProperties({ ...styles, strokeWidth: 0, fill: styles.stroke });
  }
  getCursor() {
    return "pointer";
  }
};
_DivariantHandle.HANDLE_SIZE = 11;
_DivariantHandle.GLOW_SIZE = 17;
var DivariantHandle = _DivariantHandle;
var { ZIndexMap: ZIndexMap22 } = module_support_exports;
var AnnotationScene = class extends module_support_exports.Group {
  constructor() {
    super(...arguments);
    this.name = "AnnotationScene";
    this.zIndex = ZIndexMap22.CHART_ANNOTATION;
  }
  static isCheck(value, type) {
    return isObject(value) && Object.hasOwn(value, "type") && value.type === type;
  }
  toggleHovered(hovered) {
    this.toggleHandles(hovered);
  }
  computeBBoxWithoutHandles() {
    return module_support_exports.Transformable.toCanvas(
      this,
      module_support_exports.Group.computeChildrenBBox(this.excludeChildren({ instance: Handle2 }))
    );
  }
  updateNode(constructor, node, isConfigured) {
    if (!isConfigured && node) {
      this.removeChild(node);
      return;
    }
    if (isConfigured && node == null) {
      node = new constructor();
      this.appendChild(node);
    }
    return node;
  }
};
var { ContinuousScale: ContinuousScale22, Vec2: Vec23, toRadians: toRadians3 } = module_support_exports;
function snapPoint(offset, context, snapping = false, origin3, angleStep = 1) {
  if (!snapping)
    return invertCoords(offset, context);
  const center2 = origin3 ? convertPoint(origin3, context) : Vec23.origin();
  return invertCoords(snapToAngle(offset, center2, angleStep), context);
}
function snapToAngle(vector, center2, step) {
  const radial = Vec23.sub(vector, center2);
  const stepRadians = toRadians3(step);
  const theta = Math.round(Vec23.angle(radial) / stepRadians) * stepRadians;
  return Vec23.rotate(radial, theta, center2);
}
function getDragStartState(points, context) {
  const dragState = {};
  for (const [name, point] of entries(points)) {
    dragState[name] = convertPoint(point, context);
  }
  return dragState;
}
function translate(vectors, translation, context, options = {
  overflowContinuous: 0,
  translateVectors: void 0,
  invertYVectors: void 0,
  snap: void 0
}) {
  const { xAxis, yAxis } = context;
  const vectorNames = Object.keys(vectors);
  const overflowsX = [];
  const overflowsY = [];
  const translateVectors = new Set(options.translateVectors ?? vectorNames);
  const invertYVectors = new Set(options.invertYVectors ?? []);
  const movingVectors = /* @__PURE__ */ new Set([...translateVectors, ...invertYVectors]);
  const invertYTranslation = Vec23.multiply(translation, Vec23.from(1, -1));
  for (const name of vectorNames) {
    if (movingVectors.has(name)) {
      vectors[name] = Vec23.add(vectors[name], invertYVectors.has(name) ? invertYTranslation : translation);
      if (options.snap) {
        vectors[name] = snapToAngle(vectors[name], options.snap.vectors[name], options.snap.angle);
      }
    }
    overflowsX.push(xAxis.getRangeOverflow(vectors[name].x));
    overflowsY.push(yAxis.getRangeOverflow(vectors[name].y));
  }
  const sortNumbersAbs = (a, b) => Math.abs(a) - Math.abs(b);
  const overflowDirection = (scale2, directionTranslation, overflows) => {
    if (options.overflowContinuous === 0 || !ContinuousScale22.is(scale2)) {
      return overflows.toSorted(sortNumbersAbs).at(-1) ?? 0;
    }
    if (vectorNames.length === movingVectors.size) {
      return overflows.toSorted(sortNumbersAbs).at(-options.overflowContinuous - 1) ?? 0;
    }
    if (overflows.filter((value) => value !== 0).length <= options.overflowContinuous) {
      return 0;
    }
    const newTranslatedOverflows = overflows.filter(
      (value, index) => value !== 0 && Math.abs(value) <= Math.abs(directionTranslation) && movingVectors.has(vectorNames[index])
    );
    return newTranslatedOverflows.toSorted(sortNumbersAbs).at(-1) ?? 0;
  };
  const overflow = Vec23.from(
    overflowDirection(xAxis.scale, translation.x, overflowsX),
    overflowDirection(yAxis.scale, translation.y, overflowsY)
  );
  if (!Vec23.equal(overflow, Vec23.origin())) {
    for (const name of vectorNames) {
      if (!movingVectors.has(name))
        continue;
      vectors[name] = Vec23.round(Vec23.sub(vectors[name], overflow), 4);
    }
  }
  const result = {};
  for (const name of vectorNames) {
    result[name] = invertCoords(vectors[name], context);
  }
  return result;
}
var { Vec2: Vec24 } = module_support_exports;
var PointScene = class extends AnnotationScene {
  constructor() {
    super(...arguments);
    this.handle = new DivariantHandle();
    this.anchor = {
      x: 0,
      y: 0,
      position: "above"
    };
  }
  update(datum, context) {
    const coords = convertPoint(datum, context);
    this.updateHandle(datum, coords);
    this.anchor = this.updateAnchor(datum, coords, context);
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      ...getDragStartState({ handle: datum }, context)
    };
  }
  drag(datum, target, context) {
    const { dragState } = this;
    if (datum.locked || !dragState)
      return;
    const { point } = translate({ point: dragState.handle }, Vec24.sub(target, dragState.offset), context);
    datum.x = point.x;
    datum.y = point.y;
  }
  translate(datum, translation, context) {
    if (datum.locked)
      return;
    const { point } = translate({ point: convertPoint(datum, context) }, translation, context);
    datum.x = point.x;
    datum.y = point.y;
  }
  toggleHandles(show) {
    this.handle.visible = Boolean(show);
    this.handle.toggleHovered(this.activeHandle === "handle");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.handle.toggleActive(active);
  }
  stopDragging() {
    this.handle.toggleDragging(false);
  }
  copy(datum, copiedDatum, context) {
    const coords = convertPoint(datum, context);
    const point = invertCoords({ x: coords.x - 30, y: coords.y - 30 }, context);
    copiedDatum.x = point.x;
    copiedDatum.y = point.y;
    return copiedDatum;
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    return "pointer";
  }
  containsPoint(x, y) {
    const { handle: handle22 } = this;
    this.activeHandle = void 0;
    if (handle22.containsPoint(x, y)) {
      this.activeHandle = "handle";
      return true;
    }
    return false;
  }
  getNodeAtCoords(x, y) {
    if (this.handle.containsPoint(x, y))
      return "handle";
  }
  updateHandle(datum, point, bbox) {
    const { x, y } = this.getHandleCoords(datum, point, bbox);
    const styles = this.getHandleStyles(datum);
    this.handle.update({ ...styles, x, y });
    this.handle.toggleLocked(datum.locked ?? false);
  }
  updateAnchor(datum, point, context) {
    const coords = this.getHandleCoords(datum, point);
    return {
      x: coords.x + context.seriesRect.x,
      y: coords.y + context.seriesRect.y,
      position: this.anchor.position
    };
  }
  getHandleCoords(_datum, point, _bbox) {
    return {
      x: point.x,
      y: point.y
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
};
var ShapePointScene = class extends PointScene {
  constructor() {
    super();
    this.append([this.handle]);
  }
  update(datum, context) {
    super.update(datum, context);
    const coords = convertPoint(datum, context);
    this.updateShape(datum, coords);
  }
  updateShape(datum, point) {
    this.updateShapeStyles(datum);
    this.updateShapePath(datum, point);
  }
  updateShapeStyles(datum) {
    const { shape } = this;
    shape.fill = datum.fill;
    shape.fillOpacity = datum.fillOpacity ?? 1;
  }
  updateShapePath(datum, point) {
    const { shape } = this;
    shape.x = point.x;
    shape.y = point.y;
    shape.size = datum.size;
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.shape.containsPoint(x, y);
  }
  getNodeAtCoords(x, y) {
    if (this.shape.containsPoint(x, y))
      return "shape";
    return super.getNodeAtCoords(x, y);
  }
};
var arrowUpPoints = [
  [0.5, 0],
  [1, 0.5],
  [0.75, 0.5],
  [0.75, 1],
  [0.25, 1],
  [0.25, 0.5],
  [0, 0.5]
];
function arrowUp(params) {
  module_support_exports.drawMarkerUnitPolygon(params, arrowUpPoints);
}
arrowUp.anchor = { x: 0.5, y: 0 };
var ArrowUpScene = class extends ShapePointScene {
  constructor() {
    super();
    this.type = "arrow-up";
    this.shape = new AnnotationShape({ shape: arrowUp });
    this.append([this.shape]);
  }
  static is(value) {
    return AnnotationScene.isCheck(
      value,
      "arrow-up"
      /* ArrowUp */
    );
  }
  getHandleCoords(datum, point) {
    const halfSize = DivariantHandle.HANDLE_SIZE / 2;
    const handleCoords = super.getHandleCoords(datum, point);
    handleCoords.y -= halfSize;
    return handleCoords;
  }
};
var arrowDownPoints = arrowUpPoints.map(([x, y]) => [x, 1 - y]);
function arrowDown(params) {
  module_support_exports.drawMarkerUnitPolygon(params, arrowDownPoints);
}
arrowDown.anchor = { x: 0.5, y: 1 };
var ArrowDownScene = class extends ShapePointScene {
  constructor() {
    super();
    this.type = "arrow-down";
    this.shape = new AnnotationShape({ shape: arrowDown });
    this.append([this.shape]);
  }
  static is(value) {
    return AnnotationScene.isCheck(
      value,
      "arrow-down"
      /* ArrowDown */
    );
  }
  updateAnchor(datum, point, context) {
    const anchor = super.updateAnchor(datum, point, context);
    anchor.y -= datum.size;
    return anchor;
  }
  getHandleCoords(datum, point) {
    const halfSize = DivariantHandle.HANDLE_SIZE / 2;
    const handleCoords = super.getHandleCoords(datum, point);
    handleCoords.y += halfSize;
    return handleCoords;
  }
};
var { StateMachine: StateMachine22, StateMachineProperty: StateMachineProperty22, Debug: Debug22 } = module_support_exports;
var PointStateMachine = class extends StateMachine22 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ x: point.x, y: point.y });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      this.node?.toggleActive(true);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        drag: {
          target: "waiting-first-render",
          action: actionCreate
        },
        cancel: StateMachine22.parent,
        reset: StateMachine22.parent
      },
      "waiting-first-render": {
        render: {
          target: StateMachine22.parent,
          action: actionFirstRender
        }
      }
    });
    this.debug = Debug22.create(true, "annotations");
  }
};
__decorateClass2([
  StateMachineProperty22()
], PointStateMachine.prototype, "node", 2);
var ArrowDownStateMachine = class extends PointStateMachine {
  createDatum() {
    return new ArrowDownProperties();
  }
};
var arrowDownConfig = {
  type: "arrow-down",
  datum: ArrowDownProperties,
  scene: ArrowDownScene,
  isDatum: ArrowDownProperties.is,
  translate: (node, datum, translation, context) => {
    if (ArrowDownProperties.is(datum) && ArrowDownScene.is(node))
      node.translate(datum, translation, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (ArrowDownProperties.is(datum) && ArrowDownProperties.is(copiedDatum) && ArrowDownScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ArrowDownProperties.is(datum) && ArrowDownScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new ArrowDownStateMachine({
    ...ctx,
    create: createDatum(
      "arrow-down"
      /* ArrowDown */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { Property: Property30 } = module_support_exports;
var ArrowUpProperties = class extends ShapePointProperties {
  constructor() {
    super(...arguments);
    this.type = "arrow-up";
  }
  static is(value) {
    return isObject(value) && value.type === "arrow-up";
  }
};
__decorateClass2([
  Property30
], ArrowUpProperties.prototype, "type", 2);
var ArrowUpStateMachine = class extends PointStateMachine {
  createDatum() {
    return new ArrowUpProperties();
  }
};
var arrowUpConfig = {
  type: "arrow-up",
  datum: ArrowUpProperties,
  scene: ArrowUpScene,
  isDatum: ArrowUpProperties.is,
  translate: (node, datum, translation, context) => {
    if (ArrowUpProperties.is(datum) && ArrowUpScene.is(node))
      node.translate(datum, translation, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (ArrowUpProperties.is(datum) && ArrowUpProperties.is(copiedDatum) && ArrowUpScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ArrowUpProperties.is(datum) && ArrowUpScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new ArrowUpStateMachine({
    ...ctx,
    create: createDatum(
      "arrow-up"
      /* ArrowUp */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { Vec2: Vec25, Vec4: Vec42 } = module_support_exports;
var LinearScene = class extends AnnotationScene {
  constructor() {
    super(...arguments);
    this.overflowContinuous = 0;
  }
  extendLine({ x1, y1, x2, y2 }, datum, context) {
    const linePoints = { x1, y1, x2, y2 };
    if (!datum.extendStart && !datum.extendEnd) {
      return linePoints;
    }
    const [left, right] = boundsIntersections(linePoints, context.yAxis.bounds);
    const isFlippedX = linePoints.x2 < linePoints.x1;
    const isFlippedY = linePoints.y1 >= linePoints.y2;
    const isVertical = linePoints.x2 === linePoints.x1;
    if (datum.extendEnd) {
      if (isVertical) {
        linePoints.y2 = isFlippedY ? right.y : left.y;
      } else {
        linePoints.x2 = isFlippedX ? left.x : right.x;
        linePoints.y2 = isFlippedX ? left.y : right.y;
      }
    }
    if (datum.extendStart) {
      if (isVertical) {
        linePoints.y1 = isFlippedY ? left.y : right.y;
      } else {
        linePoints.x1 = isFlippedX ? right.x : left.x;
        linePoints.y1 = isFlippedX ? right.y : left.y;
      }
    }
    return linePoints;
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      ...getDragStartState({ start: datum.start, end: datum.end }, context)
    };
  }
  drag(datum, target, context, snapping) {
    if (datum.locked)
      return;
    if (this.activeHandle) {
      this.dragHandle(datum, target, context, snapping);
    } else {
      this.dragAll(datum, target, context);
    }
  }
  dragAll(datum, target, context) {
    const { dragState } = this;
    if (!dragState)
      return;
    this.translatePoints(datum, dragState.start, dragState.end, Vec25.sub(target, dragState.offset), context);
  }
  translate(datum, translation, context) {
    if (datum.locked)
      return;
    this.translatePoints(
      datum,
      convertPoint(datum.start, context),
      convertPoint(datum.end, context),
      translation,
      context
    );
  }
  copy(datum, copiedDatum, context) {
    const coords = convertLine(datum, context);
    if (!coords) {
      return;
    }
    const bbox = this.computeBBoxWithoutHandles();
    const translation = { x: -bbox.width / 2, y: -bbox.height / 2 };
    this.translatePoints(copiedDatum, Vec42.start(coords), Vec42.end(coords), translation, context);
    return copiedDatum;
  }
  translatePoints(datum, start2, end2, translation, context) {
    const vectors = this.getTranslatePointsVectors(start2, end2);
    const points = translate(vectors, translation, context, {
      overflowContinuous: this.overflowContinuous
    });
    datum.start.x = points.start.x;
    datum.end.x = points.end.x;
    datum.start.y = points.start.y;
    datum.end.y = points.end.y;
  }
  getTranslatePointsVectors(start2, end2) {
    return { start: start2, end: end2 };
  }
};
var { Vec2: Vec26, Vec4: Vec422 } = module_support_exports;
var StartEndScene = class extends LinearScene {
  constructor() {
    super(...arguments);
    this.start = new DivariantHandle();
    this.end = new DivariantHandle();
    this.anchor = {
      x: 0,
      y: 0,
      position: "above"
    };
  }
  update(datum, context) {
    const coords = convertLine(datum, context);
    if (coords == null) {
      return;
    }
    this.updateHandles(datum, coords);
    this.updateAnchor(datum, coords, context);
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      this.start.visible = show;
      this.end.visible = show;
    } else {
      for (const [handle22, visible] of entries(show)) {
        this[handle22].visible = visible;
      }
    }
    this.start.toggleHovered(this.activeHandle === "start");
    this.end.toggleHovered(this.activeHandle === "end");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.start.toggleActive(active);
    this.end.toggleActive(active);
  }
  dragHandle(datum, target, context, snapping) {
    const { activeHandle, dragState } = this;
    if (!activeHandle || !dragState)
      return;
    this[activeHandle].toggleDragging(true);
    const snapHandle = activeHandle === "start" ? "end" : "start";
    const snap = snapping ? { vectors: { [activeHandle]: convertPoint(datum[snapHandle], context) }, angle: datum.snapToAngle } : void 0;
    const { [activeHandle]: point } = translate(
      { [activeHandle]: dragState[activeHandle] },
      Vec26.sub(target, dragState.offset),
      context,
      { overflowContinuous: 0, snap }
    );
    datum[activeHandle].x = point.x;
    datum[activeHandle].y = point.y;
  }
  stopDragging() {
    this.start.toggleDragging(false);
    this.end.toggleDragging(false);
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    return "pointer";
  }
  containsPoint(x, y) {
    const { start: start2, end: end2 } = this;
    this.activeHandle = void 0;
    if (start2.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    if (end2.containsPoint(x, y)) {
      this.activeHandle = "end";
      return true;
    }
    return false;
  }
  getNodeAtCoords(x, y) {
    if (this.start.containsPoint(x, y) || this.end.containsPoint(x, y))
      return "handle";
  }
  updateHandles(datum, coords, bbox) {
    this.start.update({
      ...this.getHandleStyles(datum, "start"),
      ...this.getHandleCoords(datum, coords, "start")
    });
    this.end.update({
      ...this.getHandleStyles(datum, "end"),
      ...this.getHandleCoords(datum, coords, "end", bbox)
    });
    this.start.toggleLocked(datum.locked ?? false);
    this.end.toggleLocked(datum.locked ?? false);
  }
  updateAnchor(_datum, coords, context, _bbox) {
    this.anchor = {
      x: coords.x1 + context.seriesRect.x,
      y: coords.y1 + context.seriesRect.y,
      position: this.anchor.position
    };
  }
  getHandleCoords(_datum, coords, handle22, _bbox) {
    return handle22 === "start" ? Vec422.start(coords) : Vec422.end(coords);
  }
  getHandleStyles(datum, _handle) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
};
var { Vec4: Vec43 } = module_support_exports;
var TextualStartEndScene = class extends StartEndScene {
  constructor() {
    super(...arguments);
    this.label = new module_support_exports.Text({ zIndex: 1 });
    this.anchor = {
      x: 0,
      y: 0,
      position: "above-left"
    };
  }
  setTextInputBBox(bbox) {
    this.textInputBBox = bbox;
    this.markDirty("TextualStartEndScene");
  }
  update(datum, context) {
    const coords = convertLine(datum, context);
    if (coords == null) {
      return;
    }
    const bbox = this.getTextBBox(datum, coords);
    this.updateLabel(datum, bbox, coords);
    this.updateHandles(datum, coords, bbox);
    this.updateShape(datum, bbox, coords);
    this.updateAnchor(datum, coords, context, bbox);
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.label.containsPoint(x, y);
  }
  getNodeAtCoords(x, y) {
    if (this.label.containsPoint(x, y))
      return "text";
    return super.getNodeAtCoords(x, y);
  }
  getTextBBox(datum, coords) {
    const { text: text2 } = datum.getText();
    return getBBox(datum, text2, Vec43.end(coords), this.textInputBBox);
  }
  updateLabel(datum, bbox, coords) {
    const { text: text2, isPlaceholder } = datum.getText();
    updateTextNode(this.label, text2, isPlaceholder, datum, this.getLabelCoords(datum, bbox, coords));
  }
  updateShape(_datum, _textBBox, _coords) {
  }
  getLabelCoords(_datum, _bbox, coords) {
    return Vec43.end(coords);
  }
  getHandleStyles(datum, handle22) {
    return {
      ...super.getHandleStyles(datum, handle22),
      stroke: datum.handle.stroke ?? datum.color
    };
  }
};
var { drawCorner: drawCorner2, Path: Path5 } = module_support_exports;
var CalloutScene = class extends TextualStartEndScene {
  constructor() {
    super();
    this.type = "callout";
    this.shape = new Path5();
    this.append([this.shape, this.label, this.start, this.end]);
  }
  static is(value) {
    return AnnotationScene.isCheck(
      value,
      "callout"
      /* Callout */
    );
  }
  drag(datum, target, context, snapping) {
    if (datum.locked)
      return;
    if (this.activeHandle === "end") {
      this.dragHandle(datum, target, context, snapping);
    } else {
      this.dragAll(datum, target, context);
    }
  }
  getLabelCoords(datum, bbox, coords) {
    const padding2 = datum.getPadding();
    const {
      bodyBounds = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    } = this.getDimensions(datum, bbox, coords) ?? {};
    return {
      x: bodyBounds.x + padding2.left,
      y: bodyBounds.y - padding2.bottom
    };
  }
  getHandleStyles(datum, handle22) {
    return handle22 === "start" ? {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    } : { fill: void 0, strokeWidth: 0 };
  }
  updateAnchor(datum, coords, context, bbox) {
    const { bodyBounds } = this.getDimensions(datum, bbox, coords) ?? {};
    const bounds = bodyBounds ?? bbox;
    this.anchor = {
      x: bounds.x + context.seriesRect.x,
      y: bounds.y + context.seriesRect.y - bounds.height,
      position: this.anchor.position
    };
  }
  updateShape(datum, textBBox, coords) {
    const { shape } = this;
    shape.fill = datum.fill;
    shape.fillOpacity = datum.fillOpacity ?? 1;
    shape.stroke = datum.stroke;
    shape.strokeWidth = datum.strokeWidth ?? 1;
    shape.strokeOpacity = datum.strokeOpacity ?? 1;
    const { tailPoint, bodyBounds } = this.getDimensions(datum, textBBox, coords) ?? {};
    if (!tailPoint || !bodyBounds) {
      return;
    }
    this.updatePath(tailPoint, bodyBounds);
  }
  updatePath(tailPoint, bodyBounds) {
    const { x: tailX, y: tailY } = tailPoint;
    const { x, y, width: width2, height: height2 } = bodyBounds;
    const top = y - height2;
    const right = x + width2;
    const placement = this.calculateCalloutPlacement({ x: tailX, y: tailY }, bodyBounds);
    const cornerRadius = 8;
    const pathParams2 = [
      {
        coordinates: {
          x0: x,
          x1: x + cornerRadius,
          y0: top + cornerRadius,
          y1: top,
          cx: placement === `topLeft` ? tailX : x + cornerRadius,
          cy: placement === `topLeft` ? tailY : top + cornerRadius
        },
        type: placement === `topLeft` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: x + cornerRadius,
          x1: right - cornerRadius,
          y0: top,
          y1: top,
          cx: tailX,
          cy: tailY
        },
        type: placement === `top` ? "calloutSide" : "side"
      },
      {
        coordinates: {
          x0: right - cornerRadius,
          x1: right,
          y0: top,
          y1: top + cornerRadius,
          cx: placement === `topRight` ? tailX : right - cornerRadius,
          cy: placement === `topRight` ? tailY : top + cornerRadius
        },
        type: placement === `topRight` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: right,
          x1: right,
          y0: top + cornerRadius,
          y1: y - cornerRadius,
          cx: tailX,
          cy: tailY
        },
        type: placement === `right` ? "calloutSide" : "side"
      },
      {
        coordinates: {
          x0: right,
          x1: right - cornerRadius,
          y0: y - cornerRadius,
          y1: y,
          cx: placement === `bottomRight` ? tailX : right - cornerRadius,
          cy: placement === `bottomRight` ? tailY : y - cornerRadius
        },
        type: placement === `bottomRight` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: right - cornerRadius,
          x1: x + cornerRadius,
          y0: y,
          y1: y,
          cx: tailX,
          cy: tailY
        },
        type: placement === `bottom` ? "calloutSide" : "side"
      },
      {
        coordinates: {
          x0: x + cornerRadius,
          x1: x,
          y0: y,
          y1: y - cornerRadius,
          cx: placement === `bottomLeft` ? tailX : x + cornerRadius,
          cy: placement === `bottomLeft` ? tailY : y - cornerRadius
        },
        type: placement === `bottomLeft` ? "calloutCorner" : "corner"
      },
      {
        coordinates: {
          x0: x,
          x1: x,
          y0: y - cornerRadius,
          y1: top + cornerRadius,
          cx: tailX,
          cy: tailY
        },
        type: placement === `left` ? "calloutSide" : "side"
      }
    ];
    const { path } = this.shape;
    path.clear();
    path.moveTo(x, top + cornerRadius);
    pathParams2.forEach(({ coordinates, type }) => {
      this.drawPath(path, coordinates, cornerRadius, type);
    });
    path.closePath();
  }
  drawPath(path, { x0, y0, x1, y1, cx, cy }, cornerRadius, type) {
    const sideTailRadius = 6;
    switch (type) {
      case "calloutCorner": {
        path.lineTo(cx, cy);
        path.lineTo(x1, y1);
        break;
      }
      case "corner": {
        drawCorner2(
          path,
          {
            x0,
            x1,
            y0,
            y1,
            cx,
            cy
          },
          cornerRadius,
          false
        );
        break;
      }
      case "calloutSide": {
        if (x0 !== x1) {
          const direction = x0 > x1 ? -1 : 1;
          const midX = Math.min(x0, x1) + Math.abs(x1 - x0) / 2;
          path.lineTo(midX - sideTailRadius * direction, y0);
          path.lineTo(cx, cy);
          path.lineTo(midX + sideTailRadius * direction, y0);
          path.lineTo(x1, y1);
        } else {
          const direction = y0 > y1 ? -1 : 1;
          const midY = Math.min(y0, y1) + Math.abs(y0 - y1) / 2;
          path.lineTo(x0, midY - sideTailRadius * direction);
          path.lineTo(cx, cy);
          path.lineTo(x0, midY + sideTailRadius * direction);
          path.lineTo(x1, y1);
        }
        break;
      }
      case "side":
      default: {
        path.lineTo(x1, y1);
        break;
      }
    }
  }
  calculateCalloutPlacement(placement, bounds) {
    const right = bounds.x + bounds.width;
    const top = bounds.y - bounds.height;
    let xPlacement;
    let yPlacement;
    if (placement.x > right) {
      xPlacement = "right";
    } else if (placement.x < bounds.x) {
      xPlacement = "left";
    }
    if (placement.y > bounds.y) {
      yPlacement = "bottom";
    } else if (placement.y < top) {
      yPlacement = "top";
    }
    if (xPlacement && yPlacement) {
      return `${yPlacement}${xPlacement[0].toUpperCase()}${xPlacement.substring(1)}`;
    } else {
      return yPlacement ?? xPlacement;
    }
  }
  getDimensions(datum, textBBox, coords) {
    const { fontSize } = datum;
    const padding2 = datum.getPadding();
    const horizontalPadding = padding2.left + padding2.right;
    const verticalPadding = padding2.top + padding2.bottom;
    const width2 = textBBox.width + horizontalPadding;
    const height2 = Math.max(textBBox.height + verticalPadding, fontSize + verticalPadding);
    return {
      tailPoint: {
        x: coords.x1,
        y: coords.y1
      },
      bodyBounds: {
        x: textBBox.x,
        y: textBBox.y,
        width: width2,
        height: height2
      }
    };
  }
  containsPoint(x, y) {
    const { start: start2, end: end2, shape } = this;
    this.activeHandle = void 0;
    if (start2.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    const bodyContainsPoint = end2.containsPoint(x, y) || shape.containsPoint(x, y);
    if (bodyContainsPoint) {
      this.activeHandle = "end";
    }
    return bodyContainsPoint;
  }
};
function guardCancelAndExit({ key }) {
  return key === "Escape";
}
function guardSaveAndExit({ key, shiftKey }) {
  return !shiftKey && key === "Enter";
}
var { StateMachine: StateMachine3, StateMachineProperty: StateMachineProperty3, Debug: Debug3 } = module_support_exports;
var TextualStartEndStateMachine = class extends StateMachine3 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ start: point, end: point, visible: true });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      const { node } = this;
      node?.toggleActive(true);
      node?.toggleHandles({ start: true });
    };
    const onStartEditing = () => {
      ctx.showTextInput();
      if (this.datum)
        this.datum.visible = false;
    };
    const onStopEditing = () => {
      ctx.hideTextInput();
      if (this.datum)
        this.datum.visible = true;
      ctx.deselect();
    };
    const actionUpdateTextInputBBox = (bbox) => {
      this.node?.setTextInputBBox(bbox);
      ctx.update();
    };
    const onEndHover = ({ point }) => {
      const { datum, node } = this;
      datum?.set({ end: point });
      node?.toggleActive(true);
      node?.toggleHandles({ end: false });
      ctx.update();
    };
    const onEndClick = () => {
      ctx.showAnnotationOptions();
      this.node?.toggleHandles({ end: true });
    };
    const actionColor = ({
      colorPickerType,
      colorOpacity,
      color: color6,
      opacity,
      isMultiColor
    }) => {
      const { datum } = this;
      if (!datum)
        return;
      if (colorPickerType === "text-color") {
        ctx.updateTextInputColor(color6);
      }
      setColor(datum, colorPickerType, colorOpacity, color6, opacity, isMultiColor);
      ctx.update();
    };
    const actionFontSize = (fontSize) => {
      const { datum, node } = this;
      if (!datum || !node || !isTextType(datum))
        return;
      datum.fontSize = fontSize;
      ctx.updateTextInputFontSize(fontSize);
      ctx.update();
    };
    const actionCancel = () => {
      ctx.delete();
    };
    const actionSave = ({ textInputValue, bbox }) => {
      const { datum } = this;
      if (bbox != null && textInputValue != null && textInputValue.length > 0) {
        if (!isTextType(datum)) {
          return;
        }
        const wrappedText = wrapText(datum, textInputValue, bbox.width);
        datum?.set({ text: wrappedText });
        ctx.update();
        ctx.recordAction(`Create ${datum?.type} annotation`);
      } else {
        ctx.delete();
      }
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        dragStart: {
          target: "waiting-first-render",
          action: actionCreate
        },
        cancel: StateMachine3.parent,
        reset: StateMachine3.parent
      },
      "waiting-first-render": {
        render: {
          target: "end",
          action: actionFirstRender
        }
      },
      end: {
        hover: onEndHover,
        drag: onEndHover,
        click: {
          target: "edit",
          action: onEndClick
        },
        dragEnd: {
          target: "edit",
          action: onEndClick
        },
        reset: {
          target: StateMachine3.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine3.parent,
          action: actionCancel
        }
      },
      edit: {
        onEnter: onStartEditing,
        updateTextInputBBox: actionUpdateTextInputBBox,
        color: actionColor,
        fontSize: actionFontSize,
        textInput: [
          {
            guard: guardCancelAndExit,
            target: StateMachine3.parent,
            action: actionCancel
          },
          {
            guard: guardSaveAndExit,
            target: StateMachine3.parent,
            action: actionSave
          }
        ],
        click: {
          target: StateMachine3.parent,
          action: actionSave
        },
        dragStart: {
          target: StateMachine3.parent,
          action: actionSave
        },
        resize: {
          target: StateMachine3.parent,
          action: actionSave
        },
        onExit: onStopEditing,
        cancel: {
          target: StateMachine3.parent,
          action: actionCancel
        }
      }
    });
    this.debug = Debug3.create(true, "annotations");
  }
};
__decorateClass2([
  StateMachineProperty3()
], TextualStartEndStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty3()
], TextualStartEndStateMachine.prototype, "node", 2);
var CalloutStateMachine = class extends TextualStartEndStateMachine {
  createDatum() {
    return new CalloutProperties();
  }
};
var calloutConfig = {
  type: "callout",
  datum: CalloutProperties,
  scene: CalloutScene,
  isDatum: CalloutProperties.is,
  translate: (node, datum, transition, context) => {
    if (CalloutProperties.is(datum) && CalloutScene.is(node))
      return node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (CalloutProperties.is(datum) && CalloutProperties.is(copiedDatum) && CalloutScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (CalloutProperties.is(datum) && CalloutScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new CalloutStateMachine({
    ...ctx,
    create: createDatum(
      "callout"
      /* Callout */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var TextualPointScene = class extends PointScene {
  constructor() {
    super(...arguments);
    this.label = new module_support_exports.Text({ zIndex: 1 });
    this.anchor = {
      x: 0,
      y: 0,
      position: "above-left"
    };
  }
  setTextInputBBox(bbox) {
    this.textInputBBox = bbox;
    this.markDirty("TextualPointScene");
  }
  update(datum, context) {
    const coords = convertPoint(datum, context);
    const bbox = this.getTextBBox(datum, coords, context);
    this.updateLabel(datum, bbox);
    this.updateHandle(datum, coords, bbox);
    this.updateShape(datum, bbox);
    this.anchor = this.updateAnchor(datum, bbox, context);
  }
  copy(datum, copiedDatum, context) {
    const coords = convertPoint(datum, context);
    const bbox = this.getTextBBox(datum, coords, context);
    const padding2 = datum.getPadding();
    const horizontalPadding = padding2.left + padding2.right;
    const verticalPadding = padding2.top + padding2.bottom;
    const xOffset = (bbox.width + horizontalPadding) / 2;
    const yOffset = bbox.height + verticalPadding;
    const point = invertCoords({ x: coords.x - xOffset, y: coords.y - yOffset }, context);
    copiedDatum.x = point.x;
    copiedDatum.y = point.y;
    return copiedDatum;
  }
  containsPoint(x, y) {
    const { label } = this;
    return super.containsPoint(x, y) || label.visible && label.containsPoint(x, y);
  }
  getNodeAtCoords(x, y) {
    if (this.label.visible && this.label.containsPoint(x, y))
      return "text";
    return super.getNodeAtCoords(x, y);
  }
  getTextBBox(datum, coords, _context) {
    const { text: text2 } = datum.getText();
    return getBBox(datum, text2, { x: coords.x, y: coords.y }, this.textInputBBox);
  }
  updateLabel(datum, bbox) {
    const { text: text2, isPlaceholder } = datum.getText();
    updateTextNode(
      this.label,
      text2,
      isPlaceholder,
      datum,
      this.getLabelCoords(datum, bbox),
      this.getTextBaseline(datum)
    );
  }
  updateShape(_datum, _bbox) {
  }
  updateAnchor(_datum, bbox, context) {
    return {
      x: bbox.x + context.seriesRect.x,
      y: bbox.y + context.seriesRect.y - bbox.height,
      position: this.anchor.position
    };
  }
  getLabelCoords(_datum, bbox) {
    return bbox;
  }
  getTextBaseline(datum) {
    return datum.position == "center" ? "middle" : datum.position;
  }
  getHandleCoords(_datum, _coords, bbox) {
    return bbox;
  }
  getHandleStyles(datum) {
    const styles = super.getHandleStyles(datum);
    styles.stroke = datum.handle.stroke ?? datum.color;
    return styles;
  }
};
var { drawCorner: drawCorner22 } = module_support_exports;
var CommentScene = class extends TextualPointScene {
  constructor() {
    super();
    this.type = "comment";
    this.shape = new module_support_exports.Path();
    this.append([this.shape, this.label, this.handle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(
      value,
      "comment"
      /* Comment */
    );
  }
  updateShape(datum, bbox) {
    const { shape } = this;
    shape.fill = datum.fill;
    shape.fillOpacity = datum.fillOpacity ?? 1;
    shape.stroke = datum.stroke ?? "transparent";
    shape.strokeWidth = datum.strokeWidth ?? 1;
    shape.strokeOpacity = datum.strokeOpacity ?? 1;
    this.updatePath(datum, bbox);
  }
  getLabelCoords(datum, point) {
    const padding2 = datum.getPadding();
    return {
      x: point.x + padding2.left,
      y: point.y - padding2.bottom
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke ?? datum.fill,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
  updateAnchor(datum, bbox, context) {
    const anchor = super.updateAnchor(datum, bbox, context);
    const padding2 = datum.getPadding();
    anchor.y -= padding2.bottom + padding2.top;
    return anchor;
  }
  updatePath(datum, bbox) {
    const padding2 = datum.getPadding();
    const { x, y } = bbox;
    let { width: width2, height: height2 } = bbox;
    const { fontSize } = datum;
    const horizontalPadding = padding2.left + padding2.right;
    const verticalPadding = padding2.top + padding2.bottom;
    width2 = width2 + horizontalPadding;
    height2 = Math.max(height2 + verticalPadding, fontSize + verticalPadding);
    const top = y - height2;
    const right = x + width2;
    const cornerRadius = (fontSize * ANNOTATION_TEXT_LINE_HEIGHT + verticalPadding) / 2;
    const { path } = this.shape;
    path.clear();
    path.moveTo(x, y);
    path.lineTo(x, top + cornerRadius);
    drawCorner22(
      path,
      {
        x0: x,
        x1: x + cornerRadius,
        y0: top + cornerRadius,
        y1: top,
        cx: x + cornerRadius,
        cy: top + cornerRadius
      },
      cornerRadius,
      false
    );
    path.lineTo(right - cornerRadius, top);
    drawCorner22(
      path,
      {
        x0: right - cornerRadius,
        x1: right,
        y0: top,
        y1: top + cornerRadius,
        cx: right - cornerRadius,
        cy: top + cornerRadius
      },
      cornerRadius,
      false
    );
    path.lineTo(right, y - cornerRadius);
    drawCorner22(
      path,
      {
        x0: right,
        x1: right - cornerRadius,
        y0: y - cornerRadius,
        y1: y,
        cx: right - cornerRadius,
        cy: y - cornerRadius
      },
      cornerRadius,
      false
    );
    path.closePath();
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.shape.containsPoint(x, y);
  }
};
var { StateMachine: StateMachine4, StateMachineProperty: StateMachineProperty4, Debug: Debug4 } = module_support_exports;
var TextualPointStateMachine = class extends StateMachine4 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ x: point.x, y: point.y });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      this.node?.toggleActive(true);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    const onStartEditing = () => {
      ctx.showTextInput();
      if (this.datum) {
        this.datum.visible = false;
      }
    };
    const onStopEditing = () => {
      ctx.hideTextInput();
      if (this.datum)
        this.datum.visible = true;
      ctx.deselect();
    };
    const actionUpdateTextInputBBox = (bbox) => {
      this.node?.setTextInputBBox(bbox);
      ctx.update();
    };
    const actionColor = ({
      colorPickerType,
      colorOpacity,
      color: color6,
      opacity,
      isMultiColor
    }) => {
      if (!this.datum)
        return;
      if (colorPickerType === "text-color") {
        ctx.updateTextInputColor(color6);
      }
      setColor(this.datum, colorPickerType, colorOpacity, color6, opacity, isMultiColor);
      ctx.update();
    };
    const actionFontSize = (fontSize) => {
      const { datum, node } = this;
      if (!datum || !node || !isTextType(datum))
        return;
      datum.fontSize = fontSize;
      ctx.updateTextInputFontSize(fontSize);
      ctx.update();
    };
    const actionCancel = () => {
      ctx.delete();
    };
    const actionSave = ({ textInputValue, bbox }) => {
      if (bbox != null && textInputValue != null && textInputValue.length > 0) {
        const { datum } = this;
        if (!isTextType(datum)) {
          return;
        }
        const wrappedText = wrapText(datum, textInputValue, bbox.width);
        datum?.set({ text: wrappedText });
        ctx.update();
        ctx.recordAction(`Create ${datum?.type} annotation`);
      } else {
        ctx.delete();
      }
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        dragStart: {
          target: "waiting-first-render",
          action: actionCreate
        },
        cancel: StateMachine4.parent,
        reset: StateMachine4.parent
      },
      "waiting-first-render": {
        render: {
          target: "edit",
          action: actionFirstRender
        }
      },
      edit: {
        onEnter: onStartEditing,
        updateTextInputBBox: actionUpdateTextInputBBox,
        color: actionColor,
        fontSize: actionFontSize,
        textInput: [
          {
            guard: guardCancelAndExit,
            target: StateMachine4.parent,
            action: actionCancel
          },
          {
            guard: guardSaveAndExit,
            target: StateMachine4.parent,
            action: actionSave
          }
        ],
        click: {
          target: StateMachine4.parent,
          action: actionSave
        },
        dragStart: {
          target: StateMachine4.parent,
          action: actionSave
        },
        resize: {
          target: StateMachine4.parent,
          action: actionSave
        },
        onExit: onStopEditing,
        cancel: {
          target: StateMachine4.parent,
          action: actionCancel
        }
      }
    });
    this.debug = Debug4.create(true, "annotations");
  }
};
__decorateClass2([
  StateMachineProperty4()
], TextualPointStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty4()
], TextualPointStateMachine.prototype, "node", 2);
var CommentStateMachine = class extends TextualPointStateMachine {
  createDatum() {
    return new CommentProperties();
  }
};
var commentConfig = {
  type: "comment",
  datum: CommentProperties,
  scene: CommentScene,
  isDatum: CommentProperties.is,
  translate: (node, datum, translation, context) => {
    if (CommentProperties.is(datum) && CommentScene.is(node))
      node.translate(datum, translation, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (CommentProperties.is(datum) && CommentProperties.is(copiedDatum) && CommentScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (CommentProperties.is(datum) && CommentScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new CommentStateMachine({
    ...ctx,
    create: createDatum(
      "comment"
      /* Comment */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { calculateLabelTranslation: calculateLabelTranslation2 } = module_support_exports;
var AxisLabelScene = class extends module_support_exports.Group {
  constructor() {
    super({ name: "AnnotationAxisLabelGroup" });
    this.label = new module_support_exports.Text({ zIndex: 1 });
    this.rect = new module_support_exports.Rect();
    const { label } = this;
    label.fontSize = 12;
    label.fontFamily = "Verdana, sans-serif";
    label.fill = "black";
    label.textBaseline = "middle";
    label.textAlign = "center";
    this.append([this.rect, this.label]);
  }
  update(opts) {
    this.updateLabel(opts);
    this.updateRect(opts);
    this.updatePosition(opts);
  }
  updateLabel({ value, styles, context }) {
    const { fontWeight, fontSize, fontStyle, fontFamily, textAlign, color: color6 = "white", formatter: formatter2 } = styles;
    const text2 = formatter2 ? formatter2({ value }) : context.formatScaleValue(value, "annotation-label");
    this.label.setProperties({
      fontWeight,
      fontSize,
      fontStyle,
      fontFamily,
      textAlign,
      fill: color6,
      text: text2
    });
  }
  updateRect({ styles }) {
    const { rect } = this;
    const { cornerRadius, fill, fillOpacity, stroke: stroke22, strokeOpacity } = styles;
    rect.fill = fill;
    rect.fillOpacity = fillOpacity ?? 1;
    rect.stroke = stroke22;
    rect.strokeOpacity = strokeOpacity ?? 1;
    rect.cornerRadius = cornerRadius ?? 0;
  }
  updatePosition({ x, y, context, styles: { padding: padding2 } }) {
    const { label, rect } = this;
    const labelBBox = label.getBBox()?.clone();
    const horizontalPadding = padding2 ?? 8;
    const verticalPadding = padding2 ?? 4;
    const { xTranslation, yTranslation } = calculateLabelTranslation2({
      yDirection: true,
      padding: context.labelPadding,
      position: context.position ?? "left",
      bbox: labelBBox
    });
    labelBBox.grow(horizontalPadding, "horizontal");
    labelBBox.grow(verticalPadding, "vertical");
    const translationX = x + xTranslation;
    const translationY = y + yTranslation;
    label.x = translationX;
    label.y = translationY;
    rect.y = translationY - Math.round(labelBBox.height / 2);
    rect.x = translationX - Math.round(labelBBox.width / 2);
    rect.height = labelBBox.height;
    rect.width = labelBBox.width;
  }
};
AxisLabelScene.className = "AxisLabel";
var { Vec2: Vec27 } = module_support_exports;
var CollidableLine = class extends module_support_exports.Line {
  constructor() {
    super(...arguments);
    this.growCollisionBox = 9;
    this.clipMask = /* @__PURE__ */ new Map();
  }
  setProperties(styles) {
    super.setProperties(styles);
    this.updateCollisionBBox();
    return this;
  }
  updateCollisionBBox() {
    const { growCollisionBox, strokeWidth, x1, y1, x2, y2 } = this;
    let height2 = strokeWidth + growCollisionBox;
    if (height2 % 2 === 0)
      height2 += 1;
    const topLeft = Vec27.from(x1, y1 - Math.floor(height2 / 2));
    const bottomRight = Vec27.from(x2, y2);
    const width2 = Vec27.distance(topLeft, bottomRight);
    this.collisionBBox = new module_support_exports.BBox(topLeft.x, topLeft.y, width2, height2);
  }
  isPointInPath(pointX, pointY) {
    const { collisionBBox, x1, y1, x2, y2 } = this;
    if (!collisionBBox)
      return false;
    const v1 = Vec27.from(x1, y1);
    const v2 = Vec27.from(x2, y2);
    const point = Vec27.sub(Vec27.from(pointX, pointY), v1);
    const end2 = Vec27.sub(v2, v1);
    const rotated = Vec27.rotate(point, Vec27.angle(point, end2), v1);
    return collisionBBox.containsPoint(rotated.x, rotated.y) ?? false;
  }
  render(renderCtx) {
    const { clipMask } = this;
    const { ctx } = renderCtx;
    if (clipMask.size === 0) {
      super.render(renderCtx);
      return;
    }
    ctx.save();
    try {
      for (const mask of this.clipMask.values()) {
        const { x, y, radius } = mask;
        ctx.beginPath();
        ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.ellipse(x, y, radius, radius, 0, Math.PI * 2, 0, true);
        ctx.clip();
      }
      super.render(renderCtx);
    } finally {
      ctx.restore();
    }
  }
  setClipMask(id, mask) {
    const cm = this.clipMask.get(id);
    if (module_support_exports.jsonDiff(cm, mask) != null) {
      this.markDirty("CollidableLine");
    }
    if (mask) {
      this.clipMask.set(id, mask);
    } else {
      this.clipMask.delete(id);
    }
  }
};
var CollidableText = class extends module_support_exports.TransformableText {
  constructor() {
    super(...arguments);
    this.growCollisionBox = {
      top: 4,
      right: 4,
      bottom: 4,
      left: 4
    };
  }
  isPointInPath(pointX, pointY) {
    const localPoint = this.fromParentPoint(pointX, pointY);
    const uBBox = this.computeBBoxWithoutTransforms();
    if (!uBBox)
      return false;
    return uBBox.grow(this.growCollisionBox).containsPoint(localPoint.x, localPoint.y);
  }
};
var { Vec2: Vec28 } = module_support_exports;
function updateLineText(id, line, coords, textProperties, textNode, text2, lineWidth) {
  if (!text2 || !textNode || !textProperties) {
    line.setClipMask(id);
    return;
  }
  const { alignment, position } = textProperties;
  const numbers = getNumbers(coords, textProperties.fontSize, lineWidth);
  const { point, textBaseline } = positionAndAlignment(numbers, position, alignment);
  setProperties(textNode, text2, textProperties, point, numbers.angle, textBaseline);
  const { x, y, width: width2, height: height2 } = textNode.getBBox();
  const diameter = Vec28.length(Vec28.from(width2, height2));
  const clipMask = {
    x: x + width2 / 2,
    y: y + height2 / 2,
    radius: diameter / 2 + Vec28.length(numbers.offset)
  };
  if (position === "center") {
    line.setClipMask(id, clipMask);
  } else {
    line.setClipMask(id);
  }
  return { clipMask, numbers };
}
function updateChannelText(offsetInsideTextLabel, top, bottom, textProperties, lineWidth, textNode, text2) {
  if (!text2 || !textNode)
    return;
  const { alignment, position } = textProperties;
  const [actualTop, actualBottom] = top.y1 <= bottom.y1 ? [top, bottom] : [bottom, top];
  let relativeLine = actualTop;
  if (position === "bottom") {
    relativeLine = actualBottom;
  } else if (position === "inside") {
    relativeLine = {
      x1: (actualTop.x1 + actualBottom.x1) / 2,
      y1: (actualTop.y1 + actualBottom.y1) / 2,
      x2: (actualTop.x2 + actualBottom.x2) / 2,
      y2: (actualTop.y2 + actualBottom.y2) / 2
    };
  }
  const numbers = getNumbers(relativeLine, textProperties.fontSize, lineWidth);
  const { point, textBaseline } = positionAndAlignment(
    numbers,
    position === "inside" ? "center" : position,
    alignment,
    offsetInsideTextLabel
  );
  setProperties(textNode, text2, textProperties, point, numbers.angle, textBaseline);
}
function getNumbers(coords, fontSize, strokeWidth) {
  let [left, right] = Vec28.from(coords);
  if (left.x > right.x)
    [left, right] = [right, left];
  const normal = Vec28.normalized(Vec28.sub(right, left));
  const angle2 = Vec28.angle(normal);
  const inset = Vec28.multiply(normal, DivariantHandle.HANDLE_SIZE / 2 + (fontSize ?? 14) / 2);
  const offset = Vec28.multiply(normal, (strokeWidth ?? 2) / 2 + (fontSize ?? 14) / 3);
  return { left, right, normal, angle: angle2, inset, offset };
}
function positionAndAlignment({ left, right, normal, angle: angle2, inset, offset }, position, alignment, offsetInsideTextLabel) {
  let point;
  if (alignment === "right") {
    point = Vec28.sub(right, inset);
  } else if (alignment === "center") {
    point = Vec28.add(left, Vec28.multiply(normal, Vec28.distance(left, right) / 2));
  } else {
    point = Vec28.add(left, inset);
  }
  let textBaseline = "bottom";
  if (position === "bottom") {
    point = Vec28.rotate(offset, angle2 + Math.PI / 2, point);
    textBaseline = "top";
  } else if (position === "center" && !offsetInsideTextLabel) {
    textBaseline = "middle";
  } else {
    point = Vec28.rotate(offset, angle2 - Math.PI / 2, point);
  }
  return { point, textBaseline };
}
function setProperties(scene, text2, textProperties, point, angle2, textBaseline) {
  scene.setProperties({
    text: text2,
    x: point.x,
    y: point.y,
    rotation: angle2,
    rotationCenterX: point.x,
    rotationCenterY: point.y,
    fill: textProperties.color,
    fontFamily: textProperties.fontFamily,
    fontSize: textProperties.fontSize,
    fontStyle: textProperties.fontStyle,
    fontWeight: textProperties.fontWeight,
    textAlign: textProperties.alignment,
    textBaseline
  });
}
var { ChartAxisDirection: ChartAxisDirection6, Vec2: Vec29, Vec4: Vec44 } = module_support_exports;
var CrossLineScene = class extends AnnotationScene {
  constructor() {
    super();
    this.type = "cross-line";
    this.line = new CollidableLine();
    this.middle = new UnivariantHandle();
    this.isHorizontal = false;
    this.append([this.line, this.middle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "cross-line");
  }
  update(datum, context) {
    const { seriesRect } = context;
    this.seriesRect = seriesRect;
    this.isHorizontal = HorizontalLineProperties.is(datum);
    const axisContext = this.isHorizontal ? context.yAxis : context.xAxis;
    const coords = this.convertCrossLine(datum, axisContext);
    if (coords == null) {
      this.visible = false;
      return;
    }
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    this.updateLine(datum, coords);
    this.updateHandle(datum, coords);
    this.updateText(datum, coords);
    this.updateAxisLabel(datum, axisContext, coords);
  }
  updateLine(datum, coords) {
    const { line } = this;
    const { lineDashOffset, stroke: stroke22, strokeWidth, strokeOpacity } = datum;
    const { x1, y1, x2, y2 } = coords;
    line.setProperties({
      x1,
      y1,
      x2,
      y2,
      lineCap: datum.getLineCap(),
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0
    });
  }
  updateHandle(datum, coords) {
    const { middle } = this;
    const { locked, stroke: stroke22, strokeWidth, strokeOpacity } = datum;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? stroke22,
      strokeOpacity: datum.handle.strokeOpacity ?? strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? strokeWidth
    };
    const handlePosition = Vec29.sub(
      Vec44.center(coords),
      Vec29.from(middle.handle.width / 2, middle.handle.height / 2)
    );
    middle.gradient = this.isHorizontal ? "horizontal" : "vertical";
    middle.update({ ...handleStyles, ...handlePosition });
    middle.toggleLocked(locked ?? false);
  }
  updateText(datum, coords) {
    this.text = this.updateNode(CollidableText, this.text, !!datum.text.label);
    updateLineText(this.line.id, this.line, coords, datum.text, this.text, datum.text.label, datum.strokeWidth);
  }
  createAxisLabel(context) {
    const axisLabel22 = new AxisLabelScene();
    context.attachLabel(axisLabel22);
    return axisLabel22;
  }
  updateAxisLabel(datum, axisContext, coords) {
    this.axisLabel ?? (this.axisLabel = this.createAxisLabel(axisContext));
    const { axisLabel: axisLabel22, seriesRect } = this;
    const { direction, position } = axisContext;
    if (datum.axisLabel.enabled) {
      axisLabel22.visible = this.visible;
      const labelCorner = position === "left" || position === "top" ? Vec44.start(coords) : Vec44.end(coords);
      const labelPosition = direction === ChartAxisDirection6.X ? labelCorner.x : labelCorner.y;
      if (!axisContext.inRange(labelPosition)) {
        axisLabel22.visible = false;
        return;
      }
      const value = getGroupingValue(datum.value);
      axisLabel22.update({
        ...Vec29.add(labelCorner, Vec29.required(seriesRect)),
        value,
        styles: datum.axisLabel,
        context: axisContext
      });
    } else {
      axisLabel22.visible = false;
    }
  }
  setAxisLabelOpacity(opacity) {
    if (!this.axisLabel)
      return;
    this.axisLabel.opacity = opacity;
  }
  setAxisLabelVisible(visible) {
    if (!this.axisLabel)
      return;
    this.axisLabel.visible = visible;
  }
  toggleHandles(show) {
    this.middle.visible = show;
    this.middle.toggleHovered(this.activeHandle === "middle");
  }
  destroy() {
    super.destroy();
    this.axisLabel?.destroy();
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.middle.toggleActive(active);
  }
  dragStart(datum, target, context) {
    const middle = HorizontalLineProperties.is(datum) ? { x: target.x, y: convert(datum.value, context.yAxis) } : { x: convert(datum.value, context.xAxis), y: target.y };
    this.dragState = {
      offset: target,
      middle
    };
  }
  drag(datum, target, context) {
    const { activeHandle, dragState } = this;
    if (datum.locked || !dragState)
      return;
    if (activeHandle) {
      this[activeHandle].toggleDragging(true);
    }
    this.translatePoint(datum, dragState.middle, Vec29.sub(target, dragState.offset), context);
  }
  translate(datum, translation, context) {
    if (datum.locked)
      return;
    const vector = HorizontalLineProperties.is(datum) ? Vec29.from(0, convert(datum.value, context.yAxis)) : Vec29.from(convert(datum.value, context.xAxis), 0);
    this.translatePoint(datum, vector, translation, context);
  }
  translatePoint(datum, value, translation, context) {
    const isHorizontal2 = HorizontalLineProperties.is(datum);
    if (isHorizontal2) {
      translation.x = 0;
    } else {
      translation.y = 0;
    }
    const { point } = translate({ point: value }, translation, context);
    datum.value = isHorizontal2 ? point.y : point.x;
  }
  stopDragging() {
    this.middle.toggleDragging(false);
  }
  copy(datum, copiedDatum, context) {
    const isHorizontal2 = HorizontalLineProperties.is(datum);
    const axisContext = this.isHorizontal ? context.yAxis : context.xAxis;
    const coords = this.convertCrossLine(datum, axisContext);
    if (!coords) {
      return;
    }
    const yOffset = isHorizontal2 ? -30 : 0;
    const xOffset = isHorizontal2 ? 0 : -30;
    const point = invertCoords({ x: coords.x1 + xOffset, y: coords.y1 + yOffset }, context);
    copiedDatum.set({ value: isHorizontal2 ? point.y : point.x });
    return copiedDatum;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
    return this[this.activeHandle].getCursor();
  }
  containsPoint(x, y) {
    const { middle, line, text: text2 } = this;
    this.activeHandle = void 0;
    if (middle.containsPoint(x, y)) {
      this.activeHandle = "middle";
      return true;
    }
    return line.isPointInPath(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  getNodeAtCoords(x, y) {
    if (this.text?.containsPoint(x, y))
      return "text";
    if (this.line.isPointInPath(x, y))
      return "line";
    if (this.middle.containsPoint(x, y))
      return "handle";
  }
  getAnchor() {
    const bbox = this.computeBBoxWithoutHandles();
    if (this.isHorizontal) {
      return { x: bbox.x + bbox.width / 2, y: bbox.y };
    }
    return { x: bbox.x + bbox.width, y: bbox.y + bbox.height / 2, position: "right" };
  }
  convertCrossLine(datum, context) {
    if (datum.value == null)
      return;
    let x1 = 0;
    let y1 = 0;
    let x2, y2;
    const { bounds } = context;
    const scaledValue = convert(datum.value, context);
    if (HorizontalLineProperties.is(datum)) {
      x2 = bounds.width;
      y1 = scaledValue;
      y2 = scaledValue;
    } else {
      x1 = scaledValue;
      x2 = scaledValue;
      y2 = bounds.height;
    }
    return { x1, y1, x2, y2 };
  }
};
var { StateMachine: StateMachine5, StateMachineProperty: StateMachineProperty5, Debug: Debug5 } = module_support_exports;
var CrossLineStateMachine = class extends StateMachine5 {
  constructor(direction, ctx) {
    const onClick = ({ point }) => {
      const isHorizontal2 = direction === "horizontal";
      const datum = isHorizontal2 ? new HorizontalLineProperties() : new VerticalLineProperties();
      datum.set({ value: isHorizontal2 ? point.y : point.x });
      ctx.create(datum);
      ctx.recordAction(
        `Create ${isHorizontal2 ? "horizontal-line" : "vertical-line"} annotation`
      );
    };
    const actionFirstRender = () => {
      this.node?.toggleActive(true);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: onClick
        },
        drag: {
          target: "waiting-first-render",
          action: onClick
        },
        reset: StateMachine5.parent,
        cancel: StateMachine5.parent
      },
      "waiting-first-render": {
        render: {
          target: StateMachine5.parent,
          action: actionFirstRender
        }
      }
    });
    this.debug = Debug5.create(true, "annotations");
  }
};
__decorateClass2([
  StateMachineProperty5()
], CrossLineStateMachine.prototype, "node", 2);
var horizontalLineConfig = {
  type: "horizontal-line",
  datum: HorizontalLineProperties,
  scene: CrossLineScene,
  isDatum: HorizontalLineProperties.is,
  translate: (node, datum, translation, context) => {
    if (HorizontalLineProperties.is(datum) && CrossLineScene.is(node))
      node.translate(datum, translation, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (HorizontalLineProperties.is(datum) && HorizontalLineProperties.is(copiedDatum) && CrossLineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (HorizontalLineProperties.is(datum) && CrossLineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new CrossLineStateMachine("horizontal", {
    ...ctx,
    create: createDatum(
      "horizontal-line"
      /* HorizontalLine */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var verticalLineConfig = {
  type: "vertical-line",
  datum: VerticalLineProperties,
  scene: CrossLineScene,
  isDatum: VerticalLineProperties.is,
  translate: (node, datum, translation, context) => {
    if (VerticalLineProperties.is(datum) && CrossLineScene.is(node))
      node.translate(datum, translation, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (VerticalLineProperties.is(datum) && VerticalLineProperties.is(copiedDatum) && CrossLineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (VerticalLineProperties.is(datum) && CrossLineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new CrossLineStateMachine("vertical", {
    ...ctx,
    create: createDatum(
      "vertical-line"
      /* VerticalLine */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { Vec4: Vec45 } = module_support_exports;
var WithBackgroundScene = class {
  static updateBackground(datum, top, bottom, context) {
    const { background } = this;
    const { seriesRect } = context;
    background.path.clear(true);
    const bounds = Vec45.from(0, 0, seriesRect.width, seriesRect.height);
    const points = this.getBackgroundPoints(datum, top, bottom, bounds);
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (i === 0) {
        background.path.moveTo(point.x, point.y);
      } else {
        background.path.lineTo(point.x, point.y);
      }
    }
    background.path.closePath();
    background.checkPathDirty();
    const backgroundStyles = this.getBackgroundStyles?.(datum) ?? datum.background;
    background.fill = backgroundStyles.fill;
    background.fillOpacity = backgroundStyles.fillOpacity ?? 1;
  }
};
var ChannelScene = class extends LinearScene {
  constructor() {
    super(...arguments);
    this.handles = {};
    this.overflowContinuous = 2;
    this.topLine = new CollidableLine();
    this.bottomLine = new CollidableLine();
    this.background = new module_support_exports.Path({ zIndex: -1 });
    this.anchor = { x: 0, y: 0 };
    this.updateBackground = WithBackgroundScene.updateBackground.bind(this);
  }
  update(datum, context) {
    const { locked, visible } = datum;
    const top = convertLine(datum, context);
    const bottom = convertLine(datum.bottom, context);
    if (top == null || bottom == null) {
      this.visible = false;
      return;
    } else {
      this.visible = visible ?? true;
    }
    const topLine = this.extendLine(top, datum, context);
    const bottomLine = this.extendLine(bottom, datum, context);
    this.updateLines(datum, topLine, bottomLine, context, top, bottom);
    this.updateHandles(datum, top, bottom);
    this.updateText(datum, top, bottom);
    this.updateBackground(datum, topLine, bottomLine, context);
    this.updateAnchor(top, bottom);
    for (const handle22 of Object.values(this.handles)) {
      handle22.toggleLocked(locked ?? false);
    }
  }
  toggleHandles(show) {
    const { handles } = this;
    if (typeof show === "boolean") {
      for (const [handle22, node] of Object.entries(handles)) {
        node.visible = show;
        node.toggleHovered(this.activeHandle === handle22);
      }
      return;
    }
    for (const [handle22, visible] of Object.entries(show)) {
      const node = handles[handle22];
      node.visible = visible ?? true;
      node.toggleHovered(this.activeHandle === handle22);
    }
  }
  toggleActive(active) {
    this.toggleHandles(active);
    for (const node of Object.values(this.handles)) {
      node.toggleActive(active);
    }
  }
  stopDragging() {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    handles[activeHandle].toggleDragging(false);
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
    return this.handles[this.activeHandle].getCursor();
  }
  containsPoint(x, y) {
    const { handles, topLine, bottomLine, text: text2 } = this;
    this.activeHandle = void 0;
    for (const [handle22, child] of Object.entries(handles)) {
      if (child.containsPoint(x, y)) {
        this.activeHandle = handle22;
        return true;
      }
    }
    return topLine.containsPoint(x, y) || bottomLine.containsPoint(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  getNodeAtCoords(x, y) {
    if (this.text?.containsPoint(x, y))
      return "text";
    if (this.topLine.containsPoint(x, y) || this.bottomLine.containsPoint(x, y))
      return "line";
    for (const [_, child] of Object.entries(this.handles)) {
      if (child.containsPoint(x, y))
        return "handle";
    }
  }
  updateAnchor(top, bottom) {
    const { x, y } = module_support_exports.Transformable.toCanvasPoint(
      this.topLine,
      (top.x1 + top.x2) / 2,
      Math.min(top.y1, top.y2, bottom.y1, bottom.y2)
    );
    this.anchor.x = x;
    this.anchor.y = y;
  }
};
var { Vec2: Vec210, Vec4: Vec46 } = module_support_exports;
var DisjointChannelScene = class extends ChannelScene {
  constructor() {
    super();
    this.type = "disjoint-channel";
    this.handles = {
      topLeft: new DivariantHandle(),
      topRight: new DivariantHandle(),
      bottomLeft: new DivariantHandle(),
      bottomRight: new UnivariantHandle()
    };
    this.append([this.background, this.topLine, this.bottomLine, ...Object.values(this.handles)]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "disjoint-channel");
  }
  dragHandle(datum, target, context, snapping) {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    const { offset } = handles[activeHandle].drag(target);
    handles[activeHandle].toggleDragging(true);
    if (activeHandle === "bottomRight") {
      offset.x = 0;
    }
    let translateVectors = [];
    let invertYVectors = [];
    let allowSnapping = snapping;
    switch (activeHandle) {
      case "topLeft":
        translateVectors = ["topLeft"];
        invertYVectors = ["bottomLeft"];
        break;
      case "bottomLeft":
        translateVectors = ["bottomLeft"];
        invertYVectors = ["topLeft"];
        break;
      case "topRight":
        translateVectors = ["topRight"];
        invertYVectors = ["bottomRight"];
        break;
      case "bottomRight":
        translateVectors = ["bottomLeft", "bottomRight"];
        allowSnapping = false;
        break;
    }
    const top = convertLine(datum, context);
    const bottom = convertLine(datum.bottom, context);
    if (!top || !bottom)
      return;
    const vectors = {
      topLeft: Vec46.start(top),
      topRight: Vec46.end(top),
      bottomLeft: Vec46.start(bottom),
      bottomRight: Vec46.end(bottom)
    };
    const snap = {
      vectors: {
        topLeft: vectors.topRight,
        bottomLeft: vectors.bottomRight,
        topRight: vectors.topLeft,
        bottomRight: vectors.bottomLeft
      },
      angle: datum.snapToAngle
    };
    const points = translate(vectors, offset, context, {
      overflowContinuous: this.overflowContinuous,
      translateVectors,
      invertYVectors,
      snap: allowSnapping ? snap : void 0
    });
    datum.start.x = points.topLeft.x;
    datum.start.y = points.topLeft.y;
    datum.end.x = points.topRight.x;
    datum.end.y = points.topRight.y;
    datum.startHeight = points.topLeft.y - points.bottomLeft.y;
    datum.endHeight = points.topRight.y - points.bottomRight.y;
  }
  getTranslatePointsVectors(start2, end2) {
    const { bottomLeft, bottomRight, topLeft, topRight } = this.handles;
    const startHeight = bottomLeft.getBBox().y - topLeft.getBBox().y;
    const endHeight = bottomRight.getBBox().y - topRight.getBBox().y;
    const bottomStart = Vec210.add(start2, Vec210.from(0, startHeight));
    const bottomEnd = Vec210.add(end2, Vec210.from(0, endHeight));
    return { start: start2, end: end2, bottomStart, bottomEnd };
  }
  updateLines(datum, top, bottom) {
    const { topLine, bottomLine } = this;
    const { lineDashOffset, stroke: stroke22, strokeOpacity, strokeWidth } = datum;
    const lineStyles = {
      lineCap: datum.getLineCap(),
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke22,
      strokeOpacity,
      strokeWidth
    };
    topLine.setProperties({ ...top, ...lineStyles });
    bottomLine.setProperties({ ...bottom, ...lineStyles });
  }
  updateHandles(datum, top, bottom) {
    const {
      handles: { topLeft, topRight, bottomLeft, bottomRight }
    } = this;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
    topLeft.update({ ...handleStyles, ...Vec46.start(top) });
    topRight.update({ ...handleStyles, ...Vec46.end(top) });
    bottomLeft.update({ ...handleStyles, ...Vec46.start(bottom) });
    bottomRight.update({
      ...handleStyles,
      ...Vec210.sub(Vec46.end(bottom), Vec210.from(bottomRight.handle.width / 2, bottomRight.handle.height / 2))
    });
  }
  updateText(datum, top, bottom) {
    this.text = this.updateNode(CollidableText, this.text, !!datum.text.label);
    updateChannelText(false, top, bottom, datum.text, datum.strokeWidth, this.text, datum.text.label);
  }
  getBackgroundPoints(datum, top, bottom, bounds) {
    const isFlippedX = top.x1 > top.x2;
    const isFlippedY = top.y1 > top.y2;
    const topY = isFlippedY ? bounds.y2 : bounds.y1;
    const bottomY = isFlippedY ? bounds.y1 : bounds.y2;
    const points = Vec210.from(top);
    if (datum.extendEnd && top.y2 === bottomY) {
      points.push(Vec210.from(isFlippedX ? bounds.x1 : bounds.x2, isFlippedY ? bounds.y1 : bounds.y2));
    }
    if (datum.extendEnd && bottom.y2 === topY) {
      points.push(Vec210.from(isFlippedX ? bounds.x1 : bounds.x2, isFlippedY ? bounds.y2 : bounds.y1));
    }
    points.push(...Vec210.from(bottom).reverse());
    if (datum.extendStart && bottom.y1 === bottomY) {
      points.push(Vec210.from(isFlippedX ? bounds.x2 : bounds.x1, isFlippedY ? bounds.y1 : bounds.y2));
    }
    if (datum.extendStart && top.y1 === topY) {
      points.push(Vec210.from(isFlippedX ? bounds.x2 : bounds.x1, isFlippedY ? bounds.y2 : bounds.y1));
    }
    return points;
  }
};
var { StateMachine: StateMachine6, StateMachineProperty: StateMachineProperty6, Debug: Debug6 } = module_support_exports;
var DisjointChannelStateMachine = class extends StateMachine6 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = new DisjointChannelProperties();
      datum.set({ start: point, end: point, startHeight: 0, endHeight: 0 });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      const { node } = this;
      node?.toggleActive(true);
      node?.toggleHandles({ topLeft: true, topRight: false, bottomLeft: false, bottomRight: false });
    };
    const actionEndUpdate = ({ offset, context }) => {
      const { datum, snapping } = this;
      if (!datum)
        return;
      datum.set({ end: snapPoint(offset, context, snapping, datum.start, datum.snapToAngle) });
      ctx.update();
    };
    const actionEndFinish = () => {
      this.node?.toggleHandles({ topRight: true });
      ctx.update();
    };
    const actionHeightUpdate = ({ point }) => {
      const { datum, node } = this;
      const endY = getGroupingValue(datum?.end.y);
      const startY = getGroupingValue(datum?.start.y);
      const { y: pointY } = point;
      if (datum == null || !isNumber(startY) || !isNumber(endY) || !isNumber(pointY))
        return;
      const endHeight = endY - (pointY ?? 0);
      const startHeight = (startY - endY) * 2 + endHeight;
      const bottomStart = { x: datum?.start.x, y: startY - startHeight };
      const bottomEnd = { x: datum?.end.x, y: point.y };
      node?.toggleHandles({ bottomLeft: true, bottomRight: true });
      if (!ctx.validatePoint(bottomStart, { overflowContinuous: true }) || !ctx.validatePoint(bottomEnd, { overflowContinuous: true })) {
        return;
      }
      datum.set({ startHeight, endHeight });
      ctx.update();
    };
    const actionHeightFinish = ({ point }) => {
      const { datum, node } = this;
      const endY = getGroupingValue(datum?.end.y);
      const startY = getGroupingValue(datum?.start.y);
      const { y: pointY } = point;
      if (datum == null || !isNumber(startY) || !isNumber(endY) || !isNumber(pointY))
        return;
      const endHeight = endY - (pointY ?? 0);
      const startHeight = (startY - endY) * 2 + endHeight;
      const bottomStart = { x: datum.start.x, y: startY - endHeight };
      const bottomEnd = { x: datum.end.x, y: point.y };
      node?.toggleHandles(true);
      if (!ctx.validatePoint(bottomStart, { overflowContinuous: true }) || !ctx.validatePoint(bottomEnd, { overflowContinuous: true })) {
        return;
      }
      datum.set({ startHeight, endHeight });
      ctx.recordAction(`Create ${"disjoint-channel"} annotation`);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    const actionCancel = () => ctx.delete();
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        drag: {
          target: "waiting-first-render",
          action: actionCreate
        },
        reset: StateMachine6.parent
      },
      "waiting-first-render": {
        render: {
          target: "end",
          action: actionFirstRender
        }
      },
      end: {
        hover: actionEndUpdate,
        drag: actionEndUpdate,
        click: {
          target: "height",
          action: actionEndFinish
        },
        dragEnd: {
          target: "height",
          action: actionEndFinish
        },
        reset: {
          target: StateMachine6.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine6.parent,
          action: actionCancel
        }
      },
      height: {
        hover: actionHeightUpdate,
        click: {
          target: StateMachine6.parent,
          action: actionHeightFinish
        },
        drag: {
          target: StateMachine6.parent,
          action: actionHeightFinish
        },
        reset: {
          target: StateMachine6.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine6.parent,
          action: actionCancel
        }
      }
    });
    this.debug = Debug6.create(true, "annotations");
    this.snapping = false;
  }
};
__decorateClass2([
  StateMachineProperty6()
], DisjointChannelStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty6()
], DisjointChannelStateMachine.prototype, "node", 2);
__decorateClass2([
  StateMachineProperty6()
], DisjointChannelStateMachine.prototype, "snapping", 2);
var disjointChannelConfig = {
  type: "disjoint-channel",
  datum: DisjointChannelProperties,
  scene: DisjointChannelScene,
  isDatum: DisjointChannelProperties.is,
  translate: (node, datum, transition, context) => {
    if (DisjointChannelProperties.is(datum) && DisjointChannelScene.is(node)) {
      node.translate(datum, transition, context);
    }
  },
  copy: (node, datum, copiedDatum, context) => {
    if (DisjointChannelProperties.is(datum) && DisjointChannelProperties.is(copiedDatum) && DisjointChannelScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (DisjointChannelProperties.is(datum) && DisjointChannelScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new DisjointChannelStateMachine({
    ...ctx,
    create: createDatum(
      "disjoint-channel"
      /* DisjointChannel */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var FIBONACCI_RETRACEMENT_RATIOS = [0, 23.6, 38.2, 50, 61.8, 78.6, 100];
var FIBONACCI_EXTENSION_RATIOS = [161.8, 261.8, 361.8, 423.6];
var FIBONACCI_RATIOS = [...FIBONACCI_RETRACEMENT_RATIOS, ...FIBONACCI_EXTENSION_RATIOS];
var FIBONACCI_RATIOS_MAP = {
  10: FIBONACCI_RATIOS,
  6: FIBONACCI_RETRACEMENT_RATIOS,
  4: FIBONACCI_RETRACEMENT_RATIOS.filter((r) => r !== 78.6 && r !== 23.6)
};
var FIBONACCI_RANGE_LABEL_PADDING = 10;
function getFibonacciCoords(coords1, coords2) {
  const { x2, y1, y2 } = coords1;
  const trendLineVerticalDistance = y1 - y2;
  if (coords2 == null) {
    return {
      x1: x2,
      x2,
      y1: y2 - trendLineVerticalDistance,
      y2
    };
  }
  return {
    x1: coords2.x1,
    x2: coords2.x2,
    y1: coords2.y2 - trendLineVerticalDistance,
    y2: coords2.y2
  };
}
function createFibonacciRangesData({ x1, y1, x2, y2 }, context, reverse, yZero, bands = 10) {
  const verticalDistance = y1 - y2;
  const direction = reverse ? -1 : 1;
  let startY = yZero;
  const data = [];
  FIBONACCI_RATIOS_MAP[bands].forEach((ratio3, index) => {
    const endY = yZero + verticalDistance * (ratio3 / 100) * direction;
    const yDatumVal = context.yAxis.scaleInvert(endY);
    data.push({
      id: index,
      x1,
      x2,
      y1: startY,
      y2: endY,
      tag: ratio3 == 100 ? 0 : 1,
      label: {
        x1: Math.min(x1, x2) - FIBONACCI_RANGE_LABEL_PADDING,
        x2,
        y1: endY,
        y2: endY,
        text: `${(ratio3 / 100).toFixed(3)} (${yDatumVal.toFixed(2)})`
      }
    });
    startY = endY;
  });
  return data;
}
var { Vec2: Vec211, Vec4: Vec47 } = module_support_exports;
var FibonacciScene = class extends AnnotationScene {
  constructor() {
    super();
    this.trendLine = new CollidableLine();
    this.rangeFillsGroup = new module_support_exports.Group({
      name: `${this.id}-range-fills`
    });
    this.rangeFillsGroupSelection = module_support_exports.Selection.select(this.rangeFillsGroup, module_support_exports.Range);
    this.rangeStrokesGroup = new module_support_exports.Group({
      name: `${this.id}-range-strokes`
    });
    this.rangeStrokesGroupSelection = module_support_exports.Selection.select(this.rangeStrokesGroup, CollidableLine);
    this.labelsGroup = new module_support_exports.Group({
      name: `${this.id}-ranges-labels`
    });
    this.labelsGroupSelection = module_support_exports.Selection.select(this.labelsGroup, CollidableText);
    this.anchor = {
      x: 0,
      y: 0,
      position: "above"
    };
    this.append([this.trendLine, this.rangeFillsGroup, this.rangeStrokesGroup, this.labelsGroup]);
  }
  update(datum, context) {
    let coords = convertLine(datum, context);
    if (coords == null) {
      this.visible = false;
      return;
    }
    coords = Vec47.round(coords);
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    this.updateLine(datum, coords, this.trendLine);
    this.updateHandles(datum, coords);
    this.updateAnchor(datum, coords, context);
    const { reverse } = datum;
    const extendedCoords = this.extendLine(coords, datum, context);
    const yZero = reverse ? extendedCoords.y1 : extendedCoords.y2;
    const yOne = reverse ? extendedCoords.y2 : extendedCoords.y1;
    const data = createFibonacciRangesData(extendedCoords, context, datum.reverse, yZero, datum.bands);
    this.updateRanges(datum, data, context);
    const oneLinePoints = { ...extendedCoords, y1: yOne, y2: yOne };
    this.updateText(datum, oneLinePoints);
  }
  extendLine({ x1, y1, x2, y2 }, datum, context) {
    const linePoints = { x1, y1, x2, y2 };
    if (!datum.extendStart && !datum.extendEnd) {
      return linePoints;
    }
    const { x, width: width2 } = context.xAxis.bounds;
    if (datum.extendEnd) {
      linePoints[x1 > x2 ? "x1" : "x2"] = x + width2;
    }
    if (datum.extendStart) {
      linePoints[x1 > x2 ? "x2" : "x1"] = x;
    }
    return linePoints;
  }
  updateLine(datum, coords, line) {
    if (!coords || !line) {
      return;
    }
    const { lineDashOffset, strokeWidth, strokeOpacity, stroke: stroke22 } = datum;
    line.setProperties({
      ...coords,
      lineCap: datum.getLineCap(),
      lineDash: [3, 4],
      lineDashOffset,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0,
      stroke: stroke22
    });
  }
  updateRangeStrokes(datum) {
    const { lineDashOffset, strokeWidth, strokeOpacity, strokes, rangeStroke, isMultiColor } = datum;
    this.rangeStrokesGroupSelection.each((line, { x1, x2, y2, tag }, index) => {
      const y = y2;
      const color6 = isMultiColor ? strokes[index % strokes.length] : rangeStroke;
      line.setProperties({
        x1,
        x2,
        y1: y,
        y2: y,
        stroke: color6,
        strokeOpacity,
        strokeWidth,
        lineCap: datum.getLineCap(),
        lineDash: datum.getLineDash(),
        lineDashOffset,
        tag
      });
    });
  }
  updateRanges(datum, data, context) {
    const getDatumId = (d) => d.id;
    this.rangeFillsGroupSelection.update(data, void 0, getDatumId);
    this.rangeStrokesGroupSelection.update(data, void 0, getDatumId);
    this.labelsGroupSelection.update(data, void 0, getDatumId);
    this.updateRangeFills(datum);
    this.updateRangeStrokes(datum);
    this.updateRangeLabels(datum, context);
  }
  updateRangeFills(datum) {
    const {
      lineDashOffset,
      strokeWidth,
      strokeOpacity,
      strokes: colors,
      rangeStroke,
      showFill,
      isMultiColor
    } = datum;
    this.rangeFillsGroupSelection.each((range22, { x1, x2, y1, y2 }, index) => {
      const color6 = isMultiColor ? colors[index % colors.length] : rangeStroke;
      if (!showFill) {
        range22.visible = false;
        return;
      }
      range22.setProperties({
        x1,
        x2,
        y1,
        y2,
        startLine: false,
        endLine: false,
        stroke: color6,
        strokeOpacity,
        fill: color6,
        fillOpacity: (strokeOpacity ?? 1) * 0.15,
        strokeWidth,
        lineCap: datum.getLineCap(),
        lineDash: datum.getLineDash(),
        lineDashOffset,
        visible: true
      });
    });
  }
  updateRangeLabels(trendLineProperties, { xAxis }) {
    const { rangeStrokesGroupSelection } = this;
    const {
      strokes: colors,
      strokeWidth,
      rangeStroke,
      isMultiColor,
      label: { fontFamily, fontSize, fontStyle, fontWeight, color: color6 }
    } = trendLineProperties;
    const labelProperties = {
      fontFamily,
      fontSize,
      fontStyle,
      fontWeight
    };
    const withinBounds = this.checkWithinBounds(xAxis, labelProperties, this.labelsGroupSelection.at(0));
    this.labelsGroupSelection.each((textNode, datum, index) => {
      const textColor = color6 ?? (isMultiColor ? colors[index % colors.length] : rangeStroke);
      const line = rangeStrokesGroupSelection.at(index);
      if (!line) {
        return;
      }
      const { text: text2, ...coords } = datum.label;
      if (withinBounds) {
        textNode.setProperties({
          ...labelProperties,
          text: text2,
          x: coords.x1,
          y: coords.y1,
          textBaseline: "middle",
          textAlign: "end",
          fill: textColor
        });
        updateLineText(textNode.id, line, coords);
      } else {
        const textProperties = {
          ...labelProperties,
          label: text2,
          position: "center",
          alignment: "left",
          color: textColor
        };
        updateLineText(textNode.id, line, coords, textProperties, textNode, text2, strokeWidth);
      }
    });
  }
  checkWithinBounds(xAxis, fontOptions, textNode) {
    if (!textNode) {
      return false;
    }
    const { text: text2, ...coords } = textNode.datum.label;
    textNode.setProperties({
      ...fontOptions,
      text: text2,
      x: coords.x1,
      y: coords.y1,
      textBaseline: "middle",
      textAlign: "end"
    });
    const { x } = textNode.getBBox();
    return x >= xAxis.bounds.x && x <= xAxis.bounds.x + xAxis.bounds.width;
  }
  updateText(datum, coords) {
    const oneLine = this.rangeStrokesGroupSelection.selectByTag(
      0
      /* OneLine */
    )[0];
    if (!oneLine) {
      return;
    }
    const { text: textProperties, strokeWidth } = datum;
    this.text = this.updateNode(CollidableText, this.text, !!textProperties.label);
    updateLineText(oneLine.id, oneLine, coords, textProperties, this.text, textProperties.label, strokeWidth);
  }
  updateAnchor(_datum, coords, _context, _bbox) {
    const point = Vec47.topCenter(coords);
    Vec211.apply(this.anchor, module_support_exports.Transformable.toCanvasPoint(this.trendLine, point.x, point.y));
  }
  containsPoint(x, y) {
    const { trendLine, rangeStrokesGroupSelection, text: text2 } = this;
    let isInStrokePath = false;
    rangeStrokesGroupSelection.each((line) => isInStrokePath || (isInStrokePath = line.isPointInPath(x, y)));
    return isInStrokePath || trendLine.isPointInPath(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  getNodeAtCoords(x, y) {
    if (this.text?.containsPoint(x, y))
      return "text";
    if (this.trendLine.isPointInPath(x, y))
      return "line";
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
  }
  drag(datum, target, context, snapping) {
    if (datum.locked)
      return;
    if (this.activeHandle) {
      this.dragHandle(datum, target, context, snapping);
    } else {
      this.dragAll(datum, target, context);
    }
  }
  getAnchor() {
    return this.anchor;
  }
  getCursor() {
    return "pointer";
  }
};
var { ContinuousScale: ContinuousScale3 } = module_support_exports;
function validateDatumPoint(context, point, options = { overflowContinuous: false }, warningPrefix) {
  if (point.x == null || point.y == null) {
    if (warningPrefix) {
      logger_exports.warnOnce(`${warningPrefix}requires both an [x] and [y] property, ignoring.`);
    }
    return false;
  }
  const { xAxis, yAxis } = context;
  const continuousX = options.overflowContinuous && ContinuousScale3.is(xAxis.scale);
  const continuousY = options.overflowContinuous && ContinuousScale3.is(yAxis.scale);
  const validX = continuousX || validateDatumPointDirection(point.x, xAxis);
  const validY = continuousY || validateDatumPointDirection(point.y, yAxis);
  if (validX && validY)
    return true;
  if (warningPrefix) {
    let text2 = "x & y domains";
    if (validX)
      text2 = "y domain";
    if (validY)
      text2 = "x domain";
    const xValue2 = getGroupingValue(point.x);
    const yValue = getGroupingValue(point.y);
    logger_exports.warnOnce(`${warningPrefix}is outside the ${text2}, ignoring. - x: [${xValue2}], y: ${yValue}]`);
  }
  return false;
}
function validateDatumPointDirection(d, context) {
  const { domain } = context.scale;
  const value = getGroupingValue(d);
  if (domain && value != null && context.continuous) {
    return value >= domain[0] && value <= domain.at(-1);
  }
  return true;
}
var { Vec2: Vec212, Vec4: Vec48 } = module_support_exports;
var FibonacciRetracementTrendBasedScene = class extends FibonacciScene {
  constructor() {
    super();
    this.type = "fibonacci-retracement-trend-based";
    this.endRetracementLine = new CollidableLine();
    this.start = new DivariantHandle();
    this.end = new DivariantHandle();
    this.endRetracement = new DivariantHandle();
    this.append([this.endRetracementLine, this.start, this.end, this.endRetracement]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "fibonacci-retracement-trend-based");
  }
  update(datum, context) {
    let { coords1, coords2 } = this.getCoords(datum, context);
    if (coords1 == null || coords2 == null) {
      this.visible = false;
      return;
    }
    coords1 = Vec48.round(coords1);
    coords2 = Vec48.round(coords2);
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    if (datum.endRetracement.x == void 0 || datum.endRetracement.y == void 0) {
      coords2 = void 0;
    }
    this.updateLine(datum, coords1, this.trendLine);
    this.updateLine(datum, coords2, this.endRetracementLine);
    this.updateHandles(datum, coords1, coords2);
    this.updateAnchor(datum, coords2 ?? coords1, context);
    const { reverse, bands } = datum;
    const coords = getFibonacciCoords(coords1, coords2);
    const extendedCoords = this.extendLine(coords, datum, context);
    const yZero = extendedCoords.y2;
    const yOne = extendedCoords.y1;
    const data = !coords2 ? [] : createFibonacciRangesData(extendedCoords, context, reverse, yZero, bands);
    this.updateRanges(datum, data, context);
    const oneLinePoints = { ...extendedCoords, y1: yOne, y2: yOne };
    this.updateText(datum, oneLinePoints);
  }
  containsPoint(x, y) {
    const { start: start2, end: end2, endRetracement, endRetracementLine } = this;
    this.activeHandle = void 0;
    if (start2.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    if (end2.containsPoint(x, y)) {
      this.activeHandle = "end";
      return true;
    }
    if (endRetracement.containsPoint(x, y)) {
      this.activeHandle = "endRetracement";
      return true;
    }
    return endRetracementLine.isPointInPath(x, y) || super.containsPoint(x, y);
  }
  getNodeAtCoords(x, y) {
    if (this.start.containsPoint(x, y) || this.end.containsPoint(x, y) || this.endRetracement.containsPoint(x, y))
      return "handle";
    if (this.endRetracementLine.isPointInPath(x, y))
      return "line";
    return super.getNodeAtCoords(x, y);
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      ...getDragStartState({ start: datum.start, end: datum.end, endRetracement: datum.endRetracement }, context)
    };
  }
  stopDragging() {
    this.start.toggleDragging(false);
    this.end.toggleDragging(false);
    this.endRetracement.toggleDragging(false);
  }
  dragAll(datum, target, context) {
    const { dragState } = this;
    if (!dragState)
      return;
    this.translatePoints({
      datum,
      start: dragState.start,
      end: dragState.end,
      endRetracement: dragState.endRetracement,
      translation: Vec212.sub(target, dragState.offset),
      context
    });
  }
  dragHandle(datum, target, context, snapping) {
    const { activeHandle, dragState } = this;
    if (!activeHandle || !dragState)
      return;
    this[activeHandle].toggleDragging(true);
    const point = snapping ? this.snapToAngle(datum, target, context) : invertCoords(this[activeHandle].drag(target).point, context);
    if (!point || !validateDatumPoint(context, point))
      return;
    datum[activeHandle].x = point.x;
    datum[activeHandle].y = point.y;
  }
  snapToAngle(datum, coords, context) {
    const { activeHandle } = this;
    const handles = ["start", "end", "endRetracement"];
    if (!activeHandle)
      return;
    const index = (handles.indexOf(activeHandle) + 1) % handles.length;
    const fixedHandle = handles[index];
    this[activeHandle].toggleDragging(true);
    const fixed = convertPoint(datum[fixedHandle], context);
    return invertCoords(snapToAngle(coords, fixed, datum.snapToAngle), context);
  }
  translatePoints({
    datum,
    start: start2,
    end: end2,
    endRetracement,
    translation,
    context
  }) {
    const points = translate({ start: start2, end: end2, endRetracement }, translation, context, { overflowContinuous: 2 });
    datum.start.x = points.start.x;
    datum.end.x = points.end.x;
    datum.endRetracement.x = points.endRetracement.x;
    datum.start.y = points.start.y;
    datum.end.y = points.end.y;
    datum.endRetracement.y = points.endRetracement.y;
  }
  translate(datum, translation, context) {
    this.translatePoints({
      datum,
      start: convertPoint(datum.start, context),
      end: convertPoint(datum.end, context),
      endRetracement: convertPoint(datum.endRetracement, context),
      translation,
      context
    });
  }
  copy(datum, copiedDatum, context) {
    const { coords1, coords2 } = this.getCoords(datum, context);
    if (!coords1 || !coords2) {
      return;
    }
    const bbox = this.computeBBoxWithoutHandles();
    this.translatePoints({
      datum: copiedDatum,
      start: Vec48.start(coords1),
      end: Vec48.end(coords1),
      endRetracement: Vec48.end(coords2),
      translation: { x: -bbox.width / 2, y: -bbox.height / 2 },
      context
    });
    return copiedDatum;
  }
  getCoords(datum, context) {
    return {
      coords1: convertLine(datum, context),
      coords2: convertLine({ start: datum.end, end: datum.endRetracement }, context)
    };
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      this.start.visible = show;
      this.end.visible = show;
      this.endRetracement.visible = show;
    } else {
      for (const [handle22, visible] of entries(show)) {
        this[handle22].visible = visible;
      }
    }
    this.start.toggleHovered(this.activeHandle === "start");
    this.end.toggleHovered(this.activeHandle === "end");
    this.endRetracement.toggleHovered(this.activeHandle === "endRetracement");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.start.toggleActive(active);
    this.end.toggleActive(active);
    this.endRetracement.toggleActive(active);
  }
  updateHandles(datum, coords1, coords2, bbox) {
    this.start.update({
      ...this.getHandleStyles(datum),
      ...this.getHandleCoords(datum, coords1, "start")
    });
    this.end.update({
      ...this.getHandleStyles(datum),
      ...this.getHandleCoords(datum, coords1, "end", bbox)
    });
    if (coords2) {
      this.endRetracement.update({
        ...this.getHandleStyles(datum),
        ...this.getHandleCoords(datum, coords2, "endRetracement", bbox)
      });
    }
    this.start.toggleLocked(datum.locked ?? false);
    this.end.toggleLocked(datum.locked ?? false);
    this.endRetracement.toggleLocked(datum.locked ?? false);
  }
  getHandleCoords(_datum, coords, handle22, _bbox) {
    return handle22 === "start" ? Vec48.start(coords) : Vec48.end(coords);
  }
};
var { StateMachine: StateMachine7, StateMachineProperty: StateMachineProperty7, Debug: Debug7 } = module_support_exports;
var FibonacciRetracementTrendBasedStateMachine = class extends StateMachine7 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ start: point, end: point });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      const { node } = this;
      node?.toggleActive(true);
      node?.toggleHandles({ start: true, end: false, endRetracement: false });
    };
    const actionEndUpdate = ({ offset, context }) => {
      const { datum, snapping } = this;
      if (!datum)
        return;
      datum.set({ end: snapPoint(offset, context, snapping, datum.start, datum.snapToAngle) });
      ctx.update();
    };
    const actionEndFinish = () => {
      const { datum } = this;
      if (!datum)
        return;
      datum.endRetracement.x = datum.end.x;
      datum.endRetracement.y = datum.end.y;
      this.node?.toggleHandles({ end: true });
      ctx.update();
    };
    const actionEndRetracementUpdate = ({
      offset,
      context
    }) => {
      const { datum, snapping } = this;
      if (!datum)
        return;
      datum.set({ endRetracement: snapPoint(offset, context, snapping, datum.end, datum.snapToAngle) });
      ctx.update();
    };
    const actionEndRetracementFinish = () => {
      this.node?.toggleHandles({ endRetracement: true });
      ctx.update();
    };
    const actionCancel = () => ctx.delete();
    const onExitEnd = () => {
      ctx.showAnnotationOptions();
      ctx.recordAction(`Create ${this.datum?.type} annotation`);
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        drag: {
          target: "waiting-first-render",
          action: actionCreate
        },
        reset: StateMachine7.parent
      },
      "waiting-first-render": {
        render: {
          target: "end",
          action: actionFirstRender
        }
      },
      end: {
        hover: actionEndUpdate,
        click: {
          target: "endRetracement",
          action: actionEndFinish
        },
        drag: actionEndUpdate,
        dragEnd: {
          target: "endRetracement",
          action: actionEndFinish
        },
        reset: {
          target: StateMachine7.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine7.parent,
          action: actionCancel
        },
        onExit: onExitEnd
      },
      endRetracement: {
        hover: actionEndRetracementUpdate,
        click: {
          target: StateMachine7.parent,
          action: actionEndRetracementFinish
        },
        drag: {
          target: StateMachine7.parent,
          action: actionEndRetracementFinish
        },
        reset: {
          target: StateMachine7.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine7.parent,
          action: actionCancel
        }
      }
    });
    this.debug = Debug7.create(true, "annotations");
    this.snapping = false;
  }
  createDatum() {
    return new FibonacciRetracementTrendBasedProperties();
  }
};
__decorateClass2([
  StateMachineProperty7()
], FibonacciRetracementTrendBasedStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty7()
], FibonacciRetracementTrendBasedStateMachine.prototype, "node", 2);
__decorateClass2([
  StateMachineProperty7()
], FibonacciRetracementTrendBasedStateMachine.prototype, "snapping", 2);
var fibonacciRetracementTrendBasedConfig = {
  type: "fibonacci-retracement-trend-based",
  datum: FibonacciRetracementTrendBasedProperties,
  scene: FibonacciRetracementTrendBasedScene,
  isDatum: FibonacciRetracementTrendBasedProperties.is,
  translate: (node, datum, transition, context) => {
    if (FibonacciRetracementTrendBasedProperties.is(datum) && FibonacciRetracementTrendBasedScene.is(node))
      node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (FibonacciRetracementTrendBasedProperties.is(datum) && FibonacciRetracementTrendBasedProperties.is(copiedDatum) && FibonacciRetracementTrendBasedScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (FibonacciRetracementTrendBasedProperties.is(datum) && FibonacciRetracementTrendBasedScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new FibonacciRetracementTrendBasedStateMachine({
    ...ctx,
    create: createDatum(
      "fibonacci-retracement-trend-based"
      /* FibonacciRetracementTrendBased */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { Vec2: Vec213, Vec4: Vec49 } = module_support_exports;
var FibonacciRetracementScene = class extends FibonacciScene {
  constructor() {
    super();
    this.type = "fibonacci-retracement";
    this.start = new DivariantHandle();
    this.end = new DivariantHandle();
    this.append([this.start, this.end]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "fibonacci-retracement");
  }
  containsPoint(x, y) {
    const { start: start2, end: end2 } = this;
    this.activeHandle = void 0;
    if (start2.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    if (end2.containsPoint(x, y)) {
      this.activeHandle = "end";
      return true;
    }
    return super.containsPoint(x, y);
  }
  getNodeAtCoords(x, y) {
    if (this.start.containsPoint(x, y) || this.end.containsPoint(x, y))
      return "handle";
    return super.getNodeAtCoords(x, y);
  }
  dragStart(datum, target, context) {
    this.dragState = {
      offset: target,
      ...getDragStartState({ start: datum.start, end: datum.end }, context)
    };
  }
  stopDragging() {
    this.start.toggleDragging(false);
    this.end.toggleDragging(false);
  }
  dragAll(datum, target, context) {
    const { dragState } = this;
    if (!dragState)
      return;
    this.translatePoints({
      datum,
      start: dragState.start,
      end: dragState.end,
      translation: Vec213.sub(target, dragState.offset),
      context
    });
  }
  dragHandle(datum, target, context, snapping) {
    const { activeHandle, dragState } = this;
    if (!activeHandle || !dragState)
      return;
    this[activeHandle].toggleDragging(true);
    const point = snapping ? this.snapToAngle(datum, target, context) : invertCoords(this[activeHandle].drag(target).point, context);
    if (!point || !validateDatumPoint(context, point))
      return;
    datum[activeHandle].x = point.x;
    datum[activeHandle].y = point.y;
  }
  snapToAngle(datum, coords, context) {
    const { activeHandle } = this;
    const handles = ["start", "end"];
    const fixedHandle = handles.find((handle22) => handle22 !== activeHandle);
    if (!activeHandle || !fixedHandle)
      return;
    this[activeHandle].toggleDragging(true);
    const fixed = convertPoint(datum[fixedHandle], context);
    return invertCoords(snapToAngle(coords, fixed, datum.snapToAngle), context);
  }
  translatePoints({
    datum,
    start: start2,
    end: end2,
    translation,
    context
  }) {
    const points = translate({ start: start2, end: end2 }, translation, context, { overflowContinuous: 1 });
    datum.start.x = points.start.x;
    datum.end.x = points.end.x;
    datum.start.y = points.start.y;
    datum.end.y = points.end.y;
  }
  translate(datum, translation, context) {
    this.translatePoints({
      datum,
      start: convertPoint(datum.start, context),
      end: convertPoint(datum.end, context),
      translation,
      context
    });
  }
  copy(datum, copiedDatum, context) {
    const coords = convertLine(datum, context);
    if (!coords) {
      return;
    }
    const bbox = this.computeBBoxWithoutHandles();
    this.translatePoints({
      datum: copiedDatum,
      start: { x: coords.x1, y: coords.y1 },
      end: { x: coords.x2, y: coords.y2 },
      translation: { x: -bbox.width / 2, y: -bbox.height / 2 },
      context
    });
    return copiedDatum;
  }
  toggleHandles(show) {
    if (typeof show === "boolean") {
      this.start.visible = show;
      this.end.visible = show;
    } else {
      for (const [handle22, visible] of entries(show)) {
        this[handle22].visible = visible;
      }
    }
    this.start.toggleHovered(this.activeHandle === "start");
    this.end.toggleHovered(this.activeHandle === "end");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.start.toggleActive(active);
    this.end.toggleActive(active);
  }
  updateHandles(datum, coords, _coords2, bbox) {
    this.start.update({
      ...this.getHandleStyles(datum),
      ...this.getHandleCoords(datum, coords, "start")
    });
    this.end.update({
      ...this.getHandleStyles(datum),
      ...this.getHandleCoords(datum, coords, "end", bbox)
    });
    this.start.toggleLocked(datum.locked ?? false);
    this.end.toggleLocked(datum.locked ?? false);
  }
  getHandleCoords(_datum, coords, handle22, _bbox) {
    return handle22 === "start" ? Vec49.start(coords) : Vec49.end(coords);
  }
};
var { StateMachine: StateMachine8, StateMachineProperty: StateMachineProperty8, Debug: Debug8 } = module_support_exports;
var LineTypeStateMachine = class extends StateMachine8 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ start: point, end: point });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      const { node } = this;
      node?.toggleActive(true);
      node?.toggleHandles({ start: true, end: false });
    };
    const actionEndUpdate = ({ offset, context }) => {
      const { datum, snapping } = this;
      if (!datum)
        return;
      datum.set({ end: snapPoint(offset, context, snapping, datum.start, datum.snapToAngle) });
      ctx.update();
    };
    const actionEndFinish = () => {
      this.node?.toggleHandles({ end: true });
      ctx.update();
    };
    const actionCancel = () => ctx.delete();
    const onExitEnd = () => {
      ctx.showAnnotationOptions();
      ctx.recordAction(`Create ${this.datum?.type} annotation`);
    };
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        drag: {
          target: "waiting-first-render",
          action: actionCreate
        },
        reset: StateMachine8.parent
      },
      "waiting-first-render": {
        render: {
          target: "end",
          action: actionFirstRender
        }
      },
      end: {
        hover: actionEndUpdate,
        click: {
          target: StateMachine8.parent,
          action: actionEndFinish
        },
        drag: actionEndUpdate,
        dragEnd: {
          target: StateMachine8.parent,
          action: actionEndFinish
        },
        reset: {
          target: StateMachine8.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine8.parent,
          action: actionCancel
        },
        onExit: onExitEnd
      }
    });
    this.debug = Debug8.create(true, "annotations");
    this.snapping = false;
  }
};
__decorateClass2([
  StateMachineProperty8()
], LineTypeStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty8()
], LineTypeStateMachine.prototype, "node", 2);
__decorateClass2([
  StateMachineProperty8()
], LineTypeStateMachine.prototype, "snapping", 2);
var ArrowStateMachine = class extends LineTypeStateMachine {
  createDatum() {
    return new ArrowProperties();
  }
};
var LineStateMachine = class extends LineTypeStateMachine {
  createDatum() {
    return new LineProperties();
  }
};
var FibonacciRetracementStateMachine = class extends LineTypeStateMachine {
  createDatum() {
    return new FibonacciRetracementProperties();
  }
};
var fibonacciRetracementConfig = {
  type: "fibonacci-retracement",
  datum: FibonacciRetracementProperties,
  scene: FibonacciRetracementScene,
  isDatum: FibonacciRetracementProperties.is,
  translate: (node, datum, transition, context) => {
    if (FibonacciRetracementProperties.is(datum) && FibonacciRetracementScene.is(node))
      node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (FibonacciRetracementProperties.is(datum) && FibonacciRetracementProperties.is(copiedDatum) && FibonacciRetracementScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (FibonacciRetracementProperties.is(datum) && FibonacciRetracementScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new FibonacciRetracementStateMachine({
    ...ctx,
    create: createDatum(
      "fibonacci-retracement"
      /* FibonacciRetracement */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { Vec2: Vec214 } = module_support_exports;
var CapScene = class extends module_support_exports.Group {
};
var ArrowCapScene = class extends CapScene {
  constructor() {
    super();
    this.type = "arrow";
    this.path = new module_support_exports.Path();
    this.armLength = 6;
    this.append([this.path]);
  }
  update(options) {
    const { path } = this;
    const { x, y, angle: angle2, ...rest } = options;
    const origin3 = Vec214.from(x, y);
    const offsetAngle = 3 * Math.PI / 4;
    const armLength = this.armLength + (options.strokeWidth ?? 0) * 2;
    const leftEnd = Vec214.rotate(Vec214.from(0, armLength), angle2 + offsetAngle, origin3);
    const rightEnd = Vec214.rotate(Vec214.from(armLength, 0), angle2 - offsetAngle, origin3);
    path.setProperties(rest);
    path.fillOpacity = 0;
    path.path.clear();
    path.path.moveTo(leftEnd.x, leftEnd.y);
    path.path.lineTo(origin3.x, origin3.y);
    path.path.lineTo(rightEnd.x, rightEnd.y);
  }
};
var { Vec2: Vec215, Vec4: Vec410 } = module_support_exports;
var LineScene = class extends StartEndScene {
  constructor() {
    super();
    this.type = "line";
    this.line = new CollidableLine();
    this.append([this.line, this.start, this.end]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "line");
  }
  update(datum, context) {
    let coords = convertLine(datum, context);
    if (coords == null) {
      this.visible = false;
      return;
    }
    coords = Vec410.round(coords);
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    this.updateLine(datum, coords, context);
    this.updateHandles(datum, coords);
    this.updateText(datum, coords);
    this.updateCaps(datum, coords);
    this.updateAnchor(datum, coords, context);
  }
  updateLine(datum, coords, context) {
    const { line } = this;
    const { lineDashOffset, stroke: stroke22, strokeWidth, strokeOpacity } = datum;
    const linePoints = this.extendLine(coords, datum, context);
    line.setProperties({
      ...linePoints,
      lineCap: datum.getLineCap(),
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0
    });
  }
  updateText(datum, coords) {
    this.text = this.updateNode(CollidableText, this.text, !!datum.text.label);
    updateLineText(this.line.id, this.line, coords, datum.text, this.text, datum.text.label, datum.strokeWidth);
  }
  updateCaps(datum, coords) {
    if (!datum.startCap && this.startCap) {
      this.removeChild(this.startCap);
      this.startCap = void 0;
    }
    if (!datum.endCap && this.endCap) {
      this.removeChild(this.endCap);
      this.endCap = void 0;
    }
    if (!datum.startCap && !datum.endCap)
      return;
    const { stroke: stroke22, strokeWidth, strokeOpacity } = datum;
    const [start2, end2] = Vec215.from(coords);
    const angle2 = Vec215.angle(Vec215.sub(end2, start2));
    if (datum.startCap) {
      if (this.startCap && this.startCap.type !== datum.startCap) {
        this.removeChild(this.startCap);
        this.startCap = void 0;
      }
      if (this.startCap == null) {
        this.startCap = new ArrowCapScene();
        this.append([this.startCap]);
      }
      this.startCap.update({
        x: start2.x,
        y: start2.y,
        angle: angle2 - Math.PI,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity
      });
    }
    if (datum.endCap) {
      if (this.endCap && this.endCap.type !== datum.endCap) {
        this.removeChild(this.endCap);
        this.endCap = void 0;
      }
      if (this.endCap == null) {
        this.endCap = new ArrowCapScene();
        this.append([this.endCap]);
      }
      this.endCap.update({
        x: end2.x,
        y: end2.y,
        angle: angle2,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity
      });
    }
  }
  updateAnchor(_datum, coords, _context, _bbox) {
    const point = Vec410.topCenter(coords);
    Vec215.apply(this.anchor, module_support_exports.Transformable.toCanvasPoint(this.line, point.x, point.y));
  }
  containsPoint(x, y) {
    const { line, text: text2 } = this;
    return super.containsPoint(x, y) || line.isPointInPath(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  getNodeAtCoords(x, y) {
    if (this.text?.containsPoint(x, y))
      return "text";
    if (this.line.isPointInPath(x, y))
      return "line";
    return super.getNodeAtCoords(x, y);
  }
  getHandleCoords(_datum, coords, handle22, _bbox) {
    const { startCap, endCap } = this;
    let [startPoint, endPoint] = Vec215.from(coords);
    const angle2 = Vec215.angle(Vec215.sub(endPoint, startPoint));
    if (startCap) {
      startPoint = Vec215.rotate(Vec215.from(0, -DivariantHandle.HANDLE_SIZE / 2), angle2, startPoint);
    }
    if (endCap) {
      endPoint = Vec215.rotate(Vec215.from(0, DivariantHandle.HANDLE_SIZE / 2), angle2, endPoint);
    }
    return handle22 === "start" ? startPoint : endPoint;
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
  }
};
var lineConfig = {
  type: "line",
  datum: LineProperties,
  scene: LineScene,
  isDatum: LineProperties.is,
  translate: (node, datum, transition, context) => {
    if (LineProperties.is(datum) && LineScene.is(node))
      node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (LineProperties.is(datum) && LineProperties.is(copiedDatum) && LineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (LineProperties.is(datum) && LineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new LineStateMachine({
    ...ctx,
    create: createDatum(
      "line"
      /* Line */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var arrowConfig = {
  type: "arrow",
  datum: ArrowProperties,
  scene: LineScene,
  isDatum: ArrowProperties.is,
  translate: (node, datum, transition, context) => {
    if (ArrowProperties.is(datum) && LineScene.is(node))
      node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (ArrowProperties.is(datum) && ArrowProperties.is(copiedDatum) && LineScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ArrowProperties.is(datum) && LineScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new ArrowStateMachine({
    ...ctx,
    create: createDatum(
      "arrow"
      /* Arrow */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
function layoutScenesRow(scenes, startX = 0, gap = 0) {
  let x = startX;
  for (const scene of scenes) {
    if (Array.isArray(scene)) {
      for (const scene_ of scene) {
        layoutSetX(scene_, x);
      }
      x += module_support_exports.Group.computeChildrenBBox(scene).width + gap;
    } else {
      layoutSetX(scene, x);
      x += scene.getBBox().width + gap;
    }
  }
}
function layoutScenesColumn(scenes, startY = 0, gap = 0) {
  let y = startY;
  for (const scene of scenes) {
    if (Array.isArray(scene)) {
      for (const scene_ of scene) {
        layoutSetY(scene_, y);
      }
      y += module_support_exports.Group.computeChildrenBBox(scene).height + gap;
    } else {
      layoutSetY(scene, y);
      y += scene.getBBox().height + gap;
    }
  }
}
function layoutSetX(scene, x) {
  if ("x1" in scene) {
    scene.x2 = x + (scene.x2 - scene.x1);
    scene.x1 = x;
  } else {
    scene.x = x;
  }
}
function layoutSetY(scene, y) {
  if ("y1" in scene) {
    scene.y2 = y + (scene.y2 - scene.y1);
    scene.y1 = y;
  } else {
    scene.y = y;
  }
}
function layoutAddX(scene, x) {
  if ("x1" in scene) {
    scene.x1 += x;
    scene.x2 += x;
  } else {
    scene.x += x;
  }
}
function layoutAddY(scene, y) {
  if ("y1" in scene) {
    scene.y1 += y;
    scene.y2 += y;
  } else {
    scene.y += y;
  }
}
var { Vec4: Vec411 } = module_support_exports;
var MeasurerStatisticsScene = class extends module_support_exports.Group {
  constructor() {
    super();
    this.name = "MeasurerStatisticsScene";
    this.background = new module_support_exports.Rect();
    this.dateRangeBarsText = new module_support_exports.Text();
    this.dateRangeDivider = new module_support_exports.Line();
    this.dateRangeValueText = new module_support_exports.Text();
    this.priceRangeValueText = new module_support_exports.Text();
    this.priceRangeDivider = new module_support_exports.Line();
    this.priceRangePercentageText = new module_support_exports.Text();
    this.volumeText = new module_support_exports.Text();
    this.volumeFormatter = new Intl.NumberFormat("en-US", {
      notation: "compact",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
    this.append([
      this.background,
      this.dateRangeBarsText,
      this.dateRangeDivider,
      this.dateRangeValueText,
      this.priceRangeValueText,
      this.priceRangeDivider,
      this.priceRangePercentageText,
      this.volumeText
    ]);
  }
  update(datum, stats, anchor, coords, context, verticalDirection, localeManager) {
    this.verticalDirection = verticalDirection;
    const scenes = this.updateStatistics(datum, stats, anchor, localeManager);
    const bbox = module_support_exports.Group.computeChildrenBBox(scenes.flat());
    const padding2 = 10;
    bbox.grow(padding2);
    this.updateBackground(datum, bbox, padding2);
    this.reposition(scenes, padding2, context);
    this.checkVisibility(datum, context, coords);
  }
  checkVisibility(datum, context, coords) {
    const bounds = Vec411.from(new module_support_exports.BBox(0, 0, context.seriesRect.width, context.seriesRect.height));
    if (Vec411.collides(coords, bounds)) {
      this.visible = datum.visible ?? true;
    } else {
      this.visible = false;
    }
  }
  updateStatistics(datum, stats, anchor, localeManager) {
    const {
      dateRangeBarsText,
      dateRangeDivider,
      dateRangeValueText,
      priceRangeValueText,
      priceRangeDivider,
      priceRangePercentageText,
      volumeText
    } = this;
    const horizontalGap = 8;
    const verticalGap = 6;
    const dividerLineHeight = datum.statistics.fontSize + 3;
    const dividerLineOffset = -2;
    const textStyles = this.getTextStyles(datum);
    const dividerLineStyles = {
      ...this.getDividerStyles(datum),
      x1: 0,
      y1: 0,
      x2: 0,
      y2: dividerLineHeight
    };
    const dateScenes = [dateRangeBarsText, dateRangeDivider, dateRangeValueText];
    const priceScenes = [priceRangeValueText, priceRangeDivider, priceRangePercentageText];
    const scenes = [];
    if (stats.priceRange) {
      priceRangeValueText.setProperties({
        ...textStyles,
        text: this.formatPriceRangeValue(stats.priceRange.value, localeManager)
      });
      priceRangeDivider.setProperties(dividerLineStyles);
      priceRangePercentageText.setProperties({
        ...textStyles,
        text: this.formatPriceRangePercentage(stats.priceRange.percentage, localeManager)
      });
      layoutScenesRow(priceScenes, anchor.x, horizontalGap);
      scenes.push(priceScenes);
    }
    if (stats.dateRange) {
      dateRangeBarsText.setProperties({
        ...textStyles,
        text: this.formatDateRangeBars(stats.dateRange.bars, localeManager)
      });
      dateRangeDivider.setProperties(dividerLineStyles);
      dateRangeValueText.setProperties({
        ...textStyles,
        text: this.formatDateRangeValue(stats.dateRange.value)
      });
      layoutScenesRow(dateScenes, anchor.x, horizontalGap);
      scenes.push(dateScenes);
    }
    if (stats.volume != null) {
      volumeText.setProperties({
        ...textStyles,
        x: anchor.x,
        text: this.formatVolume(stats.volume, localeManager),
        visible: true
      });
      scenes.push(volumeText);
    } else {
      volumeText.visible = false;
    }
    layoutScenesColumn(scenes, anchor.y, verticalGap);
    priceRangeDivider.y1 += dividerLineOffset;
    priceRangeDivider.y2 += dividerLineOffset;
    dateRangeDivider.y1 += dividerLineOffset;
    dateRangeDivider.y2 += dividerLineOffset;
    return scenes;
  }
  updateBackground(datum, bbox, padding2) {
    const styles = this.getBackgroundStyles(datum);
    this.background.setProperties({
      ...styles,
      ...bbox,
      x: bbox.x - bbox.width / 2 + padding2,
      y: bbox.y
    });
  }
  reposition(scenes, padding2, context) {
    const { width: width2, height: height2 } = context.seriesRect;
    const background = Vec411.from(this.background.getBBox());
    let offsetX = 0;
    if (background.x1 < 0)
      offsetX = -background.x1;
    if (background.x2 > width2)
      offsetX = width2 - background.x2;
    const offsetY = Math.min(padding2, height2 - background.y2);
    for (const scene of scenes) {
      if (Array.isArray(scene)) {
        const rowWidth = module_support_exports.Group.computeChildrenBBox(scene).width;
        for (const scene_ of scene) {
          layoutAddX(scene_, offsetX - rowWidth / 2);
          layoutAddY(scene_, offsetY);
        }
      } else {
        layoutAddX(scene, offsetX - scene.getBBox().width / 2);
        layoutAddY(scene, offsetY);
      }
    }
    this.background.x += offsetX;
    this.background.y += offsetY;
  }
  getTextStyles(datum) {
    return {
      fill: datum.statistics.color,
      fontFamily: datum.statistics.fontFamily,
      fontSize: datum.statistics.fontSize,
      fontStyle: datum.statistics.fontStyle,
      fontWeight: datum.statistics.fontWeight,
      textBaseline: "top"
    };
  }
  getDividerStyles(datum) {
    return {
      stroke: datum.statistics.divider.stroke,
      strokeOpacity: datum.statistics.divider.strokeOpacity,
      strokeWidth: datum.statistics.divider.strokeWidth
    };
  }
  getBackgroundStyles(datum) {
    return {
      fill: datum.statistics.fill,
      stroke: datum.statistics.stroke,
      strokeOpacity: datum.statistics.strokeOpacity,
      strokeWidth: datum.statistics.strokeWidth,
      cornerRadius: 4
    };
  }
  formatDateRangeBars(bars, localeManager) {
    return localeManager?.t("measurerDateRangeBars", { value: bars }) ?? `${bars}`;
  }
  formatDateRangeValue(time3) {
    const range22 = [];
    const sign = time3 >= 0 ? "" : "-";
    time3 = Math.abs(time3);
    const MINUTE = 1e3 * 60;
    const HOUR = MINUTE * 60;
    const DAY2 = HOUR * 24;
    const minutes = Math.floor(time3 / MINUTE);
    const hours = Math.floor(time3 / HOUR);
    const days = Math.floor(time3 / DAY2);
    const remainderHours = hours % (DAY2 / HOUR);
    const remainderMinutes = minutes % (HOUR / MINUTE);
    if (days >= 1)
      range22.push(`${days}d`);
    if (hours >= 1 && (time3 < DAY2 || remainderHours !== 0))
      range22.push(`${remainderHours}h`);
    if (time3 < HOUR || remainderMinutes !== 0)
      range22.push(`${remainderMinutes}m`);
    range22[0] = `${sign}${range22[0]}`;
    return range22.join(" ");
  }
  formatPriceRangeValue(value, localeManager) {
    return localeManager?.t("measurerPriceRangeValue", { value: Number(value.toFixed(2)) }) ?? `${value}`;
  }
  formatPriceRangePercentage(percentage, localeManager) {
    return localeManager?.t("measurerPriceRangePercent", { value: percentage }) ?? `${percentage}`;
  }
  formatVolume(volume, localeManager) {
    const volumeString = isNaN(volume) ? "" : this.volumeFormatter.format(volume);
    return localeManager?.t("measurerVolume", { value: volumeString }) ?? volumeString;
  }
};
var QuickMeasurerStatisticsScene = class extends MeasurerStatisticsScene {
  getDirectionStyles(datum) {
    return this.verticalDirection === "down" ? datum.down.statistics : datum.up.statistics;
  }
  getTextStyles(datum) {
    const styles = this.getDirectionStyles(datum);
    return {
      ...super.getTextStyles(datum),
      fill: styles.color,
      fontFamily: styles.fontFamily,
      fontSize: styles.fontSize,
      fontStyle: styles.fontStyle,
      fontWeight: styles.fontWeight
    };
  }
  getDividerStyles(datum) {
    const styles = this.getDirectionStyles(datum);
    return {
      stroke: styles.divider.stroke,
      strokeOpacity: styles.divider.strokeOpacity,
      strokeWidth: styles.divider.strokeWidth
    };
  }
  getBackgroundStyles(datum) {
    const styles = this.getDirectionStyles(datum);
    return {
      ...super.getBackgroundStyles(datum),
      fill: styles.fill,
      stroke: styles.stroke,
      strokeOpacity: styles.strokeOpacity,
      strokeWidth: styles.strokeWidth
    };
  }
};
var { Vec2: Vec216, Vec4: Vec412 } = module_support_exports;
var MeasurerScene = class extends StartEndScene {
  constructor() {
    super();
    this.type = "measurer";
    this.horizontalLine = new CollidableLine();
    this.verticalLine = new CollidableLine();
    this.horizontalStartLine = new CollidableLine();
    this.horizontalEndLine = new CollidableLine();
    this.verticalStartLine = new CollidableLine();
    this.verticalEndLine = new CollidableLine();
    this.horizontalEndCap = new ArrowCapScene();
    this.verticalEndCap = new ArrowCapScene();
    this.background = new module_support_exports.Path({ zIndex: -1 });
    this.updateBackground = WithBackgroundScene.updateBackground.bind(this);
    this.statistics = this.createStatisticsScene();
    this.statistics.zIndex = 1;
    this.append([
      this.background,
      this.verticalStartLine,
      this.verticalEndLine,
      this.horizontalStartLine,
      this.horizontalEndLine,
      this.horizontalLine,
      this.verticalLine,
      this.horizontalEndCap,
      this.verticalEndCap,
      this.start,
      this.end,
      this.statistics
    ]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "measurer");
  }
  createStatisticsScene() {
    return new MeasurerStatisticsScene();
  }
  update(datum, context) {
    const coords = convertLine(datum, context);
    if (coords == null) {
      this.visible = false;
      return;
    }
    this.visible = datum.visible ?? true;
    if (!this.visible)
      return;
    const extended = this.extendPerpendicular(coords, datum, context);
    const verticalStart = { ...extended, y2: extended.y1 };
    const verticalEnd = { ...extended, y1: extended.y2 };
    this.verticalDirection = coords.y1 < coords.y2 ? "down" : "up";
    this.updateVisibilities(datum);
    this.updateLines(datum, coords);
    this.updateHandles(datum, coords);
    this.updateText(datum, coords);
    this.updateCaps(datum, coords);
    this.updateBoundingLines(datum, extended);
    this.updateBackground(datum, verticalStart, verticalEnd, context);
    this.updateStatistics(datum, coords, context);
    this.updateAnchor(datum, coords, context);
  }
  extendPerpendicular(coords, datum, context) {
    const extended = {
      x1: Math.min(coords.x1, coords.x2),
      x2: Math.max(coords.x1, coords.x2),
      y1: Math.min(coords.y1, coords.y2),
      y2: Math.max(coords.y1, coords.y2)
    };
    const [start2, end2] = Vec216.from(context.yAxis.bounds);
    if (DateRangeProperties.is(datum)) {
      if (datum.extendAbove)
        extended.y1 = start2.y;
      if (datum.extendBelow)
        extended.y2 = end2.y;
    } else if (PriceRangeProperties.is(datum)) {
      if (datum.extendLeft)
        extended.x1 = start2.x;
      if (datum.extendRight)
        extended.x2 = end2.x;
    }
    return extended;
  }
  updateVisibilities(datum) {
    const {
      horizontalStartLine,
      horizontalEndLine,
      horizontalEndCap,
      verticalStartLine,
      verticalEndLine,
      verticalEndCap
    } = this;
    const { direction } = datum;
    verticalStartLine.visible = direction !== "vertical";
    verticalEndLine.visible = direction !== "vertical";
    horizontalEndCap.visible = direction !== "vertical";
    horizontalStartLine.visible = direction !== "horizontal";
    horizontalEndLine.visible = direction !== "horizontal";
    verticalEndCap.visible = direction !== "horizontal";
  }
  updateLines(datum, coords) {
    const { horizontalLine, verticalLine } = this;
    const { direction } = datum;
    const { x1, y1, x2, y2 } = coords;
    const center2 = Vec216.round(Vec412.center(coords), 0);
    const lineStyles = this.getLineStyles(datum);
    if (direction !== "vertical") {
      horizontalLine.setProperties({
        ...lineStyles,
        x1,
        x2,
        y1: center2.y,
        y2: center2.y
      });
    }
    if (direction !== "horizontal") {
      verticalLine.setProperties({
        ...lineStyles,
        x1: center2.x,
        x2: center2.x,
        y1,
        y2
      });
    }
  }
  updateText(datum, coords) {
    const { direction } = datum;
    const center2 = Vec216.round(Vec412.center(coords), 0);
    let line;
    const textCoords = { ...coords };
    if (direction === "vertical") {
      line = this.verticalLine;
      textCoords.x1 = center2.x;
      textCoords.x2 = center2.x;
    } else {
      line = this.horizontalLine;
      textCoords.y1 = center2.y;
      textCoords.y2 = center2.y;
    }
    this.text = this.updateNode(CollidableText, this.text, !!datum.text.label);
    const { id } = line;
    const clip = updateLineText(id, line, textCoords, datum.text, this.text, datum.text.label, datum.strokeWidth);
    let verticalClipMask;
    if (direction === "both" && clip && this.text) {
      const textBBox = Vec412.from(this.text.getBBox());
      const { offset } = clip.numbers;
      const crossesVerticalLine = textBBox.x1 <= center2.x + offset.x && textBBox.x2 >= center2.x - offset.x;
      if (crossesVerticalLine) {
        verticalClipMask = {
          x: center2.x,
          y: clip.clipMask.y,
          radius: this.text.getBBox().height / 2 + Vec216.length(offset)
        };
      }
    }
    this.verticalLine.setClipMask(id, verticalClipMask);
  }
  updateCaps(datum, coords) {
    const { horizontalEndCap, verticalEndCap } = this;
    const { direction } = datum;
    const { x1, y1, x2, y2 } = coords;
    const center2 = Vec216.round(Vec412.center(coords), 0);
    const { stroke: stroke22, strokeWidth, strokeOpacity } = this.getLineStyles(datum);
    const capStyles = { stroke: stroke22, strokeWidth, strokeOpacity };
    if (direction !== "vertical") {
      const angle2 = x1 <= x2 ? 0 : Math.PI;
      let x = x2;
      if (direction === "horizontal") {
        x += x1 <= x2 ? -2 : 2;
      }
      horizontalEndCap.update({ ...capStyles, x, y: center2.y, angle: angle2 });
    }
    if (direction !== "horizontal") {
      const angle2 = y1 <= y2 ? Math.PI / 2 : Math.PI / -2;
      let y = y2;
      if (direction === "vertical") {
        y += y1 <= y2 ? -2 : 2;
      }
      verticalEndCap.update({ ...capStyles, x: center2.x, y, angle: angle2 });
    }
  }
  updateBoundingLines(datum, extendedCoords) {
    const { verticalStartLine, verticalEndLine, horizontalStartLine, horizontalEndLine } = this;
    const { direction } = datum;
    const { x1, y1, x2, y2 } = extendedCoords;
    const lineStyles = this.getLineStyles(datum);
    if (direction === "horizontal") {
      verticalStartLine.setProperties({ ...lineStyles, x1, y1, x2: x1, y2 });
      verticalEndLine.setProperties({ ...lineStyles, x1: x2, y1, x2, y2 });
    }
    if (direction === "vertical") {
      horizontalStartLine.setProperties({ ...lineStyles, x1, y1, x2, y2: y1 });
      horizontalEndLine.setProperties({ ...lineStyles, x1, y1: y2, x2, y2 });
    }
  }
  updateStatistics(datum, coords, context) {
    const point = Vec216.add(Vec412.bottomCenter(coords), Vec216.from(0, 10));
    const statistics = { volume: this.getVolume(datum) };
    if (datum.hasPriceRange) {
      statistics.priceRange = {
        percentage: this.getPriceRangePercentage(datum),
        value: this.getPriceRangeValue(datum)
      };
    }
    if (datum.hasDateRange) {
      statistics.dateRange = {
        bars: this.getDateRangeBars(coords, context),
        value: this.getDateRangeValue(datum)
      };
    }
    this.statistics.update(datum, statistics, point, coords, context, this.verticalDirection, datum.localeManager);
  }
  updateAnchor(_datum, coords, _context, _bbox) {
    const point = Vec412.topCenter(coords);
    Vec216.apply(this.anchor, module_support_exports.Transformable.toCanvasPoint(this.horizontalLine, point.x, point.y));
  }
  getBackgroundPoints(_datum, verticalStart, verticalEnd, _bounds) {
    const [startStart, startEnd] = Vec216.from(verticalStart);
    const [endStart, endEnd] = Vec216.from(verticalEnd);
    return [startStart, startEnd, endEnd, endStart];
  }
  getLineStyles(datum) {
    const { lineDashOffset, stroke: stroke22, strokeWidth, strokeOpacity } = datum;
    return {
      lineCap: datum.getLineCap(),
      lineDash: datum.getLineDash(),
      lineDashOffset,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0
    };
  }
  getBackgroundStyles(datum) {
    const { background } = datum;
    return {
      fill: background.fill,
      fillOpacity: background.fillOpacity
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
  }
  containsPoint(x, y) {
    const {
      horizontalLine,
      text: text2,
      verticalLine,
      horizontalStartLine,
      horizontalEndLine,
      verticalStartLine,
      verticalEndLine
    } = this;
    return super.containsPoint(x, y) || horizontalLine.isPointInPath(x, y) || verticalLine.isPointInPath(x, y) || horizontalStartLine.visible && horizontalStartLine.isPointInPath(x, y) || horizontalEndLine.visible && horizontalEndLine.isPointInPath(x, y) || verticalStartLine.visible && verticalStartLine.isPointInPath(x, y) || verticalEndLine.visible && verticalEndLine.isPointInPath(x, y) || Boolean(text2?.containsPoint(x, y));
  }
  getNodeAtCoords(x, y) {
    if (this.text?.containsPoint(x, y))
      return "text";
    if (this.start.containsPoint(x, y) || this.end.containsPoint(x, y))
      return "handle";
    return "line";
  }
  getDateRangeBars(coords, context) {
    const { step } = context.xAxis.scale;
    const sign = coords.x1 <= coords.x2 ? 1 : -1;
    return step ? Math.round(Vec412.width(coords) / step) * sign : 0;
  }
  getDateRangeValue(datum) {
    const start2 = getGroupingValue(datum.start.x);
    const end2 = getGroupingValue(datum.end.x);
    if (!isDate(start2) || !isDate(end2)) {
      throw new Error("Can not create a date range measurement of non-date x-axis.");
    }
    return end2.getTime() - start2.getTime();
  }
  getPriceRangePercentage(datum) {
    if (datum.start.y == null || datum.end.y == null) {
      throw new Error("Can not create a price range measurement of a non-numeric y-axis");
    }
    const endY = getGroupingValue(datum.end.y);
    const startY = getGroupingValue(datum.start.y);
    if (!isNumber(endY) || !isNumber(startY)) {
      throw new Error("Can not create a price range measurement of a non-numeric y-axis");
    }
    return (endY - startY) / startY;
  }
  getPriceRangeValue(datum) {
    if (datum.start.y == null || datum.end.y == null) {
      throw new Error("Can not create a price range measurement of a non-numeric y-axis");
    }
    const endY = getGroupingValue(datum.end.y);
    const startY = getGroupingValue(datum.start.y);
    if (!isNumber(endY) || !isNumber(startY)) {
      throw new Error("Can not create a price range measurement of a non-numeric y-axis");
    }
    return endY - startY;
  }
  getVolume(datum) {
    return datum.getVolume(datum.start.x, datum.end.x);
  }
};
var QuickMeasurerScene = class extends MeasurerScene {
  constructor() {
    super(...arguments);
    this.type = "quick-measurer";
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "quick-measurer");
  }
  createStatisticsScene() {
    return new QuickMeasurerStatisticsScene();
  }
  getDirectionStyles(datum) {
    return this.verticalDirection === "down" ? datum.down : datum.up;
  }
  getLineStyles(datum) {
    const styles = this.getDirectionStyles(datum);
    return {
      ...super.getLineStyles(datum),
      stroke: styles.stroke,
      strokeWidth: styles.strokeWidth,
      strokeOpacity: styles.strokeOpacity
    };
  }
  getBackgroundStyles(datum) {
    const styles = this.getDirectionStyles(datum);
    return {
      fill: styles.fill,
      fillOpacity: styles.fillOpacity
    };
  }
  getHandleStyles(datum) {
    const styles = this.getDirectionStyles(datum);
    return {
      fill: styles.handle.fill,
      stroke: styles.handle.stroke ?? styles.stroke,
      strokeOpacity: styles.handle.strokeOpacity ?? styles.strokeOpacity,
      strokeWidth: styles.handle.strokeWidth ?? styles.strokeWidth
    };
  }
};
var { StateMachine: StateMachine9, StateMachineProperty: StateMachineProperty9, Debug: Debug9 } = module_support_exports;
var MeasurerTypeStateMachine = class extends StateMachine9 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = this.createDatum();
      datum.set({ start: point, end: point });
      ctx.create(datum);
    };
    const actionEndUpdate = ({ point }) => {
      const { datum, node } = this;
      datum?.set({ end: point });
      node?.toggleActive(true);
      node?.toggleHandles({ end: false });
      ctx.update();
    };
    const actionEndFinish = () => {
      this.node?.toggleHandles({ end: true });
    };
    const actionCancel = () => ctx.delete();
    const onExitEnd = () => {
      ctx.showAnnotationOptions();
      if (isEphemeralType(this.datum))
        return;
      ctx.recordAction(`Create ${this.node?.type} annotation`);
    };
    super("start", {
      start: {
        reset: StateMachine9.parent,
        click: {
          target: "end",
          action: actionCreate
        },
        drag: {
          target: "end",
          action: actionCreate
        }
      },
      end: {
        hover: actionEndUpdate,
        drag: actionEndUpdate,
        click: {
          target: StateMachine9.parent,
          action: actionEndFinish
        },
        dragEnd: {
          target: StateMachine9.parent,
          action: actionEndFinish
        },
        reset: {
          target: StateMachine9.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine9.parent,
          action: actionCancel
        },
        onExit: onExitEnd
      }
    });
    this.debug = Debug9.create(true, "annotations");
  }
};
__decorateClass2([
  StateMachineProperty9()
], MeasurerTypeStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty9()
], MeasurerTypeStateMachine.prototype, "node", 2);
var DateRangeStateMachine = class extends MeasurerTypeStateMachine {
  createDatum() {
    return new DateRangeProperties();
  }
};
var PriceRangeStateMachine = class extends MeasurerTypeStateMachine {
  createDatum() {
    return new PriceRangeProperties();
  }
};
var DatePriceRangeStateMachine = class extends MeasurerTypeStateMachine {
  createDatum() {
    return new DatePriceRangeProperties();
  }
};
var QuickDatePriceRangeStateMachine = class extends MeasurerTypeStateMachine {
  createDatum() {
    return new QuickDatePriceRangeProperties();
  }
};
var dateRangeConfig = {
  type: "date-range",
  datum: DateRangeProperties,
  scene: MeasurerScene,
  isDatum: DateRangeProperties.is,
  translate: (node, datum, translation, context) => {
    if (DateRangeProperties.is(datum) && MeasurerScene.is(node)) {
      node.translate(datum, translation, context);
    }
  },
  copy: (node, datum, copiedDatum, context) => {
    if (DateRangeProperties.is(datum) && DateRangeProperties.is(copiedDatum) && MeasurerScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (DateRangeProperties.is(datum) && MeasurerScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new DateRangeStateMachine({
    ...ctx,
    create: createDatum(
      "date-range"
      /* DateRange */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var priceRangeConfig = {
  type: "price-range",
  datum: PriceRangeProperties,
  scene: MeasurerScene,
  isDatum: PriceRangeProperties.is,
  translate: (node, datum, translation, context) => {
    if (PriceRangeProperties.is(datum) && MeasurerScene.is(node)) {
      node.translate(datum, translation, context);
    }
  },
  copy: (node, datum, copiedDatum, context) => {
    if (PriceRangeProperties.is(datum) && PriceRangeProperties.is(copiedDatum) && MeasurerScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (PriceRangeProperties.is(datum) && MeasurerScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new PriceRangeStateMachine({
    ...ctx,
    create: createDatum(
      "date-range"
      /* DateRange */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var datePriceRangeConfig = {
  type: "date-price-range",
  datum: DatePriceRangeProperties,
  scene: MeasurerScene,
  isDatum: DatePriceRangeProperties.is,
  translate: (node, datum, translation, context) => {
    if (DatePriceRangeProperties.is(datum) && MeasurerScene.is(node)) {
      node.translate(datum, translation, context);
    }
  },
  copy: (node, datum, copiedDatum, context) => {
    if (DatePriceRangeProperties.is(datum) && DatePriceRangeProperties.is(copiedDatum) && MeasurerScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (DatePriceRangeProperties.is(datum) && MeasurerScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new DatePriceRangeStateMachine({
    ...ctx,
    create: createDatum(
      "date-range"
      /* DateRange */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var quickDatePriceRangeConfig = {
  type: "quick-date-price-range",
  datum: QuickDatePriceRangeProperties,
  scene: QuickMeasurerScene,
  isDatum: QuickDatePriceRangeProperties.is,
  translate: (node, datum, translation, context) => {
    if (QuickDatePriceRangeProperties.is(datum) && QuickMeasurerScene.is(node)) {
      node.translate(datum, translation, context);
    }
  },
  copy: (node, datum, copiedDatum, context) => {
    if (QuickDatePriceRangeProperties.is(datum) && QuickDatePriceRangeProperties.is(copiedDatum) && QuickMeasurerScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (QuickDatePriceRangeProperties.is(datum) && QuickMeasurerScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new QuickDatePriceRangeStateMachine({
    ...ctx,
    create: createDatum(
      "quick-date-price-range"
      /* QuickDatePriceRange */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { ZIndexMap: ZIndexMap3, TextWrapper: TextWrapper3 } = module_support_exports;
var NoteScene = class extends TextualPointScene {
  constructor() {
    super();
    this.type = "note";
    this.shape = new module_support_exports.Rect();
    this.iconBackground = new module_support_exports.TranslatableSvgPath(
      "M22 1.83333C22 0.820811 21.1792 0 20.1667 0H1.83333C0.820811 0 0 0.82081 0 1.83333V13.9868C0 14.9994 0.820811 15.8202 1.83333 15.8202L5.88971 15.8202C6.44575 15.8202 6.97175 16.0725 7.31971 16.5062L9.57006 19.3112C10.304 20.2259 11.6962 20.2259 12.4301 19.3112L14.6804 16.5062C15.0284 16.0725 15.5544 15.8202 16.1104 15.8202L20.1667 15.8202C21.1792 15.8202 22 14.9994 22 13.9868V1.83333Z"
    );
    this.iconLines = new module_support_exports.TranslatableSvgPath(
      "M17.1114 5.75C17.1114 6.16421 16.7756 6.5 16.3614 6.5H5.63916C5.22495 6.5 4.88916 6.16421 4.88916 5.75V5.75C4.88916 5.33579 5.22495 5 5.63916 5H16.3614C16.7756 5 17.1114 5.33579 17.1114 5.75V5.75ZM17.1114 9.25C17.1114 9.66421 16.7756 10 16.3614 10H5.63916C5.22495 10 4.88916 9.66421 4.88916 9.25V9.25C4.88916 8.83579 5.22495 8.5 5.63916 8.5H16.3614C16.7756 8.5 17.1114 8.83579 17.1114 9.25V9.25Z"
    );
    this.active = false;
    this.shape.visible = false;
    this.label.visible = false;
    this.iconBackground.fillShadow = new module_support_exports.DropShadow();
    this.append([this.shape, this.label, this.iconBackground, this.iconLines, this.handle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(
      value,
      "note"
      /* Note */
    );
  }
  update(datum, context) {
    this.updateIcon(datum, context);
    super.update(datum, context);
  }
  getTextBBox(datum, coords, context) {
    const bbox = super.getTextBBox(datum, coords, context);
    bbox.x -= datum.width / 2;
    bbox.x = clamp(0, bbox.x, context.seriesRect.width - datum.width);
    const padding2 = datum.getPadding().top;
    const topY = bbox.y - LABEL_OFFSET - padding2 * 2;
    const bottomY = bbox.y + DivariantHandle.HANDLE_SIZE + padding2 * 2;
    if (topY - bbox.height - TOOLBAR_OFFSET < 0) {
      bbox.y = bottomY;
      datum.position = "top";
    } else {
      bbox.y = topY + padding2;
      datum.position = "bottom";
    }
    return bbox;
  }
  updateLabel(datum, bbox) {
    const labelVisibility = datum.visible === false ? false : this.label.visible;
    super.updateLabel(datum, bbox);
    this.label.visible = labelVisibility;
    this.label.text = TextWrapper3.wrapText(datum.text, {
      font: {
        fontFamily: datum.fontFamily,
        fontSize: datum.fontSize,
        fontStyle: datum.fontStyle,
        fontWeight: datum.fontWeight
      },
      avoidOrphans: false,
      textAlign: datum.textAlign,
      textBaseline: "top",
      textWrap: "always",
      maxWidth: 200
    });
  }
  updateShape(datum, bbox) {
    const { shape } = this;
    shape.fill = datum.background.fill;
    shape.fillOpacity = datum.background.fillOpacity ?? 1;
    shape.stroke = datum.background.stroke;
    shape.strokeOpacity = datum.background.strokeOpacity ?? 1;
    shape.strokeWidth = datum.background.strokeWidth ?? 1;
    shape.cornerRadius = 4;
    const padding2 = datum.getPadding().top;
    const isPositionTop = datum.position === "top";
    shape.x = bbox.x - padding2;
    shape.width = datum.width + padding2 * 2;
    shape.height = bbox.height + padding2 * 2;
    shape.y = bbox.y + (isPositionTop ? 0 : -bbox.height) - padding2;
  }
  updateIcon(datum, context) {
    const { active, iconBackground, iconLines } = this;
    const { x, y } = convertPoint(datum, context);
    iconBackground.translationX = x - ICON_WIDTH / 2;
    iconBackground.translationY = y - ICON_HEIGHT;
    iconLines.translationX = iconBackground.translationX;
    iconLines.translationY = iconBackground.translationY;
    iconBackground.fill = datum.fill;
    iconBackground.fillOpacity = datum.fillOpacity ?? 1;
    iconBackground.stroke = datum.stroke;
    iconBackground.strokeOpacity = datum.strokeOpacity ?? 1;
    iconBackground.strokeWidth = datum.strokeWidth ?? 1;
    iconLines.fill = datum.stroke;
    if (active) {
      iconBackground.fillShadow.color = datum.fill ?? "rgba(0, 0, 0, 0.22)";
    } else {
      iconBackground.fillShadow.color = "rgba(0, 0, 0, 0.22)";
    }
  }
  updateAnchor(datum, bbox, context) {
    const padding2 = datum.getPadding().top;
    const isPositionTop = datum.position === "top";
    const direction = isPositionTop ? 1 : -1;
    return {
      x: bbox.x + context.seriesRect.x + datum.width / 2,
      y: bbox.y + context.seriesRect.y + direction * (bbox.height + padding2),
      position: isPositionTop ? "below" : "above"
    };
  }
  getLabelCoords(datum, bbox) {
    const isPositionTop = datum.position === "top";
    const padding2 = datum.getPadding().top + datum.fontSize * ANNOTATION_TEXT_LINE_HEIGHT / 2;
    return { x: bbox.x, y: bbox.y + (isPositionTop ? padding2 / 2 : 0) };
  }
  getTextBaseline(datum) {
    return datum.position === "top" ? "middle" : datum.position;
  }
  getHandleCoords(_datum, coords, _bbox) {
    return {
      x: coords.x,
      y: coords.y + DivariantHandle.HANDLE_SIZE / 2 + 4
    };
  }
  getHandleStyles(datum) {
    return {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.fill,
      strokeOpacity: datum.handle.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth
    };
  }
  toggleHovered(hovered) {
    super.toggleHovered(hovered);
    this.label.visible = hovered;
    this.shape.visible = hovered;
    this.zIndex = hovered ? ZIndexMap3.CHART_ANNOTATION_FOCUSED : ZIndexMap3.CHART_ANNOTATION;
  }
  toggleActive(active) {
    super.toggleActive(active);
    this.label.visible = active;
    this.shape.visible = active;
    this.active = active;
  }
  containsPoint(x, y) {
    if (this.shape.visible && this.shape.containsPoint(x, y))
      return true;
    if (this.iconBackground.containsPoint(x, y))
      return true;
    return super.containsPoint(x, y);
  }
};
var NoteStateMachine = class extends TextualPointStateMachine {
  createDatum() {
    return new NoteProperties();
  }
};
var noteConfig = {
  type: "note",
  datum: NoteProperties,
  scene: NoteScene,
  isDatum: NoteProperties.is,
  translate: (node, datum, transition, context) => {
    if (NoteProperties.is(datum) && NoteScene.is(node))
      node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (NoteProperties.is(datum) && NoteProperties.is(copiedDatum) && NoteScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (NoteProperties.is(datum) && NoteScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new NoteStateMachine({
    ...ctx,
    create: createDatum(
      "note"
      /* Note */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var { Vec2: Vec217, Vec4: Vec413 } = module_support_exports;
var ParallelChannelScene = class extends ChannelScene {
  constructor() {
    super();
    this.type = "parallel-channel";
    this.handles = {
      topLeft: new DivariantHandle(),
      topMiddle: new UnivariantHandle(),
      topRight: new DivariantHandle(),
      bottomLeft: new DivariantHandle(),
      bottomMiddle: new UnivariantHandle(),
      bottomRight: new DivariantHandle()
    };
    this.middleLine = new CollidableLine();
    this.append([this.background, this.topLine, this.middleLine, this.bottomLine, ...Object.values(this.handles)]);
  }
  static is(value) {
    return AnnotationScene.isCheck(value, "parallel-channel");
  }
  dragHandle(datum, target, context, snapping) {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    const { offset } = handles[activeHandle].drag(target);
    handles[activeHandle].toggleDragging(true);
    if (activeHandle === "topMiddle" || activeHandle === "bottomMiddle") {
      offset.x = 0;
    }
    let translateVectors = [];
    let allowSnapping = snapping;
    switch (activeHandle) {
      case "topLeft":
      case "bottomLeft":
        translateVectors = ["topLeft", "bottomLeft"];
        break;
      case "topMiddle":
        translateVectors = ["topLeft", "topRight"];
        offset.y -= UnivariantHandle.HANDLE_SIZE / 2;
        allowSnapping = false;
        break;
      case "topRight":
      case "bottomRight":
        translateVectors = ["topRight", "bottomRight"];
        break;
      case "bottomMiddle":
        translateVectors = ["bottomLeft", "bottomRight"];
        offset.y -= UnivariantHandle.HANDLE_SIZE / 2;
        allowSnapping = false;
        break;
    }
    const top = convertLine(datum, context);
    const bottom = convertLine(datum.bottom, context);
    if (!top || !bottom)
      return;
    const vectors = {
      topLeft: Vec413.start(top),
      topRight: Vec413.end(top),
      bottomLeft: Vec413.start(bottom),
      bottomRight: Vec413.end(bottom)
    };
    const snap = {
      vectors: {
        topLeft: vectors.topRight,
        bottomLeft: vectors.bottomRight,
        topRight: vectors.topLeft,
        bottomRight: vectors.bottomLeft
      },
      angle: datum.snapToAngle
    };
    const points = translate(vectors, offset, context, {
      overflowContinuous: this.overflowContinuous,
      translateVectors,
      snap: allowSnapping ? snap : void 0
    });
    datum.start.x = points.topLeft.x;
    datum.start.y = points.topLeft.y;
    datum.end.x = points.topRight.x;
    datum.end.y = points.topRight.y;
    datum.height = points.topLeft.y - points.bottomLeft.y;
  }
  getTranslatePointsVectors(start2, end2) {
    const { bottomLeft, topLeft } = this.handles;
    const height2 = bottomLeft.getBBox().y - topLeft.getBBox().y;
    const bottomStart = Vec217.add(start2, Vec217.from(0, height2));
    const bottomEnd = Vec217.add(end2, Vec217.from(0, height2));
    return { start: start2, end: end2, bottomStart, bottomEnd };
  }
  containsPoint(x, y) {
    return super.containsPoint(x, y) || this.middleLine.visible && this.middleLine.strokeWidth > 0 && this.middleLine.containsPoint(x, y);
  }
  getNodeAtCoords(x, y) {
    if (this.middleLine.visible && this.middleLine.strokeWidth > 0 && this.middleLine.containsPoint(x, y))
      return "line";
    return super.getNodeAtCoords(x, y);
  }
  updateLines(datum, top, bottom, context, naturalTop, naturalBottom) {
    const { topLine, middleLine, bottomLine } = this;
    const { lineDashOffset, stroke: stroke22, strokeOpacity, strokeWidth } = datum;
    const lineDash = datum.getLineDash();
    const lineStyles = {
      lineCap: datum.getLineCap(),
      lineDash,
      lineDashOffset,
      stroke: stroke22,
      strokeOpacity,
      strokeWidth
    };
    topLine.setProperties({ ...top, ...lineStyles });
    bottomLine.setProperties({ ...bottom, ...lineStyles });
    const middlePoints = this.extendLine(
      {
        x1: naturalTop.x1,
        y1: naturalBottom.y1 + (naturalTop.y1 - naturalBottom.y1) / 2,
        x2: naturalTop.x2,
        y2: naturalBottom.y2 + (naturalTop.y2 - naturalBottom.y2) / 2
      },
      datum,
      context
    );
    middleLine.setProperties({
      ...middlePoints,
      lineDash: datum.middle.lineDash ?? lineDash,
      lineDashOffset: datum.middle.lineDashOffset ?? lineDashOffset,
      stroke: datum.middle.stroke ?? stroke22,
      strokeOpacity: datum.middle.strokeOpacity ?? strokeOpacity,
      strokeWidth: datum.middle.strokeWidth ?? strokeWidth,
      visible: datum.middle.visible ?? true
    });
  }
  updateHandles(datum, top, bottom) {
    const {
      handles: { topLeft, topMiddle, topRight, bottomLeft, bottomMiddle, bottomRight }
    } = this;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: datum.handle.stroke ?? datum.stroke,
      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,
      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth
    };
    topLeft.update({ ...handleStyles, ...Vec413.start(top) });
    topRight.update({ ...handleStyles, ...Vec413.end(top) });
    bottomLeft.update({ ...handleStyles, ...Vec413.start(bottom) });
    bottomRight.update({ ...handleStyles, ...Vec413.end(bottom) });
    topMiddle.update({
      ...handleStyles,
      ...Vec217.sub(Vec413.center(top), Vec217.from(topMiddle.handle.width / 2, topMiddle.handle.height / 2))
    });
    bottomMiddle.update({
      ...handleStyles,
      ...Vec217.sub(Vec413.center(bottom), Vec217.from(bottomMiddle.handle.width / 2, bottomMiddle.handle.height / 2))
    });
  }
  updateText(datum, top, bottom) {
    this.text = this.updateNode(CollidableText, this.text, !!datum.text.label);
    updateChannelText(true, top, bottom, datum.text, datum.strokeWidth, this.text, datum.text.label);
  }
  getBackgroundPoints(datum, top, bottom, bounds) {
    const isFlippedX = top.x1 > top.x2;
    const isFlippedY = top.y1 > top.y2;
    const outOfBoundsStart = top.x1 !== bottom.x1 && top.y1 !== bottom.y1;
    const outOfBoundsEnd = top.x2 !== bottom.x2 && top.y2 !== bottom.y2;
    const points = Vec217.from(top);
    if (datum.extendEnd && outOfBoundsEnd) {
      points.push(Vec217.from(isFlippedX ? bounds.x1 : bounds.x2, isFlippedY ? bounds.y1 : bounds.y2));
    }
    points.push(...Vec217.from(bottom).reverse());
    if (datum.extendStart && outOfBoundsStart) {
      points.push(Vec217.from(isFlippedX ? bounds.x2 : bounds.x1, isFlippedY ? bounds.y2 : bounds.y1));
    }
    return points;
  }
};
var { StateMachine: StateMachine10, StateMachineProperty: StateMachineProperty10, Debug: Debug10 } = module_support_exports;
var ParallelChannelStateMachine = class extends StateMachine10 {
  constructor(ctx) {
    const actionCreate = ({ point }) => {
      const datum = new ParallelChannelProperties();
      datum.set({ start: point, end: point, height: 0 });
      ctx.create(datum);
    };
    const actionFirstRender = () => {
      const { node } = this;
      node?.toggleActive(true);
      node?.toggleHandles({
        topLeft: true,
        topMiddle: false,
        topRight: false,
        bottomLeft: false,
        bottomMiddle: false,
        bottomRight: false
      });
    };
    const actionEndUpdate = ({ offset, context }) => {
      const { datum, snapping } = this;
      if (!datum)
        return;
      datum.set({ end: snapPoint(offset, context, snapping, datum.start, datum.snapToAngle) });
      ctx.update();
    };
    const actionEndFinish = () => {
      this.node?.toggleHandles({
        topRight: true
      });
      ctx.update();
    };
    const actionHeightUpdate = ({ point }) => {
      const { datum, node } = this;
      const endY = getGroupingValue(datum?.end.y);
      const startY = getGroupingValue(datum?.start.y);
      const { y: pointY } = point;
      if (datum == null || !isNumber(startY) || !isNumber(endY) || !isNumber(pointY))
        return;
      const height2 = endY - (pointY ?? 0);
      const bottomStartY = startY - height2;
      node?.toggleHandles({ bottomLeft: true, bottomRight: true });
      if (!ctx.validatePoint({ x: datum.start.x, y: bottomStartY }, { overflowContinuous: true }) || !ctx.validatePoint({ x: datum.end.x, y: point.y }, { overflowContinuous: true })) {
        return;
      }
      datum.set({ height: height2 });
      ctx.update();
    };
    const actionHeightFinish = ({ point }) => {
      const { datum, node } = this;
      const endY = getGroupingValue(datum?.end.y);
      const startY = getGroupingValue(datum?.start.y);
      const { y: pointY } = point;
      if (datum == null || !isNumber(startY) || !isNumber(endY) || !isNumber(pointY))
        return;
      const height2 = endY - (pointY ?? 0);
      const bottomStartY = startY - height2;
      node?.toggleHandles(true);
      if (!ctx.validatePoint({ x: datum.start.x, y: bottomStartY }, { overflowContinuous: true }) || !ctx.validatePoint({ x: datum.end.x, y: point.y }, { overflowContinuous: true })) {
        return;
      }
      datum.set({ height: height2 });
      ctx.recordAction(`Create ${"parallel-channel"} annotation`);
      ctx.showAnnotationOptions();
      ctx.update();
    };
    const actionCancel = () => ctx.delete();
    super("start", {
      start: {
        click: {
          target: "waiting-first-render",
          action: actionCreate
        },
        drag: {
          target: "waiting-first-render",
          action: actionCreate
        },
        reset: StateMachine10.parent
      },
      "waiting-first-render": {
        render: {
          target: "end",
          action: actionFirstRender
        }
      },
      end: {
        hover: actionEndUpdate,
        drag: actionEndUpdate,
        click: {
          target: "height",
          action: actionEndFinish
        },
        dragEnd: {
          target: "height",
          action: actionEndFinish
        },
        reset: {
          target: StateMachine10.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine10.parent,
          action: actionCancel
        }
      },
      height: {
        hover: actionHeightUpdate,
        click: {
          target: StateMachine10.parent,
          action: actionHeightFinish
        },
        drag: {
          target: StateMachine10.parent,
          action: actionHeightFinish
        },
        reset: {
          target: StateMachine10.parent,
          action: actionCancel
        },
        cancel: {
          target: StateMachine10.parent,
          action: actionCancel
        }
      }
    });
    this.debug = Debug10.create(true, "annotations");
    this.snapping = false;
  }
};
__decorateClass2([
  StateMachineProperty10()
], ParallelChannelStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty10()
], ParallelChannelStateMachine.prototype, "node", 2);
__decorateClass2([
  StateMachineProperty10()
], ParallelChannelStateMachine.prototype, "snapping", 2);
var parallelChannelConfig = {
  type: "parallel-channel",
  datum: ParallelChannelProperties,
  scene: ParallelChannelScene,
  isDatum: ParallelChannelProperties.is,
  translate: (node, datum, transition, context) => {
    if (ParallelChannelProperties.is(datum) && ParallelChannelScene.is(node)) {
      node.translate(datum, transition, context);
    }
  },
  copy: (node, datum, copiedDatum, context) => {
    if (ParallelChannelProperties.is(datum) && ParallelChannelProperties.is(copiedDatum) && ParallelChannelScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (ParallelChannelProperties.is(datum) && ParallelChannelScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new ParallelChannelStateMachine({
    ...ctx,
    create: createDatum(
      "parallel-channel"
      /* ParallelChannel */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var TextScene = class extends TextualPointScene {
  constructor() {
    super();
    this.type = "text";
    this.append([this.label, this.handle]);
  }
  static is(value) {
    return AnnotationScene.isCheck(
      value,
      "text"
      /* Text */
    );
  }
  getHandleCoords(_datum, point) {
    const halfSize = DivariantHandle.HANDLE_SIZE / 2;
    return {
      x: point.x + halfSize,
      y: point.y + 2 + halfSize
    };
  }
};
var TextStateMachine = class extends TextualPointStateMachine {
  createDatum() {
    return new TextProperties();
  }
};
var textConfig = {
  type: "text",
  datum: TextProperties,
  scene: TextScene,
  isDatum: TextProperties.is,
  translate: (node, datum, transition, context) => {
    if (TextProperties.is(datum) && TextScene.is(node))
      node.translate(datum, transition, context);
  },
  copy: (node, datum, copiedDatum, context) => {
    if (TextProperties.is(datum) && TextProperties.is(copiedDatum) && TextScene.is(node)) {
      return node.copy(datum, copiedDatum, context);
    }
  },
  update: (node, datum, context) => {
    if (TextProperties.is(datum) && TextScene.is(node)) {
      node.update(datum, context);
    }
  },
  createState: (ctx, { createDatum }) => new TextStateMachine({
    ...ctx,
    create: createDatum(
      "text"
      /* Text */
    )
  }),
  dragState: (ctx) => new DragStateMachine(ctx)
};
var annotationConfigs = {
  // Lines
  [lineConfig.type]: lineConfig,
  [horizontalLineConfig.type]: horizontalLineConfig,
  [verticalLineConfig.type]: verticalLineConfig,
  // Channels
  [parallelChannelConfig.type]: parallelChannelConfig,
  [disjointChannelConfig.type]: disjointChannelConfig,
  // Fibonaccis
  [fibonacciRetracementConfig.type]: fibonacciRetracementConfig,
  [fibonacciRetracementTrendBasedConfig.type]: fibonacciRetracementTrendBasedConfig,
  // Texts
  [calloutConfig.type]: calloutConfig,
  [commentConfig.type]: commentConfig,
  [noteConfig.type]: noteConfig,
  [textConfig.type]: textConfig,
  // Shapes
  [arrowConfig.type]: arrowConfig,
  [arrowUpConfig.type]: arrowUpConfig,
  [arrowDownConfig.type]: arrowDownConfig,
  // Measurers
  [dateRangeConfig.type]: dateRangeConfig,
  [priceRangeConfig.type]: priceRangeConfig,
  [datePriceRangeConfig.type]: datePriceRangeConfig,
  [quickDatePriceRangeConfig.type]: quickDatePriceRangeConfig
};
function getTypedDatum(datum) {
  for (const { isDatum } of Object.values(annotationConfigs)) {
    if (isDatum(datum)) {
      return datum;
    }
  }
}
var { ActionOnSet: ActionOnSet2, ParallelStateMachine: ParallelStateMachine2, StateMachine: StateMachine11, StateMachineProperty: StateMachineProperty11, Debug: Debug11 } = module_support_exports;
var AnnotationsStateMachine = class extends ParallelStateMachine2 {
  constructor(ctx) {
    super(
      new SnappingStateMachine((snapping) => {
        this.snapping = snapping;
      }),
      new UpdateMachine(() => {
        this.node = this.active == null ? void 0 : ctx.node(this.active);
      }),
      new AnnotationsMainStateMachine(ctx, (index) => {
        this.active = index;
        this.datum = this.active == null ? void 0 : ctx.datum(this.active);
        this.node = this.active == null ? void 0 : ctx.node(this.active);
      })
    );
    this.snapping = false;
  }
  // TODO: remove this leak
  getActive() {
    return this.active;
  }
  // TODO: remove this leak
  isActive(index) {
    return index === this.active;
  }
};
__decorateClass2([
  StateMachineProperty11()
], AnnotationsStateMachine.prototype, "snapping", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsStateMachine.prototype, "node", 2);
var SnappingStateMachine = class extends StateMachine11 {
  constructor(setSnapping) {
    super("idle", {
      [
        "idle"
        /* Idle */
      ]: {
        hover: ({ shiftKey }) => setSnapping(shiftKey),
        keyDown: ({ shiftKey }) => setSnapping(shiftKey),
        keyUp: ({ shiftKey }) => setSnapping(shiftKey),
        click: ({ shiftKey }) => setSnapping(shiftKey),
        drag: ({ shiftKey }) => setSnapping(shiftKey)
      },
      [
        "dragging"
        /* Dragging */
      ]: {},
      [
        "translating"
        /* Translating */
      ]: {},
      [
        "text-input"
        /* TextInput */
      ]: {}
    });
  }
};
var UpdateMachine = class extends StateMachine11 {
  constructor(update) {
    super("idle", {
      [
        "idle"
        /* Idle */
      ]: {
        onEnter: update,
        render: update
      },
      [
        "dragging"
        /* Dragging */
      ]: {
        onEnter: update,
        render: update
      },
      [
        "translating"
        /* Translating */
      ]: {
        onEnter: update,
        render: update
      },
      [
        "text-input"
        /* TextInput */
      ]: {
        render: update
      }
    });
  }
};
var AnnotationsMainStateMachine = class extends StateMachine11 {
  constructor(ctx, setActive) {
    const createDatum = (type) => (datum) => {
      ctx.create(type, datum);
      this.active = ctx.selectLast();
    };
    const deleteDatum = () => {
      if (this.active != null)
        ctx.delete(this.active);
      this.active = void 0;
      ctx.select();
    };
    const stateMachineHelpers = {
      createDatum
    };
    const createStateMachineContext = {
      ...ctx,
      delete: deleteDatum,
      showTextInput: () => {
        if (this.active != null)
          ctx.showTextInput(this.active);
      },
      deselect: () => {
        const prevActive = this.active;
        this.active = void 0;
        this.hovered = void 0;
        ctx.select(this.active, prevActive);
      },
      showAnnotationOptions: () => {
        if (this.active != null)
          ctx.showAnnotationOptions(this.active);
      }
    };
    const createStateMachines = Object.fromEntries(
      Object.entries(annotationConfigs).map(([type, config]) => [
        type,
        config.createState(createStateMachineContext, stateMachineHelpers)
      ])
    );
    const dragStateMachines = Object.fromEntries(
      Object.entries(annotationConfigs).map(([type, config]) => [
        type,
        config.dragState(ctx, stateMachineHelpers)
      ])
    );
    const actionColor = ({
      colorPickerType,
      colorOpacity,
      color: color6,
      opacity,
      isMultiColor
    }) => {
      if (!this.datum)
        return;
      if (colorPickerType === "text-color") {
        ctx.updateTextInputColor(color6);
      }
      setColor(this.datum, colorPickerType, colorOpacity, color6, opacity, isMultiColor);
      ctx.update();
    };
    const actionFontSize = (fontSize) => {
      const { datum, node } = this;
      if (!datum || !node)
        return;
      if (isTextType(datum)) {
        datum.fontSize = fontSize;
        ctx.updateTextInputFontSize(fontSize);
      } else if (hasLineText(datum)) {
        datum.text.fontSize = fontSize;
      }
      ctx.update();
    };
    const actionLineStyle = (lineStyle) => {
      const { datum, node } = this;
      if (!datum || !node || !hasLineStyle(datum))
        return;
      setLineStyle(datum, lineStyle);
      ctx.update();
    };
    const actionUpdateTextInputBBox = (bbox) => {
      const { node } = this;
      if (!node || !("setTextInputBBox" in node))
        return;
      node.setTextInputBBox(bbox);
      ctx.update();
    };
    const actionSaveText = ({ textInputValue, bbox }) => {
      const { datum } = this;
      if (bbox != null && textInputValue != null && textInputValue.length > 0) {
        if (!isTextType(datum)) {
          return;
        }
        const wrappedText = wrapText(datum, textInputValue, bbox.width);
        datum.set({ text: wrappedText });
        ctx.update();
        ctx.recordAction(`Change ${datum.type} annotation text`);
      } else {
        ctx.delete(this.active);
        ctx.recordAction(`Delete ${datum?.type} annotation`);
      }
    };
    const actionCancel = () => {
      ctx.updateTextInputBBox(void 0);
    };
    const guardActive = () => this.active != null;
    const guardCopied = () => this.copied != null;
    const guardActiveHasLineText = () => {
      const { active, datum } = this;
      if (active == null)
        return false;
      if (!datum)
        return false;
      return hasLineText(datum) && !datum.locked;
    };
    const guardActiveNotEphemeral = () => this.active != null && !isEphemeralType(this.datum);
    const guardHovered = () => this.hovered != null;
    super("idle", {
      [
        "idle"
        /* Idle */
      ]: {
        onEnter: () => {
          ctx.select(this.active, this.active);
          if (this.hoverCoords) {
            this.hovered = ctx.hoverAtCoords(this.hoverCoords, this.active, this.hovered);
          }
        },
        hover: ({ offset }) => {
          this.hovered = ctx.hoverAtCoords(offset, this.active, this.hovered);
          this.hoverCoords = offset;
        },
        translate: {
          guard: guardActive,
          target: "translating",
          action: ({ translation }) => {
            ctx.startInteracting();
            ctx.translate(this.active, translation);
            ctx.update();
          }
        },
        copy: {
          guard: guardActiveNotEphemeral,
          action: () => {
            this.copied = ctx.copy(this.active);
          }
        },
        cut: {
          guard: guardActiveNotEphemeral,
          action: () => {
            this.copied = ctx.copy(this.active);
            deleteDatum();
          }
        },
        paste: {
          guard: guardCopied,
          action: () => {
            ctx.paste(this.copied);
          }
        },
        selectLast: () => {
          const previousActive = this.active;
          this.active = ctx.selectLast();
          ctx.select(this.active, previousActive);
        },
        click: [
          {
            guard: () => {
              const { active, hovered, datum } = this;
              if (active == null || hovered !== active)
                return false;
              if (!datum)
                return false;
              return isTextType(datum) && !datum.locked;
            },
            target: "text-input"
            /* TextInput */
          },
          {
            action: () => {
              const prevActive = this.active;
              this.active = this.hovered;
              ctx.select(this.active, prevActive);
            }
          }
        ],
        dblclick: {
          guard: guardActiveHasLineText,
          action: ({ offset }) => {
            const nodeAtCoords = ctx.getNodeAtCoords(offset, this.active) === "text" ? "text" : "line";
            ctx.showAnnotationSettings(this.active, void 0, nodeAtCoords);
          }
        },
        dragStart: [
          {
            guard: guardHovered,
            target: "dragging",
            action: () => {
              const prevActive = this.active;
              this.active = this.hovered;
              ctx.select(this.active, prevActive);
              ctx.startInteracting();
            }
          },
          {
            action: () => {
              const prevActive = this.active;
              this.active = this.hovered;
              ctx.select(this.active, prevActive);
            }
          }
        ],
        color: {
          guard: guardActive,
          action: actionColor
        },
        fontSize: {
          guard: guardActive,
          action: actionFontSize
        },
        lineProps: {
          guard: guardActive,
          action: (props) => {
            const datum = getTypedDatum(this.datum);
            datum?.set(props);
            ctx.update();
            ctx.recordAction(
              `Change ${datum?.type} ${Object.entries(props).map(([key, value]) => `${key} to ${value}`).join(", ")}`
            );
          }
        },
        lineStyle: {
          guard: guardActive,
          action: actionLineStyle
        },
        lineText: {
          guard: guardActive,
          action: (props) => {
            const datum = getTypedDatum(this.datum);
            if (!hasLineText(datum))
              return;
            if (isChannelType(datum) && props.position === "center") {
              props.position = "inside";
            }
            datum.text.set(props);
            ctx.update();
          }
        },
        updateTextInputBBox: {
          guard: guardActive,
          action: actionUpdateTextInputBBox
        },
        toolbarPressSettings: {
          guard: guardActiveHasLineText,
          action: (sourceEvent) => {
            ctx.showAnnotationSettings(this.active, sourceEvent);
          }
        },
        reset: () => {
          if (this.active != null) {
            this.node?.toggleActive(false);
          }
          this.hovered = void 0;
          this.active = void 0;
          ctx.select(this.active, this.active);
          ctx.resetToIdle();
        },
        delete: () => {
          if (this.active == null)
            return;
          ctx.delete(this.active);
          if (isEphemeralType(this.datum))
            return;
          ctx.recordAction(`Delete ${this.datum?.type} annotation`);
        },
        deleteAll: () => {
          ctx.deleteAll();
        },
        ...createStateMachines
      },
      [
        "dragging"
        /* Dragging */
      ]: {
        onEnter: (_, data) => {
          if (this.active == null)
            return;
          const type = ctx.getAnnotationType(this.active);
          if (!type)
            return;
          this.transitionRoot(type);
          this.transitionRoot("dragStart", data);
        },
        ...dragStateMachines
      },
      [
        "translating"
        /* Translating */
      ]: {
        onEnter: () => {
        },
        translate: {
          guard: guardActive,
          target: "translating",
          action: ({ translation }) => {
            ctx.startInteracting();
            ctx.translate(this.active, translation);
            ctx.update();
          }
        },
        translateEnd: {
          guard: guardActive,
          target: "idle"
          /* Idle */
        },
        onExit: () => {
          ctx.stopInteracting();
          ctx.update();
          ctx.recordAction("Translate annotation");
        }
      },
      [
        "text-input"
        /* TextInput */
      ]: {
        onEnter: () => {
          if (this.active == null)
            return;
          const datum = getTypedDatum(this.datum);
          if (!datum || !("getTextInputCoords" in datum))
            return;
          ctx.startInteracting();
          ctx.showTextInput(this.active);
          datum.visible = false;
          ctx.update();
        },
        updateTextInputBBox: {
          guard: guardActive,
          action: actionUpdateTextInputBBox
        },
        resize: {
          target: "idle",
          action: actionSaveText
        },
        click: {
          target: "idle",
          action: actionSaveText
        },
        drag: {
          target: "idle",
          action: actionSaveText
        },
        textInput: [
          {
            guard: guardCancelAndExit,
            target: "idle",
            action: actionCancel
          },
          {
            guard: guardSaveAndExit,
            target: "idle",
            action: actionSaveText
          }
        ],
        color: {
          guard: guardActive,
          action: actionColor
        },
        fontSize: {
          guard: guardActive,
          action: actionFontSize
        },
        cancel: {
          target: "idle",
          action: actionCancel
        },
        onExit: () => {
          ctx.stopInteracting();
          ctx.hideTextInput();
          const wasActive = this.active;
          this.active = this.hovered = void 0;
          ctx.select(this.active, wasActive);
          if (wasActive == null)
            return;
          const datum = ctx.datum(wasActive);
          const node = ctx.node(wasActive);
          if (!datum || !node)
            return;
          datum.visible = true;
        }
      }
    });
    this.setActive = setActive;
    this.debug = Debug11.create(true, "annotations");
    this.snapping = false;
  }
};
__decorateClass2([
  ActionOnSet2({
    changeValue(newValue) {
      this.setActive(newValue);
    }
  }),
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "active", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "hovered", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "hoverCoords", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "copied", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "snapping", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "datum", 2);
__decorateClass2([
  StateMachineProperty11()
], AnnotationsMainStateMachine.prototype, "node", 2);
var { ActionOnSet: ActionOnSet22, LayoutElement: LayoutElement2, Menu: Menu22, PropertiesArray: PropertiesArray22, ToolbarButtonProperties: ToolbarButtonProperties22, Property: Property31, ChartAxisDirection: ChartAxisDirection7 } = module_support_exports;
var AnnotationsToolbarButtonProperties = class extends ToolbarButtonProperties22 {
};
__decorateClass2([
  Property31
], AnnotationsToolbarButtonProperties.prototype, "value", 2);
var AnnotationsToolbar = class extends module_support_exports.BaseProperties {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.padding = 20;
    this.buttons = new PropertiesArray22(AnnotationsToolbarButtonProperties);
    this.events = new EventEmitter();
    this.annotationMenu = new Menu22(this.ctx, "annotations");
    this.cleanup = new CleanupRegistry();
    this.toolbar = ctx.sharedToolbar.getSharedToolbar("annotations");
    const onKeyDown = this.onKeyDown.bind(this);
    this.toolbar.addListener("keydown", onKeyDown);
    this.cleanup.register(
      this.toolbar.addToolbarListener("button-pressed", this.onToolbarButtonPress.bind(this)),
      ctx.layoutManager.registerElement(LayoutElement2.ToolbarLeft, this.onLayoutStart.bind(this)),
      () => {
        this.toolbar.removeListener("keydown", onKeyDown);
        this.toolbar.destroy();
      }
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  toggleClearButtonEnabled(enabled) {
    const index = this.buttons.findIndex((button) => button.value === "clear");
    this.toolbar.toggleButtonEnabledByIndex(index, enabled);
  }
  resetButtonIcons() {
    for (const [index, button] of this.buttons.entries()) {
      switch (button.value) {
        case "line-menu":
          this.updateButtonByIndex(index, { icon: "trend-line-drawing", value: "line-menu" });
          break;
        case "fibonacci-menu":
          this.updateButtonByIndex(index, { icon: "fibonacci-retracement-drawing", value: "fibonacci-menu" });
          break;
        case "text-menu":
          this.updateButtonByIndex(index, { icon: "text-annotation", value: "text-menu" });
          break;
        case "shape-menu":
          this.updateButtonByIndex(index, { icon: "arrow-drawing", value: "shape-menu" });
          break;
        case "measurer-menu":
          this.updateButtonByIndex(index, { icon: "measurer-drawing", value: "measurer-menu" });
          break;
      }
    }
  }
  hideOverlays() {
    this.annotationMenu.hide();
  }
  clearActiveButton() {
    this.toolbar.clearActiveButton();
  }
  onLayoutStart(event) {
    if (!this.enabled)
      return;
    this.toolbar.updateButtons(this.buttons);
    this.toolbar.layout(event.layoutBox, this.padding);
  }
  refreshButtonsEnabled(enabled) {
    for (const [index, button] of this.buttons.entries()) {
      if (!button)
        continue;
      this.toolbar.toggleButtonEnabledByIndex(index, enabled);
    }
  }
  onToolbarButtonPress({
    event,
    button,
    buttonBounds
  }) {
    const axisScale = this.ctx.axisManager.getAxisContext(ChartAxisDirection7.Y)[0].scale;
    switch (button.value) {
      case "clear":
        this.events.emit("pressed-clear", null);
        break;
      case "line-menu":
        this.onToolbarButtonPressShowMenu(
          event,
          buttonBounds,
          button.value,
          "toolbarAnnotationsLineAnnotations",
          LINE_ANNOTATION_ITEMS.filter((item) => item.visible ? item.visible(axisScale) : true)
        );
        break;
      case "fibonacci-menu":
        this.onToolbarButtonPressShowMenu(
          event,
          buttonBounds,
          button.value,
          "toolbarAnnotationsFibonacciAnnotations",
          FIBONACCI_ANNOTATION_ITEMS
        );
        break;
      case "text-menu":
        this.onToolbarButtonPressShowMenu(
          event,
          buttonBounds,
          button.value,
          "toolbarAnnotationsTextAnnotations",
          TEXT_ANNOTATION_ITEMS
        );
        break;
      case "shape-menu":
        this.onToolbarButtonPressShowMenu(
          event,
          buttonBounds,
          button.value,
          "toolbarAnnotationsShapeAnnotations",
          SHAPE_ANNOTATION_ITEMS
        );
        break;
      case "measurer-menu":
        this.onToolbarButtonPressShowMenu(
          event,
          buttonBounds,
          button.value,
          "toolbarAnnotationsMeasurerAnnotations",
          MEASURER_ANNOTATION_ITEMS
        );
        break;
    }
  }
  onToolbarButtonPressShowMenu(event, buttonBounds, menu, ariaLabel, items) {
    this.events.emit("pressed-show-menu", null);
    const index = this.buttons.findIndex((button) => button.value === menu);
    this.toolbar.toggleActiveButtonByIndex(index);
    this.annotationMenu.setAnchor({ x: buttonBounds.x + buttonBounds.width + 6, y: buttonBounds.y });
    this.annotationMenu.show({
      items,
      ariaLabel: this.ctx.localeManager.t(ariaLabel),
      class: "ag-charts-annotations__toolbar-menu",
      sourceEvent: event.sourceEvent,
      onPress: this.onButtonPressMenuCreateAnnotation.bind(this, menu)
    });
  }
  onButtonPressMenuCreateAnnotation(menu, item) {
    const index = this.buttons.findIndex((button) => button.value === menu);
    this.updateButtonByIndex(index, { icon: item.icon });
    this.events.emit("pressed-create-annotation", { annotation: item.value });
    this.annotationMenu.hide();
  }
  onKeyDown({ sourceEvent }) {
    if (sourceEvent.key === "Escape") {
      this.events.emit("cancel-create-annotation", null);
    }
  }
  updateButtonByIndex(index, change) {
    const button = this.buttons.at(index);
    if (!button)
      return;
    button.set({ ...button.toJson(), ...change, value: change.value ?? button.value });
    this.toolbar.updateButtonByIndex(index, { ...button.toJson() });
  }
};
__decorateClass2([
  Property31,
  ActionOnSet22({
    changeValue(enabled) {
      this.toolbar?.setHidden(!enabled);
    }
  })
], AnnotationsToolbar.prototype, "enabled", 2);
__decorateClass2([
  Property31
], AnnotationsToolbar.prototype, "padding", 2);
__decorateClass2([
  Property31
], AnnotationsToolbar.prototype, "buttons", 2);
var { BaseModuleInstance: BaseModuleInstance2, InteractionState: InteractionState2, Property: Property32, ChartAxisDirection: ChartAxisDirection8, getIconClassNames: getIconClassNames2 } = module_support_exports;
var DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS = `ag-charts-annotations__axis-button`;
var AxisButton = class extends BaseModuleInstance2 {
  constructor(ctx, axisCtx, onButtonClick, seriesRect) {
    super();
    this.ctx = ctx;
    this.axisCtx = axisCtx;
    this.onButtonClick = onButtonClick;
    this.seriesRect = seriesRect;
    this.enabled = true;
    this.snap = false;
    this.padding = 0;
    this.button = this.setup();
    this.toggleVisibility(false);
    this.updateButtonElement();
    this.snap = Boolean(axisCtx.scale.bandwidth);
    ctx.domManager.addEventListener("focusin", ({ target }) => {
      const htmlTarget = target instanceof HTMLElement ? target : void 0;
      const isSeriesAreaChild = htmlTarget && ctx.domManager.contains(htmlTarget, "series-area");
      if (!isSeriesAreaChild && htmlTarget !== this.button.getElement())
        this.hide();
    });
    this.cleanup.register(
      ctx.widgets.seriesWidget.addListener("drag-move", (e) => this.onMouseDrag(e)),
      ctx.widgets.seriesWidget.addListener("mousemove", (e) => this.onMouseMove(e)),
      ctx.widgets.seriesWidget.addListener("mouseleave", () => this.onMouseLeave()),
      ctx.widgets.seriesDragInterpreter?.events.on("click", (e) => this.onClick(e)),
      ctx.eventsHub.on("series:focus-change", () => this.onKeyPress()),
      ctx.eventsHub.on("zoom:pan-start", () => this.hide()),
      ctx.eventsHub.on("zoom:change", () => this.hide()),
      () => this.destroyElements(),
      () => this.button.destroy()
    );
  }
  update(seriesRect, padding2) {
    this.seriesRect = seriesRect;
    this.padding = padding2;
  }
  setup() {
    const button = new exports_exports.ButtonWidget();
    button.addClass(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);
    button.setTabIndex(-1);
    button.setAriaLabel(this.ctx.localeManager.t("ariaLabelAddHorizontalLine"));
    this.ctx.widgets.seriesWidget.getElement().appendChild(button.getElement());
    return button;
  }
  destroyElements() {
    this.ctx.domManager.removeChild("canvas-overlay", DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);
  }
  onMouseMove(e) {
    if (this.ctx.interactionManager.isState(InteractionState2.Clickable))
      this.show(e);
  }
  onMouseDrag(e) {
    if (this.ctx.interactionManager.isState(InteractionState2.AnnotationsMoveable))
      this.show(e);
  }
  onMouseLeave() {
    if (this.ctx.interactionManager.isState(InteractionState2.Clickable))
      this.hide();
  }
  onClick(e) {
    if (this.ctx.interactionManager.isState(InteractionState2.Clickable) && e.device === "touch")
      this.show(e);
  }
  show(event) {
    const { sourceEvent, currentX: x, currentY: y } = event;
    if (!(this.enabled && this.ctx.widgets.seriesWidget.getElement().contains(sourceEvent.target))) {
      this.hide();
      return;
    }
    this.toggleVisibility(true);
    const buttonCoords = this.getButtonCoordinates({ x, y });
    this.coords = {
      x: buttonCoords.x + this.button.clientWidth / 2,
      y: buttonCoords.y + this.button.clientHeight / 2
    };
    this.updatePosition(buttonCoords);
  }
  hide() {
    this.toggleVisibility(false);
  }
  onKeyPress() {
    if (this.snap && this.ctx.interactionManager.isState(InteractionState2.Default))
      return;
    this.hide();
  }
  getButtonCoordinates({ x, y }) {
    const {
      axisCtx: { direction, position },
      seriesRect,
      snap,
      axisCtx,
      padding: padding2
    } = this;
    const { clientWidth: buttonWidth, clientHeight: buttonHeight } = this.button;
    const [minY, maxY] = [0, seriesRect.height];
    const [minX, maxX] = [0, seriesRect.width];
    if (snap) {
      x = convert(invert(x - seriesRect.x, axisCtx), axisCtx) + seriesRect.x;
      y = convert(invert(y - seriesRect.y, axisCtx), axisCtx) + seriesRect.y;
    }
    if (direction === ChartAxisDirection8.X) {
      const crosshairLabelPadding = 5;
      const offset = buttonHeight - Math.max(0, padding2 - crosshairLabelPadding);
      x = x - buttonWidth / 2;
      y = position === "top" ? minY - buttonHeight + offset : maxY - offset;
    } else {
      const crosshairLabelPadding = 9;
      const offset = buttonWidth - Math.max(0, padding2 - crosshairLabelPadding);
      x = position === "left" ? minX - buttonWidth + offset : maxX - offset;
      y = y - buttonHeight / 2;
    }
    return { x, y };
  }
  toggleVisibility(visible) {
    const { button } = this;
    if (button == null)
      return;
    const isVisible = this.enabled && visible;
    this.toggleClass("-hidden", !isVisible);
  }
  toggleClass(name, include) {
    this.button.toggleClass(`${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-${name}`, include);
  }
  updatePosition({ x, y }) {
    this.button.getElement().style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
  }
  updateButtonElement() {
    const { button } = this;
    button.addListener("click", () => this.onButtonClick(this.coords));
    button.addListener("touchend", () => this.onButtonClick(this.coords));
    button.addListener("drag-start", () => {
    });
    button.setInnerHTML(
      `<span class="${getIconClassNames2("zoom-in")} ${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-icon"></span>`
    );
  }
};
__decorateClass2([
  Property32
], AxisButton.prototype, "enabled", 2);
var {
  Color: Color5,
  DraggablePopover: DraggablePopover2,
  NativeWidget: NativeWidget2,
  Vec2: Vec218,
  createButton: createButton2,
  createCheckbox: createCheckbox2,
  createSelect: createSelect2,
  createTextArea: createTextArea2,
  initRovingTabIndex: initRovingTabIndex2,
  getIconClassNames: getIconClassNames22,
  mapValues: mapValues3
} = module_support_exports;
var _Dialog = class _Dialog2 extends DraggablePopover2 {
  constructor(ctx, id) {
    super(ctx, id);
    this.dragHandleDraggingClass = "ag-charts-dialog__drag-handle--dragging";
    this.colorPicker = new ColorPicker(this.ctx, { detached: true });
    this.cleanup.register(ctx.eventsHub.on("layout:complete", this.onLayoutComplete.bind(this)));
  }
  showWithChildren(children, options) {
    const popover = super.showWithChildren(children, options);
    popover.classList.add("ag-charts-dialog");
    popover.setAttribute("role", "dialog");
    popover.addEventListener("mousedown", (event) => {
      if (event.target.classList?.contains("ag-charts-dialog__color-picker-button"))
        return;
      this.colorPicker.hide();
    });
    popover.addEventListener("keydown", this.onKeyDown.bind(this));
    getWindow().requestAnimationFrame(() => this.reposition());
    this.colorPicker.attachTo(this);
    return popover;
  }
  updatePosition(position) {
    super.updatePosition(position);
    const { anchor, fallbackAnchor } = this.getColorPickerAnchors() ?? {};
    if (!anchor)
      return;
    this.colorPicker.setAnchor(anchor, fallbackAnchor);
  }
  /**************
   * Containers *
   **************/
  createTabs(tablistLabel, initial, tabs) {
    const element2 = createElement("div", "ag-charts-dialog__tabs");
    const tabButtonIds = mapValues3(tabs, () => createElementId());
    const tabPanelIds = mapValues3(tabs, () => createElementId());
    for (const [key, tab] of entries(tabs)) {
      setAttributes(tab.panel, {
        id: tabPanelIds[key],
        role: "tabpanel",
        "aria-labelledby": tabButtonIds[key]
      });
    }
    const onPressTab = (active) => {
      for (const [key, tab] of entries(tabs)) {
        tab.panel.classList.toggle("ag-charts-dialog__tab-panel--active", key === active);
        tabButtons[key].classList.toggle("ag-charts-dialog__tab-button--active", key === active);
        setAttribute(tabButtons[key], "aria-selected", key === active);
        if (key === active)
          tab.onShow?.();
      }
    };
    const header = new NativeWidget2(createElement("div", "ag-charts-dialog__header"));
    header.addListener("drag-start", (event) => {
      const { sourceEvent } = event;
      if (sourceEvent.target instanceof Element && sourceEvent.target.classList.contains("ag-charts-dialog__header")) {
        this.onDragStart(event);
      }
    });
    header.addListener("drag-move", (event) => this.onDragMove(event));
    header.addListener("drag-end", () => this.onDragEnd());
    const dragHandle = new DragHandleWidget2();
    this.setDragHandle(dragHandle);
    const tabButtons = mapValues3(
      tabs,
      (tab, key) => createButton2(
        {
          label: this.ctx.localeManager.t(tab.label),
          onPress: () => onPressTab(key)
        },
        {
          id: tabButtonIds[key],
          class: "ag-charts-dialog__tab-button",
          role: "tab",
          "aria-controls": tabPanelIds[key]
        }
      )
    );
    const tabList = createElement("div", "ag-charts-dialog__tab-list");
    setAttributes(tabList, { role: "tablist", "aria-label": this.ctx.localeManager.t(tablistLabel) });
    tabList.append(...Object.values(tabButtons));
    const closeButton = this.createHeaderCloseButton();
    header.getElement().append(dragHandle.getElement(), tabList, closeButton);
    element2.append(header.getElement(), ...Object.values(tabs).map((t) => t.panel));
    onPressTab(initial);
    initRovingTabIndex2({ orientation: "horizontal", buttons: Object.values(tabButtons) });
    return { tabs: element2, initialFocus: tabButtons[initial] };
  }
  createTabPanel() {
    return createElement("div", "ag-charts-dialog__tab-panel");
  }
  /**********
   * Inputs *
   **********/
  createInputGroupLine() {
    return createElement("div", "ag-charts-dialog__input-group-line");
  }
  createRadioGroup({ label, options, value, onChange }) {
    const group = this.createInputGroup(label);
    setAttributes(group, {
      role: "radiogroup",
      tabindex: -1,
      "aria-label": this.ctx.localeManager.t(label)
    });
    const activeClass = "ag-charts-dialog__button--active";
    const buttons2 = [];
    for (const button of options) {
      const { icon, altText: altTextKey } = button;
      const altText = this.ctx.localeManager.t(altTextKey);
      const buttonEl = createButton2(
        {
          icon,
          altText,
          onPress: () => {
            for (const b of Array.from(group.children)) {
              b.classList.remove(activeClass);
              b.ariaChecked = "false";
            }
            buttonEl.classList.add(activeClass);
            buttonEl.ariaChecked = "true";
            onChange(button.value);
          }
        },
        {
          "aria-checked": button.value === value,
          class: "ag-charts-dialog__button",
          role: "radio",
          title: altText
        }
      );
      if (button.value === value) {
        buttonEl.classList.add(activeClass);
      }
      group.appendChild(buttonEl);
      buttons2.push(buttonEl);
    }
    initRovingTabIndex2({ orientation: "horizontal", buttons: buttons2 });
    return group;
  }
  createSelect({ altText, label, options, value, onChange }) {
    const group = this.createInputGroup(label);
    const altTextT = this.ctx.localeManager.t(altText);
    const select = createSelect2(
      { value, options, onChange },
      { class: "ag-charts-dialog__select", "aria-label": altTextT, title: altTextT }
    );
    group.append(select);
    return group;
  }
  createTextArea({ placeholder, value, onChange }) {
    const placeholderT = placeholder ? this.ctx.localeManager.t(placeholder) : void 0;
    return createTextArea2({ value, onChange }, { placeholder: placeholderT });
  }
  createCheckbox({ label, checked, onChange }) {
    const id = createElementId();
    const group = this.createInputGroup(label, { for: id });
    const checkbox = createCheckbox2(
      { checked, onChange },
      { class: "ag-charts-dialog__checkbox", role: "switch", id }
    );
    group.append(checkbox);
    return group;
  }
  createColorPicker({
    color: color6,
    opacity,
    label,
    altText,
    onChange,
    onChangeHide,
    isMultiColor,
    hasMultiColorOption
  }) {
    const group = this.createInputGroup(label);
    const altTextT = this.ctx.localeManager.t(altText);
    const colorEl = createButton2(
      {
        label: altTextT,
        onPress: (event) => {
          const { anchor, fallbackAnchor } = this.getColorPickerAnchors(colorEl) ?? {};
          this.colorPicker.show({
            anchor,
            fallbackAnchor,
            color: color6,
            opacity,
            isMultiColor,
            hasMultiColorOption,
            sourceEvent: event,
            onChange: (newColorOpacity, newColor, newOpacity, newIsMultiColor) => {
              colorEl.style.setProperty("--color", newColorOpacity);
              colorEl.classList.toggle(
                "ag-charts-dialog__color-picker-button--multi-color",
                newIsMultiColor
              );
              onChange(newColorOpacity, newColor, newOpacity, newIsMultiColor);
            },
            onChangeHide
          });
        }
      },
      {
        "aria-label": altTextT,
        tabindex: 0,
        class: "ag-charts-dialog__color-picker-button",
        title: altTextT
      }
    );
    if (isMultiColor) {
      colorEl.classList.toggle("ag-charts-dialog__color-picker-button--multi-color");
    } else if (color6) {
      const hex = Color5.fromString(color6);
      const hexWithOpacity = new Color5(hex.r, hex.g, hex.b, opacity);
      colorEl.style.setProperty("--color", hexWithOpacity.toHexString());
    }
    group.append(colorEl);
    this.hideFns.push(() => {
      this.colorPicker.hide();
    });
    return group;
  }
  /***********
   * Private *
   ***********/
  createHeaderCloseButton() {
    return createButton2(
      { icon: "close", altText: this.ctx.localeManager.t("iconAltTextClose"), onPress: () => this.hide() },
      { class: "ag-charts-dialog__close-button" }
    );
  }
  createInputGroup(label, options) {
    const group = createElement("div", "ag-charts-dialog__input-group");
    const labelEl = createElement("label", "ag-charts-dialog__input-group-label");
    labelEl.innerText = this.ctx.localeManager.t(label);
    setAttribute(labelEl, "for", options?.for);
    group.appendChild(labelEl);
    return group;
  }
  onLayoutComplete(event) {
    this.seriesRect = event.series.paddedRect;
    this.reposition();
  }
  onKeyDown(event) {
    if (event.altKey || event.ctrlKey || event.metaKey || event.isComposing || event.key !== "Escape")
      return;
    this.hide();
  }
  reposition() {
    const { seriesRect, ctx } = this;
    const clientRect = ctx.domManager.getBoundingClientRect();
    const popover = this.getPopoverElement();
    if (!seriesRect || !popover)
      return;
    const outerOffset = Vec218.from(0, seriesRect.y);
    const outerSize = Vec218.from(clientRect.width, seriesRect.height);
    const popoverSize = Vec218.from(popover);
    const halfWidth = Vec218.from(0.5, 1);
    let position;
    if (seriesRect.width > 1e3) {
      const bottomCenter2 = Vec218.sub(
        Vec218.add(outerOffset, Vec218.multiply(outerSize, halfWidth)),
        Vec218.multiply(popoverSize, halfWidth)
      );
      position = Vec218.sub(bottomCenter2, Vec218.from(0, _Dialog2.offset));
    } else {
      const bottomRight = Vec218.sub(Vec218.add(outerOffset, outerSize), popoverSize);
      position = Vec218.sub(bottomRight, _Dialog2.offset);
    }
    this.updatePosition(position);
  }
  getColorPickerAnchors(element2) {
    if (element2)
      this.colorPickerAnchorElement = element2;
    if (!this.colorPickerAnchorElement)
      return;
    const rect = this.colorPickerAnchorElement.getBoundingClientRect();
    const canvasRect = this.ctx.domManager.getBoundingClientRect();
    const topLeft = Vec218.sub(Vec218.from(rect.x, rect.y), Vec218.from(canvasRect.left, canvasRect.top));
    const anchor = Vec218.add(topLeft, Vec218.from(0, rect.height + 5));
    const fallbackAnchor = Vec218.sub(topLeft, Vec218.from(0, 5));
    return { anchor, fallbackAnchor };
  }
};
_Dialog.offset = 60;
var Dialog = _Dialog;
var DragHandleWidget2 = class extends NativeWidget2 {
  constructor() {
    super(createElement("div", "ag-charts-dialog__drag-handle"));
    const icon = new NativeWidget2(createElement("span", getIconClassNames22("drag-handle")));
    icon.setAriaHidden(true);
    this.addChild(icon);
  }
};
var { focusCursorAtEnd: focusCursorAtEnd22 } = module_support_exports;
var AnnotationSettingsDialog = class extends Dialog {
  constructor(ctx) {
    super(ctx, "settings");
    this.events = new EventEmitter();
    this.hideFns.push(() => this.events.emit("hidden", null));
  }
  show(datum, options) {
    const lineTab = this.createLinearLineTab(datum, options);
    const textTab = this.createLinearTextTab(datum, options);
    let lineLabel = "dialogHeaderLine";
    if (isChannelType(datum)) {
      lineLabel = "dialogHeaderChannel";
    } else if (isFibonacciType(datum)) {
      lineLabel = "dialogHeaderFibonacciRange";
    } else if (datum.type === "date-range") {
      lineLabel = "dialogHeaderDateRange";
    } else if (datum.type === "price-range") {
      lineLabel = "dialogHeaderPriceRange";
    } else if (datum.type === "date-price-range") {
      lineLabel = "dialogHeaderDatePriceRange";
    }
    const { tabs, initialFocus } = this.createTabs("ariaLabelSettingsTabBar", options.initialSelectedTab, {
      line: {
        label: lineLabel,
        panel: lineTab
      },
      text: {
        label: "dialogHeaderText",
        panel: textTab.panel,
        onShow: textTab.onShow
      }
    });
    options.initialFocus = initialFocus;
    const popover = this.showWithChildren([tabs], options);
    popover.classList.add("ag-charts-dialog--annotation-settings");
  }
  createLinearLineTab(datum, options) {
    const panel = this.createTabPanel();
    const groupOne = this.createInputGroupLine();
    const groupTwo = this.createInputGroupLine();
    const hasMultiColorOption = "isMultiColor" in datum;
    const lineColorPicker = this.createColorPickerInput(
      "line-color",
      datum.getDefaultColor("line-color"),
      datum.getDefaultOpacity("line-color"),
      hasMultiColorOption ? datum.isMultiColor : false,
      hasMultiColorOption,
      options.onChangeLineColor,
      options.onChangeHideLineColor
    );
    const strokeWidth = this.createStrokeWidthSelect(datum.strokeWidth ?? 2, options.onChangeLineStyleWidth);
    const lineStyle = this.createLineStyleRadioGroup(datum.lineStyle ?? "solid", options.onChangeLineStyleType);
    groupOne.append(lineColorPicker);
    if ("background" in datum) {
      const fillColorPicker = this.createColorPickerInput(
        "fill-color",
        datum.getDefaultColor("fill-color"),
        datum.getDefaultOpacity("fill-color"),
        false,
        false,
        options.onChangeFillColor,
        options.onChangeHideFillColor
      );
      groupOne.append(fillColorPicker);
      groupTwo.append(strokeWidth);
    } else if ("showFill" in datum) {
      groupOne.append(
        this.createCheckbox({
          label: "dialogInputShowFill",
          checked: datum.showFill ?? true,
          onChange: (showFill) => options.onChangeLine({ showFill })
        })
      );
      groupTwo.append(strokeWidth);
    } else {
      groupOne.append(strokeWidth);
    }
    groupTwo.append(lineStyle);
    panel.append(groupOne, groupTwo);
    if ("bands" in datum) {
      panel.append(
        this.createFibonacciRatioSelect(datum.bands ?? 10, (bands) => options.onChangeLine({ bands }))
      );
    }
    if ("extendStart" in datum && "extendEnd" in datum) {
      panel.append(
        this.createCheckbox({
          label: isChannelType(datum) ? "dialogInputExtendChannelStart" : "dialogInputExtendLineStart",
          checked: datum.extendStart ?? false,
          onChange: (extendStart) => options.onChangeLine({ extendStart })
        }),
        this.createCheckbox({
          label: isChannelType(datum) ? "dialogInputExtendChannelEnd" : "dialogInputExtendLineEnd",
          checked: datum.extendEnd ?? false,
          onChange: (extendEnd) => options.onChangeLine({ extendEnd })
        })
      );
    }
    if ("extendAbove" in datum && "extendBelow" in datum) {
      panel.append(
        this.createCheckbox({
          label: "dialogInputExtendAbove",
          checked: datum.extendAbove ?? false,
          onChange: (extendAbove) => options.onChangeLine({ extendAbove })
        }),
        this.createCheckbox({
          label: "dialogInputExtendBelow",
          checked: datum.extendBelow ?? false,
          onChange: (extendBelow) => options.onChangeLine({ extendBelow })
        })
      );
    }
    if ("extendLeft" in datum && "extendRight" in datum) {
      panel.append(
        this.createCheckbox({
          label: "dialogInputExtendLeft",
          checked: datum.extendLeft ?? false,
          onChange: (extendLeft) => options.onChangeLine({ extendLeft })
        }),
        this.createCheckbox({
          label: "dialogInputExtendRight",
          checked: datum.extendRight ?? false,
          onChange: (extendRight) => options.onChangeLine({ extendRight })
        })
      );
    }
    if ("reverse" in datum && "showFill" in datum) {
      panel.append(
        this.createCheckbox({
          label: "dialogInputReverse",
          checked: datum.reverse ?? false,
          onChange: (reverse) => options.onChangeLine({ reverse })
        })
      );
    }
    return panel;
  }
  createLinearTextTab(datum, options) {
    const panel = this.createTabPanel();
    const textArea = this.createTextArea({
      placeholder: "inputTextareaPlaceholder",
      value: datum.text.label,
      onChange: (value) => options.onChangeText({ label: value })
    });
    const fontSize = this.createFontSizeSelect(datum.text.fontSize, options.onChangeTextFontSize);
    const colorPicker = this.createColorPickerInput(
      "text-color",
      datum.text.color,
      1,
      false,
      false,
      options.onChangeTextColor,
      options.onChangeHideTextColor
    );
    const textPosition = datum.text.position === "inside" ? "center" : datum.text.position;
    const position = this.createPositionRadioGroup(
      textPosition ?? "top",
      (value) => options.onChangeText({ position: value })
    );
    const alignment = this.createAlignmentRadioGroup(
      datum.text.alignment ?? "center",
      (value) => options.onChangeText({ alignment: value })
    );
    const inputGroupLine = this.createInputGroupLine();
    inputGroupLine.append(fontSize, colorPicker, position, alignment);
    panel.append(textArea, inputGroupLine);
    return { panel, onShow: () => focusCursorAtEnd22(textArea) };
  }
  createColorPickerInput(colorType, color6, opacity, isMultiColor, hasMultiColorOption, onChange, onChangeHide) {
    const label = colorType === "fill-color" ? "dialogInputFillColorPicker" : "dialogInputColorPicker";
    const altText = colorType === "fill-color" ? "dialogInputFillColorPickerAltText" : "dialogInputColorPickerAltText";
    return this.createColorPicker({
      label,
      altText,
      color: color6,
      opacity,
      isMultiColor,
      hasMultiColorOption,
      onChange,
      onChangeHide
    });
  }
  createStrokeWidthSelect(strokeWidth, onChange) {
    return this.createSelect({
      label: "dialogInputStrokeWidth",
      altText: "dialogInputStrokeWidthAltText",
      options: LINE_STROKE_WIDTH_ITEMS.map(({ label, value }) => ({ label, value: `${value}` })),
      value: String(strokeWidth),
      onChange: (value) => onChange(Number(value))
    });
  }
  createFibonacciRatioSelect(bands, onChange) {
    return this.createSelect({
      label: "dialogInputFibonacciBands",
      altText: "dialogInputFibonacciBandsAltText",
      options: FIBONACCI_RATIO_ITEMS.map(({ label, value }) => ({ label, value: `${value}` })),
      value: String(bands),
      onChange: (value) => onChange(Number(value))
    });
  }
  createLineStyleRadioGroup(lineStyle, onChange) {
    return this.createRadioGroup({
      label: "dialogInputLineStyle",
      options: [
        { icon: "line-style-solid", altText: "iconAltTextLineStyleSolid", value: "solid" },
        { icon: "line-style-dashed", altText: "iconAltTextLineStyleDashed", value: "dashed" },
        { icon: "line-style-dotted", altText: "iconAltTextLineStyleDotted", value: "dotted" }
      ],
      value: lineStyle,
      onChange
    });
  }
  createFontSizeSelect(fontSize, onChange) {
    return this.createSelect({
      label: "dialogInputFontSize",
      altText: "dialogInputFontSizeAltText",
      options: TEXT_SIZE_ITEMS.map(({ label, value }) => ({ label, value: String(value) })),
      value: String(fontSize),
      onChange: (value) => onChange(Number(value))
    });
  }
  createPositionRadioGroup(position, onChange) {
    return this.createRadioGroup({
      label: "dialogInputPosition",
      options: [
        { icon: "position-top", altText: "iconAltTextPositionTop", value: "top" },
        { icon: "position-center", altText: "iconAltTextPositionCenter", value: "center" },
        { icon: "position-bottom", altText: "iconAltTextPositionBottom", value: "bottom" }
      ],
      value: position,
      onChange
    });
  }
  createAlignmentRadioGroup(alignment, onChange) {
    return this.createRadioGroup({
      label: "dialogInputAlign",
      options: [
        { icon: "align-left", altText: "iconAltTextAlignLeft", value: "left" },
        { icon: "align-center", altText: "iconAltTextAlignCenter", value: "center" },
        { icon: "align-right", altText: "iconAltTextAlignRight", value: "right" }
      ],
      value: alignment,
      onChange
    });
  }
};
function calculateAxisLabelPadding(axisLayout) {
  return axisLayout.gridPadding + axisLayout.seriesAreaPadding + axisLayout.tickSize + axisLayout.label.spacing;
}
function updateAnnotation(node, datum, context) {
  for (const { update } of Object.values(annotationConfigs)) {
    update(node, datum, context);
  }
}
var {
  ChartUpdateType: ChartUpdateType2,
  InteractionState: InteractionState22,
  PropertiesArray: PropertiesArray3,
  Property: Property33,
  ChartAxisDirection: ChartAxisDirection9,
  keyProperty: keyProperty2,
  valueProperty: valueProperty2,
  Vec2: Vec219,
  Selection: Selection3,
  BBox: BBox3
} = module_support_exports;
var _Annotations = class _Annotations2 extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.toolbar = new AnnotationsToolbar(this.ctx);
    this.optionsToolbar = new AnnotationOptionsToolbar(this.ctx, () => {
      const active = this.state.getActive();
      if (active == null)
        return;
      return getTypedDatum(this.annotationData.at(active));
    });
    this.axesButtons = new AxesButtons();
    this.snap = false;
    this.data = void 0;
    this.xKey = void 0;
    this.volumeKey = void 0;
    this.annotationData = new PropertiesArray3(
      _Annotations2.createAnnotationDatum
    );
    this.defaults = new AnnotationDefaults();
    this.container = new module_support_exports.Group({ name: "static-annotations" });
    this.annotations = new Selection3(
      this.container,
      this.createAnnotationScene.bind(this)
    );
    this.settingsDialog = new AnnotationSettingsDialog(this.ctx);
    this.textInput = new TextInput(this.ctx);
    this.postUpdateFns = [];
    this.state = this.setupStateMachine();
    this.setupListeners();
    this.setupDOM();
    this.ctx.historyManager.addMementoOriginator(ctx.annotationManager);
    this.ctx.historyManager.addMementoOriginator(this.defaults);
    this.textInput.setKeyDownHandler(this.onTextInput.bind(this));
    this.cleanup.register(() => this.clear());
  }
  setupStateMachine() {
    const { ctx } = this;
    return new AnnotationsStateMachine({
      resetToIdle: () => {
        ctx.domManager.updateCursor("annotations");
        this.popAnnotationState(InteractionState22.Annotations);
        this.hideOverlays();
        this.optionsToolbar.hide();
        this.deleteEphemeralAnnotations();
        this.update();
      },
      hoverAtCoords: (coords, active, previousHovered) => {
        let hovered;
        this.annotations.each((annotation, _, index) => {
          const contains = annotation.containsPoint(coords.x, coords.y);
          if (contains)
            hovered ?? (hovered = index);
          annotation.toggleHovered(contains || active === index);
        });
        if (hovered != null) {
          ctx.tooltipManager.suppressTooltip("annotations");
        } else if (!this.isAnnotationState()) {
          ctx.tooltipManager.unsuppressTooltip("annotations");
        }
        this.ctx.domManager.updateCursor(
          "annotations",
          hovered == null ? void 0 : this.annotations.at(hovered)?.getCursor()
        );
        if (hovered !== previousHovered) {
          this.update();
        }
        return hovered;
      },
      getNodeAtCoords: (coords, active) => {
        const node = this.annotations.at(active);
        if (!node) {
          return;
        }
        return node.getNodeAtCoords(coords.x, coords.y);
      },
      translate: (index, translation) => {
        const node = this.annotations.at(index);
        const datum = getTypedDatum(this.annotationData.at(index));
        if (!node || !datum) {
          return;
        }
        return this.translateNode(node, datum, translation);
      },
      copy: (index) => {
        const node = this.annotations.at(index);
        const datum = getTypedDatum(this.annotationData.at(index));
        if (!node || !datum) {
          return;
        }
        return this.createAnnotationDatumCopy(node, datum);
      },
      paste: (datum) => {
        this.createAnnotation(datum.type, datum, false);
        this.postUpdateFns.push(() => {
          this.state.transitionAsync("selectLast");
          this.state.transitionAsync("copy");
        });
      },
      select: (index, previous) => {
        const { annotations, optionsToolbar: optionsToolbar2, toolbar: toolbar2 } = this;
        this.hideOverlays();
        toolbar2.clearActiveButton();
        toolbar2.resetButtonIcons();
        const selectedNode = index != null ? annotations.at(index) : null;
        const previousNode = previous != null ? annotations.at(previous) : null;
        if (previousNode === selectedNode && selectedNode != null) {
          return;
        }
        previousNode?.toggleActive(false);
        optionsToolbar2.hide();
        if (selectedNode) {
          this.pushAnnotationState(InteractionState22.AnnotationsSelected);
          selectedNode.toggleActive(true);
          optionsToolbar2.updateButtons(this.annotationData.at(index));
          this.postUpdateFns.push(() => {
            optionsToolbar2.show();
            optionsToolbar2.setAnchorScene(selectedNode);
          });
        } else {
          this.popAnnotationState(InteractionState22.AnnotationsSelected);
          this.popAnnotationState(InteractionState22.Annotations);
        }
        this.deleteEphemeralAnnotations();
        this.update();
      },
      selectLast: () => {
        this.pushAnnotationState(InteractionState22.AnnotationsSelected);
        return this.annotationData.length - 1;
      },
      startInteracting: () => {
        this.pushAnnotationState(InteractionState22.Annotations);
      },
      stopInteracting: () => {
        this.popAnnotationState(InteractionState22.Annotations);
      },
      create: (type, datum) => {
        this.createAnnotation(type, datum);
      },
      delete: (index) => {
        this.annotationData.splice(index, 1);
      },
      deleteAll: () => {
        this.annotationData.splice(0, this.annotationData.length);
      },
      validatePoint: (point, options) => {
        const context = this.getAnnotationContext();
        return context ? validateDatumPoint(context, point, options) : true;
      },
      getAnnotationType: (index) => {
        return stringToAnnotationType(this.annotationData[index].type);
      },
      datum: (index) => {
        return this.annotationData.at(index);
      },
      node: (index) => {
        return this.annotations.at(index);
      },
      recordAction: (label) => {
        this.recordActionAfterNextUpdate(label);
      },
      update: () => {
        this.postUpdateFns.push(() => {
          const active = this.state.getActive();
          const node = active != null ? this.annotations.at(active) : null;
          if (node == null)
            return;
          this.optionsToolbar.setAnchorScene(node);
        });
        this.update();
      },
      showTextInput: (active) => {
        const datum = getTypedDatum(this.annotationData.at(active));
        const node = this.annotations.at(active);
        if (!node || !datum || !("getTextInputCoords" in datum) || !("getTextPosition" in datum))
          return;
        const styles = {
          color: datum.color,
          fontFamily: datum.fontFamily,
          fontSize: datum.fontSize,
          fontStyle: datum.fontStyle,
          fontWeight: datum.fontWeight,
          placeholderColor: datum.getPlaceholderColor()
        };
        const context = this.getAnnotationContext();
        const getTextInputCoords = (height2) => Vec219.add(datum.getTextInputCoords(context, height2), Vec219.required(this.seriesRect));
        const getTextPosition = () => datum.getTextPosition();
        this.textInput.show({
          styles,
          layout: {
            getTextInputCoords,
            getTextPosition,
            alignment: datum.alignment,
            textAlign: datum.textAlign,
            width: datum.width
          },
          text: datum.text,
          placeholderText: datum.placeholderText,
          onChange: (_text, bbox) => {
            this.state.transition("updateTextInputBBox", bbox);
          }
        });
        this.ctx.domManager.updateCursor("annotations");
      },
      hideTextInput: () => {
        this.textInput.hide();
      },
      updateTextInputColor: (color6) => {
        this.textInput.updateColor(color6);
      },
      updateTextInputFontSize: (fontSize) => {
        const bbox = this.textInput.updateFontSize(fontSize);
        this.state.transition("updateTextInputBBox", bbox);
      },
      updateTextInputBBox: (bbox) => {
        this.state.transition("updateTextInputBBox", bbox);
      },
      showAnnotationOptions: (active) => {
        const node = this.annotations.at(active);
        if (!node || isEphemeralType(this.annotationData.at(active)))
          return;
        this.optionsToolbar.updateButtons(this.annotationData.at(active));
        this.optionsToolbar.show();
        this.optionsToolbar.setAnchorScene(node);
      },
      showAnnotationSettings: (active, sourceEvent, initialTab = "line") => {
        const datum = this.annotationData.at(active);
        if (!isLineType(datum) && !isChannelType(datum) && !isMeasurerType(datum))
          return;
        if (isEphemeralType(datum))
          return;
        const onChangeColor = (colorType) => (colorOpacity, color6, opacity, isMultiColor) => {
          this.setColorAndDefault(datum.type, colorType, colorOpacity, color6, opacity, isMultiColor);
          this.optionsToolbar.updateColorPickerColor(colorType, color6, opacity, isMultiColor);
        };
        const onChangeHideColor = (colorType) => () => {
          this.recordActionAfterNextUpdate(
            `Change ${datum.type} ${colorType} to ${datum.getDefaultColor(colorType)}`,
            ["annotations", "defaults"]
          );
          this.update();
        };
        const options = {
          initialSelectedTab: initialTab,
          ariaLabel: this.ctx.localeManager.t("ariaLabelAnnotationSettingsDialog"),
          sourceEvent,
          onChangeLine: (props) => {
            this.state.transition("lineProps", props);
            if (props.bands != null)
              this.defaults.setDefaultFibonacciOptions(datum.type, "bands", props.bands);
            if (props.reverse != null)
              this.defaults.setDefaultFibonacciOptions(datum.type, "reverse", props.reverse);
            if (props.showFill != null)
              this.defaults.setDefaultFibonacciOptions(datum.type, "showFill", props.showFill);
          },
          onChangeText: (props) => {
            this.state.transition("lineText", props);
            if (props.alignment)
              this.defaults.setDefaultLineTextAlignment(datum.type, props.alignment);
            if (props.position)
              this.defaults.setDefaultLineTextPosition(datum.type, props.position);
            this.recordActionAfterNextUpdate(
              `Change ${datum.type} text ${Object.keys(props).map((key) => `${key} to ${props[key]}`).join(", ")}`
            );
          },
          onChangeFillColor: onChangeColor("fill-color"),
          onChangeHideFillColor: onChangeHideColor("fill-color"),
          onChangeLineColor: onChangeColor("line-color"),
          onChangeHideLineColor: onChangeHideColor("line-color"),
          onChangeLineStyleType: (lineStyleType) => {
            this.setLineStyleTypeAndDefault(datum.type, lineStyleType);
            this.optionsToolbar.updateLineStyleType(
              LINE_STYLE_TYPE_ITEMS.find((item) => item.value === lineStyleType) ?? LINE_STYLE_TYPE_ITEMS[0]
            );
          },
          onChangeLineStyleWidth: (strokeWidth) => {
            this.setLineStyleWidthAndDefault(datum.type, strokeWidth);
            this.optionsToolbar.updateStrokeWidth({
              strokeWidth,
              value: strokeWidth,
              label: String(strokeWidth)
            });
          },
          onChangeTextColor: onChangeColor("text-color"),
          onChangeHideTextColor: onChangeHideColor("text-color"),
          onChangeTextFontSize: (fontSize) => {
            this.setFontSizeAndDefault(datum.type, fontSize);
          }
        };
        this.settingsDialog.show(datum, options);
      }
    });
  }
  setupListeners() {
    const { ctx, optionsToolbar: optionsToolbar2, settingsDialog, toolbar: toolbar2 } = this;
    const { seriesWidget, seriesDragInterpreter, chartWidget } = ctx.widgets;
    if (seriesDragInterpreter) {
      this.cleanup.register(
        // Interactions
        seriesDragInterpreter.events.on("click", this.hoverTouchPreHandler.bind(this)),
        seriesDragInterpreter.events.on("drag-start", this.hoverTouchPreHandler.bind(this)),
        seriesDragInterpreter.events.on("drag-move", this.dragMoveTouchPreHandler.bind(this)),
        seriesDragInterpreter.events.on("mousemove", this.onHover.bind(this)),
        seriesDragInterpreter.events.on("click", this.onClick.bind(this)),
        seriesDragInterpreter.events.on("dblclick", this.onDoubleClick.bind(this)),
        seriesDragInterpreter.events.on("drag-start", this.onDragStart.bind(this)),
        seriesDragInterpreter.events.on("drag-move", this.onDrag.bind(this)),
        seriesDragInterpreter.events.on("drag-end", this.onDragEnd.bind(this))
      );
    }
    this.cleanup.register(
      // Interactions
      seriesWidget.addListener("keydown", this.onKeyDown.bind(this)),
      seriesWidget.addListener("keyup", this.onKeyUp.bind(this)),
      chartWidget.addListener("click", this.onCancel.bind(this)),
      // Services
      ctx.eventsHub.on("annotations:restore", this.onRestoreAnnotations.bind(this)),
      ctx.eventsHub.on("layout:complete", this.onLayoutComplete.bind(this)),
      ctx.updateService.addListener("pre-scene-render", this.onPreRender.bind(this)),
      ctx.eventsHub.on("zoom:change", () => this.onResize()),
      ctx.eventsHub.on("dom:resize", () => this.onResize()),
      // Toolbar
      toolbar2.events.on("cancel-create-annotation", () => {
        this.cancel();
        this.reset();
        this.update();
      }),
      toolbar2.events.on("pressed-create-annotation", ({ annotation }) => {
        this.cancel();
        this.pushAnnotationState(InteractionState22.Annotations);
        this.state.transition(annotation);
        this.update();
      }),
      toolbar2.events.on("pressed-clear", () => {
        this.clear();
        this.recordActionAfterNextUpdate("Clear all");
      }),
      toolbar2.events.on("pressed-show-menu", () => {
        this.cancel();
        this.reset();
      }),
      toolbar2.events.on("pressed-unrelated", () => {
        this.reset();
      }),
      // Annotation Options Toolbar
      optionsToolbar2.events.on("pressed-delete", () => {
        this.cancel();
        this.delete();
        this.reset();
      }),
      optionsToolbar2.events.on("pressed-settings", ({ sourceEvent }) => {
        this.state.transition("toolbarPressSettings", sourceEvent);
      }),
      optionsToolbar2.events.on("pressed-lock", () => {
        this.update();
      }),
      optionsToolbar2.events.on("hid-overlays", () => {
        this.settingsDialog.hide();
      }),
      optionsToolbar2.events.on("saved-color", ({ type, colorPickerType, color: color6 }) => {
        this.recordActionAfterNextUpdate(`Change ${type} ${colorPickerType} to ${color6}`, [
          "annotations",
          "defaults"
        ]);
      }),
      optionsToolbar2.events.on(
        "updated-color",
        ({ type, colorPickerType, colorOpacity, color: color6, opacity, isMultiColor }) => {
          this.setColorAndDefault(type, colorPickerType, colorOpacity, color6, opacity, isMultiColor);
        }
      ),
      optionsToolbar2.events.on("updated-font-size", ({ type, fontSize }) => {
        this.setFontSizeAndDefault(type, fontSize);
      }),
      optionsToolbar2.events.on("updated-line-style", ({ type, lineStyleType }) => {
        this.setLineStyleTypeAndDefault(type, lineStyleType);
      }),
      optionsToolbar2.events.on("updated-line-width", ({ type, strokeWidth }) => {
        this.setLineStyleWidthAndDefault(type, strokeWidth);
      }),
      // Settings Dialog
      settingsDialog.events.on("hidden", () => {
        this.optionsToolbar.clearActiveButton();
      })
    );
  }
  setupDOM() {
    const { ctx, toolbar: toolbar2, optionsToolbar: optionsToolbar2 } = this;
    this.cleanup.register(ctx.annotationManager.attachNode(this.container), () => {
      ctx.domManager.removeStyles(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);
      toolbar2.destroy();
      optionsToolbar2.destroy();
    });
  }
  async processData(dataController) {
    if (!this.enabled || this.data == null || this.xKey == null || this.volumeKey == null)
      return;
    const props = [
      keyProperty2(this.xKey, void 0, { id: "date" }),
      valueProperty2(this.volumeKey, "number", { id: "volume" })
    ];
    const { dataModel, processedData } = await dataController.request("annotations", [...this.data], { props });
    this.dataModel = dataModel;
    this.processedData = processedData;
  }
  /**
   * Create an annotation scene within the `this.annotations` scene selection. This method is automatically called by
   * the selection when a new scene is required.
   */
  createAnnotationScene(datum) {
    if (datum.type in annotationConfigs) {
      return new annotationConfigs[datum.type].scene();
    }
    throw new Error(
      `AG Charts - Cannot create annotation scene of type [${datum.type}], expected one of [${Object.keys(annotationConfigs)}], ignoring.`
    );
  }
  /**
   * Create an annotation datum within the `this.annotationData` properties array. It is created as an instance
   * of `AnnotationProperties` from the given config for its type. This method is only called when annotations
   * are added from the initial state.
   */
  static createAnnotationDatum(params) {
    if (params.type in annotationConfigs) {
      return new annotationConfigs[params.type].datum().set(params);
    }
    throw new Error(
      `AG Charts - Cannot create annotation datum of unknown type [${params.type}], expected one of [${Object.keys(annotationConfigs)}], ignoring.`
    );
  }
  /**
   * Append an annotation datum to `this.annotationData`, applying default styles. This method is called when a user
   * interacts with the chart to draw their own annotations.
   */
  createAnnotation(type, datum, applyDefaults = true) {
    this.annotationData.push(datum);
    if (applyDefaults) {
      const styles = this.ctx.annotationManager.getAnnotationTypeStyles(type);
      if (styles)
        datum.set(styles);
      this.defaults.applyDefaults(datum);
    }
    this.injectDatumDependencies(datum);
    this.update();
  }
  injectDatumDependencies(datum) {
    if ("setLocaleManager" in datum) {
      datum.setLocaleManager(this.ctx.localeManager);
    }
    if ("getVolume" in datum) {
      datum.getVolume = this.getDatumRangeVolume.bind(this);
    }
  }
  getDatumRangeVolume(fromPoint, toPoint) {
    const { dataModel, processedData } = this;
    let from3 = getGroupingValue(fromPoint);
    let to = getGroupingValue(toPoint);
    if (!isValidDate(from3) || !isValidDate(to) || !dataModel || !processedData || this.volumeKey == null)
      return;
    if (from3 > to) {
      [from3, to] = [to, from3];
    }
    const dateValues = dataModel.resolveKeysById({ id: "annotations" }, "date", processedData);
    const volumeValues = dataModel.resolveColumnById({ id: "annotations" }, "volume", processedData);
    let sum2 = 0;
    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {
      const key = dateValues[datumIndex];
      if (isValidDate(key) && key >= from3 && key <= to) {
        sum2 += volumeValues[datumIndex];
      }
    }
    return sum2;
  }
  translateNode(node, datum, translation) {
    const config = this.getAnnotationConfig(datum);
    const context = this.getAnnotationContext();
    if (!context) {
      return;
    }
    config.translate(node, datum, translation, context);
  }
  createAnnotationDatumCopy(node, datum) {
    const config = this.getAnnotationConfig(datum);
    const newDatum = new config.datum();
    newDatum.set(datum.toJson());
    const context = this.getAnnotationContext();
    if (!context) {
      return;
    }
    return config.copy(node, datum, newDatum, context);
  }
  getAnnotationConfig(datum) {
    if (datum.type in annotationConfigs) {
      return annotationConfigs[datum.type];
    }
    throw new Error(
      `AG Charts - Cannot get annotation config of unknown type [${datum.type}], expected one of [${Object.keys(annotationConfigs)}], ignoring.`
    );
  }
  onRestoreAnnotations(event) {
    if (!this.enabled)
      return;
    this.clear();
    this.annotationData.set(event.annotations);
    this.postUpdateFns.push(() => {
      this.ctx.annotationManager.fireChangedEvent();
    });
    this.update();
  }
  onLayoutComplete(event) {
    const seriesRect = event.series.paddedRect;
    this.seriesRect = seriesRect;
    this.container.setClipRect(seriesRect);
    for (const axisLayout of event.axes ?? []) {
      if (axisLayout.direction === module_support_exports.ChartAxisDirection.X) {
        this.xAxis = this.getAxis(axisLayout, seriesRect, this.xAxis?.button);
      } else {
        this.yAxis = this.getAxis(axisLayout, seriesRect, this.yAxis?.button);
      }
    }
    if (this.showAnnotations()) {
      this.animateAnnotations({ from: 0, to: 1, phase: "trailing" });
    } else {
      this.animateAnnotations({ from: 1, to: 0, phase: "remove" });
    }
  }
  showAnnotations() {
    if (!this.yAxis || !this.xAxis) {
      return false;
    }
    const hasData = this.ctx.chartService.series.some((s) => s.hasData);
    const seriesIds = this.yAxis.context.seriesIds();
    const anyBoundSeriesVisible = seriesIds.some((id) => {
      const series = this.ctx.chartService.series.find((s) => s.id === id);
      return series?.visible;
    });
    return hasData && anyBoundSeriesVisible;
  }
  animateAnnotations({ from: from3, to, phase }) {
    const { annotations } = this;
    this.ctx.animationManager?.animate({
      from: from3,
      to,
      id: "chart-annotations",
      phase,
      groupId: "opacity",
      onUpdate(value) {
        annotations.each((node) => {
          node.opacity = value;
          if ("setAxisLabelOpacity" in node) {
            node.setAxisLabelOpacity(value);
          }
        });
      },
      onStop() {
        annotations.each((node) => {
          node.opacity = to;
          if ("setAxisLabelOpacity" in node) {
            node.setAxisLabelOpacity(to);
          }
        });
      }
    });
  }
  onPreRender() {
    this.updateAnnotations();
    this.state.transition("render");
  }
  getAxis(axisLayout, seriesRect, button) {
    const axisCtx = this.ctx.axisManager.getAxisContext(axisLayout.direction)[0];
    const { position: axisPosition = "bottom", direction } = axisCtx;
    const padding2 = axisLayout.gridPadding + axisLayout.seriesAreaPadding;
    const bounds = new BBox3(0, 0, seriesRect.width, seriesRect.height).grow(padding2, axisPosition);
    const lineDirection = axisCtx.direction === ChartAxisDirection9.X ? "vertical" : "horizontal";
    const { axesButtons, snap } = this;
    const buttonEnabled = this.enabled && axesButtons.enabled && (axesButtons.axes === "xy" || axesButtons.axes === direction);
    if (buttonEnabled) {
      button ?? (button = new AxisButton(
        this.ctx,
        { ...axisCtx, snapToGroup: snap },
        (coords) => this.onAxisButtonClick(coords, lineDirection),
        seriesRect
      ));
      const axisLabelPadding = calculateAxisLabelPadding(axisLayout);
      button.update(seriesRect, axisLabelPadding);
    } else {
      button?.destroy();
      button = void 0;
    }
    return { layout: axisLayout, context: axisCtx, bounds, button };
  }
  recordActionAfterNextUpdate(label, types = ["annotations"]) {
    const {
      defaults,
      ctx: { annotationManager, historyManager }
    } = this;
    const originators = types.map((type) => type === "defaults" ? defaults : annotationManager);
    this.postUpdateFns.push(() => {
      historyManager.record(label, ...originators);
      annotationManager.fireChangedEvent();
    });
  }
  setColorAndDefault(datumType, colorPickerType, colorOpacity, color6, opacity, isMultiColor) {
    this.state.transition("color", { colorPickerType, colorOpacity, color: color6, opacity, isMultiColor });
    this.defaults.setDefaultColor(datumType, colorPickerType, colorOpacity, color6, opacity, isMultiColor);
  }
  setFontSizeAndDefault(datumType, fontSize) {
    this.state.transition("fontSize", fontSize);
    this.defaults.setDefaultFontSize(datumType, fontSize);
    this.recordActionAfterNextUpdate(`Change ${datumType} font size to ${fontSize}`, ["annotations", "defaults"]);
  }
  setLineStyleTypeAndDefault(datumType, styleType) {
    this.state.transition("lineStyle", { type: styleType });
    this.defaults.setDefaultLineStyleType(datumType, styleType);
    this.recordActionAfterNextUpdate(`Change ${datumType} line style to ${styleType}`, ["annotations", "defaults"]);
  }
  setLineStyleWidthAndDefault(datumType, strokeWidth) {
    this.state.transition("lineStyle", { strokeWidth });
    this.defaults.setDefaultLineStyleWidth(datumType, strokeWidth);
    this.recordActionAfterNextUpdate(`Change ${datumType} stroke width to ${strokeWidth}`, [
      "annotations",
      "defaults"
    ]);
  }
  updateAnnotations() {
    const {
      annotationData,
      annotations,
      seriesRect,
      ctx: { annotationManager }
    } = this;
    const context = this.getAnnotationContext();
    if (!seriesRect || !context)
      return;
    annotationManager.updateData(annotationData.toJson().filter((datum) => !isEphemeralType(datum)));
    const showAnnotations = this.showAnnotations();
    this.toolbar.refreshButtonsEnabled(showAnnotations);
    this.toolbar.toggleClearButtonEnabled(annotationData.length > 0 && showAnnotations);
    annotations.update(annotationData ?? [], void 0, (datum) => datum.id).each((node, datum) => {
      if (!showAnnotations) {
        node.visible = false;
        if ("setAxisLabelVisible" in node) {
          node.setAxisLabelVisible(false);
        }
        return;
      }
      if ("setAxisLabelVisible" in node) {
        node.setAxisLabelVisible(true);
      }
      this.injectDatumDependencies(datum);
      updateAnnotation(node, datum, context);
    });
    this.postUpdateFns.forEach((fn) => fn());
    this.postUpdateFns = [];
  }
  getAnnotationContext() {
    const { seriesRect, xAxis, yAxis, snap } = this;
    if (!(seriesRect && xAxis && yAxis)) {
      return;
    }
    return {
      seriesRect,
      xAxis: {
        ...xAxis.context,
        bounds: xAxis.bounds,
        labelPadding: calculateAxisLabelPadding(xAxis.layout),
        snapToGroup: snap
      },
      yAxis: {
        ...yAxis.context,
        bounds: yAxis.bounds,
        labelPadding: calculateAxisLabelPadding(xAxis.layout),
        snapToGroup: snap
      }
    };
  }
  onHover(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const shiftKey = event.sourceEvent.shiftKey;
    const offset = Vec219.from(event);
    const point = invertCoords(offset, context);
    state.transition("hover", { offset, point, shiftKey, context });
  }
  onClick(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const shiftKey = event.sourceEvent.shiftKey;
    const point = invertCoords(Vec219.from(event), context);
    const textInputValue = this.textInput.getValue();
    const bbox = this.textInput.getBBox();
    state.transition("click", { point, shiftKey, textInputValue, bbox });
  }
  onDoubleClick(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec219.from(event);
    state.transition("dblclick", { offset });
  }
  onAxisButtonClick(coords, direction) {
    this.cancel();
    this.reset();
    const context = this.getAnnotationContext();
    if (!this.annotationData || !context)
      return;
    const { state } = this;
    this.pushAnnotationState(InteractionState22.Annotations);
    const isHorizontal2 = direction === "horizontal";
    state.transition(
      isHorizontal2 ? "horizontal-line" : "vertical-line"
      /* VerticalLine */
    );
    this.optionsToolbar.hide();
    if (!coords) {
      return;
    }
    const point = invertCoords(coords, context);
    if (!validateDatumPoint(context, point)) {
      return;
    }
    state.transition("click", { point, shiftKey: false });
    this.update();
  }
  onResize() {
    const textInputValue = this.textInput.getValue();
    const bbox = this.textInput.getBBox();
    this.state.transition("resize", { textInputValue, bbox });
  }
  hoverTouchPreHandler(event) {
    if (event.device === "touch") {
      this.onHover(event);
    }
  }
  dragMoveTouchPreHandler(event) {
    if (event.device === "touch" && this.ctx.interactionManager.isState(InteractionState22.AnnotationsSelected)) {
      event.sourceEvent.preventDefault();
    }
  }
  onDragStart(event) {
    if (!this.ctx.interactionManager.isState(InteractionState22.AnnotationsDraggable))
      return;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec219.from(event);
    const point = invertCoords(offset, context);
    const textInputValue = this.textInput.getValue();
    const bbox = this.textInput.getBBox();
    this.state.transition("dragStart", { context, offset, point, textInputValue, bbox });
  }
  onDrag(event) {
    if (!this.ctx.interactionManager.isState(InteractionState22.AnnotationsDraggable))
      return;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const offset = Vec219.from(event);
    const point = invertCoords(offset, context);
    const shiftKey = event.sourceEvent.shiftKey;
    const textInputValue = this.textInput.getValue();
    const bbox = this.textInput.getBBox();
    this.state.transition("drag", { context, offset, point, shiftKey, textInputValue, bbox });
  }
  onDragEnd() {
    this.state.transition("dragEnd");
  }
  onCancel(widgetEvent) {
    const { sourceEvent } = widgetEvent ?? {};
    if (sourceEvent?.currentTarget !== sourceEvent?.target)
      return;
    this.cancel();
    this.reset();
  }
  onDelete() {
    if (this.textInput.isVisible())
      return;
    this.cancel();
    this.delete();
    this.reset();
    this.update();
  }
  onTextInput(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context)
      return;
    const { key, shiftKey } = event;
    const textInputValue = this.textInput.getValue();
    const bbox = this.textInput.getBBox();
    state.transition("textInput", { key, shiftKey, textInputValue, bbox, context });
  }
  onKeyDown(event) {
    const { state } = this;
    const context = this.getAnnotationContext();
    if (!context) {
      return;
    }
    const { sourceEvent } = event;
    const { shiftKey, ctrlKey, metaKey } = sourceEvent;
    const ctrlMeta = ctrlKey || metaKey;
    const ctrlShift = ctrlKey || shiftKey;
    state.transition("keyDown", { shiftKey, context });
    const translation = { x: 0, y: 0 };
    const xStep = Math.max(context?.xAxis.scale.bandwidth ?? 0, ctrlShift ? 10 : 1);
    const yStep = Math.max(context?.yAxis.scale.bandwidth ?? 0, ctrlShift ? 10 : 1);
    switch (sourceEvent.key) {
      case "ArrowDown":
        translation.y = yStep;
        break;
      case "ArrowUp":
        translation.y = -yStep;
        break;
      case "ArrowLeft":
        translation.x = -xStep;
        break;
      case "ArrowRight":
        translation.x = xStep;
        break;
      case "Escape":
        this.onCancel();
        return;
      case "Backspace":
      case "Delete":
        this.onDelete();
        return;
    }
    if (translation.x || translation.y) {
      state.transition("translate", { translation });
      sourceEvent.stopPropagation();
      sourceEvent.preventDefault();
    }
    if (!ctrlMeta) {
      return;
    }
    switch (sourceEvent.key) {
      case "c":
        state.transition("copy");
        return;
      case "x":
        state.transition("cut");
        this.recordActionAfterNextUpdate("Cut annotation");
        return;
      case "v":
        state.transition("paste");
        this.recordActionAfterNextUpdate("Paste annotation");
        return;
    }
  }
  onKeyUp(event) {
    const { shiftKey } = event.sourceEvent;
    const context = this.getAnnotationContext();
    if (!context) {
      return;
    }
    this.state.transition("keyUp", { shiftKey, context });
    this.state.transition("translateEnd");
  }
  clear() {
    this.cancel();
    this.deleteAll();
    this.reset();
  }
  reset() {
    this.state.transition("reset");
  }
  cancel() {
    this.state.transition("cancel");
  }
  delete() {
    this.state.transition("delete");
  }
  deleteAll() {
    this.state.transition("deleteAll");
  }
  deleteEphemeralAnnotations() {
    for (const [index, datum] of this.annotationData.entries()) {
      if (isEphemeralType(datum)) {
        this.annotationData.splice(index, 1);
      }
    }
  }
  hideOverlays() {
    this.settingsDialog.hide();
    this.toolbar.hideOverlays();
    this.optionsToolbar.hideOverlays();
  }
  pushAnnotationState(state) {
    this.ctx.interactionManager.pushState(state);
    this.ctx.tooltipManager.suppressTooltip("annotations");
  }
  popAnnotationState(state) {
    this.ctx.interactionManager.popState(state);
    this.ctx.tooltipManager.unsuppressTooltip("annotations");
  }
  isAnnotationState() {
    return this.ctx.interactionManager.isState(InteractionState22.Annotations) || this.ctx.interactionManager.isState(InteractionState22.AnnotationsSelected);
  }
  update(status = ChartUpdateType2.PRE_SCENE_RENDER) {
    this.ctx.updateService.update(status);
  }
};
__decorateClass2([
  Property33
], _Annotations.prototype, "enabled", 2);
__decorateClass2([
  Property33
], _Annotations.prototype, "toolbar", 2);
__decorateClass2([
  Property33
], _Annotations.prototype, "optionsToolbar", 2);
__decorateClass2([
  Property33
], _Annotations.prototype, "axesButtons", 2);
__decorateClass2([
  Property33
], _Annotations.prototype, "snap", 2);
var Annotations = _Annotations;
var { FONT_SIZE_RATIO: FONT_SIZE_RATIO2, ThemeSymbols } = module_support_exports;
var stroke2 = {
  stroke: { $ref: "foregroundColor" },
  strokeOpacity: 1,
  strokeWidth: 2
};
var handle2 = {
  fill: ThemeSymbols.DEFAULT_ANNOTATION_HANDLE_FILL,
  strokeOpacity: 1,
  strokeWidth: 2
};
var font2 = {
  color: { $ref: "chartBackgroundColor" },
  fontSize: { $rem: FONT_SIZE_RATIO2.LARGE },
  fontFamily: { $ref: "fontFamily" }
};
var axisLabel2 = {
  ...font2,
  enabled: true,
  fill: { $ref: "foregroundColor" },
  fontSize: { $ref: "fontSize" }
};
var text = {
  ...font2,
  textAlign: "left"
};
var lineText2 = {
  ...font2,
  position: "top",
  alignment: "center",
  color: { $ref: "textColor" }
};
var channelText = {
  ...font2,
  position: "top",
  alignment: "center",
  color: { $ref: "textColor" }
};
var measurerStatistics2 = {
  ...font2,
  fontSize: { $ref: "fontSize" },
  color: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_COLOR,
  fill: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_FILL,
  stroke: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_STROKE,
  strokeWidth: 1,
  divider: {
    stroke: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
    strokeWidth: 1,
    strokeOpacity: 0.5
  }
};
var measurer2 = {
  ...stroke2,
  background: {
    fill: { $ref: "foregroundColor" },
    fillOpacity: 0.075
  },
  handle: { ...handle2 },
  text: { ...lineText2 },
  statistics: { ...measurerStatistics2 }
};
var toolbar = {
  buttons: [
    {
      icon: "text-annotation",
      tooltip: "toolbarAnnotationsTextAnnotations",
      value: "text-menu"
    },
    {
      icon: "trend-line-drawing",
      tooltip: "toolbarAnnotationsLineAnnotations",
      value: "line-menu"
    },
    {
      icon: "arrow-drawing",
      tooltip: "toolbarAnnotationsShapeAnnotations",
      value: "shape-menu"
    },
    {
      icon: "delete",
      tooltip: "toolbarAnnotationsClearAll",
      value: "clear"
    }
  ],
  // @ts-expect-error undocumented option
  padding: { $ref: "chartPadding" }
};
var optionsToolbar = {
  buttons: [
    {
      icon: "text-annotation",
      tooltip: "toolbarAnnotationsTextColor",
      value: "text-color"
    },
    {
      icon: "line-color",
      tooltip: "toolbarAnnotationsLineColor",
      value: "line-color"
    },
    {
      icon: "fill-color",
      tooltip: "toolbarAnnotationsFillColor",
      value: "fill-color"
    },
    {
      tooltip: "toolbarAnnotationsTextSize",
      value: "text-size"
    },
    {
      tooltip: "toolbarAnnotationsLineStrokeWidth",
      value: "line-stroke-width"
    },
    {
      icon: "line-style-solid",
      tooltip: "toolbarAnnotationsLineStyle",
      value: "line-style-type"
    },
    {
      icon: "settings",
      tooltip: "toolbarAnnotationsSettings",
      value: "settings"
    },
    {
      icon: "unlocked",
      tooltip: "toolbarAnnotationsLock",
      ariaLabel: "toolbarAnnotationsLock",
      checkedOverrides: {
        icon: "locked",
        tooltip: "toolbarAnnotationsUnlock"
      },
      value: "lock"
    },
    {
      icon: "delete",
      tooltip: "toolbarAnnotationsDelete",
      value: "delete"
    }
  ]
};
var annotationsTheme2 = {
  enabled: false,
  // Lines
  line: {
    ...stroke2,
    handle: { ...handle2 },
    text: { ...lineText2 }
  },
  "horizontal-line": {
    ...stroke2,
    handle: { ...handle2 },
    axisLabel: { ...axisLabel2 },
    text: { ...lineText2 }
  },
  "vertical-line": {
    ...stroke2,
    handle: { ...handle2 },
    axisLabel: { ...axisLabel2 },
    text: { ...lineText2 }
  },
  // Channels
  "disjoint-channel": {
    ...stroke2,
    background: {
      fill: { $ref: "foregroundColor" },
      fillOpacity: 0.075
    },
    handle: { ...handle2 },
    text: { ...channelText }
  },
  "parallel-channel": {
    ...stroke2,
    middle: {
      lineDash: [6, 5],
      strokeWidth: 1
    },
    background: {
      fill: { $ref: "foregroundColor" },
      fillOpacity: 0.075
    },
    handle: { ...handle2 },
    text: { ...channelText }
  },
  // Fibonnaccis
  "fibonacci-retracement": {
    ...stroke2,
    strokes: ThemeSymbols.DEFAULT_FIBONACCI_STROKES,
    rangeStroke: { $ref: "foregroundColor" },
    handle: { ...handle2 },
    text: { ...lineText2, position: "center" },
    label: {
      ...font2,
      color: void 0,
      fontSize: { $rem: FONT_SIZE_RATIO2.SMALLER }
    }
  },
  "fibonacci-retracement-trend-based": {
    ...stroke2,
    strokes: ThemeSymbols.DEFAULT_FIBONACCI_STROKES,
    rangeStroke: { $ref: "foregroundColor" },
    handle: { ...handle2 },
    text: { ...lineText2, position: "center" },
    label: {
      ...font2,
      color: void 0,
      fontSize: { $rem: FONT_SIZE_RATIO2.SMALLER }
    }
  },
  // Texts
  callout: {
    ...stroke2,
    ...text,
    color: { $ref: "textColor" },
    handle: { ...handle2 },
    fill: { $ref: "foregroundColor" },
    fillOpacity: 0.075
  },
  comment: {
    ...text,
    fontWeight: 700,
    handle: { ...handle2 },
    fill: { $ref: "foregroundColor" }
  },
  note: {
    ...text,
    color: ThemeSymbols.DEFAULT_TEXTBOX_COLOR,
    fill: ThemeSymbols.DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    stroke: { $ref: "chartBackgroundColor" },
    strokeWidth: 1,
    strokeOpacity: 1,
    handle: { ...handle2 },
    background: {
      fill: ThemeSymbols.DEFAULT_TEXTBOX_FILL,
      stroke: ThemeSymbols.DEFAULT_TEXTBOX_STROKE,
      strokeWidth: 1
    }
  },
  text: {
    ...text,
    color: { $ref: "textColor" },
    handle: { ...handle2 }
  },
  // Shapes
  arrow: {
    ...stroke2,
    handle: { ...handle2 },
    text: { ...lineText2 }
  },
  "arrow-up": {
    fill: { $palette: "up.fill" },
    handle: { ...handle2, stroke: { $ref: "foregroundColor" } }
  },
  "arrow-down": {
    fill: { $palette: "down.fill" },
    handle: { ...handle2, stroke: { $ref: "foregroundColor" } }
  },
  // Measurers
  "date-range": {
    ...measurer2
  },
  "price-range": {
    ...measurer2
  },
  "date-price-range": {
    ...measurer2
  },
  "quick-date-price-range": {
    up: {
      ...stroke2,
      fill: ThemeSymbols.DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2,
      handle: { ...handle2 },
      statistics: {
        ...measurerStatistics2,
        color: "#fff",
        fill: ThemeSymbols.DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    },
    down: {
      ...stroke2,
      stroke: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
      fill: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
      fillOpacity: 0.2,
      handle: {
        ...handle2,
        stroke: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE
      },
      statistics: {
        ...measurerStatistics2,
        color: "#fff",
        fill: ThemeSymbols.DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    }
  },
  axesButtons: {},
  // Toolbars
  toolbar,
  optionsToolbar
};
var AnnotationsModule = {
  type: "root",
  optionsKey: "annotations",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new Annotations(ctx),
  themeTemplate: {
    annotations: annotationsTheme2
  }
};
var { BaseProperties: BaseProperties12, ObserveChanges: ObserveChanges22, ProxyProperty: ProxyProperty2, Property: Property34, calculatePlacement: calculatePlacement2 } = module_support_exports;
var Image4 = class extends BaseProperties12 {
  constructor() {
    super();
    this.opacity = 1;
    this.loadedSynchronously = true;
    this.containerWidth = 0;
    this.containerHeight = 0;
    this.onLoad = void 0;
    this.onImageLoad = () => {
      if (this.loadedSynchronously) {
        return;
      }
      this.node.visible = false;
      this.performLayout(this.containerWidth, this.containerHeight);
      this.onLoad?.();
    };
    this.imageElement = createElement("img");
    this.imageElement.onload = this.onImageLoad;
    this.node = new module_support_exports.Image(this.imageElement);
  }
  get complete() {
    return this.imageElement.width > 0 && this.imageElement.height > 0;
  }
  performLayout(containerWidth, containerHeight) {
    this.containerWidth = containerWidth;
    this.containerHeight = containerHeight;
    const container = { width: containerWidth, height: containerHeight };
    const placement = calculatePlacement2(this.imageElement.width, this.imageElement.height, container, this);
    this.node.setProperties(
      this.complete ? {
        visible: true,
        opacity: this.opacity,
        ...placement
      } : { visible: false }
    );
    return placement;
  }
};
__decorateClass2([
  Property34
], Image4.prototype, "top", 2);
__decorateClass2([
  Property34
], Image4.prototype, "right", 2);
__decorateClass2([
  Property34
], Image4.prototype, "bottom", 2);
__decorateClass2([
  Property34
], Image4.prototype, "left", 2);
__decorateClass2([
  Property34
], Image4.prototype, "width", 2);
__decorateClass2([
  Property34
], Image4.prototype, "height", 2);
__decorateClass2([
  Property34
], Image4.prototype, "opacity", 2);
__decorateClass2([
  ProxyProperty2("imageElement.src"),
  ObserveChanges22((target) => target.loadedSynchronously = target.complete)
], Image4.prototype, "url", 2);
var { ActionOnSet: ActionOnSet3, Property: Property35 } = module_support_exports;
var Background22 = class extends module_support_exports.Background {
  constructor() {
    super(...arguments);
    this.image = new Image4();
  }
  onLayoutComplete(event) {
    super.onLayoutComplete(event);
    if (this.image) {
      const { width: width2, height: height2 } = event.chart;
      this.image.performLayout(width2, height2);
    }
  }
  onImageLoad() {
    this.ctx.updateService.update(module_support_exports.ChartUpdateType.SCENE_RENDER);
  }
};
__decorateClass2([
  Property35,
  ActionOnSet3({
    newValue(image) {
      this.node.appendChild(image.node);
      image.onLoad = () => this.onImageLoad();
    },
    oldValue(image) {
      this.node.removeChild(image.node);
      image.onLoad = void 0;
    }
  })
], Background22.prototype, "image", 2);
var BackgroundModule2 = {
  type: "root",
  optionsKey: "background",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new Background22(ctx)
};
var {
  Range: Range2,
  TranslatableGroup: TranslatableGroup2,
  BBox: BBox4,
  Property: Property36,
  ZIndexMap: ZIndexMap4,
  ChartAxisDirection: ChartAxisDirection10,
  FillGradientDefaults: FillGradientDefaults2,
  FillImageDefaults: FillImageDefaults2,
  FillPatternDefaults: FillPatternDefaults2,
  getShapeFill: getShapeFill2,
  InteractionState: InteractionState3
} = module_support_exports;
var BandHighlight = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId(this);
    this.enabled = false;
    this.stroke = "rgb(195, 195, 195)";
    this.lineDash = [6, 3];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.fillGradientDefaults = new FillGradientDefaults2();
    this.fillPatternDefaults = new FillPatternDefaults2();
    this.fillImageDefaults = new FillImageDefaults2();
    this.bounds = new BBox4(0, 0, 0, 0);
    this.bandHighlightGroup = new TranslatableGroup2({
      name: "bandHighlight",
      zIndex: ZIndexMap4.AXIS_BAND_HIGHLIGHT
    });
    this.rangeNode = this.bandHighlightGroup.appendChild(new Range2());
    this.activeAxisHighlight = void 0;
    this.axisCtx = ctx.parent;
    this.hideBand();
    ctx.domManager.addEventListener("focusin", ({ target }) => {
      const isSeriesAreaChild = target instanceof HTMLElement && ctx.domManager.contains(target, "series-area");
      if (this.bandHighlightGroup.visible && !isSeriesAreaChild) {
        this.hideBand();
        this.ctx.updateService.update(module_support_exports.ChartUpdateType.PERFORM_LAYOUT);
      }
    });
    const {
      widgets: { seriesWidget, seriesDragInterpreter },
      animationManager,
      eventsHub
    } = ctx;
    this.cleanup.register(
      ctx.scene.attachNode(this.bandHighlightGroup),
      seriesWidget.addListener("mousemove", (event) => this.onHoverLikeEvent(event)),
      seriesWidget.addListener("mouseleave", () => this.clearAllHighlight()),
      animationManager.addListener("animation-start", () => this.clearAllHighlight()),
      eventsHub.on("layout:complete", (event) => this.layout(event)),
      eventsHub.on("series:focus-change", () => this.onKeyPress()),
      eventsHub.on("zoom:pan-start", () => this.clearAllHighlight()),
      eventsHub.on("zoom:change", () => this.clearAllHighlight()),
      eventsHub.on("dom:resize", () => this.clearAllHighlight()),
      eventsHub.on("axis:change", () => this.axisChange())
    );
    if (seriesDragInterpreter) {
      this.cleanup.register(
        seriesDragInterpreter.events.on("drag-move", (event) => this.onHoverLikeEvent(event)),
        seriesDragInterpreter.events.on("click", (event) => this.onClick(event))
      );
    }
  }
  axisChange() {
    this.onHighlightChange();
  }
  isHover(event) {
    return event.type === "mousemove" || event.type === "click" || event.device === "touch" && this.ctx.chartService.touch.dragAction === "hover";
  }
  onClick(event) {
    if (event.device === "touch") {
      this.onHoverLikeEvent(event);
    }
  }
  clearAllHighlight() {
    if (!this.ctx.interactionManager.isState(InteractionState3.Clickable))
      return;
    this.onHighlightChange();
  }
  onKeyPress() {
    if (this.ctx.interactionManager.isState(InteractionState3.Default)) {
      this.onHighlightChange();
    }
  }
  onHoverLikeEvent(event) {
    const requiredState = this.isHover(event) ? InteractionState3.Clickable : InteractionState3.AnnotationsMoveable;
    if (!this.ctx.interactionManager.isState(requiredState))
      return;
    this.handleHoverHighlight(event);
  }
  handleHoverHighlight(event) {
    if (!event)
      return;
    const { currentX: x, currentY: y } = event;
    this.onHighlightChange(this.axisCtx.pickBand({ x, y }));
  }
  layout({ series: { rect, visible }, axes }) {
    if (!visible || !axes || !this.enabled)
      return;
    const { position: axisPosition = "left", axisId } = this.axisCtx;
    const axisLayout = axes.find((a) => a.id === axisId);
    if (!axisLayout)
      return;
    this.axisLayout = axisLayout;
    this.bounds = rect.clone().grow(axisLayout.gridPadding, axisPosition);
    const { bandHighlightGroup, bounds } = this;
    bandHighlightGroup.translationX = Math.round(bounds.x);
    bandHighlightGroup.translationY = Math.round(bounds.y);
    this.updateBand();
  }
  updateBand() {
    const {
      rangeNode: node,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      fill,
      fillOpacity,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5,
      lineDashOffset,
      axisLayout
    } = this;
    if (!axisLayout)
      return;
    node.stroke = stroke22;
    node.strokeWidth = strokeWidth;
    node.strokeOpacity = strokeOpacity;
    node.lineDash = lineDash;
    node.lineDashOffset = lineDashOffset;
    node.fill = getShapeFill2(fill, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    node.fillOpacity = fillOpacity;
    node.startLine = true;
    node.endLine = true;
  }
  isVertical() {
    return this.axisCtx.direction === ChartAxisDirection10.X;
  }
  onHighlightChange(axisBandDatum) {
    if (!this.enabled)
      return;
    this.activeAxisHighlight = axisBandDatum;
    if (!this.activeAxisHighlight) {
      this.hideBand();
    } else {
      this.showBand();
    }
    this.ctx.updateService.update(module_support_exports.ChartUpdateType.SCENE_RENDER);
  }
  updateBandPosition() {
    const { rangeNode, bounds } = this;
    const { band } = this.activeAxisHighlight ?? {};
    if (band == void 0) {
      this.hideBand();
      return;
    }
    let r0 = Math.min(...band);
    let r1 = Math.max(...band);
    if (r1 - r0 < 1) {
      const mid = (r0 + r1) / 2;
      r0 = mid - 0.5;
      r1 = mid + 0.5;
    }
    if (this.isVertical()) {
      rangeNode.y1 = 0;
      rangeNode.y2 = bounds.height;
      rangeNode.x1 = r0;
      rangeNode.x2 = r1;
      rangeNode.horizontal = true;
    } else {
      rangeNode.y1 = r0;
      rangeNode.y2 = r1;
      rangeNode.x1 = 0;
      rangeNode.x2 = bounds.width;
      rangeNode.horizontal = false;
    }
  }
  showBand() {
    this.updateBandPosition();
    this.bandHighlightGroup.visible = true;
  }
  hideBand() {
    this.bandHighlightGroup.visible = false;
  }
};
__decorateClass2([
  Property36
], BandHighlight.prototype, "enabled", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "stroke", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "lineDash", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "strokeWidth", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "fill", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "fillOpacity", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property36
], BandHighlight.prototype, "fillImageDefaults", 2);
var BandHighlightModule = {
  type: "axis-option",
  optionsKey: "bandHighlight",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  axisTypes: ["category", "ordinal-time", "unit-time", "grouped-category"],
  moduleFactory: (ctx) => new BandHighlight(ctx),
  themeTemplate: {
    bandHighlight: {
      enabled: false,
      strokeWidth: 0,
      lineDash: [],
      fill: { $foregroundBackgroundMix: 0.05 }
    }
  }
};
var { ActionOnSet: ActionOnSet4, LayoutElement: LayoutElement22, Menu: Menu3, Property: Property37 } = module_support_exports;
var menuItems = [
  { label: "toolbarSeriesTypeOHLC", icon: "ohlc-series", value: "ohlc" },
  { label: "toolbarSeriesTypeCandles", icon: "candlestick-series", value: "candlestick" },
  { label: "toolbarSeriesTypeHollowCandles", icon: "hollow-candlestick-series", value: "hollow-candlestick" },
  { label: "toolbarSeriesTypeLine", icon: "line-series", value: "line" },
  { label: "toolbarSeriesTypeStepLine", icon: "step-line-series", value: "step-line" },
  { label: "toolbarSeriesTypeHLC", icon: "hlc-series", value: "hlc" },
  { label: "toolbarSeriesTypeHighLow", icon: "high-low-series", value: "high-low" }
];
var ChartToolbar = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.menu = new Menu3(this.ctx, "chart-toolbar");
    this.toolbar = ctx.sharedToolbar.getSharedToolbar("chartToolbar");
    this.cleanup.register(
      this.toolbar.addToolbarListener("button-pressed", this.onButtonPressed.bind(this)),
      ctx.layoutManager.registerElement(LayoutElement22.ToolbarLeft, this.onLayoutStart.bind(this)),
      () => this.toolbar.destroy()
    );
  }
  onLayoutStart(event) {
    if (!this.enabled)
      return;
    this.updateButton();
    this.toolbar.layout(event.layoutBox);
  }
  onButtonPressed({ event, buttonBounds }) {
    this.menu.setAnchor({ x: buttonBounds.x + buttonBounds.width + 6, y: buttonBounds.y });
    this.menu.show({
      items: menuItems,
      menuItemRole: "menuitemradio",
      ariaLabel: this.ctx.localeManager.t("toolbarSeriesTypeDropdown"),
      class: "ag-charts-chart-toolbar__menu",
      value: this.getChartType(),
      sourceEvent: event.sourceEvent,
      onPress: (item) => {
        this.setChartType(item.value);
        this.hidePopover();
      },
      onHide: () => {
        this.toolbar.clearActiveButton();
      }
    });
    this.toolbar.toggleActiveButtonByIndex(0);
  }
  updateButton() {
    const chartType = this.getChartType();
    const icon = menuItems.find((item) => item.value === chartType)?.icon;
    if (icon != null) {
      this.toolbar.updateButtons([{ icon, tooltip: "toolbarSeriesTypeDropdown" }]);
    }
  }
  hidePopover() {
    this.toolbar.clearActiveButton();
    this.menu.hide();
  }
  setChartType(chartType) {
    const options = { chartType };
    this.ctx.chartService.publicApi?.updateDelta(options).catch((e) => logger_exports.error(e));
  }
  getChartType() {
    const chartType = this.ctx.chartService.publicApi?.getOptions()?.chartType;
    if (chartType == null || !menuItems.some((item) => item.value === chartType)) {
      return "candlestick";
    }
    return chartType;
  }
};
__decorateClass2([
  Property37,
  ActionOnSet4({
    changeValue(enabled) {
      this.toolbar?.setHidden(!enabled);
    }
  })
], ChartToolbar.prototype, "enabled", 2);
var ChartToolbarModule = {
  type: "root",
  optionsKey: "chartToolbar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new ChartToolbar(ctx)
};
function showsFor(showOn, showing) {
  if (showOn === "always")
    return true;
  if (showOn === "series-area")
    return showing === "series-area" || showing === "series-node";
  return showOn === showing;
}
function appendItem(showing, item, result) {
  let mustShow = true;
  if (item.type === "separator") {
    const last = result.at(result.length - 1);
    mustShow = last !== void 0 && last.type !== "separator";
  }
  mustShow && (mustShow = showsFor(item.showOn ?? "always", showing));
  if (mustShow) {
    const menuItem = new ContextMenuItem(item);
    result.push(menuItem);
    return menuItem;
  }
}
function appendBuiltinItem(showing, registry, keyword, result) {
  if (registry.isVisible(keyword)) {
    appendItem(showing, registry.builtins.items[keyword], result);
  }
}
function expandBuiltin(showing, registry, keyword, result) {
  const { builtins } = registry;
  if (isKeyOf(keyword, builtins.lists)) {
    for (const childKeyword of builtins.lists[keyword]) {
      appendBuiltinItem(showing, registry, childKeyword, result);
    }
  } else {
    appendBuiltinItem(showing, registry, keyword, result);
  }
}
function expandItems(showing, registry, items, result) {
  for (const item of items) {
    if (typeof item === "string") {
      expandBuiltin(showing, registry, item, result);
    } else {
      const menuItem = appendItem(showing, item, result);
      if (item.items && menuItem && item.items.length > 0) {
        expandItems(showing, registry, item.items, menuItem.items);
      }
    }
  }
  if (result[result.length - 1]?.type === "separator") {
    result.pop();
  }
}
var ContextMenuItem = class {
  constructor(options) {
    this.type = "action";
    this.showOn = "always";
    this.label = "";
    this.iconUrl = void 0;
    this.enabled = true;
    this.items = [];
    this.action = void 0;
    if (options)
      this.setOptions(options);
    this.items = [];
  }
  setField(key, that, value) {
    that[key] = value;
  }
  setOptions(options) {
    let key;
    for (key in options) {
      if (options[key] !== void 0) {
        this.setField(key, this, options[key]);
      }
    }
  }
};
var DEFAULT_CONTEXT_MENU_CLASS = "ag-charts-context-menu";
var { Property: Property38, ContextMenuRegistry: ContextMenuRegistry2, callWithContext: callWithContext2, getIconClassNames: getIconClassNames3 } = module_support_exports;
var moduleId2 = "context-menu";
var ContextMenu = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.darkTheme = false;
    this.items = ["defaults"];
    this.pickedNode = void 0;
    this.showEvent = void 0;
    this.x = 0;
    this.y = 0;
    this.closingSubMenus = 0;
    this.menuWidget = new exports_exports.MenuWidget();
    this.interactionManager = ctx.interactionManager;
    this.element = ctx.domManager.addChild("canvas-overlay", moduleId2);
    this.element.classList.add(DEFAULT_CONTEXT_MENU_CLASS);
    this.element.style.display = "none";
    this.element.addEventListener("contextmenu", (event) => event.preventDefault());
    this.element.addEventListener("focusout", ({ relatedTarget }) => {
      if (this.closingSubMenus > 0)
        return;
      if (relatedTarget == null || relatedTarget instanceof Node && !this.element.contains(relatedTarget)) {
        this.hide();
      }
    });
    this.cleanup.register(
      () => this.element.parentNode?.removeChild(this.element),
      () => this.menuWidget.destroy(),
      ctx.eventsHub.on("dom:hidden", () => this.hide()),
      this.menuWidget.addListener("close-widget", () => this.onClose())
    );
    this.menuWidget.addClass(`${DEFAULT_CONTEXT_MENU_CLASS}__menu`);
    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(() => {
        if (this.element.contains(this.menuWidget.getElement())) {
          this.reposition();
        }
      });
      observer.observe(this.element, { childList: true });
      this.mutationObserver = observer;
      this.cleanup.register(() => observer.disconnect());
    }
    this.ctx.contextMenuRegistry.builtins.items["download"].action = () => {
      const title = ctx.chartService.title;
      let fileName = "image";
      if (title?.enabled) {
        fileName = title.node.getPlainText().replace(/\.+/, "");
      }
      this.ctx.chartService.publicApi?.download({ fileName }).catch((e) => {
        logger_exports.error("Unable to download chart", e);
      });
    };
    this.cleanup.register(this.ctx.eventsHub.on("context-menu:complete", (e) => this.onContext(e)));
  }
  expandItemsOptions(showing) {
    const result = [];
    expandItems(showing, this.ctx.contextMenuRegistry, this.items, result);
    return result;
  }
  onContext(event) {
    if (!this.enabled)
      return;
    event.widgetEvent.sourceEvent.preventDefault();
    this.showEvent = event.widgetEvent.sourceEvent;
    this.x = event.x;
    this.y = event.y;
    this.pickedNode = void 0;
    this.pickedLegendItem = void 0;
    if (ContextMenuRegistry2.check("series-node", event)) {
      this.pickedNode = event.context.pickedNode;
    } else if (ContextMenuRegistry2.check("legend-item", event)) {
      this.pickedLegendItem = event.context.legendItem;
    }
    const expandedItems = this.expandItemsOptions(event.showOn);
    if (expandedItems.length === 0)
      return;
    this.show(event.widgetEvent, expandedItems);
  }
  show(widgetEvent, expandedItems) {
    this.interactionManager.pushState(module_support_exports.InteractionState.ContextMenu);
    this.element.style.display = "block";
    const overrideFocusVisible = widgetEvent.sourceEvent.pointerType === "touch" ? false : void 0;
    if (overrideFocusVisible !== void 0) {
      this.ctx.chartService.overrideFocusVisible(overrideFocusVisible);
    }
    this.createMenu(expandedItems);
    this.element.appendChild(this.menuWidget.getElement());
    this.menuWidget.open(widgetEvent, { overrideFocusVisible });
  }
  hide() {
    this.menuWidget.close();
  }
  onClose() {
    this.interactionManager.popState(module_support_exports.InteractionState.ContextMenu);
    this.element.removeChild(this.menuWidget.getElement());
    this.element.style.display = "none";
  }
  onSubMenuOpen(button, menu) {
    const bounds = button.getBounds();
    button.setFocusOverride(true);
    button.getElement().insertAdjacentElement("afterend", menu.getElement());
    menu.getElement().style.position = "absolute";
    const canvasRect = this.ctx.domManager.getBoundingClientRect();
    const buttonClientRect = button.getBoundingClientRect();
    const remainingSpaceOnRight = canvasRect.right - buttonClientRect.right;
    const remainingSpaceOnLeft = buttonClientRect.left - canvasRect.left;
    const { offsetWidth: menuOffsetWidth, offsetHeight: menuOffsetHeight } = menu.getElement();
    let y = bounds.y;
    if (canvasRect.height > menuOffsetHeight) {
      const remainingSpaceOnBottom = canvasRect.bottom - buttonClientRect.top;
      if (remainingSpaceOnBottom < menuOffsetHeight) {
        y -= menuOffsetHeight - remainingSpaceOnBottom;
      }
    }
    if (remainingSpaceOnRight >= menuOffsetWidth) {
      menu.setBounds({ x: bounds.x + bounds.width, y });
    } else {
      const x = bounds.x - menuOffsetWidth;
      const leftDelta = remainingSpaceOnLeft + x;
      if (leftDelta >= 0) {
        menu.setBounds({ x, y });
      } else {
        menu.setBounds({ x: x - leftDelta, y });
      }
    }
  }
  onSubMenuClose(button, menu) {
    button.setFocusOverride(void 0);
    this.closingSubMenus++;
    menu.remove();
    this.closingSubMenus--;
  }
  createMenu(expandedItems) {
    const { menuWidget } = this;
    menuWidget.clear();
    menuWidget.setTabIndex(-1);
    this.createMenuItems(menuWidget, expandedItems);
  }
  createMenuItems(menuWidget, expandedItems) {
    for (const item of expandedItems) {
      switch (item.type) {
        case "separator": {
          const sep = menuWidget.addSeparator();
          sep.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__divider`);
          break;
        }
        case "action": {
          if (item.items.length === 0) {
            const btn = new exports_exports.MenuItemWidget();
            this.initButtonElement(btn, item);
            menuWidget.addChild(btn);
          } else {
            const { subMenuButton, subMenu } = menuWidget.addSubMenu();
            subMenu.addClass(`${DEFAULT_CONTEXT_MENU_CLASS}__menu`);
            subMenu.addListener("open-widget", () => this.onSubMenuOpen(subMenuButton, subMenu));
            subMenu.addListener("close-widget", () => this.onSubMenuClose(subMenuButton, subMenu));
            this.initButtonElement(subMenuButton, item);
            this.createMenuItems(subMenu, item.items);
          }
          break;
        }
        default:
          throw new Error("unhandled case");
      }
    }
  }
  createButtonOnClick(showOn, callback2) {
    if (ContextMenuRegistry2.checkCallback("legend-item", showOn, callback2)) {
      return (widgetEvent) => {
        const event = widgetEvent.sourceEvent;
        if (this.pickedLegendItem) {
          const { seriesId, itemId, label } = this.pickedLegendItem;
          const { chartService: chart } = this.ctx;
          const series = chart.series.find((s) => s.id === seriesId);
          const callers = [series?.properties, chart];
          const apiEvent = { type: "contextmenu", seriesId, itemId, text: label.text, event };
          callWithContext2(callers, callback2, apiEvent);
          this.hide();
        } else {
          logger_exports.error("legend item not found");
        }
      };
    } else if (ContextMenuRegistry2.checkCallback("series-area", showOn, callback2)) {
      return () => {
        const caller = this.ctx.chartService;
        const apiEvent = { type: "seriesContextMenuAction", event: this.showEvent };
        callWithContext2(caller, callback2, apiEvent);
        this.hide();
      };
    } else if (ContextMenuRegistry2.checkCallback("series-node", showOn, callback2)) {
      return () => {
        const { showEvent } = this;
        const { chartService: chart } = this.ctx;
        const pickedNode = this.pickedNode;
        const callers = [pickedNode?.series.properties, chart];
        const apiEvent = pickedNode?.series.createNodeContextMenuActionEvent(showEvent, pickedNode);
        if (apiEvent) {
          callWithContext2(callers, callback2, apiEvent);
        } else {
          logger_exports.error("series node not found");
        }
        this.hide();
      };
    }
    return () => {
      const caller = this.ctx.chartService;
      const apiEvent = { type: "contextMenuEvent", event: this.showEvent };
      callWithContext2(caller, callback2, apiEvent);
      this.hide();
    };
  }
  initTableCells(elem) {
    const cellIcon = createElement("div");
    const cellLabel = createElement("div");
    const cellArrow = createElement("div");
    cellIcon.classList.toggle(`${DEFAULT_CONTEXT_MENU_CLASS}__icon`, true);
    cellLabel.classList.toggle(`${DEFAULT_CONTEXT_MENU_CLASS}__cell`, true);
    cellArrow.classList.toggle(`${DEFAULT_CONTEXT_MENU_CLASS}__cell`, true);
    cellIcon.ariaHidden = "true";
    cellLabel.role = "presentation";
    cellArrow.ariaHidden = "true";
    elem.append(cellIcon, cellLabel, cellArrow);
    return { cellIcon, cellLabel, cellArrow };
  }
  initButtonElement(button, item) {
    button.addClass(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);
    button.setEnabled(item.enabled);
    const label = this.ctx.localeManager.t(item.label);
    const cellPaddingClass = `${DEFAULT_CONTEXT_MENU_CLASS}__cellpadding`;
    const { cellIcon, cellLabel, cellArrow } = this.initTableCells(button.getElement());
    cellLabel.textContent = label;
    cellLabel.classList.add(cellPaddingClass);
    if (item.iconUrl != null) {
      const img = createElement("img");
      img.src = item.iconUrl;
      cellIcon.append(img);
      cellIcon.classList.add(cellPaddingClass);
    }
    if (item.items.length > 0) {
      const span = createElement("span", getIconClassNames3("chevron-right"));
      cellArrow.append(span);
      cellArrow.classList.add(cellPaddingClass);
    }
    const { showOn, action } = item;
    if (action != null) {
      button.addListener("click", this.createButtonOnClick(showOn, action));
    }
    button.addListener("mousemove", () => button.focus({ preventScroll: true }));
    if (item.items.length === 0) {
      button.addListener("mouseleave", () => button.setFocusOverride(false));
      button.addListener("focus", () => button.setFocusOverride(void 0));
    }
  }
  reposition() {
    let { x, y } = this;
    this.element.style.top = "unset";
    this.element.style.bottom = "unset";
    const canvasRect = this.ctx.domManager.getBoundingClientRect();
    const { offsetWidth: width2, offsetHeight: height2 } = this.element;
    x = clamp(0, x, canvasRect.width - width2);
    y = clamp(0, y, canvasRect.height - height2);
    this.element.style.left = `${x}px`;
    this.element.style.top = `calc(${y}px - 0.5em)`;
  }
  destroy() {
    super.destroy();
    this.mutationObserver?.disconnect();
    this.ctx.domManager.removeStyles(moduleId2);
    this.ctx.domManager.removeChild("canvas-overlay", moduleId2);
  }
};
__decorateClass2([
  Property38
], ContextMenu.prototype, "enabled", 2);
__decorateClass2([
  Property38
], ContextMenu.prototype, "darkTheme", 2);
__decorateClass2([
  Property38
], ContextMenu.prototype, "items", 2);
var ContextMenuModule = {
  type: "root",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  optionsKey: "contextMenu",
  moduleFactory: (ctx) => new ContextMenu(ctx),
  themeTemplate: {
    contextMenu: {
      enabled: true,
      darkTheme: module_support_exports.ThemeSymbols.IS_DARK_THEME
    }
  }
};
function readDatum(nodeDatum) {
  if (typeof nodeDatum?.datum === "object") {
    return nodeDatum.datum;
  }
  return null;
}
var { FormatManager: FormatManager2, BaseProperties: BaseProperties13, Property: Property39 } = module_support_exports;
var DEFAULT_LABEL_CLASS = "ag-charts-crosshair-label";
var CrosshairLabelProperties = class extends BaseProperties13 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.xOffset = 0;
    this.yOffset = 0;
    this.format = void 0;
    this.renderer = void 0;
    this._cachedFormatter = void 0;
  }
  formatValue(callWithContext22, type, value, params) {
    const { formatter: formatter2, format } = this;
    const { domain, boundSeries } = params;
    let result;
    if (formatter2 != null) {
      const fractionDigits = params.type === "number" ? params.fractionDigits : void 0;
      const unit = params.type === "date" ? params.unit : void 0;
      const step = params.type === "date" ? params.step : void 0;
      result = callWithContext22(formatter2, { value, domain, fractionDigits, unit, step, boundSeries });
    }
    if (format != null) {
      let cachedFormatter = this._cachedFormatter;
      if (cachedFormatter == null || cachedFormatter.type !== type || cachedFormatter.format !== format) {
        cachedFormatter = {
          type,
          format,
          formatter: FormatManager2.getFormatter(type, format)
        };
        this._cachedFormatter = cachedFormatter;
      }
      result ?? (result = cachedFormatter.formatter?.(value));
    }
    return result != null ? String(result) : void 0;
  }
};
__decorateClass2([
  Property39
], CrosshairLabelProperties.prototype, "enabled", 2);
__decorateClass2([
  Property39
], CrosshairLabelProperties.prototype, "xOffset", 2);
__decorateClass2([
  Property39
], CrosshairLabelProperties.prototype, "yOffset", 2);
__decorateClass2([
  Property39
], CrosshairLabelProperties.prototype, "formatter", 2);
__decorateClass2([
  Property39
], CrosshairLabelProperties.prototype, "format", 2);
__decorateClass2([
  Property39
], CrosshairLabelProperties.prototype, "renderer", 2);
var CrosshairLabel = class extends CrosshairLabelProperties {
  constructor(domManager, key, axisId) {
    super();
    this.domManager = domManager;
    this.id = createId(this);
    this.element = domManager.addChild("canvas-overlay", `crosshair-label-${this.id}`);
    this.element.classList.add(DEFAULT_LABEL_CLASS);
    setAttribute(this.element, "aria-hidden", true);
    this.element.setAttribute("data-key", key);
    this.element.setAttribute("data-axis-id", axisId);
  }
  show(meta) {
    const { element: element2 } = this;
    const left = meta.x + this.xOffset;
    const top = meta.y + this.yOffset;
    element2.style.top = `${Math.round(top)}px`;
    element2.style.left = `${Math.round(left)}px`;
    this.toggle(true);
  }
  setLabelHtml({ html, styles }) {
    if (html !== void 0) {
      this.element.innerHTML = html;
    }
    if (styles !== void 0) {
      const styleElement = this.element.children[0] ?? this.element;
      Object.assign(styleElement.style, styles);
    }
  }
  getBBox() {
    const { element: element2 } = this;
    return new module_support_exports.BBox(
      element2.clientLeft,
      element2.clientTop,
      element2.clientWidth,
      element2.clientHeight
    );
  }
  toggle(visible) {
    this.element.classList.toggle(`ag-charts-crosshair-label--hidden`, !visible);
  }
  destroy() {
    this.domManager.removeChild("canvas-overlay", `crosshair-label-${this.id}`);
  }
  toLabelHtml(input, defaults) {
    if (typeof input === "string") {
      return { html: input, styles: {} };
    }
    defaults = defaults ?? {};
    const {
      text: text2 = defaults.text ?? "",
      color: color6 = defaults.color,
      backgroundColor = defaults.backgroundColor,
      opacity = defaults.opacity ?? 1
    } = input;
    const styles = {
      opacity,
      "background-color": backgroundColor?.toLowerCase(),
      color: color6
    };
    return {
      html: `<div class="ag-charts-crosshair-label-content">
                    <span>${text2}</span>
                </div>`,
      styles
    };
  }
};
var { Group: Group5, TranslatableGroup: TranslatableGroup22, Line: Line4, BBox: BBox5, InteractionState: InteractionState4, Property: Property40, ZIndexMap: ZIndexMap5, ChartAxisDirection: ChartAxisDirection11 } = module_support_exports;
var Crosshair = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId(this);
    this.enabled = false;
    this.stroke = "rgb(195, 195, 195)";
    this.lineDash = [6, 3];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.snap = true;
    this.label = new CrosshairLabelProperties();
    this.seriesRect = new BBox5(0, 0, 0, 0);
    this.bounds = new BBox5(0, 0, 0, 0);
    this.crosshairGroup = new TranslatableGroup22({
      name: "crosshairs",
      zIndex: ZIndexMap5.SERIES_CROSSHAIR
    });
    this.lineGroup = this.crosshairGroup.appendChild(
      new Group5({
        name: `${this.id}-crosshair-lines`,
        zIndex: ZIndexMap5.SERIES_CROSSHAIR
      })
    );
    this.lineGroupSelection = module_support_exports.Selection.select(this.lineGroup, Line4, false);
    this.activeHighlight = void 0;
    this.axisCtx = ctx.parent;
    this.labels = {};
    this.hideCrosshairs();
    ctx.domManager.addEventListener("focusin", ({ target }) => {
      const isSeriesAreaChild = target instanceof HTMLElement && ctx.domManager.contains(target, "series-area");
      if (this.crosshairGroup.visible && !isSeriesAreaChild) {
        this.hideCrosshairs();
        this.ctx.updateService.update(module_support_exports.ChartUpdateType.PERFORM_LAYOUT);
      }
    });
    const { seriesDragInterpreter } = ctx.widgets;
    this.cleanup.register(
      ctx.scene.attachNode(this.crosshairGroup),
      ctx.widgets.seriesWidget.addListener("mousemove", (event) => this.onMouseHoverLike(event)),
      ctx.widgets.seriesWidget.addListener("mouseleave", () => this.onMouseOut()),
      ctx.eventsHub.on("series:focus-change", () => this.onKeyPress()),
      ctx.eventsHub.on("zoom:pan-start", () => this.onMouseOut()),
      ctx.eventsHub.on("zoom:change", () => this.onMouseOut()),
      ctx.eventsHub.on("highlight:change", (event) => this.onHighlightChange(event)),
      ctx.eventsHub.on("layout:complete", (event) => this.layout(event)),
      () => Object.values(this.labels).forEach((label) => label.destroy())
    );
    if (seriesDragInterpreter) {
      this.cleanup.register(
        seriesDragInterpreter.events.on("drag-move", (event) => this.onMouseHoverLike(event)),
        seriesDragInterpreter.events.on("click", (event) => this.onClick(event))
      );
    }
  }
  layout({ series: { rect, visible }, axes }) {
    if (!visible || !axes || !this.enabled)
      return;
    this.seriesRect = rect;
    const { position: axisPosition = "left", axisId } = this.axisCtx;
    const axisLayout = axes.find((a) => a.id === axisId);
    if (!axisLayout)
      return;
    this.axisLayout = axisLayout;
    this.bounds = rect.clone().grow(axisLayout.gridPadding + axisLayout.seriesAreaPadding, axisPosition);
    const { crosshairGroup, bounds } = this;
    crosshairGroup.translationX = Math.round(bounds.x);
    crosshairGroup.translationY = Math.round(bounds.y);
    const crosshairKeys = ["pointer", ...this.axisCtx.seriesKeyProperties()];
    this.updateSelections(crosshairKeys);
    this.updateLines();
    this.updateLabels(crosshairKeys);
  }
  updateSelections(data) {
    this.lineGroupSelection.update(data, void 0, (key) => key);
  }
  updateLabels(keys) {
    const { labels, ctx } = this;
    for (const key of keys) {
      if (this.label.enabled) {
        labels[key] ?? (labels[key] = new CrosshairLabel(ctx.domManager, key, this.axisCtx.axisId));
      }
      if (labels[key]) {
        this.updateLabel(labels[key]);
      }
    }
  }
  updateLabel(label) {
    const { enabled, xOffset, yOffset, format, renderer } = this.label;
    label.enabled = enabled;
    label.xOffset = xOffset;
    label.yOffset = yOffset;
    label.format = format;
    label.renderer = renderer;
  }
  updateLines() {
    const { lineGroupSelection, bounds, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset, axisLayout } = this;
    if (!axisLayout)
      return;
    const isVertical = this.isVertical();
    lineGroupSelection.each((line) => {
      line.stroke = stroke22;
      line.strokeWidth = strokeWidth;
      line.strokeOpacity = strokeOpacity;
      line.lineDash = lineDash;
      line.lineDashOffset = lineDashOffset;
      line.y1 = 0;
      line.y2 = isVertical ? bounds.height : 0;
      line.x1 = 0;
      line.x2 = isVertical ? 0 : bounds.width;
    });
  }
  isVertical() {
    return this.axisCtx.direction === ChartAxisDirection11.X;
  }
  isHover(event) {
    return event.type === "mousemove" || event.type === "click" || event.device === "touch" && this.ctx.chartService.touch.dragAction === "hover";
  }
  formatValue(value) {
    return this.axisCtx.formatScaleValue(value, "crosshair", this.label);
  }
  onClick(event) {
    if (event.device === "touch") {
      this.onMouseHoverLike(event);
    }
  }
  onMouseHoverLike(event) {
    if (!this.enabled || this.snap)
      return;
    const requiredState = this.isHover(event) ? InteractionState4.Clickable : InteractionState4.AnnotationsMoveable;
    if (!this.ctx.interactionManager.isState(requiredState))
      return;
    this.updatePositions(this.getData(event));
    this.crosshairGroup.visible = true;
    this.ctx.updateService.update(module_support_exports.ChartUpdateType.SCENE_RENDER);
  }
  onMouseOut() {
    if (!this.ctx.interactionManager.isState(InteractionState4.Clickable))
      return;
    this.hideCrosshairs();
    this.ctx.updateService.update(module_support_exports.ChartUpdateType.SCENE_RENDER);
  }
  onKeyPress() {
    if (this.enabled && !this.snap && this.ctx.interactionManager.isState(InteractionState4.Default)) {
      this.hideCrosshairs();
    }
  }
  onHighlightChange(event) {
    if (!this.enabled)
      return;
    const { crosshairGroup, axisCtx } = this;
    const { datum, series } = event.currentHighlight ?? {};
    const hasCrosshair = datum && (series?.axes.x?.id === axisCtx.axisId || series?.axes.y?.id === axisCtx.axisId);
    this.activeHighlight = hasCrosshair ? event.currentHighlight : void 0;
    if (!this.activeHighlight) {
      this.hideCrosshairs();
    } else if (this.snap) {
      const activeHighlightData = this.getActiveHighlightData(this.activeHighlight);
      this.updatePositions(activeHighlightData);
      crosshairGroup.visible = true;
    }
  }
  isInRange(value) {
    return this.axisCtx.inRange(value);
  }
  updatePositions(data) {
    const { seriesRect, lineGroupSelection } = this;
    lineGroupSelection.each((line, key) => {
      const lineData = data[key];
      if (!lineData) {
        line.visible = false;
        this.hideLabel(key);
        return;
      }
      line.visible = true;
      const { value, position } = lineData;
      let x = 0;
      let y = 0;
      if (this.isVertical()) {
        x = position;
        line.x = Math.round(x);
      } else {
        y = position;
        line.y = Math.round(y);
      }
      if (this.label.enabled) {
        this.showLabel(x + seriesRect.x, y + seriesRect.y, value, key);
      } else {
        this.hideLabel(key);
      }
    });
  }
  getData(event) {
    const { axisCtx } = this;
    const key = "pointer";
    const { xKey = "", yKey = "" } = this.activeHighlight ?? {};
    const { currentX, currentY } = event;
    const datum = readDatum(this.activeHighlight);
    const isVertical = this.isVertical();
    const position = isVertical ? currentX : currentY;
    let value = datum?.[isVertical ? xKey : yKey] ?? "";
    if (axisCtx.continuous) {
      value = axisCtx.scaleInvert(position);
    }
    return { [key]: { position, value } };
  }
  getActiveHighlightData(activeHighlight) {
    const { axisCtx } = this;
    const { series, xKey = "", aggregatedValue, cumulativeValue, midPoint } = activeHighlight;
    const datum = readDatum(activeHighlight);
    const seriesKeyProperties = series.getKeyProperties(axisCtx.direction);
    const halfBandwidth = (axisCtx.scale.bandwidth ?? 0) / 2;
    const matchingAxisId = series.axes[axisCtx.direction]?.id === axisCtx.axisId;
    const isYKey = seriesKeyProperties.indexOf("yKey") > -1 && matchingAxisId;
    const isXKey = seriesKeyProperties.indexOf("xKey") > -1 && matchingAxisId;
    const datumValue = aggregatedValue ?? cumulativeValue;
    if (isYKey && datumValue !== void 0) {
      const position = axisCtx.scale.convert(datumValue) + halfBandwidth;
      const isInRange = this.isInRange(position);
      return isInRange ? {
        yKey: { value: datumValue, position }
      } : {};
    }
    if (isXKey) {
      const position = (this.isVertical() ? midPoint?.x : midPoint?.y) ?? 0;
      const value = axisCtx.continuous ? axisCtx.scaleInvert(position) : datum?.[xKey];
      return this.isInRange(position) ? { xKey: { value, position } } : {};
    }
    const activeHighlightData = {};
    seriesKeyProperties.forEach((key) => {
      const keyValue = series.properties[key];
      const value = datum?.[keyValue];
      const position = axisCtx.scale.convert(value) + halfBandwidth;
      const isInRange = this.isInRange(position);
      if (isInRange) {
        activeHighlightData[key] = { value, position };
      }
    });
    return activeHighlightData;
  }
  getLabelHtml(value, label) {
    const fractionDigits = this.axisLayout?.label?.fractionDigits ?? 0;
    const defaults = { text: this.formatValue(value) };
    if (this.label.renderer) {
      return label.toLabelHtml(this.label.renderer({ value, fractionDigits }), defaults);
    }
    return label.toLabelHtml(defaults);
  }
  showLabel(x, y, value, key) {
    if (!this.axisLayout)
      return;
    const { bounds } = this;
    const label = this.labels[key];
    const html = this.getLabelHtml(value, label);
    label.setLabelHtml(html);
    const { width: width2, height: height2 } = label.getBBox();
    const axisPosition = this.axisCtx.position;
    let padding2 = this.axisLayout.label.spacing + this.axisLayout.tickSize;
    if (this.axisCtx.direction === ChartAxisDirection11.X) {
      padding2 -= 4;
      label.show({
        x: x - width2 / 2,
        y: axisPosition === "bottom" ? bounds.y + bounds.height + padding2 : bounds.y - height2 - padding2
      });
    } else {
      padding2 -= 8;
      label.show({
        x: axisPosition === "right" ? bounds.x + bounds.width + padding2 : bounds.x - width2 - padding2,
        y: y - height2 / 2
      });
    }
  }
  hideCrosshairs() {
    this.crosshairGroup.visible = false;
    for (const key of Object.keys(this.labels)) {
      this.hideLabel(key);
    }
  }
  hideLabel(key) {
    this.labels[key]?.toggle(false);
  }
};
__decorateClass2([
  Property40
], Crosshair.prototype, "enabled", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "stroke", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "lineDash", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "strokeWidth", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "snap", 2);
__decorateClass2([
  Property40
], Crosshair.prototype, "label", 2);
var CrosshairModule = {
  type: "axis-option",
  optionsKey: "crosshair",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  axisTypes: ["category", "time", "unit-time", "ordinal-time", "number", "log"],
  moduleFactory: (ctx) => new Crosshair(ctx),
  themeTemplate: {
    crosshair: {
      snap: true,
      stroke: { $ref: "subtleTextColor" },
      strokeWidth: 1,
      strokeOpacity: 1,
      lineDash: [5, 6],
      lineDashOffset: 0,
      label: {
        enabled: true
      }
    }
  }
};
var { ActionOnSet: ActionOnSet5, Property: Property41 } = module_support_exports;
var DataSource = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.enabled = false;
    this.getData = () => Promise.resolve();
    this.dataService = ctx.dataService;
  }
  updateCallback(enabled, getData) {
    if (!this.dataService)
      return;
    if (enabled && getData != null) {
      this.dataService.updateCallback(getData);
    } else {
      this.dataService.clearCallback();
    }
  }
};
__decorateClass2([
  ActionOnSet5({
    newValue(enabled) {
      this.updateCallback(enabled, this.getData);
    }
  }),
  Property41
], DataSource.prototype, "enabled", 2);
__decorateClass2([
  ActionOnSet5({
    newValue(getData) {
      this.updateCallback(this.enabled, getData);
    }
  }),
  Property41
], DataSource.prototype, "getData", 2);
__decorateClass2([
  ActionOnSet5({
    newValue(requestThrottle) {
      this.dataService.requestThrottle = requestThrottle;
    }
  })
], DataSource.prototype, "requestThrottle", 2);
__decorateClass2([
  ActionOnSet5({
    newValue(updateThrottle) {
      this.dataService.dispatchThrottle = updateThrottle;
    }
  })
], DataSource.prototype, "updateThrottle", 2);
__decorateClass2([
  ActionOnSet5({
    newValue(updateDuringInteraction) {
      this.dataService.dispatchOnlyLatest = !updateDuringInteraction;
    }
  })
], DataSource.prototype, "updateDuringInteraction", 2);
var DataSourceModule = {
  type: "root",
  optionsKey: "dataSource",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new DataSource(ctx),
  themeTemplate: {
    dataSource: { enabled: false }
  }
};
var { nearestSquared: nearestSquared2, nearestSquaredInContainer: nearestSquaredInContainer2, partialAssign: partialAssign2, mergeDefaults: mergeDefaults2, BBox: BBox6 } = module_support_exports;
var HierarchicalBBox = class {
  constructor(components) {
    this.components = components;
    this.union = BBox6.merge(components);
  }
  containsPoint(x, y) {
    if (!this.union.containsPoint(x, y)) {
      return false;
    }
    for (const bbox of this.components) {
      if (bbox.containsPoint(x, y)) {
        return true;
      }
    }
    return false;
  }
};
var ErrorBarNode = class extends module_support_exports.Group {
  constructor() {
    super();
    this.capLength = NaN;
    this._datum = void 0;
    this.whiskerPath = new module_support_exports.Path();
    this.capsPath = new module_support_exports.Path();
    this.bboxes = new HierarchicalBBox([]);
    this.append([this.whiskerPath, this.capsPath]);
  }
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    this._datum = datum;
  }
  calculateCapLength(capsTheme, capDefaults) {
    const { lengthRatio = 1, length: length2 } = capsTheme;
    const { lengthRatioMultiplier, lengthMax } = capDefaults;
    const desiredLength = length2 ?? lengthRatio * lengthRatioMultiplier;
    return Math.min(desiredLength, lengthMax);
  }
  getItemStylerParams(options, style2, highlighted, highlightState) {
    const { datum } = this;
    if (datum == null || options.itemStyler == null)
      return;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = options;
    return {
      ...style2,
      datum: datum.datum,
      seriesId: datum.series.id,
      xKey: datum.xKey,
      yKey: datum.yKey,
      xLowerKey,
      xUpperKey,
      yLowerKey,
      yUpperKey,
      highlighted,
      highlightState
    };
  }
  formatStyles(style2, options, caller, highlighted, highlightState) {
    let { cap: capsStyle, ...whiskerStyle } = style2;
    const params = this.getItemStylerParams(options, style2, highlighted, highlightState);
    if (params != null && options.itemStyler != null) {
      const result = caller.callWithContext(options.itemStyler, params);
      whiskerStyle = mergeDefaults2(result, whiskerStyle);
      capsStyle = mergeDefaults2(result?.cap, result, capsStyle);
    }
    return { whiskerStyle, capsStyle };
  }
  applyStyling(target, source) {
    partialAssign2(
      ["visible", "stroke", "strokeWidth", "strokeOpacity", "lineDash", "lineDashOffset"],
      target,
      source
    );
  }
  update(style2, formatters2, caller, highlighted, highlightState) {
    if (this.datum === void 0) {
      return;
    }
    const { whiskerStyle, capsStyle } = this.formatStyles(style2, formatters2, caller, highlighted, highlightState);
    const { xBar, yBar, capDefaults } = this.datum;
    const whisker = this.whiskerPath;
    this.applyStyling(whisker, whiskerStyle);
    whisker.path.clear(true);
    if (yBar !== void 0) {
      whisker.path.moveTo(yBar.lowerPoint.x, yBar.lowerPoint.y);
      whisker.path.lineTo(yBar.upperPoint.x, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      whisker.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y);
      whisker.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y);
    }
    whisker.path.closePath();
    this.capLength = this.calculateCapLength(capsStyle ?? {}, capDefaults);
    const capOffset = this.capLength / 2;
    const caps = this.capsPath;
    this.applyStyling(caps, capsStyle);
    caps.path.clear(true);
    if (yBar !== void 0) {
      caps.path.moveTo(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y);
      caps.path.lineTo(yBar.lowerPoint.x + capOffset, yBar.lowerPoint.y);
      caps.path.moveTo(yBar.upperPoint.x - capOffset, yBar.upperPoint.y);
      caps.path.lineTo(yBar.upperPoint.x + capOffset, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      caps.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset);
      caps.path.lineTo(xBar.lowerPoint.x, xBar.lowerPoint.y + capOffset);
      caps.path.moveTo(xBar.upperPoint.x, xBar.upperPoint.y - capOffset);
      caps.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y + capOffset);
    }
    caps.path.closePath();
  }
  updateBBoxes() {
    const { capLength, whiskerPath: whisker, capsPath: caps } = this;
    const { yBar, xBar } = this.datum ?? {};
    const capOffset = capLength / 2;
    const components = [];
    if (yBar !== void 0) {
      const whiskerHeight = yBar.lowerPoint.y - yBar.upperPoint.y;
      components.push(
        new BBox6(yBar.lowerPoint.x, yBar.upperPoint.y, whisker.strokeWidth, whiskerHeight),
        new BBox6(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y, capLength, caps.strokeWidth),
        new BBox6(yBar.upperPoint.x - capOffset, yBar.upperPoint.y, capLength, caps.strokeWidth)
      );
    }
    if (xBar !== void 0) {
      const whiskerWidth = xBar.upperPoint.x - xBar.lowerPoint.x;
      components.push(
        new BBox6(xBar.lowerPoint.x, xBar.upperPoint.y, whiskerWidth, whisker.strokeWidth),
        new BBox6(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset, caps.strokeWidth, capLength),
        new BBox6(xBar.upperPoint.x, xBar.upperPoint.y - capOffset, caps.strokeWidth, capLength)
      );
    }
    this.bboxes.components = components;
    this.bboxes.union = BBox6.merge(components);
  }
  containsPoint(x, y) {
    return this.bboxes.containsPoint(x, y);
  }
  pickNode(x, y) {
    return this.containsPoint(x, y) ? this : void 0;
  }
  nearestSquared(x, y, maxDistance) {
    const { bboxes } = this;
    if (bboxes.union.distanceSquared(x, y) > maxDistance) {
      return { nearest: void 0, distanceSquared: Infinity };
    }
    const { distanceSquared: distanceSquared2 } = nearestSquared2(x, y, bboxes.components);
    return { nearest: this, distanceSquared: distanceSquared2 };
  }
};
var ErrorBarGroup = class extends module_support_exports.Group {
  nearestSquared(x, y) {
    const { nearest, distanceSquared: distanceSquared2 } = nearestSquaredInContainer2(x, y, {
      children: this.children()
    });
    if (nearest !== void 0 && !isNaN(distanceSquared2)) {
      return { datum: nearest.datum, distanceSquared: distanceSquared2 };
    }
  }
};
var { BaseProperties: BaseProperties14, Property: Property42 } = module_support_exports;
var ErrorBarCap = class extends BaseProperties14 {
};
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "visible", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "stroke", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "strokeWidth", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "lineDash", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "length", 2);
__decorateClass2([
  Property42
], ErrorBarCap.prototype, "lengthRatio", 2);
var ErrorBarProperties = class extends BaseProperties14 {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cap = new ErrorBarCap();
  }
};
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "yLowerKey", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "yLowerName", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "yUpperKey", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "yUpperName", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "xLowerKey", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "xLowerName", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "xUpperKey", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "xUpperName", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "visible", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "stroke", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property42
], ErrorBarProperties.prototype, "cap", 2);
var { fixNumericExtent: fixNumericExtent2, groupAccumulativeValueProperty: groupAccumulativeValueProperty2, mergeDefaults: mergeDefaults22, valueProperty: valueProperty22, ChartAxisDirection: ChartAxisDirection12 } = module_support_exports;
function toErrorBoundCartesianSeries(ctx) {
  for (const supportedType of AgErrorBarSupportedSeriesTypes) {
    if (supportedType === ctx.series.type) {
      return ctx.series;
    }
  }
  throw new Error(
    `AG Charts - unsupported series type '${ctx.series.type}', error bars supported series types: ${AgErrorBarSupportedSeriesTypes.join(", ")}`
  );
}
var ErrorBars = class _ErrorBars extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.properties = new ErrorBarProperties();
    const series = toErrorBoundCartesianSeries(ctx);
    const { annotationGroup, annotationSelections } = series;
    this.cartesianSeries = series;
    this.groupNode = new ErrorBarGroup({
      name: `${annotationGroup.id}-errorBars`
    });
    annotationGroup.appendChild(this.groupNode);
    this.selection = module_support_exports.Selection.select(this.groupNode, () => this.errorBarFactory());
    annotationSelections.add(this.selection);
    series.addEventListener("seriesVisibilityChange", (e) => this.onToggleSeriesItem(e));
    this.cleanup.register(
      series.events.on("data-processed", (e) => this.onDataProcessed(e)),
      series.events.on("data-update", (e) => this.onDataUpdate(e)),
      ctx.eventsHub.on("highlight:change", (event) => this.onHighlightChange(event)),
      () => annotationGroup.removeChild(this.groupNode),
      () => annotationSelections.delete(this.selection)
    );
  }
  hasErrorBars() {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    return isDefined(xLowerKey) && isDefined(xUpperKey) || isDefined(yLowerKey) && isDefined(yUpperKey);
  }
  isStacked() {
    const stackCount = this.cartesianSeries.seriesGrouping?.stackCount;
    return stackCount == null ? false : stackCount > 0;
  }
  getUnstackPropertyDefinition(opts) {
    const props = [];
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { xScaleType, yScaleType } = opts;
    if (yLowerKey != null && yUpperKey != null) {
      props.push(
        valueProperty22(yLowerKey, yScaleType, { id: `${yErrorsID}-lower` }),
        valueProperty22(yUpperKey, yScaleType, { id: `${yErrorsID}-upper` })
      );
    }
    if (xLowerKey != null && xUpperKey != null) {
      props.push(
        valueProperty22(xLowerKey, xScaleType, { id: `${xErrorsID}-lower` }),
        valueProperty22(xUpperKey, xScaleType, { id: `${xErrorsID}-upper` })
      );
    }
    return props;
  }
  getStackPropertyDefinition(opts) {
    const props = [];
    const { cartesianSeries } = this;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { xScaleType, yScaleType } = opts;
    const groupIndex = cartesianSeries.seriesGrouping?.groupIndex ?? cartesianSeries.id;
    const groupOpts = {
      invalidValue: null,
      missingValue: 0,
      separateNegative: true,
      ...cartesianSeries.visible ? {} : { forceValue: 0 }
    };
    const makeErrorProperty = (key, id, type, scaleType) => {
      return groupAccumulativeValueProperty2(
        key,
        "normal",
        "current",
        {
          id: `${id}-${type}`,
          groupId: `errorGroup-${groupIndex}-${type}`,
          ...groupOpts
        },
        scaleType
      );
    };
    const pushErrorProperties = (lowerKey, upperKey, id, scaleType) => {
      props.push(
        ...makeErrorProperty(lowerKey, id, "lower", scaleType),
        ...makeErrorProperty(upperKey, id, "upper", scaleType)
      );
    };
    if (yLowerKey != null && yUpperKey != null) {
      pushErrorProperties(yLowerKey, yUpperKey, yErrorsID, yScaleType);
    }
    if (xLowerKey != null && xUpperKey != null) {
      pushErrorProperties(xLowerKey, xUpperKey, xErrorsID, xScaleType);
    }
    return props;
  }
  getPropertyDefinitions(opts) {
    if (this.isStacked()) {
      return this.getStackPropertyDefinition(opts);
    } else {
      return this.getUnstackPropertyDefinition(opts);
    }
  }
  onDataProcessed(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
  }
  getDomain(direction) {
    const { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID } = this.getMaybeFlippedKeys();
    const hasAxisErrors = direction === ChartAxisDirection12.X ? isDefined(xLowerKey) && isDefined(xUpperKey) : isDefined(yLowerKey) && isDefined(yUpperKey);
    if (hasAxisErrors) {
      const { dataModel, processedData, cartesianSeries: series } = this;
      if (dataModel != null && processedData != null) {
        const id = { x: xErrorsID, y: yErrorsID }[direction];
        const lowerDomain = dataModel.getDomain(series, `${id}-lower`, "value", processedData);
        const upperDomain = dataModel.getDomain(series, `${id}-upper`, "value", processedData);
        const domain = [Math.min(...lowerDomain, ...upperDomain), Math.max(...lowerDomain, ...upperDomain)];
        return fixNumericExtent2(domain);
      }
    }
    return [];
  }
  onDataUpdate(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
    if (isDefined(event.dataModel) && isDefined(event.processedData)) {
      this.createNodeData();
      this.update();
    }
  }
  getNodeData() {
    return this.hasErrorBars() ? this.cartesianSeries.contextNodeData?.nodeData : void 0;
  }
  createNodeData() {
    const nodeData = this.getNodeData();
    const xScale = this.cartesianSeries.axes[ChartAxisDirection12.X]?.scale;
    const yScale = this.cartesianSeries.axes[ChartAxisDirection12.Y]?.scale;
    if (!xScale || !yScale || !nodeData) {
      return;
    }
    for (let i = 0; i < nodeData.length; i++) {
      const { midPoint, xLower, xUpper, yLower, yUpper } = this.getDatum(nodeData, i);
      if (midPoint != null) {
        let xBar, yBar;
        if (isDefined(xLower) && isDefined(xUpper)) {
          xBar = {
            lowerPoint: { x: this.convert(xScale, xLower), y: midPoint.y },
            upperPoint: { x: this.convert(xScale, xUpper), y: midPoint.y }
          };
        }
        if (isDefined(yLower) && isDefined(yUpper)) {
          yBar = {
            lowerPoint: { x: midPoint.x, y: this.convert(yScale, yLower) },
            upperPoint: { x: midPoint.x, y: this.convert(yScale, yUpper) }
          };
        }
        nodeData[i].xBar = xBar;
        nodeData[i].yBar = yBar;
      }
    }
  }
  getMaybeFlippedKeys() {
    let { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    let [xErrorsID, yErrorsID] = ["xValue-errors", "yValue-errors"];
    if (this.cartesianSeries.shouldFlipXY()) {
      [xLowerKey, yLowerKey] = [yLowerKey, xLowerKey];
      [xUpperKey, yUpperKey] = [yUpperKey, xUpperKey];
      [xErrorsID, yErrorsID] = [yErrorsID, xErrorsID];
    }
    return { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID };
  }
  static getDatumKey(nodeDatum, key, offset) {
    if (key == null) {
      return;
    }
    const datum = readDatum(nodeDatum);
    const value = datum?.[key];
    if (value == null) {
      return;
    }
    if (typeof value !== "number") {
      logger_exports.warnOnce(`Found [${key}] error value of type ${typeof value}. Expected number type`);
      return;
    }
    return value + offset;
  }
  getDatum(nodeData, datumIndex) {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.getMaybeFlippedKeys();
    const datum = nodeData[datumIndex];
    const d = datum.cumulativeValue == null || !this.isStacked() ? 0 : datum.cumulativeValue - datum.yValue;
    const [xOffset, yOffset] = this.cartesianSeries.shouldFlipXY() ? [d, 0] : [0, d];
    return {
      midPoint: datum.midPoint,
      xLower: _ErrorBars.getDatumKey(datum, xLowerKey, xOffset),
      xUpper: _ErrorBars.getDatumKey(datum, xUpperKey, xOffset),
      yLower: _ErrorBars.getDatumKey(datum, yLowerKey, yOffset),
      yUpper: _ErrorBars.getDatumKey(datum, yUpperKey, yOffset)
    };
  }
  convert(scale2, value) {
    const offset = (scale2.bandwidth ?? 0) / 2;
    return scale2.convert(value) + offset;
  }
  update() {
    const nodeData = this.getNodeData();
    if (nodeData != null) {
      this.selection.update(nodeData);
      this.selection.each((node, datum, i) => this.updateNode(node, datum, i));
    }
  }
  updateNode(node, datum, _index) {
    node.datum = datum;
    node.update(this.getDefaultStyle(), this.properties, this.cartesianSeries, false, "none");
    node.updateBBoxes();
  }
  pickNodeExact(point) {
    const { x, y } = point;
    const node = this.groupNode.pickNode(x, y);
    if (node != null) {
      return { datum: node.datum, distanceSquared: 0 };
    }
  }
  pickNodeNearest(point) {
    return this.groupNode.nearestSquared(point.x, point.y);
  }
  pickNodeMainAxisFirst(point, majorDirection) {
    let closestDatum;
    let closestDistance = [Infinity, Infinity];
    const referencePoints = [point.x, point.y];
    if (majorDirection === ChartAxisDirection12.Y) {
      referencePoints.reverse();
    }
    for (const child of this.groupNode.children()) {
      const childBBox = child.getBBox();
      const childReferencePoints = [childBBox.x + childBBox.width / 2, childBBox.y + childBBox.height / 2];
      if (majorDirection === ChartAxisDirection12.Y) {
        childReferencePoints.reverse();
      }
      const childDistances = [];
      for (let i = 0; i < referencePoints.length; i++) {
        childDistances.push(Math.abs(referencePoints[i] - childReferencePoints[i]));
      }
      if (childDistances[0] < closestDistance[0] || childDistances[0] == closestDistance[0] && childDistances[1] < closestDistance[1]) {
        closestDatum = child.datum;
        closestDistance = childDistances;
      }
    }
    if (closestDatum) {
      return {
        datum: closestDatum,
        distanceSquared: Math.pow(closestDistance[0], 2) + Math.pow(closestDistance[1], 2)
      };
    }
  }
  getTooltipParams() {
    const {
      xLowerKey,
      xUpperKey,
      yLowerKey,
      yUpperKey,
      xLowerName = xLowerKey,
      xUpperName = xUpperKey,
      yLowerName = yLowerKey,
      yUpperName = yUpperKey
    } = this.properties;
    return { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName };
  }
  onToggleSeriesItem(event) {
    this.groupNode.visible = event.visible;
  }
  makeStyle(baseStyle) {
    return {
      visible: baseStyle.visible,
      lineDash: baseStyle.lineDash,
      lineDashOffset: baseStyle.lineDashOffset,
      stroke: baseStyle.stroke,
      strokeWidth: baseStyle.strokeWidth,
      strokeOpacity: baseStyle.strokeOpacity,
      cap: mergeDefaults22(this.properties.cap, baseStyle)
    };
  }
  getDefaultStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  getHighlightStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  restyleHighlightChange(highlightChange, style2, highlighted) {
    const nodeData = this.getNodeData();
    if (nodeData == null)
      return;
    for (let i = 0; i < nodeData.length; i++) {
      if (highlightChange === nodeData[i]) {
        this.selection.at(i)?.update(
          style2,
          this.properties,
          this.cartesianSeries,
          highlighted,
          highlighted ? "highlighted-item" : "unhighlighted-item"
        );
        break;
      }
    }
  }
  onHighlightChange(event) {
    const { previousHighlight, currentHighlight } = event;
    if (currentHighlight?.series === this.cartesianSeries) {
      this.restyleHighlightChange(currentHighlight, this.getHighlightStyle(), true);
    }
    if (previousHighlight?.series === this.cartesianSeries) {
      this.restyleHighlightChange(previousHighlight, this.getDefaultStyle(), false);
    }
    this.groupNode.opacity = this.cartesianSeries.getOpacity();
  }
  errorBarFactory() {
    return new ErrorBarNode();
  }
  getWhiskerProperties() {
    const { stroke: stroke22, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset } = this.properties;
    return { stroke: stroke22, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset };
  }
};
var ERROR_BARS_THEME = {
  series: {
    errorBar: {
      visible: true,
      stroke: { $ref: "foregroundColor" },
      strokeWidth: 1,
      strokeOpacity: 1,
      cap: {
        length: void 0,
        lengthRatio: void 0
      }
    }
  }
};
var ErrorBarsModule = {
  type: "series-option",
  identifier: "error-bars",
  optionsKey: "errorBar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  seriesTypes: AgErrorBarSupportedSeriesTypes,
  moduleFactory: (ctx) => new ErrorBars(ctx),
  themeTemplate: ERROR_BARS_THEME
};
var { ZIndexMap: ZIndexMap6, ActionOnSet: ActionOnSet6, Property: Property43, ProxyPropertyOnWrite: ProxyPropertyOnWrite22 } = module_support_exports;
var Foreground = class extends module_support_exports.Background {
  constructor() {
    super(...arguments);
    this.image = new Image4();
    this.fill = "transparent";
    this.fillOpacity = void 0;
  }
  createNode() {
    return new module_support_exports.Group({ name: "foreground", zIndex: ZIndexMap6.FOREGROUND });
  }
  onLayoutComplete(event) {
    super.onLayoutComplete(event);
    const { width: width2, height: height2 } = event.chart;
    let placement = {
      x: 0,
      y: 0,
      width: width2,
      height: height2
    };
    if (this.image) {
      placement = this.image.performLayout(width2, height2);
    }
    if (this.text) {
      this.updateTextNode(placement);
    }
  }
  onImageLoad() {
    this.ctx.updateService.update(module_support_exports.ChartUpdateType.SCENE_RENDER);
  }
  updateTextNode(placement) {
    const { textNode } = this;
    textNode.fontWeight = "bold";
    textNode.fontFamily = "Impact, sans-serif";
    textNode.fontSize = 19;
    textNode.opacity = 0.7;
    textNode.fill = "#9b9b9b";
    textNode.textBaseline = "top";
    const textBBox = this.textNode.getBBox();
    const textPadding = 10;
    textNode.x = placement.x + placement.width / 2 - textBBox.width / 2;
    textNode.y = placement.y + placement.height + textPadding;
  }
};
__decorateClass2([
  Property43,
  ActionOnSet6({
    newValue(image) {
      this.node.appendChild(image.node);
      image.onLoad = () => this.onImageLoad();
    },
    oldValue(image) {
      this.node.removeChild(image.node);
      image.onLoad = void 0;
    }
  })
], Foreground.prototype, "image", 2);
__decorateClass2([
  Property43,
  ProxyPropertyOnWrite22("rectNode", "fill")
], Foreground.prototype, "fill", 2);
__decorateClass2([
  Property43,
  ProxyPropertyOnWrite22("rectNode", "fillOpacity")
], Foreground.prototype, "fillOpacity", 2);
var ForegroundModule = {
  type: "root",
  optionsKey: "foreground",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  moduleFactory: (ctx) => new Foreground(ctx)
};
var { TranslatableGroup: TranslatableGroup3, SceneChangeDetection: SceneChangeDetection2 } = module_support_exports;
var MiniChartGroup = class extends TranslatableGroup3 {
  constructor() {
    super(...arguments);
    this.inset = 0;
    this.cornerRadius = 0;
  }
  applyClip(ctx, clipRect) {
    const { cornerRadius, inset } = this;
    const { x, y, width: width2, height: height2 } = clipRect;
    const path = new Path2D();
    path.roundRect(x + inset, y + inset, width2 - 2 * inset, height2 - 2 * inset, cornerRadius);
    ctx.clip(path);
  }
};
__decorateClass2([
  SceneChangeDetection2()
], MiniChartGroup.prototype, "inset", 2);
__decorateClass2([
  SceneChangeDetection2()
], MiniChartGroup.prototype, "cornerRadius", 2);
var { Property: Property44, ZIndexMap: ZIndexMap7, ActionOnSet: ActionOnSet7, CategoryAxis: CategoryAxis2, TextUtils: TextUtils22, Padding: Padding2, Group: Group6, BBox: BBox7, ProxyProperty: ProxyProperty22 } = module_support_exports;
var MiniChartPadding = class {
  constructor() {
    this.top = 0;
    this.bottom = 0;
  }
};
__decorateClass2([
  Property44
], MiniChartPadding.prototype, "top", 2);
__decorateClass2([
  Property44
], MiniChartPadding.prototype, "bottom", 2);
var MiniChart = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.padding = new MiniChartPadding();
    this.root = new Group6({ name: "root" });
    this.seriesRoot = this.root.appendChild(
      new MiniChartGroup({ name: "Series-root", zIndex: ZIndexMap7.SERIES_LAYER, renderToOffscreenCanvas: true })
    );
    this.axisGridGroup = this.root.appendChild(new Group6({ name: "Axes-Grids", zIndex: ZIndexMap7.AXIS_GRID }));
    this.axisGroup = this.root.appendChild(new Group6({ name: "Axes-Grids", zIndex: ZIndexMap7.AXIS_GRID }));
    this.axisLabelGroup = this.root.appendChild(new Group6({ name: "Axes-Labels", zIndex: ZIndexMap7.SERIES_LABEL }));
    this.axisCrosslineRangeGroup = this.root.appendChild(
      new Group6({ name: "Axes-Crosslines-Range", zIndex: ZIndexMap7.SERIES_CROSSLINE_RANGE })
    );
    this.axisCrosslineLineGroup = this.root.appendChild(
      new Group6({ name: "Axes-Crosslines-Line", zIndex: ZIndexMap7.SERIES_CROSSLINE_LINE })
    );
    this.axisCrosslineLabelGroup = this.root.appendChild(
      new Group6({ name: "Axes-Crosslines-Label", zIndex: ZIndexMap7.SERIES_LABEL })
    );
    this.data = [];
    this._destroyed = false;
    this.miniChartAnimationPhase = "initial";
    this.axes = [];
    this.series = [];
  }
  destroy() {
    if (this._destroyed) {
      return;
    }
    this.destroySeries(this.series);
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this._destroyed = true;
  }
  onSeriesChange(newValue, oldValue) {
    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];
    this.destroySeries(seriesToDestroy);
    for (const series of newValue) {
      if (oldValue?.includes(series))
        continue;
      series.attachSeries(this.seriesRoot, this.seriesRoot, void 0);
      const chart = this;
      series.chart = {
        get mode() {
          return "standalone";
        },
        get isMiniChart() {
          return true;
        },
        get seriesRect() {
          return chart.seriesRect;
        }
      };
      series.resetAnimation(this.miniChartAnimationPhase === "initial" ? "initial" : "disabled");
    }
  }
  destroySeries(allSeries) {
    allSeries?.forEach((series) => {
      series.destroy();
      series.detachSeries(this.seriesRoot, this.seriesRoot, void 0);
      series.chart = void 0;
    });
  }
  assignSeriesToAxes() {
    this.axes.forEach((axis) => {
      axis.boundSeries = this.series.filter((s) => {
        const seriesAxis = s.axes[axis.direction];
        return seriesAxis === axis;
      });
    });
  }
  assignAxesToSeries() {
    const directionToAxesMap = {};
    this.axes.forEach((axis) => {
      const direction = axis.direction;
      const directionAxes = directionToAxesMap[direction] ?? (directionToAxesMap[direction] = []);
      directionAxes.push(axis);
    });
    this.series.forEach((series) => {
      series.directions.forEach((direction) => {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          logger_exports.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);
        if (!newAxis) {
          logger_exports.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      });
    });
  }
  findMatchingAxis(directionAxes, directionKeys) {
    for (const axis of directionAxes) {
      if (!axis.keys.length) {
        return axis;
      }
      if (!directionKeys) {
        continue;
      }
      for (const directionKey of directionKeys) {
        if (axis.keys.includes(directionKey)) {
          return axis;
        }
      }
    }
  }
  updateData(data) {
    this.series.forEach((s) => s.setChartData(data));
    if (this.miniChartAnimationPhase === "initial") {
      this.ctx.animationManager.onBatchStop(() => {
        this.miniChartAnimationPhase = "ready";
        this.series.forEach((s) => s.resetAnimation("disabled"));
      });
    }
  }
  async processData(dataController) {
    if (this.series.some((s) => s.canHaveAxes)) {
      this.assignAxesToSeries();
      this.assignSeriesToAxes();
    }
    await Promise.all(
      this.series.map((s) => {
        s.resetDatumCallbackCache();
        return s.processData(dataController);
      })
    );
    for (const axis of this.axes) {
      axis.processData();
    }
  }
  computeAxisPadding() {
    const padding2 = new Padding2();
    if (!this.enabled) {
      return padding2;
    }
    this.axes.forEach(({ position, thickness, line, label }) => {
      if (position == null)
        return;
      let size;
      if (thickness) {
        size = thickness;
      } else {
        size = (line.enabled ? line.width : 0) + (label.enabled ? TextUtils22.getLineHeight(label.fontSize ?? 0) + label.spacing : 0);
      }
      padding2[position] = Math.ceil(size);
    });
    return padding2;
  }
  async layout(width2, height2) {
    const { padding: padding2 } = this;
    const animated = this.seriesRect != null;
    const seriesRect = new BBox7(0, 0, width2, height2 - (padding2.top + padding2.bottom));
    this.seriesRect = seriesRect;
    this.seriesRoot.translationY = padding2.top;
    this.seriesRoot.setClipRectCanvasSpace(new BBox7(0, -padding2.top, width2, height2));
    this.axes.forEach((axis) => {
      const { position = "left" } = axis;
      switch (position) {
        case "top":
        case "bottom":
          axis.range = [0, seriesRect.width];
          axis.gridLength = seriesRect.height;
          break;
        case "right":
        case "left": {
          const isCategoryAxis = axis instanceof CategoryAxis2;
          axis.range = isCategoryAxis ? [0, seriesRect.height] : [seriesRect.height, 0];
          axis.gridLength = seriesRect.width;
          break;
        }
      }
      axis.gridPadding = 0;
      axis.translation.x = 0;
      axis.translation.y = 0;
      if (position === "right") {
        axis.translation.x = width2;
      } else if (position === "bottom") {
        axis.translation.y = height2;
      }
      if (!animated) {
        axis.resetAnimation("initial");
      }
      axis.calculateLayout();
      axis.update();
    });
    await Promise.all(this.series.map((series) => series.update({ seriesRect })));
  }
};
__decorateClass2([
  Property44
], MiniChart.prototype, "enabled", 2);
__decorateClass2([
  ProxyProperty22(["seriesRoot", "inset"])
], MiniChart.prototype, "inset", 2);
__decorateClass2([
  ProxyProperty22(["seriesRoot", "cornerRadius"])
], MiniChart.prototype, "cornerRadius", 2);
__decorateClass2([
  ActionOnSet7({
    changeValue(newValue, oldValue = []) {
      const axisNodes = {
        axisNode: this.axisGroup,
        gridNode: this.axisGridGroup,
        labelNode: this.axisLabelGroup,
        crossLineLineNode: this.axisCrosslineLineGroup,
        crossLineRangeNode: this.axisCrosslineRangeGroup,
        crossLineLabelNode: this.axisCrosslineLabelGroup
      };
      for (const axis of oldValue) {
        if (newValue.includes(axis))
          continue;
        axis.detachAxis(axisNodes);
        axis.destroy();
      }
      for (const axis of newValue) {
        if (oldValue?.includes(axis))
          continue;
        axis.attachAxis(axisNodes);
      }
    }
  })
], MiniChart.prototype, "axes", 2);
__decorateClass2([
  ActionOnSet7({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], MiniChart.prototype, "series", 2);
var { SliderWidget: SliderWidget2 } = module_support_exports;
var NavigatorDOMProxy = class {
  constructor(ctx, sliderHandlers) {
    this.ctx = ctx;
    this.sliderHandlers = sliderHandlers;
    this._min = 0;
    this._max = 1;
    this.minRange = 1e-3;
    this.dragStartX = 0;
    this.ctx = ctx;
    this.toolbar = ctx.proxyInteractionService.createProxyContainer({
      type: "toolbar",
      domManagerId: `navigator-toolbar`,
      classList: ["ag-charts-proxy-navigator-toolbar"],
      orientation: "vertical",
      ariaLabel: { id: "ariaLabelNavigator" }
    });
    this.sliders = [
      ctx.proxyInteractionService.createProxyElement({
        type: "slider",
        domIndex: 1,
        ariaLabel: { id: "ariaLabelNavigatorMinimum" },
        parent: this.toolbar,
        cursor: "ew-resize"
      }),
      ctx.proxyInteractionService.createProxyElement({
        type: "slider",
        domIndex: -Infinity,
        ariaLabel: { id: "ariaLabelNavigatorRange" },
        parent: this.toolbar,
        cursor: "grab"
      }),
      ctx.proxyInteractionService.createProxyElement({
        type: "slider",
        domIndex: 2,
        ariaLabel: { id: "ariaLabelNavigatorMaximum" },
        parent: this.toolbar,
        cursor: "ew-resize"
      })
    ];
    for (const [index, key] of ["min", "pan", "max"].entries()) {
      const slider = this.sliders[index];
      slider.step = SliderWidget2.STEP_HUNDRETH;
      slider.keyboardStep = SliderWidget2.STEP_ONE;
      slider.orientation = "horizontal";
      slider.setPreventsDefault(false);
      slider.addListener("drag-start", (ev) => this.onDragStart(index, ev, key));
      slider.addListener("drag-move", (ev) => this.onDrag(slider, ev, key));
      slider.addListener("drag-end", () => this.updateSliderRatios());
      slider.addListener("contextmenu", (ev) => this.onContextMenu(slider, ev));
    }
    this.sliders[0].addListener("change", () => this.onMinSliderChange());
    this.sliders[1].addListener("change", () => this.onPanSliderChange());
    this.sliders[2].addListener("change", () => this.onMaxSliderChange());
    this.updateSliderRatios();
    this.updateVisibility(false);
  }
  destroy() {
    this.toolbar.destroy();
  }
  updateVisibility(visible) {
    this.toolbar.setHidden(!visible);
  }
  updateZoom() {
    const { _min: min, _max: max } = this;
    if (min == null || max == null)
      return;
    return this.ctx.zoomManager.updateZoom("navigator", { x: { min, max } });
  }
  updateBounds(bounds) {
    this.toolbar.setBounds(bounds);
  }
  updateSliderBounds(sliderIndex, bounds) {
    this.sliders[sliderIndex].setBounds(bounds);
  }
  updateMinMax(min, max) {
    this._min = min;
    this._max = max;
    this.updateSliderRatios();
  }
  updateSliderRatios() {
    let { _min: min, _max: max } = this;
    min = Math.round(min * 100) / 100;
    max = Math.round(max * 100) / 100;
    const panAria = this.ctx.localeManager.t("ariaValuePanRange", { min, max });
    this.sliders[0].setValueRatio(min);
    this.sliders[1].setValueRatio(min, { ariaValueText: panAria });
    this.sliders[2].setValueRatio(max);
  }
  toCanvasOffsets(event) {
    return { offsetX: this.dragStartX + event.originDeltaX };
  }
  moveToFront(index) {
    if (index === 1)
      return;
    const frontSlider = this.sliders[index];
    const otherSlider = this.sliders[2 - index];
    this.toolbar.moveChild(otherSlider, frontSlider.domIndex - 1);
  }
  onDragStart(index, event, key) {
    const slider = this.sliders[index];
    const toolbarLeft = this.toolbar.cssLeft();
    const sliderLeft = slider.cssLeft();
    this.dragStartX = toolbarLeft + sliderLeft + event.offsetX;
    this.moveToFront(index);
    event.sourceEvent.preventDefault();
    this.sliderHandlers.onDragStart(key, this.toCanvasOffsets(event));
  }
  onDrag(_slider, event, key) {
    event.sourceEvent.preventDefault();
    this.sliderHandlers.onDrag(key, this.toCanvasOffsets(event));
  }
  onContextMenu(slider, widgetEvent) {
    const { offsetX, offsetY } = widgetEvent;
    const { x: toolbarX, y: toolbarY } = this.toolbar.getBounds();
    const { x: sliderX, y: sliderY } = slider.getBounds();
    const canvasX = offsetX + toolbarX + sliderX;
    const canvasY = offsetY + toolbarY + sliderY;
    this.ctx.contextMenuRegistry.dispatchContext("always", { widgetEvent, canvasX, canvasY }, void 0);
  }
  onPanSliderChange() {
    const ratio3 = this.sliders[1].getValueRatio();
    const span = this._max - this._min;
    this._min = clamp(0, ratio3, 1 - span);
    this._max = this._min + span;
    this.updateZoom();
  }
  onMinSliderChange() {
    this._min = this.sliders[0].clampValueRatio(0, this._max - this.minRange);
    this.updateZoom();
  }
  onMaxSliderChange() {
    this._max = this.sliders[2].clampValueRatio(this._min + this.minRange, 1);
    this.updateZoom();
  }
};
var { Property: Property45, SceneChangeDetection: SceneChangeDetection22, BBox: BBox8, ExtendedPath2D: ExtendedPath2D2 } = module_support_exports;
var RangeHandle = class extends module_support_exports.Path {
  constructor() {
    super(...arguments);
    this.zIndex = 3;
    this.centerX = 0;
    this.centerY = 0;
    this.width = 8;
    this.height = 16;
    this.cornerRadius = 4;
    this.grip = true;
    this.gripPath = new ExtendedPath2D2();
  }
  setCenter(x, y) {
    this.dirtyPath = true;
    if (this.centerX !== x || this.centerY !== y) {
      this.centerX = x;
      this.centerY = y;
      this.markDirty("center");
    }
  }
  static align(minHandle, maxHandle, x, y, width2, height2, min, max, pixelAlign) {
    const minHandleX = minHandle.align(x + width2 * min) + pixelAlign;
    const maxHandleX = minHandleX + minHandle.align(x + width2 * min, width2 * (max - min)) - 2 * pixelAlign;
    const handleY = minHandle.align(y + height2 / 2);
    minHandle.setCenter(minHandleX, handleY);
    maxHandle.setCenter(maxHandleX, handleY);
  }
  computeBBox() {
    const { centerX, centerY, width: width2, height: height2 } = this;
    const x = centerX - width2 / 2;
    const y = centerY - height2 / 2;
    return new BBox8(x, y, width2, height2);
  }
  isPointInPath(x, y) {
    const bbox = this.getBBox();
    return bbox.containsPoint(x, y);
  }
  updatePath() {
    const { centerX, centerY, path, gripPath, strokeWidth, cornerRadius, grip } = this;
    const pixelAlign = strokeWidth / 2;
    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
    path.clear();
    gripPath.clear();
    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;
    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;
    path.roundRect(
      centerX - halfWidth + pixelAlign,
      centerY - halfHeight + pixelAlign,
      2 * (halfWidth - pixelAlign),
      2 * (halfHeight - pixelAlign),
      cornerRadius
    );
    const gripSpacing = 3;
    if (grip) {
      for (let x = -0.5; x <= 0.5; x += 1) {
        for (let y = -1; y <= 1; y += 1) {
          gripPath.arc(centerX + x * gripSpacing, centerY + y * gripSpacing, 1, 0, 2 * Math.PI);
          gripPath.closePath();
        }
      }
    }
  }
  renderFill(ctx, path) {
    const { stroke: stroke22 } = this;
    super.renderFill(ctx, path);
    ctx.fillStyle = typeof stroke22 === "string" ? stroke22 : "black";
    ctx.fill(this.gripPath.getPath2D());
  }
};
RangeHandle.className = "RangeHandle";
__decorateClass2([
  Property45,
  SceneChangeDetection22()
], RangeHandle.prototype, "width", 2);
__decorateClass2([
  Property45,
  SceneChangeDetection22()
], RangeHandle.prototype, "height", 2);
__decorateClass2([
  Property45,
  SceneChangeDetection22()
], RangeHandle.prototype, "cornerRadius", 2);
__decorateClass2([
  Property45,
  SceneChangeDetection22()
], RangeHandle.prototype, "grip", 2);
var { Path: Path6, BBox: BBox9, ExtendedPath2D: ExtendedPath2D22, clippedRoundRect: clippedRoundRect2, Property: Property46, SceneChangeDetection: SceneChangeDetection3 } = module_support_exports;
var RangeMask = class extends Path6 {
  constructor() {
    super(...arguments);
    this.cornerRadius = 4;
    this.zIndex = 2;
    this.x = 0;
    this.y = 0;
    this.width = 200;
    this.height = 30;
    this.min = 0;
    this.max = 1;
    this.visiblePath = new ExtendedPath2D22();
  }
  layout(x, y, width2, height2, min, max) {
    min = isNaN(min) ? this.min : min;
    max = isNaN(max) ? this.max : max;
    if (x !== this.x || y !== this.y || width2 !== this.width || this.height !== height2 || min !== this.min || max !== this.max) {
      this.x = x;
      this.y = y;
      this.width = width2;
      this.height = height2;
      this.min = min;
      this.max = max;
      this.dirtyPath = true;
      this.markDirty("RangeMask.layout");
    }
  }
  computeBBox() {
    const { x, y, width: width2, height: height2 } = this;
    return new BBox9(x, y, width2, height2);
  }
  computeVisibleRangeBBox() {
    const { x, y, width: width2, height: height2, min, max } = this;
    const minX = x + width2 * min;
    const maxX = x + width2 * max;
    return new BBox9(minX, y, maxX - minX, height2);
  }
  updatePath() {
    const { path, visiblePath, x, y, width: width2, height: height2, min, max, strokeWidth, cornerRadius } = this;
    const pixelAlign = strokeWidth / 2;
    path.clear();
    visiblePath.clear();
    const ax = this.align(x) + pixelAlign;
    const ay = this.align(y) + pixelAlign;
    const aw = this.align(x, width2) - 2 * pixelAlign;
    const ah = this.align(y, height2) - 2 * pixelAlign;
    const minX = this.align(x + width2 * min) + pixelAlign;
    const maxX = minX + this.align(x + width2 * min, width2 * (max - min)) - 2 * pixelAlign;
    const cornerRadiusParams = {
      topLeft: cornerRadius,
      topRight: cornerRadius,
      bottomRight: cornerRadius,
      bottomLeft: cornerRadius
    };
    const drawRect = (p, x0, x1) => {
      if (x1 - x0 < 1)
        return;
      const bbox = new BBox9(x0, ay, x1 - x0, ah);
      clippedRoundRect2(p, ax, ay, aw, ah, cornerRadiusParams, bbox);
    };
    drawRect(path, ax, minX);
    drawRect(path, maxX, aw + ax);
    drawRect(visiblePath, minX, maxX);
  }
  renderStroke(ctx, path) {
    super.renderStroke(ctx, path);
    super.renderStroke(ctx, this.visiblePath.getPath2D());
  }
};
RangeMask.className = "RangeMask";
__decorateClass2([
  Property46,
  SceneChangeDetection3()
], RangeMask.prototype, "cornerRadius", 2);
var RangeSelector = class extends module_support_exports.Group {
  constructor(children) {
    super({ name: "rangeSelectorGroup", zIndex: module_support_exports.ZIndexMap.NAVIGATOR });
    this.x = 0;
    this.y = 0;
    this.width = 200;
    this.height = 30;
    this.lOffset = 0;
    this.rOffset = 0;
    this.background = this.appendChild(
      new module_support_exports.TranslatableGroup({ name: "navigator-background", zIndex: 1 })
    );
    this.append(children);
  }
  layout(x, y, width2, height2, lOffset, rOffset) {
    this.x = x;
    this.y = y;
    this.width = width2;
    this.height = height2;
    this.lOffset = lOffset;
    this.rOffset = rOffset;
    this.background.translationX = x;
    this.background.translationY = y;
    this.markDirty("RangeSelector");
  }
  updateBackground(oldGroup, newGroup) {
    if (oldGroup != null) {
      this.background.removeChild(oldGroup);
    }
    if (newGroup != null) {
      this.background.appendChild(newGroup);
    }
    this.markDirty("RangeSelector");
  }
  computeBBox() {
    const { x, y, width: width2, height: height2, lOffset, rOffset } = this;
    return new module_support_exports.BBox(x - lOffset, y, width2 + (lOffset + rOffset), height2);
  }
};
var { BaseModuleInstance: BaseModuleInstance22, ObserveChanges: ObserveChanges3, Property: Property47 } = module_support_exports;
var Navigator = class extends BaseModuleInstance22 {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.mask = new RangeMask();
    this.minHandle = new RangeHandle();
    this.maxHandle = new RangeHandle();
    this.maskVisibleRange = {
      id: "navigator-mask-visible-range",
      getBBox: () => this.mask.computeVisibleRangeBBox(),
      toCanvasBBox: () => this.mask.computeVisibleRangeBBox(),
      fromCanvasPoint: (x, y) => ({ x, y })
    };
    this.height = 30;
    this.cornerRadius = 0;
    this.spacing = 10;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);
    this.cleanup.register(
      ctx.scene.attachNode(this.rangeSelector),
      ctx.eventsHub.on("locale:change", () => this.updateZoom()),
      ctx.layoutManager.registerElement(module_support_exports.LayoutElement.Navigator, (e) => this.onLayoutStart(e)),
      ctx.eventsHub.on("layout:complete", (e) => this.onLayoutComplete(e)),
      ctx.eventsHub.on("zoom:change", (event) => this.onZoomChange(event))
    );
    this.domProxy = new NavigatorDOMProxy(ctx, this);
    this.updateGroupVisibility();
    this.miniChart = new MiniChart(ctx);
  }
  updateBackground(oldGroup, newGroup) {
    this.rangeSelector?.updateBackground(oldGroup, newGroup);
  }
  updateGroupVisibility() {
    const { enabled } = this;
    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)
      return;
    this.rangeSelector.visible = enabled;
    this.domProxy.updateVisibility(enabled);
    if (enabled) {
      this.updateZoom();
    } else {
      this.ctx.zoomManager.updateZoom("navigator");
    }
  }
  onLayoutStart(ctx) {
    if (this.enabled) {
      const { layoutBox } = ctx;
      const navigatorTotalHeight = this.height + this.spacing;
      layoutBox.shrink(navigatorTotalHeight, "bottom");
      this.y = layoutBox.y + layoutBox.height + this.spacing;
    } else {
      this.y = 0;
    }
    if (this.enabled && this.miniChart) {
      const { top, bottom } = this.miniChart.computeAxisPadding();
      ctx.layoutBox.shrink(top + bottom, "bottom");
      this.y -= bottom;
      this.miniChart.inset = this.mask.strokeWidth / 2;
      this.miniChart.cornerRadius = this.mask.cornerRadius;
    }
  }
  onLayoutComplete(opts) {
    const { x, width: width2 } = opts.series.rect;
    const { y, height: height2 } = this;
    this.domProxy.updateVisibility(this.enabled);
    if (this.enabled) {
      const { _min: min, _max: max } = this.domProxy;
      this.layoutNodes(x, y, width2, height2, min, max);
      this.domProxy.updateBounds({ x, y, width: width2, height: height2 });
    }
    this.x = x;
    this.width = width2;
    this.miniChart?.layout(width2, height2).catch((e) => logger_exports.error(e));
  }
  canDrag() {
    return this.enabled && this.ctx.interactionManager.isState(module_support_exports.InteractionState.ZoomDraggable);
  }
  onDragStart(dragging, { offsetX }) {
    if (!this.canDrag())
      return;
    if (dragging === "pan") {
      this.panStart = (offsetX - this.x) / this.width - this.domProxy._min;
    }
    this.ctx.zoomManager.fireZoomPanStartEvent("navigator");
  }
  onDrag(dragging, { offsetX }) {
    if (!this.canDrag())
      return;
    const { panStart, x, width: width2 } = this;
    const { minRange } = this.domProxy;
    let { _min: min, _max: max } = this.domProxy;
    const ratio3 = (offsetX - x) / width2;
    if (dragging === "min") {
      min = clamp(0, ratio3, max - minRange);
    } else if (dragging === "max") {
      max = clamp(min + minRange, ratio3, 1);
    } else if (dragging === "pan" && panStart != null) {
      const span = max - min;
      min = clamp(0, ratio3 - panStart, 1 - span);
      max = min + span;
    }
    this.domProxy._min = min;
    this.domProxy._max = max;
    this.updateZoom();
  }
  onZoomChange(event) {
    const { x: xZoom } = event;
    if (!xZoom)
      return;
    const { x, y, width: width2, height: height2 } = this;
    const { min, max } = xZoom;
    this.domProxy.updateMinMax(min, max);
    this.layoutNodes(x, y, width2, height2, min, max);
  }
  layoutNodes(x, y, width2, height2, min, max) {
    const { rangeSelector, mask, minHandle, maxHandle } = this;
    mask.layout(x, y, width2, height2, min, max);
    rangeSelector.layout(x, y, width2, height2, minHandle.width / 2, maxHandle.width / 2);
    RangeHandle.align(minHandle, maxHandle, x, y, width2, height2, min, max, mask.strokeWidth / 2);
    if (min + (max - min) / 2 < 0.5) {
      minHandle.zIndex = 3;
      maxHandle.zIndex = 4;
    } else {
      minHandle.zIndex = 4;
      maxHandle.zIndex = 3;
    }
    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {
      const bbox = node.getBBox();
      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };
      this.domProxy.updateSliderBounds(index, tbox);
    });
  }
  updateZoom() {
    if (!this.enabled)
      return;
    this.domProxy.updateZoom();
  }
  updateData(data) {
    return this.miniChart?.updateData(data);
  }
  async processData(dataController) {
    if (this.miniChart) {
      return this.miniChart?.processData(dataController);
    }
  }
};
__decorateClass2([
  ObserveChanges3((target, value, oldValue) => {
    target.updateBackground(oldValue?.root, value?.root);
  })
], Navigator.prototype, "miniChart", 2);
__decorateClass2([
  Property47,
  ObserveChanges3((target, value) => {
    target.ctx.zoomManager.setNavigatorEnabled(Boolean(value));
    target.updateGroupVisibility();
  })
], Navigator.prototype, "enabled", 2);
__decorateClass2([
  Property47
], Navigator.prototype, "height", 2);
__decorateClass2([
  Property47,
  ObserveChanges3((target, value) => {
    target.mask.cornerRadius = value;
  })
], Navigator.prototype, "cornerRadius", 2);
__decorateClass2([
  Property47
], Navigator.prototype, "spacing", 2);
function prepareBoxPlotFromTo(isVertical) {
  const from3 = isVertical ? { scalingX: 1, scalingY: 0 } : { scalingX: 0, scalingY: 1 };
  const to = { scalingX: 1, scalingY: 1 };
  return { from: from3, to };
}
function resetBoxPlotSelectionsScalingCenterFn(isVertical) {
  return (_node, datum) => {
    if (isVertical) {
      return { scalingCenterY: datum.scaledValues.medianValue };
    }
    return { scalingCenterX: datum.scaledValues.medianValue };
  };
}
var { ScalableGroup: ScalableGroup2, Rect: Rect2, Line: Line5, BBox: BBox10, Selection: Selection4, applyShapeFillBBox: applyShapeFillBBox2 } = module_support_exports;
var BoxPlotGroup = class extends ScalableGroup2 {
  constructor() {
    super();
    this.append([
      new Rect2({
        tag: 0
        /* Box */
      }),
      new Rect2({
        tag: 2
        /* Outline */
      }),
      new Rect2({
        tag: 1
        /* Median */
      }),
      new Line5({
        tag: 3
        /* Whisker */
      }),
      new Line5({
        tag: 3
        /* Whisker */
      }),
      new Line5({
        tag: 4
        /* Cap */
      }),
      new Line5({
        tag: 4
        /* Cap */
      })
    ]);
  }
  updateDatumStyles(datum, activeStyles, isVertical, isReversedValueAxis, fillBBox) {
    const {
      bandwidth,
      scaledValues: { xValue: axisValue, medianValue }
    } = datum;
    let { minValue, q1Value, q3Value, maxValue } = datum.scaledValues;
    if (isVertical && !isReversedValueAxis || !isVertical && isReversedValueAxis) {
      [maxValue, q3Value, q1Value, minValue] = [minValue, q1Value, q3Value, maxValue];
    }
    const position = (x, y, width2, height2) => isVertical ? { y: x, x: y, width: height2, height: width2 } : { x, y, width: width2, height: height2 };
    const hPosition = (x1, x2, y) => isVertical ? { y1: x1, y2: x2, x: y } : { x1, x2, y };
    const vPosition = (x, y1, y2) => isVertical ? { x1: y1, x2: y2, y: x } : { x, y1, y2 };
    const bbox = (x, y, width2, height2) => {
      ({ x, y, width: width2, height: height2 } = position(x, y, width2, height2));
      return new BBox10(x, y, width2, height2);
    };
    const {
      opacity,
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      cap,
      whisker: whiskerStyles
    } = activeStyles;
    this.opacity = opacity ?? 1;
    const selection = Selection4.select(this, Rect2);
    const [box] = selection.selectByTag(
      0
      /* Box */
    );
    const [outline] = selection.selectByTag(
      2
      /* Outline */
    );
    const [median] = selection.selectByTag(
      1
      /* Median */
    );
    const whiskers = selection.selectByTag(
      3
      /* Whisker */
    );
    const caps = selection.selectByTag(
      4
      /* Cap */
    );
    if (whiskerStyles.strokeWidth > bandwidth) {
      whiskerStyles.strokeWidth = bandwidth;
    }
    const boxesPosition = position(q1Value, axisValue, q3Value - q1Value, bandwidth);
    outline.setProperties(boxesPosition);
    box.setProperties(boxesPosition);
    box.setProperties({
      cornerRadius
    });
    const medianStart = Math.max(Math.round(medianValue - strokeWidth / 2), q1Value + strokeWidth);
    const medianEnd = Math.min(Math.round(medianValue + strokeWidth / 2), q3Value - strokeWidth);
    median.setProperties(boxesPosition);
    median.setProperties({
      visible: medianStart < medianEnd,
      cornerRadius,
      clipBBox: bbox(
        medianStart,
        axisValue + strokeWidth,
        medianEnd - medianStart,
        Math.max(0, bandwidth - strokeWidth * 2)
      )
    });
    const capStart = Math.floor(axisValue + bandwidth * (1 - cap.lengthRatio) / 2);
    const capEnd = Math.ceil(axisValue + bandwidth * (1 + cap.lengthRatio) / 2);
    caps[0].setProperties(vPosition(minValue, capStart, capEnd));
    caps[1].setProperties(vPosition(maxValue, capStart, capEnd));
    whiskers[0].setProperties(
      hPosition(
        Math.round(minValue + whiskerStyles.strokeWidth / 2),
        q1Value,
        Math.floor(axisValue + bandwidth / 2)
      )
    );
    whiskers[1].setProperties(
      hPosition(
        q3Value,
        Math.round(maxValue - whiskerStyles.strokeWidth / 2),
        Math.floor(axisValue + bandwidth / 2)
      )
    );
    applyShapeFillBBox2(box, fill, fillBBox);
    box.setProperties({
      fill,
      fillOpacity,
      strokeWidth: strokeWidth * 2,
      strokeOpacity: 0
    });
    median.setProperties({ fill: stroke22, fillOpacity: strokeOpacity, strokeWidth: 0 });
    for (const element2 of [...whiskers, ...caps]) {
      element2.setProperties(whiskerStyles);
    }
    outline.setProperties({
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      fillOpacity: 0
    });
  }
  distanceSquared(x, y) {
    const nodes = Selection4.selectByClass(this, Rect2, Line5);
    return module_support_exports.nearestSquared(x, y, nodes).distanceSquared;
  }
  get midPoint() {
    const datum = this.datum;
    if (datum.midPoint === void 0) {
      logger_exports.error("BoxPlotGroup.datum.midPoint is undefined");
      return { x: NaN, y: NaN };
    }
    return datum.midPoint;
  }
};
var {
  BaseProperties: BaseProperties15,
  FillGradientDefaults: FillGradientDefaults22,
  FillPatternDefaults: FillPatternDefaults22,
  FillImageDefaults: FillImageDefaults22,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties2,
  makeSeriesTooltip: makeSeriesTooltip2,
  Property: Property48,
  mergeDefaults: mergeDefaults3
} = module_support_exports;
var BoxPlotSeriesCap = class extends BaseProperties15 {
  constructor() {
    super(...arguments);
    this.lengthRatio = 0.5;
  }
};
__decorateClass2([
  Property48
], BoxPlotSeriesCap.prototype, "lengthRatio", 2);
var BoxPlotSeriesWhisker = class extends BaseProperties15 {
};
__decorateClass2([
  Property48
], BoxPlotSeriesWhisker.prototype, "stroke", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesWhisker.prototype, "strokeWidth", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesWhisker.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesWhisker.prototype, "lineDash", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesWhisker.prototype, "lineDashOffset", 2);
var BoxPlotSeriesProperties = class extends AbstractBarSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults22();
    this.fillPatternDefaults = new FillPatternDefaults22();
    this.fillImageDefaults = new FillImageDefaults22();
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.cap = new BoxPlotSeriesCap();
    this.whisker = new BoxPlotSeriesWhisker();
    this.tooltip = makeSeriesTooltip2();
  }
  toJson() {
    const { stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    const properties = super.toJson();
    properties.whisker = mergeDefaults3(properties.whisker, {
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return properties;
  }
  getStyle() {
    const {
      fill,
      fillOpacity,
      strokeWidth,
      strokeOpacity,
      stroke: stroke22,
      lineDash,
      lineDashOffset,
      cornerRadius,
      cap,
      whisker
    } = this;
    return {
      fill,
      fillOpacity,
      strokeWidth,
      strokeOpacity,
      stroke: stroke22,
      lineDash,
      lineDashOffset,
      cornerRadius,
      cap,
      whisker,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "xKey", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "minKey", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "q1Key", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "medianKey", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "q3Key", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "maxKey", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "xName", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "yName", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "minName", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "q1Name", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "medianName", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "q3Name", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "maxName", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "cap", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "whisker", 2);
__decorateClass2([
  Property48
], BoxPlotSeriesProperties.prototype, "tooltip", 2);
var {
  fixNumericExtent: fixNumericExtent22,
  keyProperty: keyProperty22,
  mergeDefaults: mergeDefaults4,
  SeriesNodePickMode: SeriesNodePickMode2,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL2,
  valueProperty: valueProperty3,
  diff: diff2,
  animationValidation: animationValidation2,
  computeBarFocusBounds: computeBarFocusBounds2,
  createDatumId: createDatumId2,
  ContinuousScale: ContinuousScale4,
  ChartAxisDirection: ChartAxisDirection13,
  motion: motion2,
  getShapeStyle: getShapeStyle2
} = module_support_exports;
var BoxPlotSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.minKey = series.properties.minKey;
    this.q1Key = series.properties.q1Key;
    this.medianKey = series.properties.medianKey;
    this.q3Key = series.properties.q3Key;
    this.maxKey = series.properties.maxKey;
  }
};
var BoxPlotSeries = class extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode2.NEAREST_NODE, SeriesNodePickMode2.EXACT_SHAPE_MATCH],
      propertyKeys: {
        x: ["xKey"],
        y: ["medianKey", "q1Key", "q3Key", "minKey", "maxKey"]
      },
      propertyNames: {
        x: ["xName"],
        y: ["medianName", "q1Name", "q3Name", "minName", "maxName"]
      },
      categoryKey: "xValue",
      pathsPerSeries: []
    });
    this.properties = new BoxPlotSeriesProperties();
    this.NodeEvent = BoxPlotSeriesNodeEvent;
  }
  async processData(dataController) {
    if (!this.visible)
      return;
    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (animationEnabled && this.processedData) {
      extraProps.push(diff2(this.id, this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation2());
    }
    const { processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty22(xKey, xScaleType, { id: `xValue` }),
        valueProperty3(minKey, yScaleType, { id: `minValue` }),
        valueProperty3(q1Key, yScaleType, { id: `q1Value` }),
        valueProperty3(medianKey, yScaleType, { id: `medianValue` }),
        valueProperty3(q3Key, yScaleType, { id: `q3Value` }),
        valueProperty3(maxKey, yScaleType, { id: `maxValue` }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL2] : [],
        ...extraProps
      ]
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    if (direction !== this.getBarDirection()) {
      const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = processedData.domain.keys[index];
      if (def.type === "key" && def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    }
    const yExtent = this.domainForClippedRange(direction, ["minValue", "maxValue"], "xValue");
    return fixNumericExtent22(yExtent);
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange(ChartAxisDirection13.Y, ["maxValue", "minValue"], "xValue", visibleRange);
  }
  createNodeData() {
    const { visible, dataModel, processedData } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(dataModel && processedData && xAxis && yAxis))
      return;
    const { xKey } = this.properties;
    const nodeData = [];
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const minValues = dataModel.resolveColumnById(this, "minValue", processedData);
    const q1Values = dataModel.resolveColumnById(this, "q1Value", processedData);
    const medianValues = dataModel.resolveColumnById(this, "medianValue", processedData);
    const q3Values = dataModel.resolveColumnById(this, "q3Value", processedData);
    const maxValues = dataModel.resolveColumnById(this, "maxValue", processedData);
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale4.is(xAxis.scale) ? barWidth * -0.5 : 0;
    const { groupScale } = this;
    const isVertical = this.isVertical();
    const context = {
      itemId: xKey,
      nodeData,
      labelData: [],
      scales: this.calculateScaling(),
      groupScale: this.getScaling(this.groupScale),
      visible: this.visible
    };
    if (!visible)
      return context;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const xValue2 = xValues[datumIndex];
      if (xValue2 == null)
        return;
      const minValue = minValues[datumIndex];
      const q1Value = q1Values[datumIndex];
      const medianValue = medianValues[datumIndex];
      const q3Value = q3Values[datumIndex];
      const maxValue = maxValues[datumIndex];
      if ([minValue, q1Value, medianValue, q3Value, maxValue].some((value) => typeof value !== "number") || minValue > q1Value || q1Value > medianValue || medianValue > q3Value || q3Value > maxValue) {
        return;
      }
      const scaledValues = {
        xValue: Math.round(xAxis.scale.convert(xValue2)),
        minValue: Math.round(yAxis.scale.convert(minValue)),
        q1Value: Math.round(yAxis.scale.convert(q1Value)),
        medianValue: Math.round(yAxis.scale.convert(medianValue)),
        q3Value: Math.round(yAxis.scale.convert(q3Value)),
        maxValue: Math.round(yAxis.scale.convert(maxValue))
      };
      scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;
      const bandwidth = Math.round(barWidth);
      const height2 = Math.abs(scaledValues.q3Value - scaledValues.q1Value);
      const midX = scaledValues.xValue + bandwidth / 2;
      const midY = Math.min(scaledValues.q3Value, scaledValues.q1Value) + height2 / 2;
      const midPoint = {
        x: isVertical ? midX : midY,
        y: isVertical ? midY : midX
      };
      let focusRect;
      if (isVertical) {
        focusRect = {
          x: midPoint.x - bandwidth / 2,
          y: scaledValues.minValue,
          width: bandwidth,
          height: scaledValues.maxValue - scaledValues.minValue
        };
      } else {
        focusRect = {
          x: scaledValues.minValue,
          y: midPoint.y - bandwidth / 2,
          width: scaledValues.maxValue - scaledValues.minValue,
          height: bandwidth
        };
      }
      nodeData.push({
        series: this,
        itemId: xValue2,
        datum,
        datumIndex,
        xKey,
        bandwidth,
        scaledValues,
        midPoint,
        focusRect
      });
    });
    return context;
  }
  legendItemSymbol() {
    const {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.properties;
    return {
      marker: getShapeStyle2(
        {
          fill,
          fillOpacity,
          stroke: stroke22,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults5,
        fillPatternDefaults5,
        fillImageDefaults5
      )
    };
  }
  getLegendData(legendType) {
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { xKey, yName, showInLegend, legendItemName } = this.properties;
    if (!xKey || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId: seriesId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: seriesId }),
        label: {
          text: legendItemName ?? yName ?? seriesId
        },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const {
      xKey,
      xName,
      yName,
      medianKey,
      medianName,
      q1Key,
      q1Name,
      q3Key,
      q3Name,
      minKey,
      minName,
      maxKey,
      maxName,
      legendItemName,
      tooltip
    } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const minValue = dataModel.resolveColumnById(this, `minValue`, processedData)[datumIndex];
    const q1Value = dataModel.resolveColumnById(this, `q1Value`, processedData)[datumIndex];
    const medianValue = dataModel.resolveColumnById(this, `medianValue`, processedData)[datumIndex];
    const q3Value = dataModel.resolveColumnById(this, `q3Value`, processedData)[datumIndex];
    const maxValue = dataModel.resolveColumnById(this, `maxValue`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const format = this.getItemStyle({ datumIndex, datum }, false);
    const data = [
      {
        label: minName,
        fallbackLabel: minKey,
        value: this.getAxisValueText(yAxis, "tooltip", minValue, datum, minKey, legendItemName)
      },
      {
        label: q1Name,
        fallbackLabel: q1Key,
        value: this.getAxisValueText(yAxis, "tooltip", q1Value, datum, q1Key, legendItemName)
      },
      {
        label: medianName,
        fallbackLabel: medianKey,
        value: this.getAxisValueText(yAxis, "tooltip", medianValue, datum, medianKey, legendItemName)
      },
      {
        label: q3Name,
        fallbackLabel: q3Key,
        value: this.getAxisValueText(yAxis, "tooltip", q3Value, datum, q3Key, legendItemName)
      },
      {
        label: maxName,
        fallbackLabel: maxKey,
        value: this.getAxisValueText(yAxis, "tooltip", maxValue, datum, maxKey, legendItemName)
      }
    ];
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        title: legendItemName ?? yName,
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yName,
        medianKey,
        medianName,
        q1Key,
        q1Name,
        q3Key,
        q3Name,
        minKey,
        minName,
        maxKey,
        maxName,
        ...format
      }
    );
  }
  animateEmptyUpdateReady({
    datumSelection
  }) {
    const isVertical = this.isVertical();
    const { from: from3, to } = prepareBoxPlotFromTo(isVertical);
    motion2.resetMotion([datumSelection], resetBoxPlotSelectionsScalingCenterFn(isVertical));
    motion2.staticFromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], from3, to, {
      phase: "initial"
    });
  }
  isLabelEnabled() {
    return false;
  }
  updateDatumSelection(opts) {
    const data = opts.nodeData ?? [];
    return opts.datumSelection.update(data);
  }
  getItemStyle({ datumIndex, datum }, isHighlight) {
    const { id: seriesId, properties } = this;
    const {
      xKey,
      minKey,
      q1Key,
      medianKey,
      q3Key,
      maxKey,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5,
      itemStyler
    } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight);
    let style2 = getShapeStyle2(
      mergeDefaults4(highlightStyle, properties.getStyle()),
      fillGradientDefaults5,
      fillPatternDefaults5,
      fillImageDefaults5
    );
    if (itemStyler != null && datumIndex != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId2(datumIndex, isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            xKey,
            minKey,
            q1Key,
            medianKey,
            q3Key,
            maxKey,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle2(
          mergeDefaults4(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    const { stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = style2;
    style2.whisker = mergeDefaults4(style2.whisker, {
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return style2;
  }
  updateDatumNodes({
    datumSelection,
    isHighlight
  }) {
    const isVertical = this.isVertical();
    const isReversedValueAxis = this.getValueAxis()?.isReversed();
    datumSelection.each((boxPlotGroup, nodeDatum) => {
      const style2 = this.getItemStyle(nodeDatum, isHighlight);
      const fillBBox = this.getShapeFillBBox();
      boxPlotGroup.updateDatumStyles(
        nodeDatum,
        style2,
        isVertical,
        isReversedValueAxis,
        fillBBox
      );
    });
  }
  updateLabelNodes() {
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  nodeFactory() {
    return new BoxPlotGroup();
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds2(this, this.contextNodeData?.nodeData[datumIndex].focusRect);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
BoxPlotSeries.className = "BoxPlotSeries";
BoxPlotSeries.type = "box-plot";
var { boxPlotSeriesThemeableOptionsDef: boxPlotSeriesThemeableOptionsDef2, commonSeriesOptionsDefs: commonSeriesOptionsDefs2 } = module_support_exports;
var boxPlotSeriesOptionsDef = {
  ...commonSeriesOptionsDefs2,
  ...boxPlotSeriesThemeableOptionsDef2,
  type: required(constant("box-plot")),
  xKey: required(string),
  minKey: required(string),
  q1Key: required(string),
  medianKey: required(string),
  q3Key: required(string),
  maxKey: required(string),
  xName: string,
  yName: string,
  minName: string,
  q1Name: string,
  medianName: string,
  q3Name: string,
  maxName: string,
  grouped: boolean,
  legendItemName: string
};
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE2 },
  multiSeriesHighlightStyle: multiSeriesHighlightStyle2
} = module_support_exports;
var BOX_PLOT_SERIES_THEME = {
  series: {
    direction: "vertical",
    fill: {
      $if: [
        {
          $or: [
            { $isGradient: { $palette: "fill" } },
            { $isPattern: { $palette: "fill" } },
            { $isImage: { $palette: "fill" } }
          ]
        },
        { $palette: "fill" },
        { $mix: [module_support_exports.SAFE_FILL_OPERATION, { $ref: "chartBackgroundColor" }, 0.7] }
      ]
    },
    stroke: { $palette: "stroke" },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    strokeWidth: 2,
    highlight: multiSeriesHighlightStyle2()
  },
  axes: {
    [CARTESIAN_AXIS_TYPE2.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [CARTESIAN_AXIS_TYPE2.CATEGORY]: {
      groupPaddingInner: 0.2,
      crosshair: {
        enabled: false,
        snap: false
      }
    }
  }
};
var BoxPlotModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "box-plot",
  moduleFactory: (ctx) => new BoxPlotSeries(ctx),
  defaultAxes: module_support_exports.DIRECTION_SWAP_AXES,
  themeTemplate: BOX_PLOT_SERIES_THEME,
  groupable: true
};
var BoxPlotSeriesModule = {
  type: "series",
  name: "box-plot",
  chartType: "cartesian",
  enterprise: true,
  options: boxPlotSeriesOptionsDef,
  create: (ctx) => new BoxPlotSeries(ctx)
};
var {
  AGGREGATION_SPAN: AGGREGATION_SPAN2,
  AGGREGATION_INDEX_X_MAX: AGGREGATION_INDEX_X_MAX2,
  AGGREGATION_INDEX_X_MIN: AGGREGATION_INDEX_X_MIN2,
  AGGREGATION_INDEX_Y_MAX: AGGREGATION_INDEX_Y_MAX2,
  AGGREGATION_INDEX_Y_MIN: AGGREGATION_INDEX_Y_MIN2,
  aggregationDomain: aggregationDomain2,
  aggregationRangeFittingPoints: aggregationRangeFittingPoints2,
  compactAggregationIndices: compactAggregationIndices2,
  createAggregationIndices: createAggregationIndices2
} = module_support_exports;
var AGGREGATION_THRESHOLD3 = 1e3;
var OPEN = AGGREGATION_INDEX_X_MIN2;
var HIGH = AGGREGATION_INDEX_Y_MAX2;
var LOW = AGGREGATION_INDEX_Y_MIN2;
var CLOSE = AGGREGATION_INDEX_X_MAX2;
function aggregateOhlcData(scale2, xValues, highValues, lowValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD3)
    return;
  const [d0, d1] = aggregationDomain2(scale2, domain);
  let maxRange = aggregationRangeFittingPoints2(xValues);
  let { indexData, valueData } = createAggregationIndices2(xValues, highValues, lowValues, d0, d1, maxRange);
  const filters = [{ maxRange, indexData }];
  while (maxRange > 64) {
    ({ indexData, valueData, maxRange } = compactAggregationIndices2(indexData, valueData, maxRange));
    filters.push({ maxRange, indexData });
  }
  filters.reverse();
  return filters;
}
var {
  fixNumericExtent: fixNumericExtent3,
  keyProperty: keyProperty3,
  createDatumId: createDatumId22,
  SeriesNodePickMode: SeriesNodePickMode22,
  ChartAxisDirection: ChartAxisDirection14,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL22,
  valueProperty: valueProperty4,
  diff: diff22,
  animationValidation: animationValidation22,
  computeBarFocusBounds: computeBarFocusBounds22,
  visibleRangeIndices: visibleRangeIndices2,
  BandScale: BandScale2,
  getShapeStyle: getShapeStyle22,
  processedDataIsAnimatable: processedDataIsAnimatable2,
  mergeDefaults: mergeDefaults5,
  simpleMemorize2: simpleMemorize22
} = module_support_exports;
var memoizedAggregateOhlcData = simpleMemorize22(aggregateOhlcData);
var OhlcSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.openKey = series.properties.openKey;
    this.closeKey = series.properties.closeKey;
    this.highKey = series.properties.highKey;
    this.lowKey = series.properties.lowKey;
  }
};
var OhlcSeriesBase = class extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode22.AXIS_ALIGNED, SeriesNodePickMode22.EXACT_SHAPE_MATCH],
      propertyKeys: {
        x: ["xKey"],
        y: ["lowKey", "highKey", "openKey", "closeKey"]
      },
      propertyNames: {
        x: ["xName"],
        y: ["lowName", "highName", "openName", "closeName"]
      },
      categoryKey: "xValue",
      pathsPerSeries: []
    });
    this.NodeEvent = OhlcSeriesNodeEvent;
    this.dataAggregationFilters = void 0;
  }
  async processData(dataController) {
    if (!this.visible)
      return;
    const { xKey, openKey, closeKey, highKey, lowKey } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (animationEnabled) {
      if (this.processedData) {
        extraProps.push(diff22(this.id, this.processedData));
      }
      extraProps.push(animationValidation22());
    }
    if (openKey) {
      extraProps.push(
        valueProperty4(openKey, yScaleType, {
          id: `openValue`,
          invalidValue: void 0,
          missingValue: void 0
        })
      );
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty3(xKey, xScaleType, { id: `xValue` }),
        valueProperty4(closeKey, yScaleType, { id: `closeValue` }),
        valueProperty4(highKey, yScaleType, { id: `highValue` }),
        valueProperty4(lowKey, yScaleType, { id: `lowValue` }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL22] : [],
        ...extraProps
      ]
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.dataAggregationFilters = this.aggregateData(
      dataModel,
      processedData
    );
    this.animationState.transition("updateData");
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable2(processedData))
      return;
    const xAxis = this.axes[ChartAxisDirection14.X];
    if (xAxis == null)
      return;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const highValues = dataModel.resolveColumnById(this, `highValue`, processedData);
    const lowValues = dataModel.resolveColumnById(this, `lowValue`, processedData);
    const { index } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const domain = processedData.domain.keys[index];
    return memoizedAggregateOhlcData(xAxis.scale.type, xValues, highValues, lowValues, domain);
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    if (direction !== this.getBarDirection()) {
      const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = processedData.domain.keys[index];
      if (def.type === "key" && def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    }
    const yExtent = this.domainForClippedRange(direction, ["highValue", "lowValue"], "xValue");
    return fixNumericExtent3(yExtent);
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange(ChartAxisDirection14.Y, ["highValue", "lowValue"], "xValue", visibleRange);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    return this.countVisibleItems(
      "xValue",
      ["highValue", "lowValue"],
      xVisibleRange,
      yVisibleRange,
      minVisibleItems
    );
  }
  createNodeData() {
    const { visible, dataModel, processedData } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(dataModel && processedData && xAxis && yAxis))
      return;
    const nodeData = [];
    const { xKey, highKey, lowKey } = this.properties;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const openValues = dataModel.resolveColumnById(this, "openValue", processedData);
    const closeValues = dataModel.resolveColumnById(this, "closeValue", processedData);
    const highValues = dataModel.resolveColumnById(this, "highValue", processedData);
    const lowValues = dataModel.resolveColumnById(this, "lowValue", processedData);
    const { groupScale } = this;
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const groupOffset = groupScale.convert(String(groupIndex));
    const effectiveBarWidth = barWidth >= 1 ? barWidth : groupScale.rawBandwidth;
    const applyWidthOffset = BandScale2.is(xAxis.scale);
    const context = {
      itemId: xKey,
      nodeData,
      labelData: [],
      scales: this.calculateScaling(),
      groupScale: this.getScaling(this.groupScale),
      visible: this.visible
    };
    if (!visible)
      return context;
    const handleDatum = (datumIndex, xValue2, openValue, closeValue, highValue, lowValue, width2, crisp) => {
      const datum = rawData[datumIndex];
      const xOffset = applyWidthOffset ? width2 / 2 : 0;
      const centerX = xAxis.scale.convert(xValue2) + groupOffset + xOffset;
      const yOpen = yAxis.scale.convert(openValue);
      const yClose = yAxis.scale.convert(closeValue);
      const yHigh = yAxis.scale.convert(highValue);
      const yLow = yAxis.scale.convert(lowValue);
      const isRising = closeValue > openValue;
      const itemId = isRising ? "up" : "down";
      const y = Math.min(yHigh, yLow);
      const height2 = Math.max(yHigh, yLow) - y;
      const midPoint = {
        x: centerX,
        y: y + height2 / 2
      };
      nodeData.push({
        series: this,
        itemId,
        datum,
        datumIndex,
        xKey,
        xValue: xValue2,
        openValue,
        closeValue,
        highValue,
        lowValue,
        midPoint,
        aggregatedValue: closeValue,
        isRising,
        centerX,
        width: width2,
        y,
        height: height2,
        yOpen,
        yClose,
        crisp
      });
    };
    const { dataAggregationFilters } = this;
    const xScale = xAxis.scale;
    const [r0, r1] = xScale.range;
    const range22 = Math.abs(r1 - r0);
    const xPosition = (index) => xScale.convert(xValues[index]) + groupOffset;
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range22);
    if (dataAggregationFilter == null) {
      const invalidData = processedData.invalidData?.get(this.id);
      let [start2, end2] = visibleRangeIndices2(1, rawData.length, xAxis.range, (index) => {
        const xOffset = applyWidthOffset ? 0 : -effectiveBarWidth / 2;
        const x = xPosition(index) + xOffset;
        return [x, x + effectiveBarWidth];
      });
      if (processedData.input.count < 1e3) {
        start2 = 0;
        end2 = processedData.input.count;
      }
      for (let datumIndex = start2; datumIndex < end2; datumIndex += 1) {
        if (invalidData?.[datumIndex] === true)
          continue;
        const xValue2 = xValues[datumIndex];
        if (xValue2 == null)
          continue;
        const openValue = openValues[datumIndex];
        const closeValue = closeValues[datumIndex];
        const highValue = highValues[datumIndex];
        const lowValue = lowValues[datumIndex];
        const validLowValue = lowValue != null && lowValue <= openValue && lowValue <= closeValue;
        const validHighValue = highValue != null && highValue >= openValue && highValue >= closeValue;
        if (!validLowValue) {
          logger_exports.warnOnce(
            `invalid low value for key [${lowKey}] in data element, low value cannot be higher than datum open or close values`
          );
          continue;
        }
        if (!validHighValue) {
          logger_exports.warnOnce(
            `invalid high value for key [${highKey}] in data element, high value cannot be lower than datum open or close values.`
          );
          continue;
        }
        handleDatum(datumIndex, xValue2, openValue, closeValue, highValue, lowValue, effectiveBarWidth, true);
      }
    } else {
      const { maxRange, indexData } = dataAggregationFilter;
      const [start2, end2] = visibleRangeIndices2(1, maxRange, xAxis.range, (index) => {
        const aggIndex = index * AGGREGATION_SPAN2;
        const openIndex = indexData[aggIndex + OPEN];
        const closeIndex = indexData[aggIndex + CLOSE];
        if (openIndex === -1)
          return;
        const xOffset = applyWidthOffset ? 0 : -effectiveBarWidth / 2;
        return [xPosition(openIndex) + xOffset, xPosition(closeIndex) + xOffset + effectiveBarWidth];
      });
      for (let i = start2; i < end2; i += 1) {
        const aggIndex = i * AGGREGATION_SPAN2;
        const openIndex = indexData[aggIndex + OPEN];
        const closeIndex = indexData[aggIndex + CLOSE];
        const highIndex = indexData[aggIndex + HIGH];
        const lowIndex = indexData[aggIndex + LOW];
        if (openIndex === -1)
          continue;
        const midDatumIndex = (openIndex + closeIndex) / 2 | 0;
        const xValue2 = xValues[midDatumIndex];
        if (xValue2 == null)
          continue;
        const openValue = openValues[openIndex];
        const closeValue = closeValues[closeIndex];
        const highValue = highValues[highIndex];
        const lowValue = lowValues[lowIndex];
        const width2 = Math.abs(xPosition(closeIndex) - xPosition(openIndex)) + effectiveBarWidth;
        handleDatum(midDatumIndex, xValue2, openValue, closeValue, highValue, lowValue, width2, false);
      }
    }
    return context;
  }
  isVertical() {
    return true;
  }
  isLabelEnabled() {
    return false;
  }
  updateDatumSelection(opts) {
    const data = opts.nodeData ?? [];
    return opts.datumSelection.update(data);
  }
  updateLabelNodes(_opts) {
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  getItemStyle({ datumIndex, itemId = "up", datum, xValue: xValue2 }, isHighlight) {
    const { id: seriesId, properties } = this;
    const item = properties.item[itemId];
    const { itemStyler } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight);
    const baseStyle = mergeDefaults5(highlightStyle, properties.getStyle(itemId));
    let style2 = item.fillGradientDefaults && item.fillPatternDefaults && item.fillImageDefaults ? getShapeStyle22(baseStyle, item.fillGradientDefaults, item.fillPatternDefaults, item.fillImageDefaults) : baseStyle;
    if (itemStyler != null && datumIndex != null) {
      const { xKey, openKey, closeKey, highKey, lowKey } = properties;
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId22(createDatumId22(xValue2), isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            itemId,
            xKey,
            openKey,
            closeKey,
            highKey,
            lowKey,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = item.fillGradientDefaults && item.fillPatternDefaults && item.fillImageDefaults ? getShapeStyle22(
          mergeDefaults5(overrides, style2),
          item.fillGradientDefaults,
          item.fillPatternDefaults,
          item.fillImageDefaults
        ) : mergeDefaults5(overrides, style2);
      }
    }
    return style2;
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const {
      xKey,
      xName,
      yName,
      openKey,
      openName,
      highKey,
      highName,
      lowKey,
      lowName,
      closeKey,
      closeName,
      legendItemName,
      tooltip
    } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const openValue = dataModel.resolveColumnById(this, `openValue`, processedData)[datumIndex];
    const highValue = dataModel.resolveColumnById(this, `highValue`, processedData)[datumIndex];
    const lowValue = dataModel.resolveColumnById(this, `lowValue`, processedData)[datumIndex];
    const closeValue = dataModel.resolveColumnById(this, `closeValue`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const itemId = closeValue >= openValue ? "up" : "down";
    const item = this.properties.item[itemId];
    const format = this.getItemStyle({ datumIndex, datum, itemId }, false);
    let marker = {
      fill: item.fill ?? item.stroke,
      fillOpacity: item.fillOpacity ?? item.strokeOpacity ?? 1,
      stroke: item.stroke,
      strokeWidth: item.strokeWidth ?? 1,
      strokeOpacity: item.strokeOpacity ?? 1,
      lineDash: item.lineDash ?? [0],
      lineDashOffset: item.lineDashOffset ?? 0
    };
    if (item.fillGradientDefaults && item.fillPatternDefaults && item.fillImageDefaults) {
      marker = getShapeStyle22(marker, item.fillGradientDefaults, item.fillPatternDefaults, item.fillImageDefaults);
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        title: legendItemName,
        symbol: {
          marker
        },
        data: [
          {
            label: openName,
            fallbackLabel: openKey,
            value: this.getAxisValueText(yAxis, "tooltip", openValue, datum, openKey, legendItemName)
          },
          {
            label: highName,
            fallbackLabel: highKey,
            value: this.getAxisValueText(yAxis, "tooltip", highValue, datum, highKey, legendItemName)
          },
          {
            label: lowName,
            fallbackLabel: lowKey,
            value: this.getAxisValueText(yAxis, "tooltip", lowValue, datum, lowKey, legendItemName)
          },
          {
            label: closeName,
            fallbackLabel: closeKey,
            value: this.getAxisValueText(yAxis, "tooltip", closeValue, datum, closeKey, legendItemName)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        itemId,
        xKey,
        xName,
        yName,
        openKey,
        openName,
        highKey,
        highName,
        lowKey,
        lowName,
        closeKey,
        closeName,
        ...format
      }
    );
  }
  computeFocusBounds(opts) {
    const nodeDatum = this.getNodeData()?.at(opts.datumIndex);
    if (nodeDatum == null)
      return;
    const { centerX, y, width: width2, height: height2 } = nodeDatum;
    const datum = {
      x: centerX - width2 / 2,
      y,
      width: width2,
      height: height2
    };
    return computeBarFocusBounds22(this, datum);
  }
};
var { Path: Path7, SceneChangeDetection: SceneChangeDetection4, BBox: BBox11 } = module_support_exports;
var OhlcBaseNode = class extends Path7 {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.yOpen = 0;
    this.yClose = 0;
    this.crisp = false;
    this.strokeAlignment = 0;
  }
  computeBBox() {
    const { centerX, y, width: width2, height: height2 } = this;
    return new BBox11(centerX - width2 / 2, y, width2, height2);
  }
  isPointInPath(x, y) {
    return this.getBBox().containsPoint(x, y);
  }
  distanceSquared(x, y) {
    return this.getBBox().distanceSquared(x, y);
  }
  get midPoint() {
    return { x: this.centerX, y: this.y + this.height / 2 };
  }
  alignedCoordinates() {
    const { y, width: width2, height: height2, crisp, strokeAlignment } = this;
    let { centerX, yOpen, yClose } = this;
    let x0 = centerX - width2 / 2;
    let x1 = centerX + width2 / 2;
    let y0 = y;
    let y1 = y + height2;
    if (crisp && width2 > 1) {
      centerX = this.align(centerX);
      yOpen = this.align(yOpen);
      yClose = this.align(yClose);
      const halfWidth = this.align(width2 / 2);
      x0 = centerX - halfWidth;
      x1 = centerX + halfWidth;
      y0 = this.align(y);
      y1 = y0 + this.align(y0, height2);
    }
    const centerY = (y0 + y1) / 2;
    centerX += strokeAlignment;
    x0 += strokeAlignment;
    x1 += strokeAlignment;
    y0 -= strokeAlignment;
    y1 += strokeAlignment;
    yOpen += yOpen < centerY ? strokeAlignment : -strokeAlignment;
    yClose += yClose < centerY ? strokeAlignment : -strokeAlignment;
    return { centerX, x0, x1, y0, y1, yOpen, yClose };
  }
  executeStroke(ctx, path) {
    const { width: width2, strokeWidth } = this;
    if (width2 < strokeWidth) {
      ctx.lineWidth = width2;
    }
    super.executeStroke(ctx, path);
  }
};
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "centerX", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "y", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "width", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "height", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "yOpen", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "yClose", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "crisp", 2);
__decorateClass2([
  SceneChangeDetection4()
], OhlcBaseNode.prototype, "strokeAlignment", 2);
var OhlcNode = class extends OhlcBaseNode {
  updatePath() {
    const { path } = this;
    const { centerX, x0, x1, y0, y1, yOpen, yClose } = this.alignedCoordinates();
    path.clear();
    path.moveTo(centerX, y0);
    path.lineTo(centerX, y1);
    if (Math.abs(x1 - x0) > 1) {
      path.moveTo(x0, yOpen);
      path.lineTo(centerX, yOpen);
      path.moveTo(centerX, yClose);
      path.lineTo(x1, yClose);
    }
  }
};
var { SceneArrayChangeDetection: SceneArrayChangeDetection2, SceneChangeDetection: SceneChangeDetection5, ExtendedPath2D: ExtendedPath2D3, BBox: BBox12 } = module_support_exports;
var CandlestickNode = class extends OhlcBaseNode {
  constructor() {
    super(...arguments);
    this.wickPath = new ExtendedPath2D3();
    this.wickStroke = void 0;
    this.wickStrokeWidth = void 0;
    this.wickStrokeOpacity = void 0;
  }
  computeDefaultGradientFillBBox() {
    const { width: width2, centerX, yOpen, yClose } = this;
    const boxTop = Math.min(yOpen, yClose);
    const boxBottom = Math.max(yOpen, yClose);
    const rectHeight = boxBottom - boxTop;
    const x0 = centerX - width2 / 2;
    const x1 = centerX + width2 / 2;
    return new BBox12(x0, boxTop, x1 - x0, rectHeight);
  }
  updatePath() {
    const {
      path,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      wickStroke,
      wickStrokeWidth,
      wickStrokeOpacity,
      wickLineDash,
      wickLineDashOffset,
      strokeAlignment
    } = this;
    const { centerX, x0, x1, y0, y1, yOpen, yClose } = this.alignedCoordinates();
    this.path.clear();
    this.wickPath.clear();
    const needsWickPath = wickStroke != null && wickStroke !== stroke22 || wickStrokeWidth != null && wickStrokeWidth !== strokeWidth || wickStrokeOpacity != null && wickStrokeOpacity !== strokeOpacity || wickLineDash != null && wickLineDash !== lineDash || wickLineDashOffset != null && wickLineDashOffset !== lineDashOffset;
    const wickPath = needsWickPath ? this.wickPath : path;
    if (Math.abs(x1 - x0) <= 3) {
      wickPath.moveTo(centerX, y0);
      wickPath.lineTo(centerX, y1);
      return;
    }
    const boxTop = Math.min(yOpen, yClose);
    const boxBottom = Math.max(yOpen, yClose);
    wickPath.moveTo(centerX, y0);
    wickPath.lineTo(centerX, boxTop + strokeWidth / 2);
    wickPath.moveTo(centerX, y1);
    wickPath.lineTo(centerX, boxBottom - strokeWidth / 2);
    const boxStrokeAdjustment = strokeAlignment + strokeWidth / 2;
    const rectHeight = boxBottom - boxTop - 2 * boxStrokeAdjustment;
    if (rectHeight > 0) {
      path.rect(
        x0 + boxStrokeAdjustment,
        boxTop + boxStrokeAdjustment,
        x1 - x0 - 2 * boxStrokeAdjustment,
        rectHeight
      );
    } else {
      const boxMid = (boxTop + boxBottom) / 2;
      path.moveTo(x0, boxMid);
      path.lineTo(x1, boxMid);
    }
  }
  drawPath(ctx) {
    super.drawPath(ctx);
    const { wickPath } = this;
    if (wickPath.isEmpty())
      return;
    const {
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      wickStroke = stroke22,
      wickStrokeWidth = strokeWidth,
      wickStrokeOpacity = strokeOpacity,
      wickLineDash = lineDash,
      wickLineDashOffset = lineDashOffset
    } = this;
    if (wickStrokeWidth === 0)
      return;
    ctx.globalAlpha *= wickStrokeOpacity;
    if (typeof wickStroke === "string") {
      ctx.strokeStyle = wickStroke;
    }
    ctx.lineWidth = wickStrokeWidth;
    if (wickLineDash != null) {
      ctx.setLineDash([...wickLineDash]);
    }
    ctx.lineDashOffset = wickLineDashOffset;
    ctx.stroke(wickPath.getPath2D());
  }
};
__decorateClass2([
  SceneChangeDetection5()
], CandlestickNode.prototype, "wickStroke", 2);
__decorateClass2([
  SceneChangeDetection5()
], CandlestickNode.prototype, "wickStrokeWidth", 2);
__decorateClass2([
  SceneChangeDetection5()
], CandlestickNode.prototype, "wickStrokeOpacity", 2);
__decorateClass2([
  SceneArrayChangeDetection2()
], CandlestickNode.prototype, "wickLineDash", 2);
__decorateClass2([
  SceneChangeDetection5()
], CandlestickNode.prototype, "wickLineDashOffset", 2);
var { BaseProperties: BaseProperties16, Property: Property49, AbstractBarSeriesProperties: AbstractBarSeriesProperties22, makeSeriesTooltip: makeSeriesTooltip22 } = module_support_exports;
var OhlcSeriesItem = class extends BaseProperties16 {
  constructor() {
    super(...arguments);
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property49
], OhlcSeriesItem.prototype, "stroke", 2);
__decorateClass2([
  Property49
], OhlcSeriesItem.prototype, "strokeWidth", 2);
__decorateClass2([
  Property49
], OhlcSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property49
], OhlcSeriesItem.prototype, "lineDash", 2);
__decorateClass2([
  Property49
], OhlcSeriesItem.prototype, "lineDashOffset", 2);
var OhlcSeriesItems = class extends BaseProperties16 {
  constructor() {
    super(...arguments);
    this.up = new OhlcSeriesItem();
    this.down = new OhlcSeriesItem();
  }
};
__decorateClass2([
  Property49
], OhlcSeriesItems.prototype, "up", 2);
__decorateClass2([
  Property49
], OhlcSeriesItems.prototype, "down", 2);
var OhlcSeriesBaseProperties = class extends AbstractBarSeriesProperties22 {
};
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "xKey", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "openKey", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "closeKey", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "highKey", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "lowKey", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "xName", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "yName", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "openName", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "closeName", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "highName", 2);
__decorateClass2([
  Property49
], OhlcSeriesBaseProperties.prototype, "lowName", 2);
var OhlcSeriesProperties = class extends OhlcSeriesBaseProperties {
  constructor() {
    super(...arguments);
    this.tooltip = makeSeriesTooltip22();
    this.item = new OhlcSeriesItems();
  }
  getStyle(itemId) {
    const { strokeWidth, strokeOpacity, stroke: stroke22, lineDash, lineDashOffset } = this.item[itemId];
    return {
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property49
], OhlcSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Property49
], OhlcSeriesProperties.prototype, "item", 2);
__decorateClass2([
  Property49
], OhlcSeriesProperties.prototype, "itemStyler", 2);
var { FillGradientDefaults: FillGradientDefaults3, FillPatternDefaults: FillPatternDefaults3, FillImageDefaults: FillImageDefaults3, BaseProperties: BaseProperties17, makeSeriesTooltip: makeSeriesTooltip3, Property: Property50 } = module_support_exports;
var CandlestickSeriesWick = class extends BaseProperties17 {
};
__decorateClass2([
  Property50
], CandlestickSeriesWick.prototype, "stroke", 2);
__decorateClass2([
  Property50
], CandlestickSeriesWick.prototype, "strokeWidth", 2);
__decorateClass2([
  Property50
], CandlestickSeriesWick.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property50
], CandlestickSeriesWick.prototype, "lineDash", 2);
__decorateClass2([
  Property50
], CandlestickSeriesWick.prototype, "lineDashOffset", 2);
var CandlestickSeriesItem = class extends BaseProperties17 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults3();
    this.fillPatternDefaults = new FillPatternDefaults3();
    this.fillImageDefaults = new FillImageDefaults3();
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.wick = new CandlestickSeriesWick();
  }
};
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "fill", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "fillOpacity", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "stroke", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "strokeWidth", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "lineDash", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "cornerRadius", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItem.prototype, "wick", 2);
var CandlestickSeriesItems = class extends BaseProperties17 {
  constructor() {
    super(...arguments);
    this.up = new CandlestickSeriesItem();
    this.down = new CandlestickSeriesItem();
  }
};
__decorateClass2([
  Property50
], CandlestickSeriesItems.prototype, "up", 2);
__decorateClass2([
  Property50
], CandlestickSeriesItems.prototype, "down", 2);
var CandlestickSeriesProperties = class extends OhlcSeriesBaseProperties {
  constructor() {
    super();
    this.item = new CandlestickSeriesItems();
    this.tooltip = makeSeriesTooltip3();
    this.highlightStyle.deprecated = false;
  }
  getStyle(itemId) {
    const { fill, fillOpacity, strokeWidth, strokeOpacity, stroke: stroke22, lineDash, lineDashOffset, cornerRadius, wick } = this.item[itemId];
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1,
      wick
    };
  }
};
__decorateClass2([
  Property50
], CandlestickSeriesProperties.prototype, "item", 2);
__decorateClass2([
  Property50
], CandlestickSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Property50
], CandlestickSeriesProperties.prototype, "itemStyler", 2);
var { isGradientFill: isGradientFill2, isPatternFill: isPatternFill2, isImageFill: isImageFill2, getShapeFill: getShapeFill22, applyShapeStyle: applyShapeStyle2 } = module_support_exports;
var CandlestickSeries = class extends OhlcSeriesBase {
  constructor() {
    super(...arguments);
    this.properties = new CandlestickSeriesProperties();
  }
  nodeFactory() {
    return new CandlestickNode();
  }
  updateDatumNodes({
    datumSelection,
    isHighlight
  }) {
    const { item } = this.properties;
    const { up, down } = item;
    const { strokeWidth: upStrokeWidth } = up;
    const { strokeWidth: downStrokeWidth } = down;
    datumSelection.each((node, datum) => {
      const { isRising, centerX, width: width2, y, height: height2, yOpen, yClose, crisp } = datum;
      const style2 = this.getItemStyle(datum, isHighlight);
      node.centerX = centerX;
      node.width = width2;
      node.y = y;
      node.height = height2;
      node.yOpen = yOpen;
      node.yClose = yClose;
      node.crisp = crisp;
      applyShapeStyle2(node, style2, this.getShapeFillBBox());
      const styleWick = style2?.wick;
      node.wickStroke = styleWick?.stroke;
      node.wickStrokeWidth = styleWick?.strokeWidth;
      node.wickStrokeOpacity = styleWick?.strokeOpacity;
      node.wickLineDash = styleWick?.lineDash;
      node.wickLineDashOffset = styleWick?.lineDashOffset;
      node.strokeAlignment = (isRising ? upStrokeWidth : downStrokeWidth) / 2;
    });
  }
  legendItemSymbol() {
    const { up, down } = this.properties.item;
    const upFill = getShapeFill22(up.fill, up.fillGradientDefaults, up.fillPatternDefaults, up.fillImageDefaults);
    const upColorStops = isGradientFill2(upFill) ? upFill.colorStops.map(
      (c) => typeof c === "string" ? c : { color: c.color, stop: c.stop != null ? c.stop * 0.5 : void 0 }
    ) : [
      { color: isPatternFill2(upFill) || isImageFill2(upFill) ? up.stroke : upFill, stop: 0 },
      { color: isPatternFill2(upFill) || isImageFill2(upFill) ? up.stroke : upFill, stop: 0.5 }
    ];
    const downFill = getShapeFill22(
      down.fill,
      down.fillGradientDefaults,
      down.fillPatternDefaults,
      down.fillImageDefaults
    );
    const downColorStops = isGradientFill2(downFill) ? downFill.colorStops.map(
      (c) => typeof c === "string" ? c : { color: c.color, stop: c.stop != null ? c.stop * 0.5 : void 0 }
    ) : [{ color: isPatternFill2(downFill) || isImageFill2(downFill) ? down.stroke : downFill, stop: 0.5 }];
    const fill = {
      type: "gradient",
      gradient: "linear",
      rotation: 90,
      colorStops: [...upColorStops, ...downColorStops],
      reverse: false
    };
    const stroke22 = {
      type: "gradient",
      gradient: "linear",
      rotation: 90,
      colorStops: [
        { color: up.stroke, stop: 0 },
        { color: up.stroke, stop: 0.5 },
        { color: down.stroke, stop: 0.5 }
      ],
      reverse: false
    };
    return {
      marker: {
        fill,
        fillOpacity: up.fillOpacity,
        stroke: stroke22,
        strokeWidth: up.strokeWidth ?? 1,
        strokeOpacity: up.strokeOpacity ?? 1,
        lineDash: up.lineDash,
        lineDashOffset: up.lineDashOffset
      }
    };
  }
  getLegendData(legendType) {
    const {
      id,
      data,
      visible,
      ctx: { legendManager }
    } = this;
    const { xKey, yName, showInLegend, legendItemName } = this.properties;
    if (!data?.length || !xKey || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id,
        itemId: id,
        seriesId: id,
        enabled: visible && legendManager.getItemEnabled({ seriesId: id, itemId: id }),
        label: {
          text: legendItemName ?? yName ?? id
        },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
CandlestickSeries.className = "CandleStickSeries";
CandlestickSeries.type = "candlestick";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs22, candlestickSeriesThemeableOptionsDef: candlestickSeriesThemeableOptionsDef2 } = module_support_exports;
var candlestickSeriesOptionsDef = {
  ...commonSeriesOptionsDefs22,
  ...candlestickSeriesThemeableOptionsDef2,
  type: required(constant("candlestick")),
  xKey: required(string),
  openKey: required(string),
  highKey: required(string),
  lowKey: required(string),
  closeKey: required(string),
  xName: string,
  yName: string,
  openName: string,
  highName: string,
  lowName: string,
  closeName: string
};
candlestickSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented(boolean);
candlestickSeriesOptionsDef.focusPriority = undocumented(number);
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE22 },
  multiSeriesHighlightStyle: multiSeriesHighlightStyle22
} = module_support_exports;
function itemTheme(key) {
  return {
    fill: {
      $if: [
        { $eq: [{ $palette: "type" }, "user-indexed"] },
        key === "up" ? "transparent" : { $palette: "fill" },
        { $palette: `${key}.fill` }
      ]
    },
    stroke: {
      $if: [
        { $eq: [{ $palette: "type" }, "user-indexed"] },
        { $palette: "stroke" },
        { $palette: `${key}.stroke` }
      ]
    },
    // @ts-expect-error undocumented-option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_SHADED_DEFAULTS(key),
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS
  };
}
var CANDLESTICK_SERIES_THEME = {
  series: {
    item: {
      up: itemTheme("up"),
      down: itemTheme("down")
    },
    highlightStyle: {
      item: { strokeWidth: 3 }
    },
    tooltip: {
      range: { $path: ["/tooltip/range", "nearest"] }
    },
    highlight: multiSeriesHighlightStyle22()
  },
  animation: { enabled: false },
  axes: {
    [CARTESIAN_AXIS_TYPE22.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [CARTESIAN_AXIS_TYPE22.ORDINAL_TIME]: {
      groupPaddingInner: 0,
      crosshair: {
        enabled: true
      }
    }
  }
};
var { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE3, CARTESIAN_POSITION: CARTESIAN_POSITION2 } = module_support_exports.ThemeConstants;
var CandlestickModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "candlestick",
  moduleFactory: (ctx) => new CandlestickSeries(ctx),
  defaultAxes: [
    {
      type: CARTESIAN_AXIS_TYPE3.NUMBER,
      position: CARTESIAN_POSITION2.LEFT
    },
    {
      type: CARTESIAN_AXIS_TYPE3.ORDINAL_TIME,
      position: CARTESIAN_POSITION2.BOTTOM
    }
  ],
  themeTemplate: CANDLESTICK_SERIES_THEME,
  groupable: false
};
var CandlestickSeriesModule = {
  type: "series",
  name: "candlestick",
  chartType: "cartesian",
  enterprise: true,
  options: candlestickSeriesOptionsDef,
  create: (ctx) => new CandlestickSeries(ctx)
};
var { CachedTextMeasurerPool: CachedTextMeasurerPool22, TextUtils: TextUtils3, TextWrapper: TextWrapper4 } = module_support_exports;
function generateLabelSecondaryLabelFontSizeCandidates(label, secondaryLabel) {
  const { fontSize: labelFontSize, minimumFontSize: labelMinimumFontSize = labelFontSize } = label;
  const {
    fontSize: secondaryLabelFontSize,
    minimumFontSize: secondaryLabelMinimumFontSize = secondaryLabelFontSize
  } = secondaryLabel;
  const labelTracks = labelFontSize - labelMinimumFontSize;
  const secondaryLabelTracks = secondaryLabelFontSize - secondaryLabelMinimumFontSize;
  let currentLabelFontSize = label.fontSize;
  let currentSecondaryLabelFontSize = secondaryLabel.fontSize;
  const out = [{ labelFontSize, secondaryLabelFontSize }];
  while (currentLabelFontSize > labelMinimumFontSize || currentSecondaryLabelFontSize > secondaryLabelMinimumFontSize) {
    const labelProgress = labelTracks > 0 ? (currentLabelFontSize - labelMinimumFontSize) / labelTracks : -1;
    const secondaryLabelProgress = secondaryLabelTracks > 0 ? (currentSecondaryLabelFontSize - secondaryLabelMinimumFontSize) / secondaryLabelTracks : -1;
    if (labelProgress > secondaryLabelProgress) {
      currentLabelFontSize--;
    } else {
      currentSecondaryLabelFontSize--;
    }
    out.push({
      labelFontSize: currentLabelFontSize,
      secondaryLabelFontSize: currentSecondaryLabelFontSize
    });
  }
  out.reverse();
  return out;
}
function getLineHeight(labelProps, fontSize) {
  if (labelProps.lineHeight != null && labelProps.fontSize != null) {
    return labelProps.lineHeight * fontSize / labelProps.fontSize;
  } else {
    return TextUtils3.getLineHeight(fontSize);
  }
}
function formatStackedLabels(labelValue, labelProps, secondaryLabelValue, secondaryLabelProps, { padding: padding2 }, sizeFittingHeight) {
  const { spacing = 0 } = labelProps;
  const widthAdjust = 2 * padding2;
  const heightAdjust = 2 * padding2 + spacing;
  const minimumHeight = (labelProps.minimumFontSize ?? labelProps.fontSize) + (secondaryLabelProps.minimumFontSize ?? secondaryLabelProps.fontSize);
  if (minimumHeight > sizeFittingHeight(minimumHeight + heightAdjust, false).height - heightAdjust)
    return;
  const fontSizeCandidates = generateLabelSecondaryLabelFontSizeCandidates(labelProps, secondaryLabelProps);
  const labelTextSizeProps = {
    fontFamily: labelProps.fontFamily,
    fontSize: labelProps.fontSize,
    fontStyle: labelProps.fontStyle,
    fontWeight: labelProps.fontWeight
  };
  const secondaryLabelTextSizeProps = {
    fontFamily: secondaryLabelProps.fontFamily,
    fontSize: secondaryLabelProps.fontSize,
    fontStyle: secondaryLabelProps.fontStyle,
    fontWeight: secondaryLabelProps.fontWeight
  };
  let label;
  let secondaryLabel;
  return findMaxValue(0, fontSizeCandidates.length - 1, (index) => {
    const { labelFontSize, secondaryLabelFontSize } = fontSizeCandidates[index];
    const allowTruncation = index === 0;
    const labelLineHeight = getLineHeight(labelProps, labelFontSize);
    const secondaryLabelLineHeight = getLineHeight(secondaryLabelProps, secondaryLabelFontSize);
    const sizeFitting = sizeFittingHeight(
      labelLineHeight + secondaryLabelLineHeight + heightAdjust,
      allowTruncation
    );
    const availableWidth = sizeFitting.width - widthAdjust;
    const availableHeight = sizeFitting.height - heightAdjust;
    if (labelLineHeight + secondaryLabelLineHeight > availableHeight)
      return;
    if (label == null || label.fontSize !== labelFontSize) {
      labelTextSizeProps.fontSize = labelFontSize;
      label = wrapLabel(
        labelProps,
        labelValue,
        availableWidth,
        availableHeight,
        labelTextSizeProps,
        labelProps.wrapping,
        allowTruncation ? labelProps.overflowStrategy : "hide"
      );
    }
    if (label == null || label.width > availableWidth || label.height > availableHeight)
      return;
    if (secondaryLabel == null || secondaryLabel.fontSize !== secondaryLabelFontSize) {
      secondaryLabelTextSizeProps.fontSize = secondaryLabelFontSize;
      secondaryLabel = wrapLabel(
        secondaryLabelProps,
        secondaryLabelValue,
        availableWidth,
        availableHeight,
        secondaryLabelTextSizeProps,
        secondaryLabelProps.wrapping,
        allowTruncation ? secondaryLabelProps.overflowStrategy : "hide"
      );
    }
    if (secondaryLabel == null)
      return;
    const totalLabelHeight = label.height + secondaryLabel.height;
    if (secondaryLabel.width > availableWidth || totalLabelHeight > availableHeight)
      return;
    return {
      width: Math.max(label.width, secondaryLabel.width),
      height: totalLabelHeight + spacing,
      meta: sizeFitting.meta,
      label,
      secondaryLabel
    };
  });
}
function formatSingleLabel(value, props, { padding: padding2 }, sizeFittingHeight) {
  const sizeAdjust = 2 * padding2;
  const minimumFontSize = Math.min(props.minimumFontSize ?? props.fontSize, props.fontSize);
  const textSizeProps = {
    fontFamily: props.fontFamily,
    fontSize: props.fontSize,
    fontStyle: props.fontStyle,
    fontWeight: props.fontWeight
  };
  return findMaxValue(minimumFontSize, props.fontSize, (fontSize) => {
    const lineHeight = getLineHeight(props, fontSize);
    const allowTruncation = fontSize === minimumFontSize;
    const sizeFitting = sizeFittingHeight(lineHeight + sizeAdjust, allowTruncation);
    const availableWidth = sizeFitting.width - sizeAdjust;
    const availableHeight = sizeFitting.height - sizeAdjust;
    if (lineHeight > availableHeight)
      return;
    textSizeProps.fontSize = fontSize;
    const lines = TextWrapper4.wrapLines(value, {
      maxWidth: availableWidth,
      maxHeight: availableHeight,
      font: textSizeProps,
      textWrap: props.wrapping,
      overflow: (allowTruncation ? props.overflowStrategy : void 0) ?? "hide"
    });
    if (!lines.length)
      return;
    const clippedLabel = clipLines(lines, {
      lineHeight,
      font: textSizeProps,
      maxWidth: availableWidth,
      maxHeight: availableHeight
    });
    if (!clippedLabel)
      return;
    return [{ fontSize, lineHeight, ...clippedLabel }, sizeFitting.meta];
  });
}
function hasInvalidFontSize(label) {
  return label?.minimumFontSize != null && label?.fontSize != null && label?.minimumFontSize > label?.fontSize;
}
function formatLabels(baseLabelValue, labelProps, baseSecondaryLabelValue, secondaryLabelProps, layoutParams, sizeFittingHeight) {
  const labelValue = labelProps.enabled ? baseLabelValue : void 0;
  const secondaryLabelValue = secondaryLabelProps.enabled ? baseSecondaryLabelValue : void 0;
  if (hasInvalidFontSize(labelProps) || hasInvalidFontSize(secondaryLabelProps)) {
    logger_exports.warnOnce(`minimumFontSize should be set to a value less than or equal to the font size`);
  }
  let value;
  if (labelValue != null && secondaryLabelValue != null) {
    value = formatStackedLabels(
      labelValue,
      labelProps,
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  let labelMeta;
  if (value == null && labelValue != null) {
    labelMeta = formatSingleLabel(labelValue, labelProps, layoutParams, sizeFittingHeight);
  }
  if (labelMeta != null) {
    const [label, meta] = labelMeta;
    value = {
      width: label.width,
      height: label.height,
      meta,
      label,
      secondaryLabel: void 0
    };
  }
  let secondaryLabelMeta;
  if (value == null && labelValue == null && secondaryLabelValue != null) {
    secondaryLabelMeta = formatSingleLabel(
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  if (secondaryLabelMeta != null) {
    const [secondaryLabel, meta] = secondaryLabelMeta;
    value = {
      width: secondaryLabel.width,
      height: secondaryLabel.height,
      meta,
      label: void 0,
      secondaryLabel
    };
  }
  return value;
}
function wrapLabel(props, text2, maxWidth, maxHeight, font22, textWrap, overflow) {
  const lines = TextWrapper4.wrapLines(text2, { maxWidth, maxHeight, font: font22, textWrap, overflow });
  if (!lines.length)
    return;
  const lineHeight = getLineHeight(props, font22.fontSize);
  const { width: width2 } = CachedTextMeasurerPool22.measureLines(lines, { font: font22 });
  return {
    width: width2,
    lineHeight,
    text: lines.join("\n"),
    height: lines.length * lineHeight,
    fontSize: font22.fontSize
  };
}
function clipLines(lines, { font: font22, lineHeight = TextUtils3.defaultLineHeight, maxWidth, maxHeight = Infinity }) {
  let height2 = lineHeight * lines.length;
  while (height2 > maxHeight) {
    if (lines.length === 1)
      return;
    lines.pop();
    lines[lines.length - 1] = TextWrapper4.appendEllipsis(lines.at(-1));
    height2 = lineHeight * lines.length;
  }
  const metrics = CachedTextMeasurerPool22.measureLines(lines, { font: font22 });
  let text2, width2;
  if (metrics.width > maxWidth) {
    const clippedLines = [];
    width2 = 0;
    for (const line of metrics.lineMetrics) {
      if (line.width > maxWidth) {
        if (!clippedLines.length)
          return;
        break;
      }
      clippedLines.push(line.text);
      width2 = Math.max(width2, line.width);
    }
    text2 = TextWrapper4.appendEllipsis(clippedLines.join("\n"));
  } else {
    text2 = lines.join("\n");
    width2 = metrics.width;
  }
  return { text: text2, width: width2, height: height2 };
}
var { Property: Property51 } = module_support_exports;
var BaseAutoSizedLabel = class extends module_support_exports.Label {
  constructor() {
    super(...arguments);
    this.wrapping = "on-space";
    this.overflowStrategy = "ellipsis";
  }
};
__decorateClass2([
  Property51
], BaseAutoSizedLabel.prototype, "wrapping", 2);
__decorateClass2([
  Property51
], BaseAutoSizedLabel.prototype, "overflowStrategy", 2);
__decorateClass2([
  Property51
], BaseAutoSizedLabel.prototype, "lineHeight", 2);
__decorateClass2([
  Property51
], BaseAutoSizedLabel.prototype, "minimumFontSize", 2);
var AutoSizedLabel = class extends BaseAutoSizedLabel {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass2([
  Property51
], AutoSizedLabel.prototype, "spacing", 2);
var AutoSizedSecondaryLabel = class extends BaseAutoSizedLabel {
};
var { CartesianSeriesProperties: CartesianSeriesProperties2, makeSeriesTooltip: makeSeriesTooltip4, Property: Property52 } = module_support_exports;
var HeatmapSeriesProperties = class extends CartesianSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.colorRange = ["black", "black"];
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.itemPadding = 0;
    this.label = new AutoSizedLabel();
    this.tooltip = makeSeriesTooltip4();
  }
};
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "xKey", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "yKey", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "xName", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "yName", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "textAlign", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "verticalAlign", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "itemPadding", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property52
], HeatmapSeriesProperties.prototype, "tooltip", 2);
var {
  SeriesNodePickMode: SeriesNodePickMode3,
  computeBarFocusBounds: computeBarFocusBounds3,
  getMissCount: getMissCount2,
  valueProperty: valueProperty5,
  ChartAxisDirection: ChartAxisDirection15,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: DEFAULT_CARTESIAN_DIRECTION_KEYS2,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: DEFAULT_CARTESIAN_DIRECTION_NAMES2,
  createDatumId: createDatumId3,
  ColorScale: ColorScale2,
  Rect: Rect22,
  PointerEvents: PointerEvents2,
  applyShapeStyle: applyShapeStyle22,
  mergeDefaults: mergeDefaults6,
  formatValue: formatValue2,
  addHitTestersToQuadtree: addHitTestersToQuadtree2,
  findQuadtreeMatch: findQuadtreeMatch2,
  updateLabelNode: updateLabelNode2
} = module_support_exports;
var HeatmapSeriesNodeEvent = class extends module_support_exports.CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.colorKey = series.properties.colorKey;
  }
};
var textAlignFactors = {
  left: -0.5,
  center: 0,
  right: -0.5
};
var verticalAlignFactors = {
  top: -0.5,
  middle: 0,
  bottom: -0.5
};
var HeatmapSeries = class extends module_support_exports.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: {
        ...DEFAULT_CARTESIAN_DIRECTION_KEYS2,
        color: ["colorKey"]
      },
      propertyNames: {
        ...DEFAULT_CARTESIAN_DIRECTION_NAMES2,
        color: ["colorName"]
      },
      categoryKey: void 0,
      pickModes: [SeriesNodePickMode3.NEAREST_NODE, SeriesNodePickMode3.EXACT_SHAPE_MATCH],
      pathsPerSeries: []
    });
    this.properties = new HeatmapSeriesProperties();
    this.NodeEvent = HeatmapSeriesNodeEvent;
    this.colorScale = new ColorScale2();
  }
  async processData(dataController) {
    const xAxis = this.axes[ChartAxisDirection15.X];
    const yAxis = this.axes[ChartAxisDirection15.Y];
    if (!xAxis || !yAxis || !this.data?.length) {
      return;
    }
    const { xKey, yKey, colorRange, colorKey } = this.properties;
    const xScale = this.axes[ChartAxisDirection15.X]?.scale;
    const yScale = this.axes[ChartAxisDirection15.Y]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const colorScaleType = this.colorScale.type;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty5(xKey, xScaleType, { id: "xValue" }),
        valueProperty5(yKey, yScaleType, { id: "yValue" }),
        ...colorKey ? [valueProperty5(colorKey, colorScaleType, { id: "colorValue", invalidValue: void 0 })] : []
      ]
    });
    if (this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      const rawDomain = processedData.domain.values[colorKeyIdx].filter((v) => v != null);
      const domain = module_support_exports.extent(rawDomain);
      this.colorScale.domain = domain ?? [];
      if (domain?.length && domain[0] === domain[1]) {
        const midIndex = Math.floor(colorRange.length / 2);
        this.colorScale.range = [colorRange[midIndex], colorRange[midIndex]];
      } else {
        this.colorScale.range = colorRange;
      }
      this.colorScale.update();
    }
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorDataIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.input.count;
    const missCount = getMissCount2(this, processedData.defs.values[colorDataIdx].missing);
    const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const actualCount = processedData.domain.values[colorKeyIdx].filter((v) => v != null).length;
    const colorDataMissing = dataCount === 0 || dataCount === missCount || actualCount === 0;
    return !colorDataMissing;
  }
  xCoordinateRange(xValue2, pixelSize) {
    const xScale = this.axes[ChartAxisDirection15.X].scale;
    const xOffset = pixelSize * (xScale.bandwidth ?? 0) / 2;
    const x = xScale.convert(xValue2) + xOffset;
    const width2 = pixelSize * (xScale.bandwidth ?? 10);
    return [x, x + width2];
  }
  yCoordinateRange(yValues, pixelSize) {
    const yScale = this.axes[ChartAxisDirection15.Y].scale;
    const yOffset = pixelSize * (yScale.bandwidth ?? 0) / 2;
    const y = yScale.convert(yValues[0]) + yOffset;
    const height2 = pixelSize * (yScale.bandwidth ?? 10);
    return [y, y + height2];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === ChartAxisDirection15.X) {
      return dataModel.getDomain(this, `xValue`, "value", processedData);
    } else {
      return dataModel.getDomain(this, `yValue`, "value", processedData);
    }
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  createNodeData() {
    const { data, visible, axes, dataModel, processedData } = this;
    const xAxis = axes[ChartAxisDirection15.X];
    const yAxis = axes[ChartAxisDirection15.Y];
    if (!(data && dataModel && processedData && visible && xAxis && yAxis))
      return;
    if (xAxis.type !== "category" || yAxis.type !== "category") {
      logger_exports.warnOnce(
        `Heatmap series expected axes to have "category" type, but received "${xAxis.type}" and "${yAxis.type}" instead.`
      );
      return;
    }
    const { xKey, xName, yKey, yName, colorKey, colorName, textAlign, verticalAlign, itemPadding, label } = this.properties;
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const colorValues = colorKey ? dataModel.resolveColumnById(this, `colorValue`, processedData) : void 0;
    const colorDomain = colorKey ? dataModel.getDomain(this, "colorValue", "value", processedData) : [];
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    const labelData = [];
    const width2 = xScale.bandwidth ?? 10;
    const height2 = yScale.bandwidth ?? 10;
    const textAlignFactor = (width2 - 2 * itemPadding) * textAlignFactors[textAlign];
    const verticalAlignFactor = (height2 - 2 * itemPadding) * verticalAlignFactors[verticalAlign];
    const sizeFittingHeight = () => ({ width: width2, height: height2, meta: null });
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const xDatum = xValues[datumIndex];
      const yDatum = yValues[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      const colorValue = colorValues?.[datumIndex];
      const labelText = label.enabled && colorValue != null ? this.getLabelText(
        colorValue,
        datum,
        colorKey,
        "color",
        colorDomain,
        label,
        { value: colorValue, datum, colorKey, colorName, xKey, yKey, xName, yName }
      ) : void 0;
      const labels = formatLabels(
        labelText,
        this.properties.label,
        void 0,
        this.properties.label,
        { padding: itemPadding },
        sizeFittingHeight
      );
      const point = { x, y, size: 0 };
      nodeData.push({
        series: this,
        itemId: yKey,
        datumIndex,
        yKey,
        xKey,
        xValue: xDatum,
        yValue: yDatum,
        colorValue,
        datum,
        point,
        width: width2,
        height: height2,
        midPoint: { x, y },
        missing: colorValues != null && colorValue == null
      });
      if (labels?.label != null) {
        const { text: text2, fontSize, lineHeight, height: labelHeight } = labels.label;
        const { fontStyle, fontFamily, fontWeight, color: color6 } = this.properties.label;
        const lx = point.x + textAlignFactor * (width2 - 2 * itemPadding);
        const ly = point.y + verticalAlignFactor * (height2 - 2 * itemPadding) - (labels.height - labelHeight) * 0.5;
        labelData.push({
          series: this,
          itemId: yKey,
          datum,
          datumIndex,
          text: text2,
          fontSize,
          lineHeight,
          fontStyle,
          fontFamily,
          fontWeight,
          color: color6,
          textAlign,
          textBaseline: verticalAlign,
          x: lx,
          y: ly
        });
      }
    });
    return {
      itemId: this.properties.yKey ?? this.id,
      nodeData,
      labelData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  nodeFactory() {
    return new Rect22();
  }
  update(params) {
    this.ctx.animationManager.skipCurrentBatch();
    return super.update(params);
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data);
  }
  getItemStyle({ datumIndex, datum, colorValue }, isHighlight) {
    const { id: seriesId, properties } = this;
    const { xKey, yKey, itemStyler, stroke: stroke22, strokeWidth, strokeOpacity } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults6(highlightStyle, {
      fill: this.isColorScaleValid() && colorValue != null ? this.colorScale.convert(colorValue) : "transparent",
      fillOpacity: 1,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      opacity: 1
    });
    let overrides;
    if (itemStyler != null && datumIndex != null) {
      overrides = this.cachedDatumCallback(createDatumId3(datumIndex, isHighlight ? "highlight" : "node"), () => {
        const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
        const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
        return this.callWithContext(itemStyler, {
          seriesId,
          datum,
          xKey,
          yKey,
          highlighted: isHighlight,
          highlightState,
          ...baseStyle
        });
      });
    }
    return overrides ? mergeDefaults6(overrides, baseStyle) : baseStyle;
  }
  updateDatumNodes(opts) {
    const { isHighlight } = opts;
    const xAxis = this.axes[ChartAxisDirection15.X];
    const [visibleMin, visibleMax] = xAxis?.visibleRange ?? [];
    const isZoomed = visibleMin !== 0 || visibleMax !== 1;
    const crisp = !isZoomed;
    opts.datumSelection.each((rect, nodeDatum) => {
      const { point, width: width2, height: height2 } = nodeDatum;
      const style2 = this.getItemStyle(nodeDatum, isHighlight);
      rect.crisp = crisp;
      rect.x = Math.floor(point.x - width2 / 2);
      rect.y = Math.floor(point.y - height2 / 2);
      rect.width = Math.ceil(width2);
      rect.height = Math.ceil(height2);
      applyShapeStyle22(rect, style2);
    });
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    const { enabled } = this.properties.label;
    const data = enabled ? labelData : [];
    return labelSelection.update(data);
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((text2, datum) => {
      text2.pointerEvents = PointerEvents2.None;
      text2.text = datum.text;
      text2.fillOpacity = this.getHighlightStyle(false, datum.datumIndex)?.opacity ?? 1;
      updateLabelNode2(this, text2, this.properties, this.properties.label, datum);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties, colorScale, ctx } = this;
    const { formatManager } = ctx;
    const { xKey, xName, yKey, yName, colorKey, colorName, colorRange, title, legendItemName, tooltip } = properties;
    const xAxis = axes[ChartAxisDirection15.X];
    const yAxis = axes[ChartAxisDirection15.Y];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    const colorValue = colorKey != null && this.isColorScaleValid() ? dataModel.resolveColumnById(this, `colorValue`, processedData)[datumIndex] : void 0;
    if (xValue2 == null)
      return;
    const data = [];
    let fill;
    if (colorValue == null) {
      fill = colorRange[0];
    } else {
      fill = colorScale.convert(colorValue);
      const domain = dataModel.getDomain(this, `colorValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: colorValue,
        datum,
        seriesId,
        legendItemName,
        key: colorKey,
        source: "tooltip",
        property: "color",
        domain,
        boundSeries: this.getFormatterContext("color"),
        fractionDigits: void 0
      });
      data.push({ label: colorName, fallbackLabel: colorKey, value: content ?? formatValue2(colorValue) });
    }
    data.push(
      {
        label: xName,
        fallbackLabel: xKey,
        value: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName)
      },
      {
        label: yName,
        fallbackLabel: yKey,
        value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
      }
    );
    const format = this.getItemStyle({ datumIndex, datum, colorValue }, false);
    if (format.fill != null) {
      fill = format.fill;
    }
    const symbol = fill != null ? {
      marker: {
        shape: "square",
        fill,
        fillOpacity: 1,
        stroke: void 0,
        strokeWidth: 0,
        strokeOpacity: 1,
        lineDash: [0],
        lineDashOffset: 0
      }
    } : void 0;
    return this.formatTooltipWithContext(
      tooltip,
      { title: title ?? legendItemName, symbol, data },
      {
        seriesId,
        datum,
        title,
        xKey,
        xName,
        yKey,
        yName,
        colorKey,
        colorName,
        ...format
      }
    );
  }
  getLegendData(legendType) {
    if (legendType !== "gradient" || !this.isColorScaleValid() || !this.dataModel) {
      return [];
    }
    return [
      {
        legendType: "gradient",
        enabled: this.visible,
        seriesId: this.id,
        series: this.getFormatterContext("color"),
        colorDomain: this.colorScale.domain,
        colorRange: this.colorScale.range
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled && Boolean(this.properties.colorKey);
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
  computeFocusBounds({ datumIndex }) {
    const datum = this.contextNodeData?.nodeData[datumIndex];
    if (datum === void 0)
      return void 0;
    const { width: width2, height: height2, midPoint } = datum;
    const focusRect = { x: midPoint.x - width2 / 2, y: midPoint.y - height2 / 2, width: width2, height: height2 };
    return computeBarFocusBounds3(this, focusRect);
  }
  initQuadTree(quadtree) {
    addHitTestersToQuadtree2(quadtree, this.datumNodesIter());
  }
  pickNodesExactShape(point) {
    const item = findQuadtreeMatch2(this, point);
    return item != null && item.distance <= 0 ? [item.datum] : [];
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch2(this, point);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
HeatmapSeries.className = "HeatmapSeries";
HeatmapSeries.type = "heatmap";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs3, heatmapSeriesThemeableOptionsDef: heatmapSeriesThemeableOptionsDef2, without: without2 } = module_support_exports;
var heatmapSeriesOptionsDef = {
  ...without2(heatmapSeriesThemeableOptionsDef2, ["showInLegend"]),
  ...without2(commonSeriesOptionsDefs3, ["showInLegend"]),
  type: required(constant("heatmap")),
  xKey: required(string),
  yKey: required(string),
  colorKey: string,
  xName: string,
  yName: string,
  colorName: string,
  colorRange: arrayOf(color)
};
var HEATMAP_SERIES_THEME = {
  series: {
    stroke: {
      $if: [
        { $eq: [{ $palette: "type" }, "inbuilt"] },
        { $ref: "chartBackgroundColor" },
        { $path: ["/0", { $palette: "stroke" }, { $palette: "strokes" }] }
      ]
    },
    strokeWidth: { $isUserOption: ["./stroke", 2, void 0] },
    // @ts-expect-error undocumented option
    colorRange: {
      $if: [
        { $eq: [{ $palette: "type" }, "inbuilt"] },
        { $palette: "divergingColors" },
        module_support_exports.SAFE_RANGE2_OPERATION
      ]
    },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      color: { $ref: "textColor" },
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      wrapping: "on-space",
      overflowStrategy: "ellipsis"
    },
    itemPadding: 3,
    highlight: module_support_exports.singleSeriesHighlightStyle()
  },
  gradientLegend: {
    enabled: true,
    ...module_support_exports.LEGEND_CONTAINER_THEME
  }
};
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE4, CARTESIAN_POSITION: CARTESIAN_POSITION22 }
} = module_support_exports;
var HeatmapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "heatmap",
  moduleFactory: (ctx) => new HeatmapSeries(ctx),
  defaultAxes: [
    { type: CARTESIAN_AXIS_TYPE4.CATEGORY, position: CARTESIAN_POSITION22.LEFT },
    { type: CARTESIAN_AXIS_TYPE4.CATEGORY, position: CARTESIAN_POSITION22.BOTTOM }
  ],
  themeTemplate: HEATMAP_SERIES_THEME
};
var HeatmapSeriesModule = {
  type: "series",
  name: "heatmap",
  chartType: "cartesian",
  enterprise: true,
  options: heatmapSeriesOptionsDef,
  create: (ctx) => new HeatmapSeries(ctx)
};
var { applyShapeStyle: applyShapeStyle3 } = module_support_exports;
var OhlcSeries = class extends OhlcSeriesBase {
  constructor() {
    super(...arguments);
    this.properties = new OhlcSeriesProperties();
  }
  nodeFactory() {
    return new OhlcNode();
  }
  updateDatumNodes({
    datumSelection,
    isHighlight
  }) {
    const { item } = this.properties;
    const { up, down } = item;
    const { strokeWidth: upStrokeWidth } = up;
    const { strokeWidth: downStrokeWidth } = down;
    datumSelection.each((node, datum) => {
      const { isRising, centerX, width: width2, y, height: height2, yOpen, yClose, crisp } = datum;
      node.centerX = centerX;
      node.width = width2;
      node.y = y;
      node.height = height2;
      node.yOpen = yOpen;
      node.yClose = yClose;
      node.crisp = crisp;
      const style2 = this.getItemStyle(datum, isHighlight);
      applyShapeStyle3(node, style2);
      node.strokeAlignment = (isRising ? upStrokeWidth : downStrokeWidth) / 2;
    });
  }
  getLegendData(legendType) {
    const {
      id,
      data,
      ctx: { legendManager },
      visible
    } = this;
    const {
      xKey,
      yName,
      item: { up, down },
      showInLegend,
      legendItemName
    } = this.properties;
    if (!data?.length || !xKey || legendType !== "category") {
      return [];
    }
    const fill = {
      type: "gradient",
      gradient: "linear",
      colorSpace: "rgb",
      colorStops: [
        { color: up.stroke, stop: 0 },
        { color: up.stroke, stop: 0.5 },
        { color: down.stroke, stop: 0.5 }
      ],
      rotation: 90
    };
    return [
      {
        legendType: "category",
        id,
        itemId: id,
        seriesId: id,
        enabled: visible && legendManager.getItemEnabled({ seriesId: id, itemId: id }),
        label: {
          text: legendItemName ?? yName ?? id
        },
        symbol: {
          marker: {
            fill,
            fillOpacity: up.strokeOpacity,
            stroke: void 0,
            strokeWidth: 0,
            strokeOpacity: 1,
            lineDash: [0],
            lineDashOffset: 0
          }
        },
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
OhlcSeries.className = "ohlc";
OhlcSeries.type = "ohlc";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs4, ohlcSeriesThemeableOptionsDef: ohlcSeriesThemeableOptionsDef2 } = module_support_exports;
var ohlcSeriesOptionsDef = {
  ...commonSeriesOptionsDefs4,
  ...ohlcSeriesThemeableOptionsDef2,
  type: required(constant("ohlc")),
  xKey: required(string),
  openKey: required(string),
  highKey: required(string),
  lowKey: required(string),
  closeKey: required(string),
  xName: string,
  yName: string,
  openName: string,
  highName: string,
  lowName: string,
  closeName: string
};
ohlcSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented(boolean);
ohlcSeriesOptionsDef.focusPriority = undocumented(number);
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE5, CARTESIAN_POSITION: CARTESIAN_POSITION3 },
  multiSeriesHighlightStyle: multiSeriesHighlightStyle3
} = module_support_exports;
var OhlcModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "ohlc",
  moduleFactory: (ctx) => new OhlcSeries(ctx),
  defaultAxes: [
    { type: CARTESIAN_AXIS_TYPE5.NUMBER, position: CARTESIAN_POSITION3.LEFT },
    { type: CARTESIAN_AXIS_TYPE5.ORDINAL_TIME, position: CARTESIAN_POSITION3.BOTTOM }
  ],
  themeTemplate: {
    animation: { enabled: false },
    series: {
      item: {
        up: {
          stroke: {
            $if: [
              { $eq: [{ $palette: "type" }, "user-indexed"] },
              { $palette: "stroke" },
              { $palette: "up.stroke" }
            ]
          }
        },
        down: {
          stroke: {
            $if: [
              { $eq: [{ $palette: "type" }, "user-indexed"] },
              { $palette: "stroke" },
              { $palette: "down.stroke" }
            ]
          }
        }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", "nearest"] }
      },
      highlight: multiSeriesHighlightStyle3(false)
    },
    axes: {
      [CARTESIAN_AXIS_TYPE5.NUMBER]: {
        crosshair: {
          snap: false
        }
      },
      [CARTESIAN_AXIS_TYPE5.ORDINAL_TIME]: {
        groupPaddingInner: 0,
        crosshair: {
          enabled: true
        }
      }
    }
  },
  groupable: false
};
var OhlcSeriesModule = {
  type: "series",
  name: "ohlc",
  chartType: "cartesian",
  enterprise: true,
  options: ohlcSeriesOptionsDef,
  create: (ctx) => new OhlcSeries(ctx)
};
var {
  AGGREGATION_INDEX_Y_MAX: AGGREGATION_INDEX_Y_MAX22,
  AGGREGATION_INDEX_Y_MIN: AGGREGATION_INDEX_Y_MIN22,
  aggregationDomain: aggregationDomain22,
  aggregationIndexForXRatio: aggregationIndexForXRatio2,
  aggregationRangeFittingPoints: aggregationRangeFittingPoints22,
  aggregationXRatioForXValue: aggregationXRatioForXValue2,
  compactAggregationIndices: compactAggregationIndices22,
  createAggregationIndices: createAggregationIndices22
} = module_support_exports;
var AGGREGATION_THRESHOLD22 = 1e3;
function aggregationContainsTopIndex(xValues, d0, d1, indexData, maxRange, datumIndex) {
  const xValue2 = xValues[datumIndex];
  if (xValue2 == null)
    return false;
  const xRatio = aggregationXRatioForXValue2(xValue2, d0, d1);
  const aggIndex = aggregationIndexForXRatio2(xRatio, maxRange);
  return datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MAX22];
}
function aggregationContainsBottomIndex(xValues, d0, d1, indexData, maxRange, datumIndex) {
  const xValue2 = xValues[datumIndex];
  if (xValue2 == null)
    return false;
  const xRatio = aggregationXRatioForXValue2(xValue2, d0, d1);
  const aggIndex = aggregationIndexForXRatio2(xRatio, maxRange);
  return datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MIN22];
}
function aggregateRangeAreaData(scale2, xValues, highValues, lowValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD22)
    return;
  const [d0, d1] = aggregationDomain22(scale2, domain);
  let maxRange = aggregationRangeFittingPoints22(xValues);
  const { indexData, valueData } = createAggregationIndices22(xValues, highValues, lowValues, d0, d1, maxRange);
  let topIndices = [];
  let bottomIndices = [];
  for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
    if (aggregationContainsTopIndex(xValues, d0, d1, indexData, maxRange, datumIndex)) {
      topIndices.push(datumIndex);
    }
    if (aggregationContainsBottomIndex(xValues, d0, d1, indexData, maxRange, datumIndex)) {
      bottomIndices.push(datumIndex);
    }
  }
  const filters = [{ maxRange, topIndices, bottomIndices }];
  while (maxRange > 64) {
    ({ maxRange } = compactAggregationIndices22(indexData, valueData, maxRange, { inPlace: true }));
    topIndices = topIndices.filter(aggregationContainsTopIndex.bind(null, xValues, d0, d1, indexData, maxRange));
    bottomIndices = bottomIndices.filter(
      aggregationContainsBottomIndex.bind(null, xValues, d0, d1, indexData, maxRange)
    );
    filters.push({ maxRange, topIndices, bottomIndices });
  }
  filters.reverse();
  return filters;
}
var {
  CartesianSeriesProperties: CartesianSeriesProperties22,
  FillGradientDefaults: FillGradientDefaults4,
  FillPatternDefaults: FillPatternDefaults4,
  FillImageDefaults: FillImageDefaults4,
  InterpolationProperties: InterpolationProperties2,
  SeriesMarker: SeriesMarker2,
  makeSeriesTooltip: makeSeriesTooltip5,
  Property: Property53,
  DropShadow: DropShadow2,
  Label: Label22
} = module_support_exports;
var RangeAreaSeriesLabel = class extends Label22 {
  constructor() {
    super(...arguments);
    this.placement = "outside";
    this.spacing = 0;
  }
};
__decorateClass2([
  Property53
], RangeAreaSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Property53
], RangeAreaSeriesLabel.prototype, "spacing", 2);
var RangeAreaProperties = class extends CartesianSeriesProperties22 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillGradientDefaults = new FillGradientDefaults4();
    this.fillPatternDefaults = new FillPatternDefaults4();
    this.fillImageDefaults = new FillImageDefaults4();
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties2();
    this.shadow = new DropShadow2().set({ enabled: false });
    this.marker = new SeriesMarker2();
    this.label = new RangeAreaSeriesLabel();
    this.tooltip = makeSeriesTooltip5();
    this.connectMissingData = false;
  }
};
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "xKey", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "yLowKey", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "yHighKey", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "xName", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "yName", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "yLowName", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "yHighName", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "fill", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "stroke", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "interpolation", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "shadow", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "marker", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "label", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "tooltip", 2);
__decorateClass2([
  Property53
], RangeAreaProperties.prototype, "connectMissingData", 2);
var {
  CollapseMode: CollapseMode2,
  isScaleValid: isScaleValid2,
  pairUpSpans: pairUpSpans2,
  prepareAreaFillAnimationFns: prepareAreaFillAnimationFns2,
  plotInterpolatedLinePathStroke: plotInterpolatedLinePathStroke2,
  prepareLinePathPropertyAnimation: prepareLinePathPropertyAnimation2,
  areScalingEqual: areScalingEqual2
} = module_support_exports;
function prepareRangeAreaPathStrokeAnimationFns(status, highSpans, lowSpans, visibleToggleMode) {
  const removePhaseFn = (ratio3, path) => {
    plotInterpolatedLinePathStroke2(ratio3, path, highSpans.removed);
    plotInterpolatedLinePathStroke2(ratio3, path, lowSpans.removed);
  };
  const updatePhaseFn = (ratio3, path) => {
    plotInterpolatedLinePathStroke2(ratio3, path, highSpans.moved);
    plotInterpolatedLinePathStroke2(ratio3, path, lowSpans.moved);
  };
  const addPhaseFn = (ratio3, path) => {
    plotInterpolatedLinePathStroke2(ratio3, path, highSpans.added);
    plotInterpolatedLinePathStroke2(ratio3, path, lowSpans.added);
  };
  const pathProperties = prepareLinePathPropertyAnimation2(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareRangeAreaPathAnimation(newData, oldData, diff8) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid2(newData.scales.x) || !isScaleValid2(oldData.scales.x)) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const fillSpans = pairUpSpans2(
    { scales: newData.scales, data: newData.fillData.spans },
    { scales: oldData.scales, data: oldData.fillData.spans },
    CollapseMode2.Split
  );
  if (fillSpans == null)
    return;
  const fillPhantomSpans = pairUpSpans2(
    { scales: newData.scales, data: newData.fillData.phantomSpans },
    { scales: oldData.scales, data: oldData.fillData.phantomSpans },
    CollapseMode2.Split
  );
  if (fillPhantomSpans == null)
    return;
  const highStrokeSpans = pairUpSpans2(
    { scales: newData.scales, data: newData.highStrokeData.spans },
    { scales: oldData.scales, data: oldData.highStrokeData.spans },
    CollapseMode2.Split
  );
  if (highStrokeSpans == null)
    return;
  const lowStrokeSpans = pairUpSpans2(
    { scales: newData.scales, data: newData.lowStrokeData.spans },
    { scales: oldData.scales, data: oldData.lowStrokeData.spans },
    CollapseMode2.Split
  );
  if (lowStrokeSpans == null)
    return;
  const fadeMode = "fade";
  const fill = prepareAreaFillAnimationFns2(status, fillSpans, fillPhantomSpans, fadeMode);
  const stroke22 = prepareRangeAreaPathStrokeAnimationFns(status, highStrokeSpans, lowStrokeSpans, fadeMode);
  const hasMotion = (diff8?.changed ?? true) || !areScalingEqual2(newData.scales.x, oldData.scales.x) || !areScalingEqual2(newData.scales.y, oldData.scales.y) || status !== "updated";
  return { status, fill, stroke: stroke22, hasMotion };
}
var {
  valueProperty: valueProperty6,
  keyProperty: keyProperty4,
  ChartAxisDirection: ChartAxisDirection16,
  mergeDefaults: mergeDefaults7,
  updateLabelNode: updateLabelNode22,
  fixNumericExtent: fixNumericExtent4,
  buildResetPathFn: buildResetPathFn2,
  resetLabelFn: resetLabelFn2,
  resetMarkerFn: resetMarkerFn2,
  resetMarkerPositionFn: resetMarkerPositionFn2,
  pathSwipeInAnimation: pathSwipeInAnimation2,
  resetMotion: resetMotion2,
  markerSwipeScaleInAnimation: markerSwipeScaleInAnimation2,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation2,
  animationValidation: animationValidation3,
  diff: diff3,
  updateClipPath: updateClipPath2,
  computeMarkerFocusBounds: computeMarkerFocusBounds2,
  plotAreaPathFill: plotAreaPathFill2,
  plotLinePathStroke: plotLinePathStroke2,
  interpolatePoints: interpolatePoints2,
  pathFadeInAnimation: pathFadeInAnimation2,
  markerFadeInAnimation: markerFadeInAnimation2,
  fromToMotion: fromToMotion2,
  pathMotion: pathMotion2,
  extent: extent2,
  applyShapeFillBBox: applyShapeFillBBox22,
  PointerEvents: PointerEvents22,
  Marker: Marker2,
  BBox: BBox13,
  findMinMax: findMinMax22,
  getShapeStyle: getShapeStyle3,
  getShapeFill: getShapeFill3,
  applyShapeStyle: applyShapeStyle4,
  processedDataIsAnimatable: processedDataIsAnimatable22,
  simpleMemorize2: simpleMemorize222
} = module_support_exports;
var memoizedAggregateRangeAreaData = simpleMemorize222(aggregateRangeAreaData);
var RangeAreaSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var RangeAreaSeries = class extends module_support_exports.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pathsPerSeries: ["fill", "stroke"],
      pickModes: [module_support_exports.SeriesNodePickMode.AXIS_ALIGNED],
      propertyKeys: {
        [ChartAxisDirection16.X]: ["xKey"],
        [ChartAxisDirection16.Y]: ["yLowKey", "yHighKey"]
      },
      propertyNames: {
        [ChartAxisDirection16.X]: ["xName"],
        [ChartAxisDirection16.Y]: ["yLowName", "yHighName", "yName"]
      },
      categoryKey: "xValue",
      animationResetFns: {
        path: buildResetPathFn2({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn2,
        datum: (node, datum) => ({ ...resetMarkerFn2(node), ...resetMarkerPositionFn2(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new RangeAreaProperties();
    this.NodeEvent = RangeAreaSeriesNodeEvent;
    this.dataAggregationFilters = void 0;
  }
  async processData(dataController) {
    const { xKey, yLowKey, yHighKey } = this.properties;
    const xScale = this.axes[ChartAxisDirection16.X]?.scale;
    const yScale = this.axes[ChartAxisDirection16.Y]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    if (!this.ctx.animationManager.isSkipped() && this.processedData) {
      extraProps.push(diff3(this.id, this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation3());
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty4(xKey, xScaleType, { id: `xValue` }),
        valueProperty6(yLowKey, yScaleType, { id: `yLowValue` }),
        valueProperty6(yHighKey, yScaleType, { id: `yHighValue` }),
        ...extraProps
      ]
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable22(processedData))
      return;
    const xAxis = this.axes[ChartAxisDirection16.X];
    if (xAxis == null)
      return;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yHighValues = dataModel.resolveColumnById(this, `yHighValue`, processedData);
    const yLowValues = dataModel.resolveColumnById(this, `yLowValue`, processedData);
    const { index } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const domain = processedData.domain.keys[index];
    return memoizedAggregateRangeAreaData(xAxis.scale.type, xValues, yHighValues, yLowValues, domain);
  }
  xCoordinateRange(xValue2) {
    const x = this.axes[ChartAxisDirection16.X].scale.convert(xValue2);
    return [x, x];
  }
  yCoordinateRange(yValues) {
    const y = this.axes[ChartAxisDirection16.Y].scale.convert(yValues[0]);
    return [y, y];
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys]
      }
    } = processedData;
    if (direction === ChartAxisDirection16.X) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent4(extent2(keys));
    } else {
      const yExtent = this.domainForClippedRange(ChartAxisDirection16.Y, ["yHighValue", "yLowValue"], "xValue");
      const fixedYExtent = findMinMax22(yExtent);
      return fixNumericExtent4(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange(ChartAxisDirection16.Y, ["yHighValue", "yLowValue"], "xValue", visibleRange);
  }
  createNodeData() {
    const { data, dataModel, processedData, axes } = this;
    const xAxis = axes[ChartAxisDirection16.X];
    const yAxis = axes[ChartAxisDirection16.Y];
    if (!(data && xAxis && yAxis && dataModel && processedData))
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const { xKey, yLowKey, yHighKey, connectMissingData, marker, interpolation } = this.properties;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const yHighValues = dataModel.resolveColumnById(this, "yHighValue", processedData);
    const yLowValues = dataModel.resolveColumnById(this, "yLowValue", processedData);
    const xPosition = (index) => xScale.convert(xValues[index]) + xOffset;
    const labelData = [];
    const markerData = [];
    const spanPoints = [];
    const handleDatumPoint = (datumIndex, yHighValue, yLowValue) => {
      const datum = rawData[datumIndex];
      const xValue2 = xValues[datumIndex];
      if (xValue2 == null)
        return;
      const currentSpanPoints = spanPoints[spanPoints.length - 1];
      if (Number.isFinite(yHighValue) && Number.isFinite(yLowValue)) {
        const appendMarker = (id, yValue, y) => {
          markerData.push({
            index: datumIndex,
            series: this,
            itemId: id,
            datum,
            datumIndex,
            midPoint: { x, y },
            yHighValue,
            yLowValue,
            xValue: xValue2,
            xKey,
            yLowKey,
            yHighKey,
            point: { x, y, size },
            enabled: true
          });
          const highLabelDatum = this.createLabelData({
            datumIndex,
            point: { x, y },
            value: yValue,
            yLowValue,
            yHighValue,
            itemId: id,
            inverted,
            datum,
            series: this
          });
          labelData.push(highLabelDatum);
        };
        const inverted = yLowValue > yHighValue;
        const x = xPosition(datumIndex);
        const yHighCoordinate = yScale.convert(yHighValue);
        const yLowCoordinate = yScale.convert(yLowValue);
        const { size } = marker;
        appendMarker("high", yHighValue, yHighCoordinate);
        appendMarker("low", yLowValue, yLowCoordinate);
        const spanPoint = {
          high: {
            point: { x, y: yHighCoordinate },
            xDatum: xValue2,
            yDatum: yHighValue
          },
          low: {
            point: { x, y: yLowCoordinate },
            xDatum: xValue2,
            yDatum: yLowValue
          }
        };
        if (Array.isArray(currentSpanPoints)) {
          currentSpanPoints.push(spanPoint);
        } else if (currentSpanPoints != null) {
          currentSpanPoints.skip += 1;
          spanPoints.push([spanPoint]);
        } else {
          spanPoints.push([spanPoint]);
        }
      } else if (!connectMissingData) {
        if (Array.isArray(currentSpanPoints) || currentSpanPoints == null) {
          spanPoints.push({ skip: 0 });
        } else {
          currentSpanPoints.skip += 1;
        }
      }
    };
    const { dataAggregationFilters } = this;
    const [r0, r1] = xScale.range;
    const range22 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range22);
    const topIndices = dataAggregationFilter?.topIndices;
    const bottomIndices = dataAggregationFilter?.bottomIndices;
    let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, topIndices);
    start2 = Math.max(start2 - 1, 0);
    end2 = Math.min(end2 + 1, topIndices?.length ?? xValues.length);
    if (processedData.input.count < 1e3) {
      start2 = 0;
      end2 = processedData.input.count;
    }
    for (let i = start2; i < end2; i += 1) {
      const topDatumIndex = topIndices?.[i] ?? i;
      const bottomDatumIndex = bottomIndices?.[i] ?? i;
      handleDatumPoint(topDatumIndex, yHighValues[topDatumIndex], yLowValues[bottomDatumIndex]);
    }
    const highSpans = spanPoints.flatMap((p) => {
      if (!Array.isArray(p))
        return [];
      const highPoints = p.map((d) => d.high);
      return interpolatePoints2(highPoints, interpolation);
    });
    const lowSpans = spanPoints.flatMap((p) => {
      if (!Array.isArray(p))
        return [];
      const lowPoints = p.map((d) => d.low);
      return interpolatePoints2(lowPoints, interpolation);
    });
    const context = {
      itemId: `${yLowKey}-${yHighKey}`,
      labelData,
      nodeData: markerData,
      fillData: { itemId: "high", spans: highSpans, phantomSpans: lowSpans },
      highStrokeData: { itemId: "high", spans: highSpans },
      lowStrokeData: { itemId: "low", spans: lowSpans },
      scales: this.calculateScaling(),
      visible: this.visible
    };
    return context;
  }
  createLabelData({
    datumIndex,
    point,
    value,
    itemId,
    inverted,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, label } = this.properties;
    const { placement } = label;
    const spacing = label.spacing + (typeof label.padding === "number" ? label.padding : 0);
    let actualItemId = itemId;
    if (inverted) {
      actualItemId = itemId === "low" ? "high" : "low";
    }
    const direction = placement === "outside" && actualItemId === "high" || placement === "inside" && actualItemId === "low" ? -1 : 1;
    const yDomain = this.getSeriesDomain(ChartAxisDirection16.Y);
    return {
      x: point.x,
      y: point.y + spacing * direction,
      series,
      itemId,
      datum,
      datumIndex,
      text: this.getLabelText(
        value,
        datum,
        itemId === "high" ? yHighKey : yLowKey,
        "y",
        yDomain,
        label,
        { value, datum, itemId, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName }
      ),
      textAlign: "center",
      textBaseline: direction === -1 ? "bottom" : "top"
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const { visible } = opts;
    const [fill, stroke22] = opts.paths;
    const {
      strokeWidth,
      stroke: strokeColor,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fill: fillColor,
      fillOpacity,
      opacity
    } = mergeDefaults7(this.getHighlightStyle(), this.properties);
    stroke22.setProperties({
      fill: void 0,
      lineCap: "round",
      lineJoin: "round",
      pointerEvents: PointerEvents22.None,
      stroke: strokeColor,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      opacity,
      visible
    });
    const seriesFill = getShapeFill3(
      fillColor,
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    const fillBBox = this.getShapeFillBBox();
    applyShapeFillBBox22(fill, seriesFill, fillBBox);
    applyShapeStyle4(
      fill,
      {
        stroke: void 0,
        fill: seriesFill,
        fillOpacity,
        lineDash,
        lineDashOffset,
        strokeOpacity,
        strokeWidth,
        opacity
      },
      fillBBox
    );
    fill.setProperties({
      pointerEvents: PointerEvents22.None,
      lineJoin: "round",
      fillShadow: this.properties.shadow,
      opacity,
      visible
    });
    updateClipPath2(this, stroke22);
    updateClipPath2(this, fill);
  }
  updatePaths(opts) {
    this.updateAreaPaths(opts.paths, opts.contextData);
  }
  updateAreaPaths(paths, contextData) {
    for (const path of paths) {
      path.visible = contextData.visible;
    }
    if (contextData.visible) {
      this.updateFillPath(paths, contextData);
      this.updateStrokePath(paths, contextData);
    } else {
      for (const path of paths) {
        path.path.clear();
        path.markDirty("RangeArea");
      }
    }
  }
  updateFillPath(paths, contextData) {
    const [fill] = paths;
    fill.path.clear();
    plotAreaPathFill2(fill, contextData.fillData);
    fill.markDirty("RangeArea");
  }
  updateStrokePath(paths, contextData) {
    const [, stroke22] = paths;
    stroke22.path.clear();
    plotLinePathStroke2(stroke22, contextData.highStrokeData.spans);
    plotLinePathStroke2(stroke22, contextData.lowStrokeData.spans);
    stroke22.markDirty("RangeArea");
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    if (this.properties.marker.isDirty()) {
      datumSelection.clear();
      datumSelection.cleanup();
    }
    return datumSelection.update(this.properties.marker.enabled ? nodeData : []);
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { xKey, yLowKey, yHighKey, marker, fill, stroke: stroke22, strokeWidth, fillOpacity, strokeOpacity } = this.properties;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((node, datum) => {
      const params = { xKey, yHighKey, yLowKey };
      const style2 = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity
      });
      this.applyMarkerStyle(style2, node, datum.point, fillBBox);
    });
    if (!isHighlight) {
      this.properties.marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = PointerEvents22.None;
    });
  }
  updateLabelNodes(opts) {
    const params = {
      xKey: this.properties.xKey,
      xName: this.properties.xName ?? this.properties.xKey,
      yName: this.properties.yName,
      yLowKey: this.properties.yLowKey,
      yLowName: this.properties.yLowName ?? this.properties.yLowKey,
      yHighKey: this.properties.yHighKey,
      yHighName: this.properties.yHighName ?? this.properties.yHighKey
    };
    opts.labelSelection.each((textNode, datum) => {
      textNode.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
      updateLabelNode22(this, textNode, params, this.properties.label, datum);
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItems = nodeData.filter((nodeDatum) => nodeDatum.datum === highlightedItem.datum);
    return highlightItems.length > 0 ? highlightItems : void 0;
  }
  getTooltipContent(datumIndex, removeThisDatum) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xName, yName, yLowKey, yLowName, xKey, yHighKey, yHighName, tooltip, legendItemName } = properties;
    const xAxis = axes[ChartAxisDirection16.X];
    const yAxis = axes[ChartAxisDirection16.Y];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yHighValue = dataModel.resolveColumnById(this, `yHighValue`, processedData)[datumIndex];
    const yLowValue = dataModel.resolveColumnById(this, `yLowValue`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const format = this.getMarkerStyle(
      this.properties.marker,
      { datumIndex, datum },
      { xKey, yLowKey, yHighKey },
      false
    );
    const value = `${this.getAxisValueText(yAxis, "tooltip", yLowValue, datum, yLowKey, legendItemName)} - ${this.getAxisValueText(yAxis, "tooltip", yHighValue, datum, yHighKey, legendItemName)}`;
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [{ label: yName, fallbackLabel: `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`, value }]
      },
      {
        seriesId,
        datum,
        title: yName,
        itemId: removeThisDatum?.itemId ?? "unknown",
        xName,
        yName,
        yLowKey,
        yLowName,
        xKey,
        yHighKey,
        yHighName,
        ...format
      }
    );
  }
  legendItemSymbol() {
    const { fill, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, marker } = this.properties;
    const markerStyle = getShapeStyle3(
      {
        shape: marker.shape,
        fill: marker.fill ?? fill,
        stroke: marker.stroke ?? stroke22,
        fillOpacity: marker.fillOpacity,
        strokeOpacity: marker.strokeOpacity,
        strokeWidth: marker.strokeWidth,
        lineDash: marker.lineDash,
        lineDashOffset: marker.lineDashOffset
      },
      marker.fillGradientDefaults,
      marker.fillPatternDefaults,
      marker.fillImageDefaults
    );
    return {
      marker: markerStyle,
      line: {
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id: seriesId, visible } = this;
    const { yLowKey, yHighKey, yName, yLowName, yHighName, showInLegend } = this.properties;
    const legendItemText = yName ?? `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`;
    const itemId = `${yLowKey}-${yHighKey}`;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible,
        label: { text: `${legendItemText}` },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  nodeFactory() {
    return new Marker2();
  }
  animateEmptyUpdateReady(animationData) {
    const { datumSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation2(this, animationManager, ...paths);
    resetMotion2([datumSelection], resetMarkerPositionFn2);
    markerSwipeScaleInAnimation2(this, animationManager, datumSelection);
    seriesLabelFadeInAnimation2(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const { datumSelection, labelSelection, contextData, paths, previousContextData } = animationData;
    const [fill, stroke22] = paths;
    if (fill == null && stroke22 == null)
      return;
    this.resetDatumAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateAreaPaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation2(this, animationManager, "added", datumSelection);
      pathFadeInAnimation2(this, "fill_path_properties", animationManager, "add", fill);
      pathFadeInAnimation2(this, "stroke_path_properties", animationManager, "add", stroke22);
      seriesLabelFadeInAnimation2(this, "labels", animationManager, labelSelection);
      return;
    }
    const fns = prepareRangeAreaPathAnimation(
      contextData,
      previousContextData,
      this.processedData?.reduced?.diff?.[this.id]
    );
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    fromToMotion2(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
    fromToMotion2(this.id, "stroke_path_properties", animationManager, [stroke22], fns.stroke.pathProperties);
    if (fns.status === "added") {
      this.updateAreaPaths(paths, contextData);
    } else if (fns.status === "removed") {
      this.updateAreaPaths(paths, previousContextData);
    } else {
      pathMotion2(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
      pathMotion2(this.id, "stroke_path_update", animationManager, [stroke22], fns.stroke.path);
    }
    if (fns.hasMotion) {
      markerFadeInAnimation2(this, animationManager, void 0, datumSelection);
      seriesLabelFadeInAnimation2(this, "labels", animationManager, labelSelection);
    }
    this.ctx.animationManager.animate({
      id: this.id,
      groupId: "reset_after_animation",
      phase: "trailing",
      from: {},
      to: {},
      onComplete: () => this.updateAreaPaths(paths, contextData)
    });
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yLowKey, yHighKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, datum, { xKey, yLowKey, yHighKey }, true);
  }
  computeFocusBounds(opts) {
    const hiBox = computeMarkerFocusBounds2(this, opts);
    const loBox = computeMarkerFocusBounds2(this, { ...opts, datumIndex: opts.datumIndex + 1 });
    if (hiBox && loBox) {
      return BBox13.merge([hiBox, loBox]);
    }
    return void 0;
  }
  isDatumEnabled(nodeData, datumIndex) {
    return datumIndex % 2 === 0 && super.isDatumEnabled(nodeData, datumIndex);
  }
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
RangeAreaSeries.className = "RangeAreaSeries";
RangeAreaSeries.type = "range-area";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs5, rangeAreaSeriesThemeableOptionsDef: rangeAreaSeriesThemeableOptionsDef2 } = module_support_exports;
var rangeAreaSeriesOptionsDef = {
  ...commonSeriesOptionsDefs5,
  ...rangeAreaSeriesThemeableOptionsDef2,
  type: required(constant("range-area")),
  xKey: required(string),
  yLowKey: required(string),
  yHighKey: required(string),
  xName: string,
  yName: string,
  yLowName: string,
  yHighName: string
};
rangeAreaSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented(boolean);
rangeAreaSeriesOptionsDef.focusPriority = undocumented(number);
var RANGE_AREA_SERIES_THEME = {
  series: {
    fill: { $palette: "fill" },
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    stroke: { $palette: "stroke" },
    fillOpacity: 0.7,
    nodeClickRange: "nearest",
    marker: {
      enabled: false,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      size: 6,
      strokeWidth: 2
    },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      placement: "outside",
      padding: { $isUserOption: ["./spacing", 0, 10] },
      // compatibility with old `padding` property (now named `spacing`).
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" }
    },
    interpolation: {
      type: "linear"
    },
    tooltip: {
      range: { $path: ["/tooltip/range", "nearest"] }
    },
    highlight: module_support_exports.multiSeriesHighlightStyle()
  },
  axes: {
    [module_support_exports.ThemeConstants.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: { enabled: true }
    }
  }
};
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE6, CARTESIAN_POSITION: CARTESIAN_POSITION4 }
} = module_support_exports;
var RangeAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-area",
  moduleFactory: (ctx) => new RangeAreaSeries(ctx),
  defaultAxes: [
    { type: CARTESIAN_AXIS_TYPE6.NUMBER, position: CARTESIAN_POSITION4.LEFT },
    { type: CARTESIAN_AXIS_TYPE6.CATEGORY, position: CARTESIAN_POSITION4.BOTTOM }
  ],
  themeTemplate: RANGE_AREA_SERIES_THEME
};
var RangeAreaSeriesModule = {
  type: "series",
  name: "range-area",
  chartType: "cartesian",
  enterprise: true,
  options: rangeAreaSeriesOptionsDef,
  create: (ctx) => new RangeAreaSeries(ctx)
};
var { aggregationDomain: aggregationDomain3, aggregationRangeFittingPoints: aggregationRangeFittingPoints3, compactAggregationIndices: compactAggregationIndices3, createAggregationIndices: createAggregationIndices3 } = module_support_exports;
var AGGREGATION_THRESHOLD32 = 1e3;
function aggregateRangeBarData(scale2, xValues, highValues, lowValues, domain) {
  if (xValues.length < AGGREGATION_THRESHOLD32)
    return;
  const [d0, d1] = aggregationDomain3(scale2, domain);
  let maxRange = aggregationRangeFittingPoints3(xValues);
  let { indexData, valueData } = createAggregationIndices3(xValues, highValues, lowValues, d0, d1, maxRange);
  const filters = [{ maxRange, indexData }];
  while (maxRange > 64) {
    ({ indexData, valueData, maxRange } = compactAggregationIndices3(indexData, valueData, maxRange));
    filters.push({ maxRange, indexData });
  }
  filters.reverse();
  return filters;
}
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties3,
  FillGradientDefaults: FillGradientDefaults5,
  FillPatternDefaults: FillPatternDefaults5,
  FillImageDefaults: FillImageDefaults5,
  makeSeriesTooltip: makeSeriesTooltip6,
  Property: Property54,
  DropShadow: DropShadow22,
  Label: Label3
} = module_support_exports;
var RangeBarSeriesLabel = class extends Label3 {
  constructor() {
    super(...arguments);
    this.placement = "inside";
    this.spacing = 0;
  }
};
__decorateClass2([
  Property54
], RangeBarSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Property54
], RangeBarSeriesLabel.prototype, "spacing", 2);
var RangeBarProperties = class extends AbstractBarSeriesProperties3 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillGradientDefaults = new FillGradientDefaults5();
    this.fillPatternDefaults = new FillPatternDefaults5();
    this.fillImageDefaults = new FillImageDefaults5();
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.shadow = new DropShadow22().set({ enabled: false });
    this.label = new RangeBarSeriesLabel();
    this.tooltip = makeSeriesTooltip6();
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "xKey", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "yLowKey", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "yHighKey", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "xName", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "yName", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "yLowName", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "yHighName", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "fill", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "stroke", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "shadow", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "label", 2);
__decorateClass2([
  Property54
], RangeBarProperties.prototype, "tooltip", 2);
var {
  SeriesNodePickMode: SeriesNodePickMode4,
  valueProperty: valueProperty7,
  keyProperty: keyProperty5,
  ChartAxisDirection: ChartAxisDirection17,
  checkCrisp: checkCrisp2,
  updateLabelNode: updateLabelNode3,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL3,
  LARGEST_KEY_INTERVAL: LARGEST_KEY_INTERVAL2,
  diff: diff4,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions2,
  midpointStartingBarPosition: midpointStartingBarPosition2,
  resetBarSelectionsFn: resetBarSelectionsFn2,
  fixNumericExtent: fixNumericExtent5,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation22,
  resetLabelFn: resetLabelFn22,
  animationValidation: animationValidation4,
  computeBarFocusBounds: computeBarFocusBounds4,
  visibleRangeIndices: visibleRangeIndices22,
  createDatumId: createDatumId4,
  ContinuousScale: ContinuousScale5,
  Rect: Rect3,
  PointerEvents: PointerEvents3,
  motion: motion22,
  applyShapeStyle: applyShapeStyle5,
  findMinMax: findMinMax3,
  getShapeStyle: getShapeStyle4,
  areScalingEqual: areScalingEqual22,
  processedDataIsAnimatable: processedDataIsAnimatable3,
  AGGREGATION_SPAN: AGGREGATION_SPAN22,
  AGGREGATION_INDEX_X_MAX: AGGREGATION_INDEX_X_MAX22,
  AGGREGATION_INDEX_X_MIN: AGGREGATION_INDEX_X_MIN22,
  AGGREGATION_INDEX_Y_MAX: AGGREGATION_INDEX_Y_MAX3,
  AGGREGATION_INDEX_Y_MIN: AGGREGATION_INDEX_Y_MIN3,
  mergeDefaults: mergeDefaults8,
  simpleMemorize2: simpleMemorize23
} = module_support_exports;
var memoizedAggregateRangeBarData = simpleMemorize23(aggregateRangeBarData);
var RangeBarSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var RangeBarSeries = class extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode4.AXIS_ALIGNED, SeriesNodePickMode4.EXACT_SHAPE_MATCH],
      propertyKeys: {
        x: ["xKey"],
        y: ["yLowKey", "yHighKey"]
      },
      propertyNames: {
        x: ["xName"],
        y: ["yLowName", "yHighName", "yName"]
      },
      categoryKey: "xValue",
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn2,
        label: resetLabelFn22
      }
    });
    this.properties = new RangeBarProperties();
    this.dataAggregationFilters = void 0;
    this.NodeEvent = RangeBarSeriesNodeEvent;
  }
  async processData(dataController) {
    const { xKey, yLowKey, yHighKey } = this.properties;
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      if (this.processedData) {
        extraProps.push(diff4(this.id, this.processedData));
      }
      extraProps.push(animationValidation4());
    }
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty5(xKey, xScaleType, { id: "xValue" }),
        valueProperty7(yLowKey, yScaleType, { id: `yLowValue`, invalidValue: null, ...visibleProps }),
        valueProperty7(yHighKey, yScaleType, { id: `yHighValue`, invalidValue: null, ...visibleProps }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL3, LARGEST_KEY_INTERVAL2] : [],
        ...extraProps
      ],
      groupByKeys: false
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  aggregateData(dataModel, processedData) {
    if (processedData.type !== "ungrouped")
      return;
    if (processedDataIsAnimatable3(processedData))
      return;
    const xAxis = this.axes[ChartAxisDirection17.X];
    if (xAxis == null)
      return;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yHighValues = dataModel.resolveColumnById(this, `yHighValue`, processedData);
    const yLowValues = dataModel.resolveColumnById(this, `yLowValue`, processedData);
    const { index } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const domain = processedData.domain.keys[index];
    return memoizedAggregateRangeBarData(xAxis.scale.type, xValues, yHighValues, yLowValues, domain);
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel)
      return [];
    const {
      keys: [keys]
    } = processedData.domain;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef?.def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    } else {
      const yExtent = this.domainForClippedRange(direction, ["yHighValue", "yLowValue"], "xValue");
      const fixedYExtent = findMinMax3(yExtent);
      return fixNumericExtent5(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange(ChartAxisDirection17.Y, ["yHighValue", "yLowValue"], "xValue", visibleRange);
  }
  createNodeData() {
    const { data, dataModel, groupScale, processedData, visible } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(data && xAxis && yAxis && dataModel && processedData?.dataSources))
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const barAlongX = this.getBarDirection() === ChartAxisDirection17.X;
    const { xKey, yLowKey, yHighKey, strokeWidth } = this.properties;
    const itemId = `${yLowKey}-${yHighKey}`;
    const context = {
      itemId,
      nodeData: [],
      labelData: [],
      scales: this.calculateScaling(),
      groupScale: this.getScaling(this.groupScale),
      visible: this.visible
    };
    if (!visible)
      return context;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yLowValues = dataModel.resolveColumnById(this, `yLowValue`, processedData);
    const yHighValues = dataModel.resolveColumnById(this, `yHighValue`, processedData);
    const { barWidth: effectiveBarWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale5.is(xScale) ? effectiveBarWidth * -0.5 : 0;
    const groupOffset = groupScale.convert(String(groupIndex));
    const defaultCrisp = checkCrisp2(
      xAxis?.scale,
      xAxis?.visibleRange,
      this.smallestDataInterval,
      this.largestDataInterval
    );
    const xPosition = (datumIndex) => Math.round(xScale.convert(xValues[datumIndex])) + groupOffset + barOffset;
    const handleDatum = (datumIndex, groupedDataIndex, x, width2, yLow, yHigh, crisp) => {
      const datum = rawData[datumIndex];
      const xDatum = xValues[datumIndex];
      if (xDatum == null)
        return;
      const rawLowValue = yLowValues[datumIndex];
      const rawHighValue = yHighValues[datumIndex];
      if (!Number.isFinite(rawLowValue?.valueOf()) || !Number.isFinite(rawHighValue?.valueOf()))
        return;
      const [yLowValue, yHighValue] = rawLowValue < rawHighValue ? [rawLowValue, rawHighValue] : [rawHighValue, rawLowValue];
      const y = Math.round(yScale.convert(yHigh));
      const bottomY = Math.round(yScale.convert(yLow));
      const height2 = Math.max(strokeWidth, Math.abs(bottomY - y));
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : x,
        y: barAlongX ? x : Math.min(y, bottomY),
        width: barAlongX ? height2 : width2,
        height: barAlongX ? width2 : height2
      };
      const nodeMidPoint = {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      };
      const labelData = this.createLabelData({
        datumIndex,
        rect,
        barAlongX,
        yLowValue,
        yHighValue,
        datum,
        series: this
      });
      const nodeDatum = {
        index: groupedDataIndex,
        series: this,
        itemId,
        datum,
        datumIndex,
        xValue: xDatum,
        yLowValue: rawLowValue,
        yHighValue: rawHighValue,
        yLowKey,
        yHighKey,
        xKey,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        midPoint: nodeMidPoint,
        crisp,
        labels: labelData
      };
      context.nodeData.push(nodeDatum);
      context.labelData.push(...labelData);
    };
    const { dataAggregationFilters } = this;
    const [r0, r1] = xScale.range;
    const range22 = Math.abs(r1 - r0);
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range22);
    if (dataAggregationFilter != null) {
      const { maxRange, indexData } = dataAggregationFilter;
      const [start2, end2] = visibleRangeIndices22(1, maxRange, xAxis.range, (index) => {
        const aggIndex = index * AGGREGATION_SPAN22;
        const xMinIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MIN22];
        const xMaxIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MAX22];
        if (xMinIndex === -1)
          return;
        const midDatumIndex = (xMinIndex + xMaxIndex) / 2 | 0;
        return [xPosition(midDatumIndex), xPosition(xMaxIndex) + effectiveBarWidth];
      });
      for (let i = start2; i < end2; i += 1) {
        const aggIndex = i * AGGREGATION_SPAN22;
        const xMinIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MIN22];
        const xMaxIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MAX22];
        const yMinIndex = indexData[aggIndex + AGGREGATION_INDEX_Y_MIN3];
        const yMaxIndex = indexData[aggIndex + AGGREGATION_INDEX_Y_MAX3];
        if (xMinIndex === -1)
          continue;
        const midDatumIndex = (xMinIndex + xMaxIndex) / 2 | 0;
        const xValue2 = xValues[midDatumIndex];
        if (xValue2 == null)
          continue;
        const x = xPosition(midDatumIndex);
        const width2 = Math.abs(xPosition(xMinIndex) - xPosition(xMaxIndex)) + effectiveBarWidth;
        const yLow = yLowValues[yMinIndex];
        const yHigh = yHighValues[yMaxIndex];
        handleDatum(midDatumIndex, 0, x, width2, yLow, yHigh, false);
      }
    } else if (processedData.type === "ungrouped") {
      const invalidData = processedData.invalidData?.get(this.id);
      let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range);
      if (processedData.input.count < 1e3) {
        start2 = 0;
        end2 = processedData.input.count;
      }
      for (let datumIndex = start2; datumIndex < end2; datumIndex += 1) {
        if (invalidData?.[datumIndex] === true)
          continue;
        const x = xPosition(datumIndex);
        const width2 = effectiveBarWidth;
        const yLow = yLowValues[datumIndex];
        const yHigh = yHighValues[datumIndex];
        handleDatum(datumIndex, 0, x, width2, yLow, yHigh, defaultCrisp);
      }
    } else {
      for (const { datumIndex, groupIndex: groupDataIndex } of dataModel.forEachGroupDatum(this, processedData)) {
        const x = xPosition(datumIndex);
        const width2 = effectiveBarWidth;
        const yLow = yLowValues[datumIndex];
        const yHigh = yHighValues[datumIndex];
        handleDatum(datumIndex, groupDataIndex, x, width2, yLow, yHigh, defaultCrisp);
      }
    }
    return context;
  }
  createLabelData({
    datumIndex,
    rect,
    barAlongX,
    yLowValue,
    yHighValue,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, label } = this.properties;
    const labelParams = { datum, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName };
    const { placement } = label;
    const spacing = label.spacing + (typeof label.padding === "number" ? label.padding : 0);
    const paddingDirection = placement === "outside" ? 1 : -1;
    const labelPadding = spacing * paddingDirection;
    const yDomain = this.getSeriesDomain(ChartAxisDirection17.Y);
    const yLowLabel = {
      datumIndex,
      x: rect.x + (barAlongX ? -labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : rect.height + labelPadding),
      textAlign: barAlongX ? "left" : "center",
      textBaseline: barAlongX ? "middle" : "bottom",
      text: this.getLabelText(
        yLowValue,
        datum,
        yLowKey,
        "y",
        yDomain,
        label,
        { itemId: "low", value: yLowValue, ...labelParams }
      ),
      itemId: "low",
      datum,
      series
    };
    const yHighLabel = {
      datumIndex,
      x: rect.x + (barAlongX ? rect.width + labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : -labelPadding),
      textAlign: barAlongX ? "right" : "center",
      textBaseline: barAlongX ? "middle" : "top",
      text: this.getLabelText(
        yHighValue,
        datum,
        yHighKey,
        "y",
        yDomain,
        label,
        { itemId: "high", value: yHighValue, ...labelParams }
      ),
      itemId: "high",
      datum,
      series
    };
    if (placement === "outside") {
      yLowLabel.textAlign = barAlongX ? "right" : "center";
      yLowLabel.textBaseline = barAlongX ? "middle" : "top";
      yHighLabel.textAlign = barAlongX ? "left" : "center";
      yHighLabel.textBaseline = barAlongX ? "middle" : "bottom";
    }
    return [yLowLabel, yHighLabel];
  }
  nodeFactory() {
    return new Rect3();
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data, void 0, (datum) => this.getDatumId(datum));
  }
  getItemStyle(datum, isHighlight) {
    const { id: seriesId, properties } = this;
    const { xKey, yHighKey, yLowKey, itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, datum.datumIndex);
    const baseStyle = mergeDefaults8(highlightStyle, properties.getStyle());
    let style2 = getShapeStyle4(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && datum != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId4(this.getDatumId(datum), isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum: datum.datum,
            xKey,
            yHighKey,
            yLowKey,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle4(
          mergeDefaults8(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection17.X;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((rect, datum) => {
      const style2 = this.getItemStyle(datum, isHighlight);
      applyShapeStyle5(rect, style2, fillBBox);
      rect.cornerRadius = style2.cornerRadius;
      rect.visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
      rect.crisp = datum.crisp;
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  updateLabelSelection(opts) {
    const labelData = this.properties.label.enabled ? opts.labelData : [];
    return opts.labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = PointerEvents3.None;
    });
  }
  updateLabelNodes(opts) {
    const params = {
      xKey: this.properties.xKey,
      xName: this.properties.xName ?? this.properties.xKey,
      yName: this.properties.yName,
      yLowKey: this.properties.yLowKey,
      yLowName: this.properties.yLowName ?? this.properties.yLowKey,
      yHighKey: this.properties.yHighKey,
      yHighName: this.properties.yHighName ?? this.properties.yHighKey
    };
    opts.labelSelection.each((textNode, datum) => {
      textNode.fillOpacity = this.getHighlightStyle(false, datum?.datumIndex).opacity ?? 1;
      updateLabelNode3(this, textNode, params, this.properties.label, datum);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { xKey, xName, yName, yLowKey, yHighKey, yLowName, yHighName, tooltip, legendItemName } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    const nodeDatum = this.contextNodeData?.nodeData?.[datumIndex];
    if (!dataModel || !processedData || !xAxis || !yAxis || !nodeDatum) {
      return;
    }
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yHighValue = dataModel.resolveColumnById(this, `yHighValue`, processedData)[datumIndex];
    const yLowValue = dataModel.resolveColumnById(this, `yLowValue`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const format = this.getItemStyle(nodeDatum, false);
    const value = `${this.getAxisValueText(yAxis, "tooltip", yLowValue, datum, yLowKey, legendItemName)} - ${this.getAxisValueText(yAxis, "tooltip", yHighValue, datum, yHighKey, legendItemName)}`;
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(),
        data: [{ label: yName, fallbackLabel: `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`, value }]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yName,
        yLowKey,
        yHighKey,
        yLowName,
        yHighName,
        ...format
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke22,
      strokeWidth,
      fillOpacity,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.properties;
    return {
      marker: getShapeStyle4(
        {
          fill,
          stroke: stroke22,
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults5,
        fillPatternDefaults5,
        fillImageDefaults5
      )
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id: seriesId, visible } = this;
    const { yName, yLowName, yHighName, yLowKey, yHighKey, showInLegend } = this.properties;
    const legendItemText = yName ?? `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`;
    const itemId = `${yLowKey}-${yHighKey}`;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible,
        label: { text: `${legendItemText}` },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition2(this.isVertical(), "normal"));
    motion22.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation22(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection: datumSelections, labelSelection, contextData, previousContextData } = data;
    const dataDiff = module_support_exports.calculateDataDiff(
      this.id,
      datumSelections,
      this.getDatumId.bind(this),
      contextData,
      previousContextData,
      this.processedData
    );
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const mode = previousContextData == null ? "fade" : "normal";
    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition2(this.isVertical(), mode));
    motion22.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [datumSelections],
      fns,
      (_, datum) => this.getDatumId(datum),
      dataDiff
    );
    if (dataDiff?.changed || !areScalingEqual22(contextData.groupScale, previousContextData?.groupScale)) {
      seriesLabelFadeInAnimation22(this, "labels", this.ctx.animationManager, labelSelection);
    }
  }
  getDatumId(datum) {
    return `${datum.xValue}`;
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds4(this, this.contextNodeData?.nodeData[datumIndex]);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
RangeBarSeries.className = "RangeBarSeries";
RangeBarSeries.type = "range-bar";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs6, rangeBarSeriesThemeableOptionsDef: rangeBarSeriesThemeableOptionsDef2 } = module_support_exports;
var rangeBarSeriesOptionsDef = {
  ...commonSeriesOptionsDefs6,
  ...rangeBarSeriesThemeableOptionsDef2,
  type: required(constant("range-bar")),
  xKey: required(string),
  yLowKey: required(string),
  yHighKey: required(string),
  xName: string,
  yName: string,
  yLowName: string,
  yHighName: string
};
rangeBarSeriesOptionsDef.pickOutsideVisibleMinorAxis = undocumented(boolean);
rangeBarSeriesOptionsDef.focusPriority = undocumented(number);
var RANGE_BAR_SERIES_THEME = {
  series: {
    direction: "vertical",
    fill: { $palette: "fill" },
    stroke: { $palette: "stroke" },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "chartBackgroundColor" },
      placement: "inside",
      padding: { $isUserOption: ["./spacing", 0, 6] }
      // compatibility with old `padding` property (now named `spacing`).
    },
    highlight: module_support_exports.multiSeriesHighlightStyle()
  },
  axes: {
    [module_support_exports.ThemeConstants.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: { enabled: true }
    }
  }
};
var RangeBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-bar",
  moduleFactory: (ctx) => new RangeBarSeries(ctx),
  defaultAxes: module_support_exports.DIRECTION_SWAP_AXES,
  themeTemplate: RANGE_BAR_SERIES_THEME,
  groupable: true
};
var RangeBarSeriesModule = {
  type: "series",
  name: "range-bar",
  chartType: "cartesian",
  enterprise: true,
  options: rangeBarSeriesOptionsDef,
  create: (ctx) => new RangeBarSeries(ctx)
};
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties4,
  BaseProperties: BaseProperties18,
  FillGradientDefaults: FillGradientDefaults6,
  FillPatternDefaults: FillPatternDefaults6,
  FillImageDefaults: FillImageDefaults6,
  PropertiesArray: PropertiesArray4,
  makeSeriesTooltip: makeSeriesTooltip7,
  Property: Property55,
  DropShadow: DropShadow3,
  Label: Label4
} = module_support_exports;
var WaterfallSeriesTotal = class extends BaseProperties18 {
};
__decorateClass2([
  Property55
], WaterfallSeriesTotal.prototype, "totalType", 2);
__decorateClass2([
  Property55
], WaterfallSeriesTotal.prototype, "index", 2);
__decorateClass2([
  Property55
], WaterfallSeriesTotal.prototype, "axisLabel", 2);
var WaterfallSeriesItemTooltip = class extends BaseProperties18 {
};
__decorateClass2([
  Property55
], WaterfallSeriesItemTooltip.prototype, "renderer", 2);
var WaterfallSeriesLabel = class extends Label4 {
  constructor() {
    super(...arguments);
    this.placement = "outside-end";
    this.spacing = 0;
  }
};
__decorateClass2([
  Property55
], WaterfallSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Property55
], WaterfallSeriesLabel.prototype, "spacing", 2);
var WaterfallSeriesItem = class extends BaseProperties18 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults6();
    this.fillPatternDefaults = new FillPatternDefaults6();
    this.fillImageDefaults = new FillImageDefaults6();
    this.stroke = "#c16068";
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.cornerRadius = 0;
    this.shadow = new DropShadow3().set({ enabled: false });
    this.label = new WaterfallSeriesLabel();
    this.tooltip = new WaterfallSeriesItemTooltip();
  }
};
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "name", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "fill", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "stroke", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "fillOpacity", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "lineDash", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "strokeWidth", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "cornerRadius", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "itemStyler", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "shadow", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "label", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItem.prototype, "tooltip", 2);
var WaterfallSeriesConnectorLine = class extends BaseProperties18 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 2;
  }
};
__decorateClass2([
  Property55
], WaterfallSeriesConnectorLine.prototype, "enabled", 2);
__decorateClass2([
  Property55
], WaterfallSeriesConnectorLine.prototype, "stroke", 2);
__decorateClass2([
  Property55
], WaterfallSeriesConnectorLine.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property55
], WaterfallSeriesConnectorLine.prototype, "lineDash", 2);
__decorateClass2([
  Property55
], WaterfallSeriesConnectorLine.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property55
], WaterfallSeriesConnectorLine.prototype, "strokeWidth", 2);
var WaterfallSeriesItems = class extends BaseProperties18 {
  constructor() {
    super(...arguments);
    this.positive = new WaterfallSeriesItem();
    this.negative = new WaterfallSeriesItem();
    this.total = new WaterfallSeriesItem();
  }
};
__decorateClass2([
  Property55
], WaterfallSeriesItems.prototype, "positive", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItems.prototype, "negative", 2);
__decorateClass2([
  Property55
], WaterfallSeriesItems.prototype, "total", 2);
var WaterfallSeriesProperties = class extends AbstractBarSeriesProperties4 {
  constructor() {
    super(...arguments);
    this.item = new WaterfallSeriesItems();
    this.totals = new PropertiesArray4(WaterfallSeriesTotal);
    this.line = new WaterfallSeriesConnectorLine();
    this.tooltip = makeSeriesTooltip7();
  }
  getStyle(itemId) {
    const { fillOpacity, strokeWidth, strokeOpacity, fill, stroke: stroke22, lineDash, lineDashOffset, cornerRadius } = this.item[itemId === "subtotal" ? "total" : itemId];
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "xKey", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "yKey", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "xName", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "yName", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "item", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "totals", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "line", 2);
__decorateClass2([
  Property55
], WaterfallSeriesProperties.prototype, "tooltip", 2);
var {
  adjustLabelPlacement: adjustLabelPlacement2,
  SeriesNodePickMode: SeriesNodePickMode5,
  fixNumericExtent: fixNumericExtent6,
  valueProperty: valueProperty8,
  keyProperty: keyProperty6,
  accumulativeValueProperty: accumulativeValueProperty2,
  trailingAccumulatedValueProperty: trailingAccumulatedValueProperty2,
  ChartAxisDirection: ChartAxisDirection18,
  createDatumId: createDatumId5,
  checkCrisp: checkCrisp22,
  updateLabelNode: updateLabelNode4,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions22,
  collapsedStartingBarPosition: collapsedStartingBarPosition2,
  resetBarSelectionsFn: resetBarSelectionsFn22,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation3,
  resetLabelFn: resetLabelFn3,
  animationValidation: animationValidation5,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: DEFAULT_CARTESIAN_DIRECTION_KEYS22,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: DEFAULT_CARTESIAN_DIRECTION_NAMES22,
  computeBarFocusBounds: computeBarFocusBounds5,
  isContinuous: isContinuous2,
  Rect: Rect4,
  motion: motion3,
  applyShapeStyle: applyShapeStyle6,
  getShapeStyle: getShapeStyle5,
  mergeDefaults: mergeDefaults9
} = module_support_exports;
var WaterfallSeries = class extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS22,
      propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES22,
      categoryKey: void 0,
      pickModes: [SeriesNodePickMode5.NEAREST_NODE, SeriesNodePickMode5.EXACT_SHAPE_MATCH],
      pathsPerSeries: ["connector"],
      pathsZIndexSubOrderOffset: [-1, -1],
      animationResetFns: {
        datum: resetBarSelectionsFn22,
        label: resetLabelFn3
      }
    });
    this.properties = new WaterfallSeriesProperties();
    this.seriesItemTypes = /* @__PURE__ */ new Set(["positive", "negative", "total"]);
  }
  async processData(dataController) {
    const { xKey, yKey, totals } = this.properties;
    const { data = [] } = this;
    if (!this.visible)
      return;
    const positiveNumber3 = (v) => isContinuous2(v) && Number(v) >= 0;
    const negativeNumber = (v) => isContinuous2(v) && Number(v) >= 0;
    const totalTypeValue = (v) => v === "total" || v === "subtotal";
    const propertyDefinition = { missingValue: void 0, invalidValue: void 0 };
    const dataWithTotals = [];
    const totalsMap = totals.reduce((result, total) => {
      const totalsAtIndex = result.get(total.index);
      if (totalsAtIndex) {
        totalsAtIndex.push(total);
      } else {
        result.set(total.index, [total]);
      }
      return result;
    }, /* @__PURE__ */ new Map());
    data.forEach((datum, i) => {
      dataWithTotals.push(datum);
      totalsMap.get(i)?.forEach((total) => dataWithTotals.push({ ...total.toJson(), [xKey]: total.axisLabel }));
    });
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      extraProps.push(animationValidation5());
    }
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const { processedData } = await this.requestDataModel(dataController, dataWithTotals, {
      props: [
        keyProperty6(xKey, xScaleType, { id: `xValue` }),
        accumulativeValueProperty2(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yCurrent`
        }),
        accumulativeValueProperty2(yKey, yScaleType, {
          ...propertyDefinition,
          missingValue: 0,
          id: `yCurrentTotal`
        }),
        accumulativeValueProperty2(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yCurrentPositive`,
          validation: positiveNumber3
        }),
        accumulativeValueProperty2(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yCurrentNegative`,
          validation: negativeNumber
        }),
        trailingAccumulatedValueProperty2(yKey, yScaleType, {
          ...propertyDefinition,
          id: `yPrevious`
        }),
        valueProperty8(yKey, yScaleType, { id: `yRaw` }),
        // Raw value pass-through.
        valueProperty8("totalType", "category", {
          id: `totalTypeValue`,
          missingValue: void 0,
          validation: totalTypeValue
        }),
        ...isContinuousX ? [module_support_exports.SMALLEST_KEY_INTERVAL, module_support_exports.LARGEST_KEY_INTERVAL] : [],
        ...extraProps
      ]
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.updateSeriesItemTypes();
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel)
      return [];
    const {
      keys: [keys],
      values
    } = processedData.domain;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef?.def.valueType === "category") {
        return keys;
      }
      const isDirectionY = direction === ChartAxisDirection18.Y;
      const isReversed = this.getCategoryAxis().isReversed();
      return this.padBandExtent(keys, isReversed !== isDirectionY);
    } else {
      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent");
      const yExtent = values[yCurrIndex];
      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];
      return fixNumericExtent6(fixedYExtent);
    }
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  createNodeData() {
    const { data, dataModel, processedData } = this;
    const categoryAxis = this.getCategoryAxis();
    const valueAxis = this.getValueAxis();
    if (!data || !categoryAxis || !valueAxis || !dataModel || !processedData) {
      return;
    }
    const { line } = this.properties;
    const xScale = categoryAxis.scale;
    const yScale = valueAxis.scale;
    const barAlongX = this.getBarDirection() === ChartAxisDirection18.X;
    const barWidth = this.getBandwidth(categoryAxis) ?? 10;
    const categoryAxisReversed = categoryAxis.isReversed();
    const valueAxisReversed = valueAxis.isReversed();
    if (processedData.type !== "ungrouped")
      return;
    const context = {
      itemId: this.properties.yKey,
      nodeData: [],
      labelData: [],
      pointData: [],
      scales: this.calculateScaling(),
      groupScale: this.getScaling(this.groupScale),
      visible: this.visible
    };
    if (!this.visible)
      return context;
    const pointData = [];
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yRaw`, processedData);
    const totalTypeValues = dataModel.resolveColumnById(
      this,
      `totalTypeValue`,
      processedData
    );
    const yCurrValues = dataModel.resolveColumnById(this, "yCurrent", processedData);
    const yPrevValues = dataModel.resolveColumnById(this, "yPrevious", processedData);
    const yCurrTotalValues = dataModel.resolveColumnById(this, "yCurrentTotal", processedData);
    const yDomain = this.getSeriesDomain(ChartAxisDirection18.Y);
    const crisp = checkCrisp22(
      categoryAxis?.scale,
      categoryAxis?.visibleRange,
      this.smallestDataInterval,
      this.largestDataInterval
    );
    function getValues(isTotal, isSubtotal, datumIndex) {
      if (isTotal || isSubtotal) {
        return {
          cumulativeValue: yCurrTotalValues[datumIndex],
          trailingValue: isSubtotal ? trailingSubtotal : 0
        };
      }
      return {
        cumulativeValue: yCurrValues[datumIndex],
        trailingValue: yPrevValues[datumIndex]
      };
    }
    function getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue) {
      if (isTotal) {
        return cumulativeValue;
      }
      if (isSubtotal) {
        return (cumulativeValue ?? 0) - (trailingValue ?? 0);
      }
      return rawValue;
    }
    let trailingSubtotal = 0;
    const { xKey, yKey, xName, yName } = this.properties;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const datumType = totalTypeValues[datumIndex];
      const isSubtotal = this.isSubtotal(datumType);
      const isTotal = this.isTotal(datumType);
      const isTotalOrSubtotal = isTotal || isSubtotal;
      const xDatum = xValues[datumIndex];
      if (xDatum == null)
        return;
      const x = Math.round(xScale.convert(xDatum));
      const rawValue = yRawValues[datumIndex];
      const { cumulativeValue, trailingValue } = getValues(isTotal, isSubtotal, datumIndex);
      if (isTotalOrSubtotal) {
        trailingSubtotal = cumulativeValue ?? 0;
      }
      const currY = Math.round(yScale.convert(cumulativeValue));
      const trailY = Math.round(yScale.convert(trailingValue));
      const value = getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue);
      const isPositive = (value ?? 0) >= 0;
      const seriesItemType = this.getSeriesItemType(isPositive, datumType);
      const { strokeWidth, label } = this.getItemConfig(seriesItemType);
      const y = isPositive ? currY : trailY;
      const bottomY = isPositive ? trailY : currY;
      const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : x,
        y: barAlongX ? x : Math.min(y, bottomY),
        width: barAlongX ? barHeight : barWidth,
        height: barAlongX ? barWidth : barHeight
      };
      const nodeMidPoint = {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      };
      const pointY = isTotalOrSubtotal ? currY : trailY;
      const pixelAlignmentOffset = Math.floor(line.strokeWidth) % 2 / 2;
      const startY = categoryAxisReversed ? currY : pointY;
      const stopY = categoryAxisReversed ? pointY : currY;
      let startCoordinates;
      let stopCoordinates;
      if (barAlongX) {
        startCoordinates = {
          x: startY + pixelAlignmentOffset,
          y: rect.y
        };
        stopCoordinates = {
          x: stopY + pixelAlignmentOffset,
          y: rect.y + rect.height
        };
      } else {
        startCoordinates = {
          x: rect.x,
          y: startY + pixelAlignmentOffset
        };
        stopCoordinates = {
          x: rect.x + rect.width,
          y: stopY + pixelAlignmentOffset
        };
      }
      const pathPoint = {
        // lineTo
        x: categoryAxisReversed ? stopCoordinates.x : startCoordinates.x,
        y: categoryAxisReversed ? stopCoordinates.y : startCoordinates.y,
        // moveTo
        x2: categoryAxisReversed ? startCoordinates.x : stopCoordinates.x,
        y2: categoryAxisReversed ? startCoordinates.y : stopCoordinates.y,
        size: 0
      };
      pointData.push(pathPoint);
      const itemId = seriesItemType === "subtotal" ? "total" : seriesItemType;
      const labelText = this.getLabelText(
        value,
        datum,
        yKey,
        "y",
        yDomain,
        label,
        {
          itemId,
          value,
          datum,
          xKey,
          yKey,
          xName,
          yName
        }
      );
      const spacing = label.spacing + (typeof label.padding === "number" ? label.padding : 0);
      const nodeDatum = {
        index: datumIndex,
        series: this,
        itemId: seriesItemType,
        datum,
        datumIndex,
        cumulativeValue: cumulativeValue ?? 0,
        xValue: xDatum,
        yValue: value,
        yKey,
        xKey,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        midPoint: nodeMidPoint,
        crisp,
        label: {
          text: labelText,
          ...adjustLabelPlacement2({
            isUpward: (value ?? -1) >= 0 !== valueAxisReversed,
            isVertical: !barAlongX,
            placement: label.placement,
            spacing,
            rect
          })
        }
      };
      context.nodeData.push(nodeDatum);
      context.labelData.push(nodeDatum);
    });
    const connectorLinesEnabled = this.properties.line.enabled;
    if (yCurrValues != null && connectorLinesEnabled) {
      context.pointData = pointData;
    }
    return context;
  }
  updateSeriesItemTypes() {
    const { dataModel, seriesItemTypes, processedData } = this;
    if (!dataModel || !processedData) {
      return;
    }
    seriesItemTypes.clear();
    const yPositiveIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentPositive");
    const yNegativeIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentNegative");
    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);
    const positiveDomain = processedData.domain.values[yPositiveIndex] ?? [];
    const negativeDomain = processedData.domain.values[yNegativeIndex] ?? [];
    if (positiveDomain.length > 0) {
      seriesItemTypes.add("positive");
    }
    if (negativeDomain.length > 0) {
      seriesItemTypes.add("negative");
    }
    const itemTypes = processedData?.domain.values[totalTypeIndex];
    if (!itemTypes) {
      return;
    }
    itemTypes.forEach((type) => {
      if (type === "total" || type === "subtotal") {
        seriesItemTypes.add("total");
      }
    });
  }
  isSubtotal(datumType) {
    return datumType === "subtotal";
  }
  isTotal(datumType) {
    return datumType === "total";
  }
  nodeFactory() {
    return new Rect4();
  }
  getSeriesItemType(isPositive, datumType) {
    return datumType ?? (isPositive ? "positive" : "negative");
  }
  getItemConfig(seriesItemType) {
    switch (seriesItemType) {
      case "positive": {
        return this.properties.item.positive;
      }
      case "negative": {
        return this.properties.item.negative;
      }
      case "subtotal":
      case "total": {
        return this.properties.item.total;
      }
    }
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data);
  }
  getItemStyle({ datumIndex = 0, datum, itemId = "total" }, isHighlight) {
    const { id: seriesId, properties } = this;
    const item = properties.item[itemId === "subtotal" ? "total" : itemId];
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults9(highlightStyle, properties.getStyle(itemId));
    const { itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = item;
    const { xKey, yKey } = properties;
    let style2 = getShapeStyle5(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId5(datumIndex, isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            itemId,
            datum,
            xKey,
            yKey,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle5(
          mergeDefaults9(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection18.X;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((rect, datum) => {
      const style2 = this.getItemStyle(datum, isHighlight);
      applyShapeStyle6(rect, style2, fillBBox);
      rect.cornerRadius = style2.cornerRadius ?? 0;
      rect.visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
      rect.crisp = datum.crisp;
    });
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    if (labelData.length === 0) {
      return labelSelection.update([]);
    }
    const data = labelData.filter((labelDatum) => {
      const { label } = this.getItemConfig(labelDatum.itemId);
      return label.enabled;
    });
    return labelSelection.update(data);
  }
  updateLabelNodes(opts) {
    const params = {
      itemId: "positive",
      xKey: this.properties.xKey,
      xName: this.properties.xName ?? this.properties.xName,
      yKey: this.properties.yKey,
      yName: this.properties.yName ?? this.properties.yName
    };
    opts.labelSelection.each((textNode, datum) => {
      params.itemId = datum.itemId;
      textNode.fillOpacity = this.getHighlightStyle(false, datum.datumIndex)?.opacity ?? 1;
      updateLabelNode4(this, textNode, params, this.getItemConfig(datum.itemId).label, datum.label);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yRaw`, processedData)[datumIndex];
    const yCurrTotalValues = dataModel.resolveColumnById(this, "yCurrentTotal", processedData);
    const totalTypeValues = dataModel.resolveColumnById(
      this,
      `totalTypeValue`,
      processedData
    );
    if (xValue2 == null)
      return;
    const datumType = totalTypeValues[datumIndex];
    const isPositive = (yValue ?? 0) >= 0;
    const seriesItemType = this.getSeriesItemType(isPositive, datumType);
    let total;
    if (this.isTotal(datumType)) {
      total = yCurrTotalValues[datumIndex];
    } else if (this.isSubtotal(datumType)) {
      total = yCurrTotalValues[datumIndex];
      for (let previousIndex = datumIndex - 1; previousIndex >= 0; previousIndex -= 1) {
        if (this.isSubtotal(totalTypeValues[previousIndex])) {
          total = total - yCurrTotalValues[previousIndex];
          break;
        }
      }
    } else {
      total = yValue;
    }
    const format = this.getItemStyle({ datumIndex, datum, itemId: seriesItemType }, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, xKey, legendItemName),
        symbol: this.legendItemSymbol(seriesItemType),
        data: [
          {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", total, datum, yKey, legendItemName)
          }
        ]
      },
      { seriesId, datum, title: yName, itemId: seriesItemType, xKey, xName, yKey, yName, ...format }
    );
  }
  legendItemSymbol(item) {
    const {
      fill,
      stroke: stroke22,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.getItemConfig(item);
    return {
      marker: getShapeStyle5(
        {
          fill,
          stroke: stroke22,
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults5,
        fillPatternDefaults5,
        fillImageDefaults5
      )
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id, seriesItemTypes } = this;
    const legendData = [];
    const capitalise = (text2) => text2.charAt(0).toUpperCase() + text2.substring(1);
    const { showInLegend } = this.properties;
    seriesItemTypes.forEach((item) => {
      const { name } = this.getItemConfig(item);
      legendData.push({
        legendType: "category",
        id,
        itemId: item,
        seriesId: id,
        enabled: true,
        label: { text: name ?? capitalise(item) },
        symbol: this.legendItemSymbol(item),
        hideInLegend: !showInLegend,
        isFixed: true
      });
    });
    return legendData;
  }
  toggleSeriesItem() {
  }
  animateEmptyUpdateReady(opts) {
    const { datumSelection, labelSelection, contextData } = opts;
    const fns = prepareBarAnimationFunctions22(collapsedStartingBarPosition2(this.isVertical(), this.axes, "normal"));
    motion3.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation3(this, "labels", this.ctx.animationManager, labelSelection);
    const { pointData } = contextData;
    if (!pointData)
      return;
    if (this.isVertical()) {
      this.animateConnectorLinesVertical(opts);
    } else {
      this.animateConnectorLinesHorizontal(opts);
    }
  }
  animateConnectorLinesHorizontal(opts) {
    const { pointData = [] } = opts.contextData;
    const [lineNode] = opts.paths;
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis?.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v < v2 : (v, v2) => v > v2;
    const startX = valueAxis?.scale.convert(0);
    const endX = pointData.reduce(
      (end2, point) => {
        if (compare(point.x, end2)) {
          end2 = point.x;
        }
        return end2;
      },
      valueAxisReversed ? Infinity : 0
    );
    const scale2 = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_connectors`,
      groupId: this.id,
      phase: "initial",
      from: startX,
      to: endX,
      ease: module_support_exports.Motion.easeOut,
      collapsable: false,
      onUpdate(pointX) {
        linePath.clear(true);
        pointData.forEach((point, index) => {
          const x = scale2(pointX, startX, endX, startX, point.x);
          const x2 = scale2(pointX, startX, endX, startX, point.x2);
          if (index !== 0) {
            linePath.lineTo(x, point.y);
          }
          linePath.moveTo(x2, point.y2);
        });
        lineNode.checkPathDirty();
      },
      onStop: () => this.resetConnectorLinesPath(opts)
    });
  }
  animateConnectorLinesVertical(opts) {
    const { pointData = [] } = opts.contextData;
    const [lineNode] = opts.paths;
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis?.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v > v2 : (v, v2) => v < v2;
    const startY = valueAxis?.scale.convert(0);
    const endY = pointData.reduce(
      (end2, point) => {
        if (compare(point.y, end2)) {
          end2 = point.y;
        }
        return end2;
      },
      valueAxisReversed ? 0 : Infinity
    );
    const scale2 = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_connectors`,
      groupId: this.id,
      phase: "initial",
      from: startY,
      to: endY,
      ease: module_support_exports.Motion.easeOut,
      collapsable: false,
      onUpdate(pointY) {
        linePath.clear(true);
        pointData.forEach((point, index) => {
          const y = scale2(pointY, startY, endY, startY, point.y);
          const y2 = scale2(pointY, startY, endY, startY, point.y2);
          if (index !== 0) {
            linePath.lineTo(point.x, y);
          }
          linePath.moveTo(point.x2, y2);
        });
        lineNode.checkPathDirty();
      },
      onStop: () => this.resetConnectorLinesPath(opts)
    });
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetConnectorLinesPath(data);
  }
  updatePaths(opts) {
    this.resetConnectorLinesPath({ contextData: opts.contextData, paths: opts.paths });
  }
  resetConnectorLinesPath({
    contextData,
    paths
  }) {
    if (paths.length === 0) {
      return;
    }
    const [lineNode] = paths;
    this.updateLineNode(lineNode);
    const { path: linePath } = lineNode;
    linePath.clear(true);
    const { pointData } = contextData;
    if (!pointData) {
      return;
    }
    pointData.forEach((point, index) => {
      if (index !== 0) {
        linePath.lineTo(point.x, point.y);
      }
      linePath.moveTo(point.x2, point.y2);
    });
    lineNode.checkPathDirty();
  }
  updateLineNode(lineNode) {
    const { stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.properties.line;
    lineNode.setProperties({
      fill: void 0,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      lineJoin: "round",
      pointerEvents: module_support_exports.PointerEvents.None
    });
  }
  isLabelEnabled() {
    const { positive, negative, total } = this.properties.item;
    return positive.label.enabled || negative.label.enabled || total.label.enabled;
  }
  onDataChange() {
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds5(this, this.contextNodeData?.nodeData[datumIndex]);
  }
  hasItemStylers() {
    const { positive, negative, total } = this.properties.item;
    return positive.itemStyler != null || negative.itemStyler != null || total.itemStyler != null;
  }
};
WaterfallSeries.className = "WaterfallSeries";
WaterfallSeries.type = "waterfall";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs7, waterfallSeriesThemeableOptionsDef: waterfallSeriesThemeableOptionsDef2 } = module_support_exports;
var waterfallSeriesOptionsDef = {
  ...waterfallSeriesThemeableOptionsDef2,
  ...commonSeriesOptionsDefs7,
  type: required(constant("waterfall")),
  xKey: required(string),
  yKey: required(string),
  xName: string,
  yName: string,
  totals: arrayOfDefs(
    {
      totalType: required(union("total", "subtotal")),
      index: required(positiveNumber),
      axisLabel: required(string)
    },
    "a total definition options array"
  )
};
function itemTheme2(key, index) {
  return {
    fill: {
      $if: [
        { $eq: [{ $palette: "type" }, "user-indexed"] },
        { $path: [`/${index}`, { $palette: "fill" }, { $palette: "fills" }] },
        { $palette: `${key}.fill` }
      ]
    },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_SHADED_DEFAULTS(key),
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    stroke: { $palette: `${key}.stroke` },
    strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      fontStyle: void 0,
      fontWeight: { $ref: "fontWeight" },
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      color: { $ref: "textColor" },
      formatter: void 0,
      placement: "outside-end",
      padding: { $isUserOption: ["./spacing", 0, 6] }
      // compatibility with old `padding` property (now named `spacing`).
    }
  };
}
var WATERFALL_SERIES_THEME = {
  series: {
    item: {
      positive: itemTheme2("altUp", 0),
      negative: itemTheme2("altDown", 1),
      total: itemTheme2("neutral", 2)
    },
    line: {
      stroke: { $palette: "neutral.stroke" },
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      strokeWidth: 2
    },
    highlight: module_support_exports.singleSeriesHighlightStyle()
  },
  legend: {
    enabled: true,
    toggleSeries: false
  }
};
var WaterfallModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "waterfall",
  solo: true,
  moduleFactory: (ctx) => new WaterfallSeries(ctx),
  defaultAxes: module_support_exports.DIRECTION_SWAP_AXES,
  themeTemplate: WATERFALL_SERIES_THEME
};
var WaterfallSeriesModule = {
  type: "series",
  name: "waterfall",
  chartType: "cartesian",
  enterprise: true,
  options: waterfallSeriesOptionsDef,
  create: (ctx) => new WaterfallSeries(ctx)
};
var {
  NewAreaSeriesModule: NewAreaSeriesModule2,
  NewBarSeriesModule: NewBarSeriesModule2,
  NewBubbleSeriesModule: NewBubbleSeriesModule2,
  NewHistogramSeriesModule: NewHistogramSeriesModule2,
  NewLineSeriesModule: NewLineSeriesModule2,
  NewScatterSeriesModule: NewScatterSeriesModule2,
  numberFormatValidator: numberFormatValidator2,
  without: without22
} = module_support_exports;
var navigatorHandleOptionsDef2 = {
  width: positiveNumber,
  height: positiveNumber,
  grip: boolean,
  fill: color,
  stroke: color,
  strokeWidth: positiveNumber,
  cornerRadius: positiveNumber
};
var commonIgnoredMiniChartProperties = [
  "cursor",
  "highlightStyle",
  "listeners",
  "nodeClickRange",
  "showInLegend",
  "showInMiniChart",
  "tooltip",
  "visible",
  "xName",
  "yName"
];
var barIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "errorBar",
  "label",
  "legendItemName",
  "direction"
];
var boxPlotIngnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "direction",
  "legendItemName",
  "minName",
  "q1Name",
  "medianName",
  "q3Name",
  "maxName"
];
var bubbleIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "title",
  "label",
  "labelKey",
  "labelName",
  "sizeName"
];
var heatmapIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "title",
  "label",
  "colorName",
  "textAlign",
  "verticalAlign",
  "itemPadding",
  "colorRange"
];
var histogramIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "label"
];
var lineIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "errorBar",
  "title",
  "label"
];
var rangeAreaIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "label",
  "yLowName",
  "yHighName"
];
var rangeBarIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "direction",
  "label",
  "yLowName",
  "yHighName"
];
var scatterIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "errorBar",
  "title",
  "label",
  "labelKey",
  "labelName"
];
var waterfallIgnoredMiniChartProperties = [
  ...commonIgnoredMiniChartProperties,
  "direction"
];
var navigatorOptionsDef2 = {
  enabled: boolean,
  height: positiveNumber,
  spacing: positiveNumber,
  cornerRadius: number,
  mask: {
    fill: color,
    fillOpacity: ratio,
    stroke: color,
    strokeWidth: positiveNumber
  },
  minHandle: navigatorHandleOptionsDef2,
  maxHandle: navigatorHandleOptionsDef2,
  miniChart: {
    enabled: boolean,
    padding: {
      top: positiveNumber,
      bottom: positiveNumber
    },
    label: {
      enabled: boolean,
      avoidCollisions: boolean,
      spacing: positiveNumber,
      format: numberFormatValidator2,
      formatter: callback,
      interval: {
        minSpacing: positiveNumber,
        maxSpacing: positiveNumber,
        values: array,
        step: number
      },
      ...fontOptionsDef
    },
    series: arrayOfDefs(
      typeUnion(
        {
          area: without22(NewAreaSeriesModule2.options, [...commonIgnoredMiniChartProperties, "type"]),
          bar: without22(NewBarSeriesModule2.options, [...barIgnoredMiniChartProperties, "type"]),
          "box-plot": without22(BoxPlotSeriesModule.options, [...boxPlotIngnoredMiniChartProperties, "type"]),
          bubble: without22(NewBubbleSeriesModule2.options, [...bubbleIgnoredMiniChartProperties, "type"]),
          candlestick: without22(CandlestickSeriesModule.options, [
            ...commonIgnoredMiniChartProperties,
            "type"
          ]),
          heatmap: without22(HeatmapSeriesModule.options, [...heatmapIgnoredMiniChartProperties, "type"]),
          histogram: without22(NewHistogramSeriesModule2.options, [
            ...histogramIgnoredMiniChartProperties,
            "type"
          ]),
          line: without22(NewLineSeriesModule2.options, [...lineIgnoredMiniChartProperties, "type"]),
          ohlc: without22(OhlcSeriesModule.options, [...commonIgnoredMiniChartProperties, "type"]),
          "range-area": without22(RangeAreaSeriesModule.options, [
            ...rangeAreaIgnoredMiniChartProperties,
            "type"
          ]),
          "range-bar": without22(RangeBarSeriesModule.options, [...rangeBarIgnoredMiniChartProperties, "type"]),
          scatter: without22(NewScatterSeriesModule2.options, [...scatterIgnoredMiniChartProperties, "type"]),
          waterfall: without22(WaterfallSeriesModule.options, [...waterfallIgnoredMiniChartProperties, "type"])
        },
        "miniChart series options"
      )
    )
  }
};
var validMiniChartSeriesTypes = [
  "area",
  "bar",
  "bubble",
  "candlestick",
  "heatmap",
  "histogram",
  "line",
  "ohlc",
  "range-area",
  "range-bar",
  "scatter",
  "waterfall"
];
var priceVolumePresetIgnoredMiniChartProperties = [
  "itemStyler",
  "direction",
  "fill",
  "fillGradientDefaults",
  "fillPatternDefaults",
  "fillImageDefaults",
  "fillOpacity",
  "shadow",
  "focusPriority",
  "seriesGrouping",
  "highlight",
  "lineDash",
  "lineDashOffset",
  "strokeWidth"
];
function miniChartSeriesTheme(seriesPath, typePath) {
  return {
    $merge: [
      {
        $switch: [
          typePath,
          {},
          [
            ["area", "line", "range-area"],
            {
              marker: {
                enabled: {
                  $isUserOption: [
                    "/series/$index/marker/enabled",
                    { $path: ["/series/$index/marker/enabled", false] },
                    false
                  ]
                }
              }
            }
          ]
        ]
      },
      {
        $omit: [
          {
            $switch: [
              typePath,
              commonIgnoredMiniChartProperties,
              ["bar", barIgnoredMiniChartProperties],
              ["box-plot", boxPlotIngnoredMiniChartProperties],
              ["bubble", bubbleIgnoredMiniChartProperties],
              ["heatmap", heatmapIgnoredMiniChartProperties],
              ["histogram", histogramIgnoredMiniChartProperties],
              [
                "line",
                [...lineIgnoredMiniChartProperties, ...priceVolumePresetIgnoredMiniChartProperties]
              ],
              ["range-area", rangeAreaIgnoredMiniChartProperties],
              ["range-bar", rangeBarIgnoredMiniChartProperties],
              ["scatter", scatterIgnoredMiniChartProperties],
              ["waterfall", waterfallIgnoredMiniChartProperties]
            ]
          },
          seriesPath
        ]
      }
    ]
  };
}
var NAVIGATOR_THEME = {
  enabled: false,
  height: { $if: [{ $path: "./miniChart/enabled" }, 40, 18] },
  cornerRadius: 4,
  mask: {
    fill: { $ref: "foregroundColor" },
    fillOpacity: 0.1,
    stroke: { $ref: "borderColor" },
    strokeWidth: 1
  },
  minHandle: {
    fill: { $ref: "chartBackgroundColor" },
    stroke: { $ref: "borderColor" },
    strokeWidth: 1,
    width: 12,
    height: 24,
    cornerRadius: 4
  },
  maxHandle: {
    fill: { $ref: "chartBackgroundColor" },
    stroke: { $ref: "borderColor" },
    strokeWidth: 1,
    width: 12,
    height: 24,
    cornerRadius: 4
  },
  miniChart: {
    enabled: false,
    label: {
      color: { $ref: "textColor" },
      fontSize: { $rem: module_support_exports.FONT_SIZE_RATIO.SMALLER },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      spacing: 5
    },
    padding: {
      top: 0,
      bottom: 0
    },
    series: {
      $apply: [
        miniChartSeriesTheme(
          { $path: "/series/$index" },
          {
            $path: [
              "/navigator/miniChart/series/$index/type",
              { $path: ["type", { $path: "/series/$index/type" }] }
            ]
          }
        ),
        {
          // TODO: this should be a $switch but switches can not resolve the case value yet
          $if: [
            {
              $or: validMiniChartSeriesTypes.map((type) => ({
                $eq: [{ $path: "/series/0/type" }, type]
              }))
            },
            {
              $map: [
                miniChartSeriesTheme({ $value: "$1" }, { $path: "/series/$index/type" }),
                { $path: "/series" }
              ]
            },
            void 0
          ]
        }
      ]
    }
  }
};
var NavigatorModule = {
  type: "root",
  optionsKey: "navigator",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new Navigator(ctx),
  removable: false,
  // Toggling this module causes zoom state flakiness.
  themeTemplate: {
    navigator: NAVIGATOR_THEME
  }
};
var { ToolbarButtonProperties: ToolbarButtonProperties3, Property: Property56 } = module_support_exports;
var RangesButtonProperties = class extends ToolbarButtonProperties3 {
};
__decorateClass2([
  Property56
], RangesButtonProperties.prototype, "value", 2);
var { ChartAxisDirection: ChartAxisDirection19, LayoutElement: LayoutElement3, PropertiesArray: PropertiesArray5, Toolbar: Toolbar2, Property: Property57 } = module_support_exports;
var Ranges = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.buttons = new PropertiesArray5(RangesButtonProperties);
    this.verticalSpacing = 10;
    this.container = ctx.domManager.addChild("canvas-overlay", "range-buttons");
    this.container.role = "presentation";
    this.toolbar = new Toolbar2(this.ctx, "ariaLabelRangesToolbar", "horizontal");
    this.toolbar.addClass("ag-charts-range-buttons");
    this.container.append(this.toolbar.getElement());
    this.cleanup.register(
      this.toolbar.addToolbarListener("button-pressed", this.onButtonPress.bind(this)),
      ctx.layoutManager.registerElement(LayoutElement3.ToolbarBottom, this.onLayoutStart.bind(this)),
      ctx.eventsHub.on("zoom:change", this.onZoomChanged.bind(this)),
      this.teardown.bind(this)
    );
  }
  teardown() {
    this.container.removeChild(this.toolbar.getElement());
    this.toolbar.destroy();
  }
  onLayoutStart(event) {
    const { buttons: buttons2, ctx, enabled, toolbar: toolbar2, verticalSpacing } = this;
    const { layoutBox } = event;
    if (!enabled || !ctx.zoomManager.isZoomEnabled()) {
      toolbar2.setHidden(true);
      return;
    }
    toolbar2.setHidden(false);
    toolbar2.updateButtons(buttons2);
    const height2 = toolbar2.getBounds().height;
    toolbar2.setBounds({
      x: layoutBox.x,
      y: layoutBox.y + layoutBox.height - height2,
      width: layoutBox.width,
      height: height2
    });
    layoutBox.shrink({ bottom: height2 + verticalSpacing });
  }
  onZoomChanged() {
    this.toolbar.clearActiveButton();
  }
  onButtonPress({ button: { index } }) {
    const { zoomManager } = this.ctx;
    const button = this.buttons.at(index);
    if (!button)
      return;
    const { value } = button;
    if (value == null) {
      zoomManager.resetZoom("zoom-buttons");
    } else if (typeof value === "number") {
      zoomManager.extendToEnd("zoom-buttons", ChartAxisDirection19.X, value);
    } else if (Array.isArray(value)) {
      zoomManager.updateWith("zoom-buttons", ChartAxisDirection19.X, () => value);
    } else if (typeof value === "function") {
      zoomManager.updateWith("zoom-buttons", ChartAxisDirection19.X, value);
    }
    this.toolbar.toggleActiveButtonByIndex(index);
  }
};
__decorateClass2([
  Property57
], Ranges.prototype, "enabled", 2);
__decorateClass2([
  Property57
], Ranges.prototype, "buttons", 2);
var DAY = 1e3 * 60 * 60 * 24;
var MONTH = DAY * 30;
var YEAR = DAY * 365;
var RangesModule = {
  type: "root",
  optionsKey: "ranges",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new Ranges(ctx),
  themeTemplate: {
    ranges: {
      enabled: false,
      buttons: {
        $shallow: [
          {
            label: "toolbarRange1Month",
            ariaLabel: "toolbarRange1MonthAria",
            value: MONTH
          },
          {
            label: "toolbarRange3Months",
            ariaLabel: "toolbarRange3MonthsAria",
            value: 3 * MONTH
          },
          {
            label: "toolbarRange6Months",
            ariaLabel: "toolbarRange6MonthsAria",
            value: 6 * MONTH
          },
          {
            label: "toolbarRangeYearToDate",
            ariaLabel: "toolbarRangeYearToDateAria",
            value: (_start, end2) => [
              (/* @__PURE__ */ new Date(`${new Date(end2).getFullYear()}-01-01`)).getTime(),
              end2
            ]
          },
          {
            label: "toolbarRange1Year",
            ariaLabel: "toolbarRange1YearAria",
            value: YEAR
          },
          {
            label: "toolbarRangeAll",
            ariaLabel: "toolbarRangeAllAria",
            value: void 0
            // Reset zoom
          }
        ]
      }
    }
  }
};
var _SharedToolbar = class _SharedToolbar2 extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.activeSections = /* @__PURE__ */ new Set();
    this.sectionButtons = {
      annotations: [],
      chartToolbar: []
    };
    this.container = this.ctx.domManager.addChild("canvas-overlay", "shared-toolbar");
    this.container.role = "presentation";
  }
  getSharedToolbar(section) {
    if (!this.sharedToolbar) {
      this.createSharedToolbar();
    }
    if (section === "chartToolbar" && this.sharedToolbar) {
      this.sharedToolbar.setAriaLabelId("ariaLabelFinancialCharts");
    }
    return this.toolbarWithSection(section);
  }
  createSharedToolbar() {
    this.sharedToolbar = new module_support_exports.Toolbar(this.ctx, "ariaLabelAnnotationsToolbar", "vertical");
    this.sharedToolbar.addClass("ag-charts-shared-toolbar");
    this.container.append(this.sharedToolbar.getElement());
    this.cleanup.register(() => {
      if (!this.sharedToolbar)
        return;
      this.container.removeChild(this.sharedToolbar.getElement());
      this.sharedToolbar.destroy();
      this.sharedToolbar = void 0;
    });
  }
  toolbarWithSection(section) {
    const sharedToolbar = this.sharedToolbar;
    const withSection = {
      layout: (layoutBox, padding2) => {
        if (this.firstLayoutSection != null && this.firstLayoutSection !== section && this.activeSections.has(this.firstLayoutSection)) {
          return;
        }
        this.firstLayoutSection = section;
        const width2 = sharedToolbar.getBounds().width;
        sharedToolbar.setBounds({
          x: layoutBox.x,
          y: layoutBox.y,
          width: width2
        });
        layoutBox.shrink({ left: width2 + sharedToolbar.horizontalSpacing + (padding2 ?? 0) });
      },
      addToolbarListener: (eventType, handler) => {
        return sharedToolbar.addToolbarListener(eventType, (sharedEvent) => {
          const sectionIndex = this.getSectionIndex(section, sharedEvent.button.index);
          if (sectionIndex < 0)
            return;
          const event = {
            ...sharedEvent,
            button: this.sectionButtons[section][sectionIndex]
          };
          handler(event);
        });
      },
      updateButtons: (buttons2) => {
        this.sectionButtons[section] = buttons2;
        const sharedButtons = _SharedToolbar2.SECTION_ORDER.flatMap((order) => this.sectionButtons[order]);
        sharedToolbar.updateButtons(sharedButtons);
      },
      updateButtonByIndex: (index, button) => {
        sharedToolbar.updateButtonByIndex(this.getIndex(section, index), button);
      },
      toggleActiveButtonByIndex: (index) => {
        sharedToolbar.toggleActiveButtonByIndex(this.getIndex(section, index));
      },
      toggleButtonEnabledByIndex: (index, enabled) => {
        sharedToolbar.toggleButtonEnabledByIndex(this.getIndex(section, index), enabled);
      },
      setHidden: (hidden) => {
        if (hidden) {
          this.activeSections.delete(section);
        } else {
          this.activeSections.add(section);
        }
        let sum2 = 0;
        for (const order of _SharedToolbar2.SECTION_ORDER) {
          if (order !== section) {
            sum2 += this.sectionButtons[order].length;
            continue;
          }
          for (const index of this.sectionButtons[section].keys()) {
            sharedToolbar.setButtonHiddenByIndex(sum2 + index, hidden);
          }
        }
      },
      destroy: () => {
        withSection.setHidden(true);
        if (this.activeSections.size === 0) {
          this.destroy();
        }
      },
      clearActiveButton: sharedToolbar.clearActiveButton.bind(sharedToolbar),
      addListener: sharedToolbar.addListener.bind(sharedToolbar),
      removeListener: sharedToolbar.removeListener.bind(sharedToolbar)
    };
    withSection.setHidden(false);
    return withSection;
  }
  getIndex(section, index) {
    let sum2 = 0;
    for (const order of _SharedToolbar2.SECTION_ORDER) {
      if (order === section)
        return sum2 + index;
      sum2 += this.sectionButtons[order].length;
    }
    return -1;
  }
  getSectionIndex(section, index) {
    let sum2 = 0;
    for (const order of _SharedToolbar2.SECTION_ORDER) {
      if (order === section) {
        if (index >= sum2 + this.sectionButtons[section].length)
          return -1;
        return index - sum2;
      }
      sum2 += this.sectionButtons[order].length;
    }
    return -1;
  }
};
_SharedToolbar.SECTION_ORDER = ["chartToolbar", "annotations"];
var SharedToolbar = _SharedToolbar;
var SharedToolbarModule = {
  type: "context",
  contextKey: "sharedToolbar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new SharedToolbar(ctx)
};
var {
  CachedTextMeasurerPool: CachedTextMeasurerPool3,
  ZIndexMap: ZIndexMap8,
  LayoutElement: LayoutElement4,
  Property: Property58,
  BaseProperties: BaseProperties19,
  valueProperty: valueProperty9,
  TextUtils: TextUtils4,
  Group: Group7,
  Label: Label5,
  Rect: Rect5,
  Text: Text2
} = module_support_exports;
var chartConfigurations = {
  ohlc: 2 | 4 | 8 | 16 | 32,
  candlestick: 2 | 4 | 8 | 16 | 32,
  "hollow-candlestick": 2 | 4 | 8 | 16 | 32,
  line: 64 | 32,
  "step-line": 64 | 32,
  hlc: 128 | 8 | 16 | 32,
  "high-low": 512 | 256 | 32
  /* Volume */
};
var itemIdMap = {
  up: "positive",
  down: "negative"
};
var neutralColorMap = {
  hlc: "altNeutral"
};
var StatusBarBackground = class extends BaseProperties19 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
  }
};
__decorateClass2([
  Property58
], StatusBarBackground.prototype, "fill", 2);
__decorateClass2([
  Property58
], StatusBarBackground.prototype, "fillOpacity", 2);
var StatusBar = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.openKey = void 0;
    this.highKey = void 0;
    this.lowKey = void 0;
    this.closeKey = void 0;
    this.volumeKey = void 0;
    this.title = new Label5();
    this.positive = new Label5();
    this.negative = new Label5();
    this.neutral = new Label5();
    this.altNeutral = new Label5();
    this.background = new StatusBarBackground();
    this.layoutStyle = "block";
    this.id = "status-bar";
    this.data = void 0;
    this.layer = new Group7({
      name: "StatusBar",
      zIndex: ZIndexMap8.STATUS_BAR
    });
    this.labelGroup = this.layer.appendChild(new module_support_exports.TranslatableGroup());
    this.backgroundNode = this.labelGroup.appendChild(new Rect5());
    this.labels = [
      {
        label: "O",
        configuration: 2,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        id: "openValue",
        key: "openKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "H",
        configuration: 16,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        id: "highValue",
        key: "highKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "H",
        configuration: 256,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        style: "neutral",
        id: "highValue",
        key: "highKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "L",
        configuration: 8,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        id: "lowValue",
        key: "lowKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "L",
        configuration: 512,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        style: "neutral",
        id: "lowValue",
        key: "lowKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "C",
        configuration: 4,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        id: "closeValue",
        key: "closeKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "C",
        configuration: 128,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        id: "closeValue",
        key: "closeKey",
        style: "neutral",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "",
        configuration: 64,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        style: "neutral",
        id: "closeValue",
        key: "closeKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          notation: "compact",
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      },
      {
        label: "Vol",
        configuration: 32,
        title: this.labelGroup.appendChild(new Text2()),
        value: this.labelGroup.appendChild(new Text2()),
        id: "volumeValue",
        key: "volumeKey",
        domain: void 0,
        formatter: new Intl.NumberFormat("en-US", {
          notation: "compact",
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })
      }
    ];
    this.highlightManager = ctx.highlightManager;
    this.labelGroup.visible = false;
    this.cleanup.register(
      ctx.scene.attachNode(this.layer),
      ctx.layoutManager.registerElement(LayoutElement4.Overlay, (e) => this.startPerformLayout(e)),
      ctx.eventsHub.on("layout:complete", (e) => this.onLayoutComplete(e)),
      ctx.eventsHub.on("highlight:change", () => this.updateHighlight())
    );
  }
  async processData(dataController) {
    if (!this.enabled || this.data == null)
      return;
    const props = [];
    for (const label of this.labels) {
      const { id, key } = label;
      const datumKey = this[key];
      if (datumKey == null) {
        label.domain = void 0;
      } else {
        props.push(valueProperty9(datumKey, "number", { id }));
      }
    }
    if (props.length === 0)
      return;
    const { processedData, dataModel } = await dataController.request(this.id, this.data, {
      props
    });
    for (const label of this.labels) {
      const { id, key } = label;
      const datumKey = this[key];
      if (datumKey != null) {
        label.domain = dataModel.getDomain(this, id, "value", processedData);
      }
    }
  }
  startPerformLayout(opts) {
    this.labelGroup.translationX = 0;
    this.labelGroup.translationY = 0;
    if (!this.enabled)
      return;
    const { layoutBox } = opts;
    const innerSpacing = 4;
    const outerSpacing = 12;
    const spacingAbove = 0;
    const spacingBelow = 8;
    this.labelGroup.translationY = layoutBox.y + spacingAbove;
    const maxFontSize = Math.max(this.title.fontSize, this.positive.fontSize, this.negative.fontSize);
    const lineHeight = TextUtils4.getLineHeight(maxFontSize);
    const labelConfigurations = chartConfigurations[this.getChartType()] ?? 0;
    let left = 0;
    let offsetTop;
    let textVAlign = "alphabetic";
    if (this.layoutStyle === "block") {
      layoutBox.shrink(spacingAbove + lineHeight + spacingBelow, "top");
      offsetTop = maxFontSize + (lineHeight - maxFontSize) / 2;
    } else {
      const { title } = this.ctx.chartService;
      textVAlign = "top";
      offsetTop = spacingAbove + title.padding;
      if (title.enabled) {
        const titleBox = title.node.getBBox();
        left = titleBox.x + titleBox.width + outerSpacing;
      } else {
        left = title.padding;
      }
    }
    for (const { label, configuration, title, value, domain, formatter: formatter2 } of this.labels) {
      if (domain == null || (labelConfigurations & configuration) === 0) {
        title.visible = false;
        value.visible = false;
        continue;
      }
      const maxValueWidth = Math.max(
        CachedTextMeasurerPool3.measureText(formatter2.format(domain[0]), {
          font: this.positive,
          textBaseline: textVAlign,
          textAlign: "left"
        }).width,
        CachedTextMeasurerPool3.measureText(formatter2.format(domain[1]), {
          font: this.positive,
          textBaseline: textVAlign,
          textAlign: "left"
        }).width,
        CachedTextMeasurerPool3.measureText(formatter2.format(domain[0]), {
          font: this.negative,
          textBaseline: textVAlign,
          textAlign: "left"
        }).width,
        CachedTextMeasurerPool3.measureText(formatter2.format(domain[1]), {
          font: this.negative,
          textBaseline: textVAlign,
          textAlign: "left"
        }).width
      );
      title.visible = true;
      value.visible = true;
      const titleMetrics = CachedTextMeasurerPool3.measureText(label, {
        font: this.title,
        textBaseline: textVAlign,
        textAlign: "left"
      });
      title.setFont(this.title);
      title.fill = this.title.color;
      title.text = label;
      title.textBaseline = textVAlign;
      title.y = offsetTop;
      title.x = left;
      left += titleMetrics.width + innerSpacing;
      value.textBaseline = textVAlign;
      value.y = offsetTop;
      value.x = left;
      left += maxValueWidth + outerSpacing;
    }
    this.backgroundNode.x = 0;
    this.backgroundNode.y = 0;
    this.backgroundNode.width = left - outerSpacing;
    this.backgroundNode.height = lineHeight + spacingAbove + spacingBelow;
    this.backgroundNode.fill = this.background.fill;
    this.backgroundNode.fillOpacity = this.background.fillOpacity;
  }
  onLayoutComplete(opts) {
    this.labelGroup.translationX = opts.series.rect.x;
    this.updateHighlight();
  }
  updateHighlight() {
    if (!this.enabled)
      return;
    const activeHighlight = this.highlightManager.getActiveHighlight();
    const datum = activeHighlight?.datum ?? this.data?.at(-1);
    if (datum == null) {
      this.labelGroup.visible = false;
      return;
    }
    this.labelGroup.visible = true;
    const itemId = activeHighlight?.itemId;
    let baseStyle = itemId != null ? itemIdMap[itemId] : void 0;
    if (baseStyle == null && this.openKey != null && this.closeKey != null) {
      if (datum[this.openKey] < datum[this.closeKey]) {
        baseStyle = "positive";
      } else {
        baseStyle = "negative";
      }
    }
    for (const { domain, value, key, formatter: formatter2, style: style2 } of this.labels) {
      if (domain == null)
        continue;
      let labelStyle = style2 ?? baseStyle ?? "neutral";
      if (labelStyle === "neutral") {
        labelStyle = neutralColorMap[this.getChartType()] ?? labelStyle;
      }
      const datumKey = this[key];
      const datumValue = datumKey != null ? datum?.[datumKey] : void 0;
      value.setFont(this[labelStyle]);
      value.fill = this[labelStyle].color;
      value.text = typeof datumValue === "number" ? formatter2.format(datumValue) : "";
    }
  }
  getChartType() {
    let chartType = this.ctx.chartService.publicApi?.getOptions()?.chartType;
    if (chartType == null || chartConfigurations[chartType] == null) {
      chartType = "candlestick";
    }
    return chartType;
  }
};
__decorateClass2([
  Property58
], StatusBar.prototype, "enabled", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "openKey", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "highKey", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "lowKey", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "closeKey", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "volumeKey", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "title", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "positive", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "negative", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "neutral", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "altNeutral", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "background", 2);
__decorateClass2([
  Property58
], StatusBar.prototype, "layoutStyle", 2);
var StatusBarModule = {
  type: "root",
  identifier: "status-bar",
  optionsKey: "statusBar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new StatusBar(ctx),
  themeTemplate: {
    statusBar: {
      enabled: false,
      layoutStyle: module_support_exports.ThemeSymbols.DEFAULT_CAPTION_LAYOUT_STYLE,
      title: {
        color: { $ref: "textColor" },
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" }
      },
      positive: {
        color: { $palette: "up.stroke" },
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" }
      },
      negative: {
        color: { $palette: "down.stroke" },
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" }
      },
      neutral: {
        color: { $palette: "neutral.stroke" },
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" }
      },
      background: {
        fill: { $ref: "chartBackgroundColor" },
        fillOpacity: 0.5
      },
      altNeutral: {
        color: "gray",
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" }
      }
    }
  }
};
var UNIT_MIN = 0;
var UNIT_MAX = 1;
var UNIT_SIZE = UNIT_MAX - UNIT_MIN;
var DEFAULT_ANCHOR_POINT_X = "end";
var DEFAULT_ANCHOR_POINT_Y = "middle";
var constrain = (value, min = UNIT_MIN, max = UNIT_MAX) => clamp(min, value, max);
function unitZoomState() {
  return { x: { min: UNIT_MIN, max: UNIT_MAX }, y: { min: UNIT_MIN, max: UNIT_MAX } };
}
function dx(zoom) {
  return zoom.x.max - zoom.x.min;
}
function dy(zoom) {
  return zoom.y.max - zoom.y.min;
}
function isZoomRangeEqual(left, right, epsilon2 = 1e-10) {
  return isNumberEqual(left.min, right.min, epsilon2) && isNumberEqual(left.max, right.max, epsilon2);
}
function isZoomEqual(left, right, epsilon2) {
  return isZoomRangeEqual(left.x, right.x, epsilon2) && isZoomRangeEqual(left.y, right.y, epsilon2);
}
function isMaxZoom(zoom) {
  return isZoomEqual(zoom, unitZoomState());
}
function definedZoomState(zoom) {
  return {
    x: { min: zoom?.x?.min ?? UNIT_MIN, max: zoom?.x?.max ?? UNIT_MAX },
    y: { min: zoom?.y?.min ?? UNIT_MIN, max: zoom?.y?.max ?? UNIT_MAX }
  };
}
function pointToRatio(bbox, x, y) {
  if (!bbox)
    return { x: 0, y: 0 };
  const constrainedX = constrain(x - bbox.x, 0, bbox.x + bbox.width);
  const constrainedY = constrain(y - bbox.y, 0, bbox.y + bbox.height);
  const rx = 1 / bbox.width * constrainedX;
  const ry = 1 - 1 / bbox.height * constrainedY;
  return { x: constrain(rx), y: constrain(ry) };
}
function translateZoom(zoom, x, y) {
  return {
    x: { min: zoom.x.min + x, max: zoom.x.max + x },
    y: { min: zoom.y.min + y, max: zoom.y.max + y }
  };
}
function scaleZoom(zoom, sx, sy) {
  return {
    x: { min: zoom.x.min, max: zoom.x.min + dx(zoom) * sx },
    y: { min: zoom.y.min, max: zoom.y.min + dy(zoom) * sy }
  };
}
function scaleZoomCenter(zoom, sx, sy) {
  const dx_ = dx(zoom);
  const dy_ = dy(zoom);
  const cx = zoom.x.min + dx_ / 2;
  const cy = zoom.y.min + dy_ / 2;
  return {
    x: { min: cx - dx_ * sx / 2, max: cx + dx_ * sx / 2 },
    y: { min: cy - dy_ * sy / 2, max: cy + dy_ * sy / 2 }
  };
}
function scaleZoomAxisWithAnchor(newState, oldState, anchor, origin3) {
  const { min, max } = oldState;
  const center2 = min + (max - min) / 2;
  const diff8 = newState.max - newState.min;
  switch (anchor) {
    case "start":
      return { min, max: oldState.min + diff8 };
    case "end":
      return { min: oldState.max - diff8, max };
    case "middle":
      return { min: center2 - diff8 / 2, max: center2 + diff8 / 2 };
    case "pointer":
      return scaleZoomAxisWithPoint(newState, oldState, origin3 ?? center2);
    default:
      return { min, max };
  }
}
function scaleZoomAxisWithPoint(newState, oldState, origin3) {
  const newDelta = newState.max - newState.min;
  const oldDelta = oldState.max - oldState.min;
  const scaledOrigin = origin3 * (1 - (oldDelta - newDelta));
  const translation = origin3 - scaledOrigin;
  const min = newState.min + translation;
  const max = newState.max + translation;
  return { min, max };
}
function multiplyZoom(zoom, nx, ny) {
  return {
    x: { min: zoom.x.min * nx, max: zoom.x.max * nx },
    y: { min: zoom.y.min * ny, max: zoom.y.max * ny }
  };
}
function constrainZoom(zoom) {
  return {
    x: constrainAxis(zoom.x),
    y: constrainAxis(zoom.y)
  };
}
function constrainAxis(axis) {
  const size = axis.max - axis.min;
  let min = axis.max > UNIT_MAX ? UNIT_MAX - size : axis.min;
  let max = axis.min < UNIT_MIN ? size : axis.max;
  min = Math.max(UNIT_MIN, min);
  max = Math.min(UNIT_MAX, max);
  return { min, max };
}
var {
  BaseProperties: BaseProperties20,
  CartesianAxis: CartesianAxis2,
  ChartAxisDirection: ChartAxisDirection20,
  ContinuousScale: ContinuousScale6,
  TimeScale: TimeScale2,
  UnitTimeScale: UnitTimeScale2,
  ChartUpdateType: ChartUpdateType22,
  ObserveChanges: ObserveChanges4,
  TooltipManager: TooltipManager2,
  Property: Property59,
  findMinMax: findMinMax4,
  isObjectWithStringProperty: isObjectWithStringProperty2
} = module_support_exports;
var debug4 = module_support_exports.Debug.create("sync");
function getDirectionKeys(series, primary, secondary) {
  const primaryKeys = series.getKeys(primary);
  const secondaryKeys = series.getKeys(secondary);
  if (series.shouldFlipXY?.()) {
    return [secondaryKeys, primaryKeys];
  }
  return [primaryKeys, secondaryKeys];
}
function syncedDirections(axes = "x") {
  switch (axes) {
    case "x":
      return [ChartAxisDirection20.X];
    case "y":
      return [ChartAxisDirection20.Y];
    case "xy":
      return [ChartAxisDirection20.X, ChartAxisDirection20.Y];
  }
}
function domainChanged(scale2, a, b) {
  if (TimeScale2.is(scale2) || UnitTimeScale2.is(scale2)) {
    return !arraysEqual(
      a.map((x) => x?.valueOf()),
      b.map((x) => x?.valueOf())
    );
  } else {
    return !arraysEqual(a, b);
  }
}
var ChartSync = class extends BaseProperties20 {
  constructor(moduleContext) {
    super();
    this.moduleContext = moduleContext;
    this.enabled = false;
    this.axes = "x";
    this.nodeInteraction = true;
    this.zoom = true;
    this.domainMode = "key";
    this.domainSync = new AsyncAwaitQueue();
  }
  updateSiblings(groupId) {
    const { syncManager } = this.moduleContext;
    for (const chart of syncManager.getGroupSiblings(groupId ?? this.groupId)) {
      debug4("ChartSync.updateSiblings()", chart.id, chart);
      this.updateChart(chart);
    }
  }
  updateChart(chart, updateType = ChartUpdateType22.PROCESS_DOMAIN) {
    debug4("ChartSync.updateChart()", chart.id, ChartUpdateType22[updateType], chart);
    if (updateType === ChartUpdateType22.PROCESS_DOMAIN) {
      chart.ctx.updateService.update(updateType, { forceNodeDataRefresh: true });
    } else {
      chart.ctx.updateService.update(updateType);
    }
  }
  enabledZoomSync() {
    const { eventsHub } = this.moduleContext;
    this.disableZoomSync?.();
    this.disableZoomSync = eventsHub.on("zoom:change", this.onZoom.bind(this));
  }
  onZoom() {
    const { syncManager } = this.moduleContext;
    for (const chart of syncManager.getGroupSiblings(this.groupId)) {
      if (!chart.modulesManager.getModule("sync")?.zoom)
        continue;
      const zoomModule = chart.modulesManager.getModule("zoom");
      if (!zoomModule)
        continue;
      const zoom = this.prepareZoomUpdate();
      debug4("ChartsSyncManager.enabledZoomSync()", chart.id, zoom);
      zoomModule.updateSyncZoom(zoom);
    }
  }
  enabledNodeInteractionSync() {
    this.disableNodeInteractionSync?.();
    this.disableNodeInteractionSync = this.moduleContext.eventsHub.on(
      "highlight:change",
      this.onHighlightChange.bind(this)
    );
  }
  onHighlightChange(event) {
    const { syncManager } = this.moduleContext;
    if (event.callerId.endsWith("-sync"))
      return;
    debug4("ChartSync.onHighlightChange()", event);
    const series = event.currentHighlight?.series;
    const [mainDirection] = syncedDirections(this.axes);
    const secondaryDirection = mainDirection === ChartAxisDirection20.X ? ChartAxisDirection20.Y : ChartAxisDirection20.X;
    const [primaryKeys, secondaryKeys] = series ? getDirectionKeys(series, mainDirection, secondaryDirection) : [];
    const datum = readDatum(event.currentHighlight);
    let eventValue = primaryKeys?.[0] ? datum?.[primaryKeys[0]] : void 0;
    let valueIsDate = false;
    if (isDate(eventValue)) {
      valueIsDate = true;
      eventValue = eventValue.getTime();
    }
    if (!event.currentHighlight?.datum) {
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if (!chart.modulesManager.getModule("sync")?.nodeInteraction)
          continue;
        chart.ctx.highlightManager.updateHighlight(`${chart.id}-sync`);
        chart.ctx.tooltipManager.removeTooltip(`${chart.id}-sync`);
      }
      return;
    }
    const useSecondaryDirectionKey = syncManager.getGroupSyncMode(this.groupId) === "multi-series";
    this.findMatchingHighlightNodes(
      mainDirection,
      secondaryDirection,
      useSecondaryDirectionKey ? secondaryKeys : [],
      valueIsDate,
      eventValue,
      event
    );
  }
  findMatchingHighlightNodes(primaryDirection, secondaryDirection, secondaryKeys, valueIsDate, eventValue, event) {
    const { syncManager } = this.moduleContext;
    debug4("ChartSync.findMatchingHighlightNodes()", {
      mainDirection: primaryDirection,
      secondaryKeys
    });
    for (const chart of syncManager.getGroupSiblings(this.groupId)) {
      if (!chart.modulesManager.getModule("sync")?.nodeInteraction)
        continue;
      let dispatched = false;
      for (const axis of chart.axes) {
        if (!CartesianAxis2.is(axis) || axis.direction !== primaryDirection)
          continue;
        const matchingNodes = chart.series.filter((s) => {
          if (!s.visible)
            return false;
          if (secondaryKeys.length > 0) {
            const [, seriesKeys] = getDirectionKeys(s, primaryDirection, secondaryDirection);
            return secondaryKeys.every((key) => seriesKeys.includes(key));
          }
          return true;
        }).map(this.findMatchingNodes(axis, primaryDirection, valueIsDate, eventValue)).filter(isDefined);
        if (matchingNodes.length === 1 && matchingNodes[0]?.nodeDatum !== chart.ctx.highlightManager.getActiveHighlight()) {
          this.dispatchHighlightUpdate(chart, matchingNodes[0].nodeDatum);
          dispatched = true;
          break;
        }
      }
      if (!dispatched) {
        debug4("ChartSync.findMatchingHighlightNodes() - no matching nodes", chart.id, event);
        this.dispatchHighlightUpdate(chart);
      }
    }
  }
  findMatchingNodes(axis, mainDirection, valueIsDate, eventValue) {
    return (series) => {
      const seriesKeys = series.getKeys(axis.direction);
      if (axis.keys.length && !axis.keys.some((key) => seriesKeys.includes(key)))
        return;
      const nodeData = series.contextNodeData?.nodeData ?? [];
      if (!nodeData?.length)
        return;
      const firstNode = nodeData[0];
      const mainDirectionKey = `${mainDirection}Key`;
      if (!isObjectWithStringProperty2(firstNode, mainDirectionKey))
        return;
      const valueKey = firstNode[mainDirectionKey];
      const nodeDatum = nodeData.find((datum) => {
        const nodeValue = datum.datum[valueKey];
        return valueIsDate ? nodeValue.getTime() === eventValue : nodeValue === eventValue;
      });
      return nodeDatum ? { series, nodeDatum } : null;
    };
  }
  dispatchHighlightUpdate(chart, nodeDatum) {
    debug4("ChartSync.dispatchHighlightUpdate()", chart.id, nodeDatum);
    chart.ctx.highlightManager.updateHighlight(`${chart.id}-sync`, nodeDatum);
    const tooltipEnabled = nodeDatum?.series.tooltipEnabled ?? chart.tooltip.enabled;
    if (nodeDatum && tooltipEnabled) {
      const bbox = chart.seriesAreaBoundingBox;
      const canvasX = bbox.x + (nodeDatum.midPoint?.x ?? nodeDatum.point?.x ?? 0);
      const canvasY = bbox.y + (nodeDatum.midPoint?.y ?? nodeDatum.point?.y ?? 0);
      const tooltipMeta = TooltipManager2.makeTooltipMeta(
        { type: "pointermove", canvasX, canvasY },
        nodeDatum.series,
        nodeDatum,
        void 0
      );
      chart.ctx.tooltipManager.updateTooltip(
        `${chart.id}-sync`,
        tooltipMeta,
        chart.getTooltipContent(nodeDatum.series, nodeDatum.datumIndex, nodeDatum)
      );
    } else {
      chart.ctx.tooltipManager.removeTooltip(`${chart.id}-sync`);
    }
    this.updateChart(chart, ChartUpdateType22.SERIES_UPDATE);
  }
  async getSyncedDomain(axis) {
    if (!CartesianAxis2.is(axis) || this.axes !== "xy" && this.axes !== axis.direction) {
      return;
    }
    const { groupState, directionDomains, domainsByKey, positionDomains } = this.updateDomainState(axis);
    this.validateAxis(axis, groupState);
    await this.waitForDomainsToBeReady();
    if (this.domainMode === "position") {
      return this.calculateDerivedDomain(axis, positionDomains);
    }
    if (this.domainMode === "direction" || axis.keys.length === 0) {
      return this.calculateDerivedDomain(axis, directionDomains);
    }
    return this.calculateKeyDerivedDomain(axis, domainsByKey);
  }
  updateDomainState(axis) {
    var _a, _b, _c, _d, _e;
    const { syncManager } = this.moduleContext;
    const chartId = syncManager.getChart().id;
    const axisId = axis.id;
    const groupState = syncManager.getGroupState(this.groupId);
    if (!groupState)
      throw new Error("AG Charts - no GroupState for groupId: " + this.groupId);
    const domainsByDirection = groupState.domains ?? (groupState.domains = {});
    const directionDomains = domainsByDirection[_a = axis.direction] ?? (domainsByDirection[_a] = { derived: [], sources: {}, dirty: true });
    const chartDirectionDomains = (_b = directionDomains.sources)[chartId] ?? (_b[chartId] = {});
    chartDirectionDomains[axisId] = axis.dataDomain.domain;
    directionDomains.dirty = true;
    const domainsByKey = groupState.domainsByKey ?? (groupState.domainsByKey = {});
    for (const key of axis.keys ?? []) {
      const keyDomains = domainsByKey[key] ?? (domainsByKey[key] = { derived: [], sources: {}, dirty: true });
      const chartKeyDomains = (_c = keyDomains.sources)[chartId] ?? (_c[chartId] = {});
      chartKeyDomains[axisId] = axis.dataDomain.domain;
      keyDomains.dirty = true;
    }
    const domainsByPosition = groupState.domainsByPosition ?? (groupState.domainsByPosition = {});
    const positionDomains = domainsByPosition[_d = axis.position] ?? (domainsByPosition[_d] = { derived: [], sources: {}, dirty: true });
    const chartPositionDomains = (_e = positionDomains.sources)[chartId] ?? (_e[chartId] = {});
    chartPositionDomains[axisId] = axis.dataDomain.domain;
    positionDomains.dirty = true;
    return { groupState, directionDomains, domainsByKey, positionDomains };
  }
  validateAxis(axis, groupState) {
    const multiSeries = this.moduleContext.syncManager.getGroupSyncMode(this.groupId) === "multi-series";
    if (!syncedDirections(this.axes).includes(axis.direction))
      return;
    if (multiSeries) {
      this.validateMultiSeries(axis, groupState);
    } else {
      this.validateSingleSeries(axis, groupState);
    }
  }
  validateMultiSeries(axis, groupState) {
    const { min, max, nice, reverse } = axis;
    const matchingKeys = new Set(axis.boundSeries.flatMap((s) => s.getKeys(axis.direction)));
    for (const member of groupState.members) {
      const { axes, modulesManager } = member;
      const memberSyncDirections = syncedDirections(modulesManager.getModule("sync")?.axes);
      const keyMatchedAxes = axes.filter((a) => memberSyncDirections.includes(a.direction)).filter((a) => a.boundSeries.some((s) => s.getKeys(a.direction).some((k) => matchingKeys.has(k))));
      if (keyMatchedAxes.length === 0)
        continue;
      const [firstAxis] = keyMatchedAxes;
      if (firstAxis.min !== min || firstAxis.max !== max || firstAxis.nice !== nice || firstAxis.reverse !== reverse) {
        logger_exports.warnOnce(
          "To allow synchronization, ensure that all synchronized axes with matching keys have matching min, max, nice, and reverse properties."
        );
        this.enabled = false;
        return;
      }
    }
  }
  validateSingleSeries(axis, groupState) {
    const members = groupState.members;
    const [{ axes: syncAxes }] = members;
    const { direction, min, max, nice, reverse } = axis;
    for (const nextAxis of syncAxes) {
      if (direction !== nextAxis.direction)
        continue;
      if (nice !== nextAxis.nice || reverse !== nextAxis.reverse || min !== nextAxis.min && (isFiniteNumber(min) || isFiniteNumber(nextAxis.min)) || max !== nextAxis.max && (isFiniteNumber(max) || isFiniteNumber(nextAxis.max))) {
        logger_exports.warnOnce(
          "To allow synchronization, ensure that all charts have matching min, max, nice, and reverse properties on the synchronized axes."
        );
        this.enabled = false;
        return;
      }
    }
  }
  calculateDerivedDomain(axis, directionDomains) {
    if (!directionDomains.dirty)
      return directionDomains.derived;
    const previousDerived = directionDomains.derived;
    directionDomains.derived = unique(
      Object.values(directionDomains.sources).map((d) => Object.values(d)).flat(2)
    );
    if (ContinuousScale6.is(axis.scale)) {
      directionDomains.derived = findMinMax4(directionDomains.derived);
    }
    directionDomains.dirty = false;
    if (domainChanged(axis.scale, previousDerived, directionDomains.derived)) {
      debug4(axis.id, "updated", axis.keys, { before: previousDerived, after: directionDomains.derived });
      this.updateSiblings();
    }
    return directionDomains.derived;
  }
  calculateKeyDerivedDomain(axis, domainsByKey) {
    let previousDerived = [];
    let newDerived = [];
    let updated = false;
    for (const key of axis.keys ?? []) {
      const keyDomains = domainsByKey[key];
      const previousDerivedForKey = keyDomains.derived;
      previousDerived.push(...previousDerivedForKey);
      if (!keyDomains.dirty) {
        newDerived.push(...keyDomains.derived);
        continue;
      }
      keyDomains.derived = unique(
        Object.values(keyDomains.sources).map((d) => Object.values(d)).flat(2)
      );
      if (ContinuousScale6.is(axis.scale)) {
        keyDomains.derived = findMinMax4(keyDomains.derived);
      }
      newDerived.push(...keyDomains.derived);
      keyDomains.dirty = false;
      updated || (updated = !arraysEqual(previousDerivedForKey, keyDomains.derived));
    }
    if (ContinuousScale6.is(axis.scale)) {
      previousDerived = findMinMax4(previousDerived);
      newDerived = findMinMax4(newDerived);
    }
    if (updated && domainChanged(axis.scale, previousDerived, newDerived)) {
      debug4(axis.id, "updated", axis.keys, { before: previousDerived, after: newDerived });
      this.updateSiblings();
    }
    return newDerived;
  }
  removeAxis(axis) {
    if (!CartesianAxis2.is(axis) || this.axes !== "xy" && this.axes !== axis.direction) {
      return;
    }
    const { syncManager } = this.moduleContext;
    const syncGroup = syncManager.getGroupState(this.groupId);
    const chartId = syncManager.getChart().id;
    const axisId = axis.id;
    delete syncGroup?.domains?.[axis.direction]?.sources?.[chartId]?.[axisId];
    for (const key of axis.keys ?? []) {
      delete syncGroup?.domainsByKey?.[key]?.sources?.[chartId]?.[axisId];
    }
    delete syncGroup?.domainsByPosition?.[axis.position]?.sources?.[chartId]?.[axisId];
  }
  async waitForDomainsToBeReady() {
    const { syncManager } = this.moduleContext;
    let count = 0;
    while (syncManager.getGroupMembers(this.groupId).some((c) => c.syncStatus === "init")) {
      debug4("ChartSync.waitForDomainsToBeReady() - waiting for all domains to be calculated", this.groupId);
      await this.domainSync.await();
      count++;
    }
    if (count > 0) {
      debug4("ChartSync.waitForDomainsToBeReady() - waited for", count, "iterations");
    }
    this.domainSync.notify();
  }
  prepareZoomUpdate() {
    const { zoomManager } = this.moduleContext;
    const zoom = zoomManager.getZoom();
    if (this.axes === "x") {
      delete zoom?.y;
    } else if (this.axes === "y") {
      delete zoom?.x;
    }
    return definedZoomState(zoom);
  }
  onEnabledChange() {
    const { syncManager } = this.moduleContext;
    if (this.enabled) {
      syncManager.subscribe(this.groupId);
    } else {
      syncManager.unsubscribe(this.groupId);
    }
    this.updateSiblings();
    this.onNodeInteractionChange();
    this.onZoomChange();
  }
  onGroupIdChange(newValue, oldValue) {
    if (!this.enabled || newValue === oldValue)
      return;
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(oldValue);
    syncManager.subscribe(newValue);
    this.updateSiblings(oldValue);
    this.updateSiblings(newValue);
  }
  onAxesChange() {
    if (!this.enabled)
      return;
    const { syncManager } = this.moduleContext;
    this.updateChart(syncManager.getChart());
  }
  onNodeInteractionChange() {
    if (this.enabled && this.nodeInteraction) {
      this.enabledNodeInteractionSync();
    } else {
      this.disableNodeInteractionSync?.();
    }
  }
  onZoomChange() {
    if (this.enabled && this.zoom) {
      this.enabledZoomSync();
    } else {
      this.disableZoomSync?.();
    }
  }
  destroy() {
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(this.groupId);
    this.updateSiblings();
    this.disableZoomSync?.();
  }
};
ChartSync.className = "Sync";
__decorateClass2([
  Property59,
  ObserveChanges4((target) => target.onEnabledChange())
], ChartSync.prototype, "enabled", 2);
__decorateClass2([
  Property59,
  ObserveChanges4((target, newValue, oldValue) => target.onGroupIdChange(newValue, oldValue))
], ChartSync.prototype, "groupId", 2);
__decorateClass2([
  Property59,
  ObserveChanges4((target) => target.onAxesChange())
], ChartSync.prototype, "axes", 2);
__decorateClass2([
  Property59,
  ObserveChanges4((target) => target.onNodeInteractionChange())
], ChartSync.prototype, "nodeInteraction", 2);
__decorateClass2([
  Property59,
  ObserveChanges4((target) => target.onZoomChange())
], ChartSync.prototype, "zoom", 2);
__decorateClass2([
  Property59,
  ObserveChanges4((target) => target.onAxesChange())
], ChartSync.prototype, "domainMode", 2);
var SyncModule = {
  type: "root",
  optionsKey: "sync",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new ChartSync(ctx),
  themeTemplate: {
    sync: { enabled: false }
  }
};
var { Property: Property60 } = module_support_exports;
var VALID_COLOR = "#2196f3";
var INVALID_COLOR = "#8a8a8a";
var ZoomRect = class extends module_support_exports.Rect {
  constructor() {
    super(...arguments);
    this.fill = VALID_COLOR;
    this.fillOpacity = 0.2;
    this.zIndex = module_support_exports.ZIndexMap.ZOOM_SELECTION;
  }
  updateValid() {
    this.fill = VALID_COLOR;
  }
  updateInvalid() {
    this.fill = INVALID_COLOR;
  }
};
ZoomRect.className = "ZoomRect";
__decorateClass2([
  Property60
], ZoomRect.prototype, "fill", 2);
__decorateClass2([
  Property60
], ZoomRect.prototype, "fillOpacity", 2);
var ZoomAxisDragger = class {
  update(event, direction, anchor, bbox, zoom, axisZoom) {
    this.oldZoom ?? (this.oldZoom = definedZoomState(
      direction === module_support_exports.ChartAxisDirection.X ? { ...zoom, x: axisZoom } : { ...zoom, y: axisZoom }
    ));
    this.updateCoords(event.offsetX, event.offsetY);
    return this.updateZoom(direction, anchor, bbox);
  }
  stop() {
    this.coords = void 0;
    this.oldZoom = void 0;
  }
  updateCoords(x, y) {
    if (this.coords) {
      this.coords.x2 = x;
      this.coords.y2 = y;
    } else {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    }
  }
  updateZoom(direction, anchor, bbox) {
    const { coords, oldZoom } = this;
    let newZoom = definedZoomState(oldZoom);
    if (!coords || !oldZoom) {
      if (direction === module_support_exports.ChartAxisDirection.X)
        return newZoom.x;
      return newZoom.y;
    }
    const origin3 = pointToRatio(bbox, coords.x1, coords.y1);
    const target = pointToRatio(bbox, coords.x2, coords.y2);
    if (direction === module_support_exports.ChartAxisDirection.X) {
      const scaleX = (target.x - origin3.x) * dx(oldZoom);
      newZoom.x.max += scaleX;
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchor, origin3.x);
      newZoom = constrainZoom(newZoom);
      return newZoom.x;
    }
    const scaleY = (target.y - origin3.y) * dy(oldZoom);
    newZoom.y.max -= scaleY;
    newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchor, origin3.y);
    newZoom = constrainZoom(newZoom);
    return newZoom.y;
  }
};
var ZoomContextMenu = class {
  constructor(eventsHub, contextMenuRegistry, zoomManager, getModuleProperties, canResetZoom, getRect, updateZoom, isZoomValid) {
    this.eventsHub = eventsHub;
    this.contextMenuRegistry = contextMenuRegistry;
    this.zoomManager = zoomManager;
    this.getModuleProperties = getModuleProperties;
    this.canResetZoom = canResetZoom;
    this.getRect = getRect;
    this.updateZoom = updateZoom;
    this.isZoomValid = isZoomValid;
  }
  registerActions(enabled) {
    const { contextMenuRegistry } = this;
    if (enabled) {
      contextMenuRegistry.setVisible("zoom-to-cursor", true);
      contextMenuRegistry.setVisible("pan-to-cursor", true);
      contextMenuRegistry.setVisible("reset-zoom", true);
    } else {
      contextMenuRegistry.setVisible("zoom-to-cursor", false);
      contextMenuRegistry.setVisible("pan-to-cursor", false);
      contextMenuRegistry.setVisible("reset-zoom", false);
      return;
    }
    contextMenuRegistry.builtins.items["zoom-to-cursor"].action = this.onZoomToHere.bind(this);
    contextMenuRegistry.builtins.items["pan-to-cursor"].action = this.onPanToHere.bind(this);
    contextMenuRegistry.builtins.items["reset-zoom"].action = this.onResetZoom.bind(this);
    const shouldEnableZoomToHere = (event) => {
      const rect = this.getRect();
      if (!rect)
        return true;
      const origin3 = pointToRatio(rect, event.x, event.y);
      return this.iterateFindNextZoomAtPoint(origin3) != null;
    };
    const shouldEnablePanToHere = () => {
      return !isZoomEqual(definedZoomState(this.zoomManager.getZoom()), unitZoomState());
    };
    const removeListener = this.eventsHub.on("context-menu:setup", (event) => {
      contextMenuRegistry.builtins.items["zoom-to-cursor"].enabled = shouldEnableZoomToHere(event);
      contextMenuRegistry.builtins.items["pan-to-cursor"].enabled = shouldEnablePanToHere();
      contextMenuRegistry.builtins.items["reset-zoom"].enabled = this.canResetZoom();
    });
    return () => {
      removeListener();
      contextMenuRegistry.setVisible("zoom-to-cursor", false);
      contextMenuRegistry.setVisible("pan-to-cursor", false);
      contextMenuRegistry.setVisible("reset-zoom", false);
    };
  }
  computeOrigin(event) {
    const rect = this.getRect();
    const { enabled } = this.getModuleProperties();
    if (!enabled || !rect || !event?.target || !(event instanceof MouseEvent))
      return;
    const relativeRect = { x: 0, y: 0, width: rect.width, height: rect.height };
    return pointToRatio(relativeRect, event.offsetX, event.offsetY);
  }
  onZoomToHere({ event }) {
    const origin3 = this.computeOrigin(event);
    if (!origin3)
      return;
    const zoom = this.iterateFindNextZoomAtPoint(origin3);
    if (zoom == null)
      return;
    this.updateZoom(zoom);
  }
  onPanToHere({ event }) {
    const origin3 = this.computeOrigin(event);
    if (!origin3)
      return;
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const scaleX = dx(zoom);
    const scaleY = dy(zoom);
    const scaledOriginX = origin3.x * scaleX;
    const scaledOriginY = origin3.y * scaleY;
    const halfSize = UNIT_SIZE / 2;
    let newZoom = {
      x: { min: origin3.x - halfSize, max: origin3.x + halfSize },
      y: { min: origin3.y - halfSize, max: origin3.y + halfSize }
    };
    newZoom = scaleZoomCenter(newZoom, scaleX, scaleY);
    newZoom = translateZoom(newZoom, zoom.x.min - origin3.x + scaledOriginX, zoom.y.min - origin3.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
  onResetZoom(_actionEvent) {
    this.zoomManager.resetZoom("zoom");
  }
  iterateFindNextZoomAtPoint(origin3) {
    const { scrollingStep } = this.getModuleProperties();
    for (let i = scrollingStep; i <= 1 - scrollingStep; i += scrollingStep) {
      const zoom = this.getNextZoomAtPoint(origin3, i);
      if (this.isZoomValid(zoom)) {
        return zoom;
      }
    }
  }
  getNextZoomAtPoint(origin3, step) {
    const { isScalingX, isScalingY } = this.getModuleProperties();
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const scaledOriginX = origin3.x * dx(zoom);
    const scaledOriginY = origin3.y * dy(zoom);
    const halfSize = UNIT_SIZE / 2;
    let newZoom = {
      x: { min: origin3.x - halfSize, max: origin3.x + halfSize },
      y: { min: origin3.y - halfSize, max: origin3.y + halfSize }
    };
    newZoom = scaleZoomCenter(
      newZoom,
      isScalingX ? dx(zoom) * step : UNIT_SIZE,
      isScalingY ? dy(zoom) * step : UNIT_SIZE
    );
    newZoom = translateZoom(newZoom, zoom.x.min - origin3.x + scaledOriginX, zoom.y.min - origin3.y + scaledOriginY);
    return constrainZoom(newZoom);
  }
};
var { ChartAxisDirection: ChartAxisDirection21 } = module_support_exports;
var ZoomDOMProxy = class {
  constructor(axesHandlers) {
    this.axesHandlers = axesHandlers;
    this.axes = [];
  }
  destroy() {
    this.axes.forEach((a) => a.div.destroy());
  }
  update(enableAxisDragging, enableAxisScrolling, ctx) {
    this.axes.forEach((ax) => ax.div.setHidden(!enableAxisDragging && !enableAxisScrolling));
    if (!enableAxisDragging && !enableAxisScrolling)
      return;
    const { X, Y } = ChartAxisDirection21;
    const axesCtx = [...ctx.axisManager.getAxisContext(X), ...ctx.axisManager.getAxisContext(Y)];
    const { removed, added } = this.diffAxisIds(axesCtx);
    if (removed.length > 0) {
      this.axes = this.axes.filter((entry) => {
        if (removed.includes(entry.axisId)) {
          entry.div.destroy();
          return false;
        }
        return true;
      });
    }
    for (const newAxisCtx of added) {
      const { axisId, direction } = newAxisCtx;
      this.axes.push(this.initAxis(ctx, axisId, this.axesHandlers, direction));
    }
    for (const axis of this.axes) {
      const axisCtx = axesCtx.find((ac) => ac.axisId === axis.axisId);
      const bbox = axisCtx.getCanvasBounds();
      axis.div.setHidden(boxEmpty(bbox));
      if (bbox !== void 0) {
        axis.div.setBounds(bbox);
      }
    }
  }
  setAxisCursor(cursor) {
    this.cursor = cursor;
    for (const axis of this.axes) {
      axis.div.setCursor(this.getCursor(axis.direction));
    }
  }
  toggleAxisDraggingCursor(direction, enabled) {
    for (const axis of this.axes) {
      if (axis.direction !== direction)
        continue;
      axis.div.setCursor(enabled ? this.getCursor(direction) : void 0);
    }
  }
  getCursor(direction) {
    if (this.cursor)
      return this.cursor;
    return direction === ChartAxisDirection21.X ? "ew-resize" : "ns-resize";
  }
  initAxis(ctx, axisId, handlers, direction) {
    const where = "afterend";
    const div = ctx.proxyInteractionService.createProxyElement({ type: "region", domManagerId: axisId, where });
    div.setCursor(this.getCursor(direction));
    div.addListener("drag-start", (e) => {
      if (e.device === "touch") {
        e.sourceEvent.preventDefault();
      }
      handlers.onAxisDragStart(direction);
    });
    div.addListener("drag-move", (event) => handlers.onAxisDragMove(axisId, direction, event));
    div.addListener("drag-end", handlers.onAxisDragEnd);
    div.addListener("dblclick", () => handlers.onAxisDoubleClick(axisId, direction));
    div.addListener("wheel", (event) => handlers.onAxisWheel(axisId, direction, event));
    return { axisId, div, direction };
  }
  diffAxisIds(axesCtx) {
    const myIds = this.axes.map((entry) => entry.axisId);
    const ctxIds = axesCtx.map((ctx) => ctx.axisId);
    const removed = myIds.filter((id) => !ctxIds.includes(id));
    const added = axesCtx.filter((ac) => !myIds.includes(ac.axisId));
    return { removed, added };
  }
};
var maxZoomCoords = 16;
var decelerationValues = {
  off: 1,
  short: 0.01,
  long: 2e-3
};
var ZoomPanner = class {
  constructor() {
    this.deceleration = 1;
    this.zoomCoordsHistoryIndex = 0;
    this.coordsHistory = [];
  }
  get decelerationValue() {
    const { deceleration } = this;
    return Math.max(
      typeof deceleration === "number" ? deceleration : decelerationValues[deceleration] ?? 1,
      1e-4
    );
  }
  addListener(_type, fn) {
    this.onUpdate = fn;
    return () => {
      this.onUpdate = void 0;
    };
  }
  stopInteractions() {
    if (this.inertiaHandle != null) {
      cancelAnimationFrame(this.inertiaHandle);
      this.inertiaHandle = void 0;
    }
  }
  update(event) {
    this.updateCoords(event.currentX, event.currentY);
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = this.coords ?? {};
    this.onUpdate?.({
      type: "update",
      deltaX: this.isPanningX() ? x1 - x2 : 0,
      deltaY: this.isPanningY() ? y1 - y2 : 0
    });
  }
  start(direction) {
    this.direction = direction;
    this.coordsMonitorTimeout = setInterval(this.recordCurrentZoomCoords.bind(this), 16);
  }
  stop() {
    const { coordsHistory } = this;
    let deltaX = 0;
    let deltaY = 0;
    let deltaT = 0;
    if (coordsHistory.length > 0) {
      const arrayIndex = this.zoomCoordsHistoryIndex % maxZoomCoords;
      let index1 = arrayIndex - 1;
      if (index1 < 0)
        index1 = coordsHistory.length - 1;
      let index0 = arrayIndex;
      if (index0 >= coordsHistory.length)
        index0 = 0;
      const coords1 = coordsHistory[index1];
      const coords0 = coordsHistory[index0];
      deltaX = this.isPanningX() ? coords1.x - coords0.x : 0;
      deltaY = this.isPanningY() ? coords1.y - coords0.y : 0;
      deltaT = coords1.t - coords0.t;
    }
    this.coords = void 0;
    this.direction = void 0;
    clearInterval(this.coordsMonitorTimeout);
    this.coordsMonitorTimeout = void 0;
    this.zoomCoordsHistoryIndex = 0;
    this.coordsHistory.length = 0;
    if (deltaT > 0 && this.decelerationValue < 1) {
      const xVelocity = deltaX / deltaT;
      const yVelocity = deltaY / deltaT;
      const velocity = Math.hypot(xVelocity, yVelocity);
      const angle2 = Math.atan2(yVelocity, xVelocity);
      const t0 = performance.now();
      this.inertiaHandle = getWindow().requestAnimationFrame((t) => {
        this.animateInertia(t, t, t0, velocity, angle2);
      });
    }
  }
  recordCurrentZoomCoords() {
    const { coords, coordsHistory, zoomCoordsHistoryIndex } = this;
    if (!coords)
      return;
    const { x2: x, y2: y } = coords;
    const t = Date.now();
    coordsHistory[zoomCoordsHistoryIndex % maxZoomCoords] = { x, y, t };
    this.zoomCoordsHistoryIndex += 1;
  }
  animateInertia(t, prevT, t0, velocity, angle2) {
    const friction = 1 - this.decelerationValue;
    const maxS = -velocity / Math.log(friction);
    const s0 = velocity * (friction ** (prevT - t0) - 1) / Math.log(friction);
    const s1 = velocity * (friction ** (t - t0) - 1) / Math.log(friction);
    this.onUpdate?.({
      type: "update",
      deltaX: this.isPanningX() ? -Math.cos(angle2) * (s1 - s0) : 0,
      deltaY: this.isPanningY() ? -Math.sin(angle2) * (s1 - s0) : 0
    });
    if (s1 >= maxS - 1)
      return;
    this.inertiaHandle = requestAnimationFrame((nextT) => {
      this.animateInertia(nextT, t, t0, velocity, angle2);
    });
  }
  updateCoords(x, y) {
    if (this.coords) {
      this.coords = { x1: this.coords.x2, y1: this.coords.y2, x2: x, y2: y };
    } else {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    }
  }
  isPanningX() {
    return this.direction == null || this.direction === module_support_exports.ChartAxisDirection.X;
  }
  isPanningY() {
    return this.direction == null || this.direction === module_support_exports.ChartAxisDirection.Y;
  }
  translateZooms(bbox, currentZooms, deltaX, deltaY) {
    const offset = pointToRatio(bbox, bbox.x + Math.abs(deltaX), bbox.y + bbox.height - Math.abs(deltaY));
    const offsetX = Math.sign(deltaX) * offset.x;
    const offsetY = -Math.sign(deltaY) * offset.y;
    const newZooms = {};
    for (const [axisId, { direction, zoom: currentZoom }] of entries(currentZooms)) {
      if (currentZoom && currentZoom.min === UNIT_MIN && currentZoom.max === UNIT_MAX) {
        continue;
      }
      let zoom = definedZoomState({ [direction]: currentZoom });
      zoom = constrainZoom(translateZoom(zoom, offsetX * dx(zoom), offsetY * dy(zoom)));
      newZooms[axisId] = { direction, zoom: zoom[direction] };
    }
    return newZooms;
  }
};
var DELTA_SCALE = 200;
var ZoomScrollPanner = class {
  update(event, step, bbox, zooms) {
    const deltaX = event.deltaX * step * DELTA_SCALE;
    return this.translateZooms(bbox, zooms, deltaX);
  }
  translateZooms(bbox, currentZooms, deltaX) {
    const newZooms = {};
    const offset = pointToRatio(bbox, bbox.x + Math.abs(deltaX), 0);
    const offsetX = deltaX < 0 ? -offset.x : offset.x;
    for (const [axisId, { direction, zoom: currentZoom }] of entries(currentZooms)) {
      if (direction !== module_support_exports.ChartAxisDirection.X)
        continue;
      let zoom = definedZoomState({ x: currentZoom });
      zoom = constrainZoom(translateZoom(zoom, offsetX * dx(zoom), 0));
      newZooms[axisId] = { direction, zoom: zoom.x };
    }
    return newZooms;
  }
};
var ZoomScroller = class {
  updateAxes(event, props, bbox, zooms) {
    const sourceEvent = event.sourceEvent;
    const newZooms = {};
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const origin3 = pointToRatio(
      bbox,
      sourceEvent.offsetX ?? sourceEvent.clientX,
      sourceEvent.offsetY ?? sourceEvent.clientY
    );
    for (const [axisId, { direction, zoom }] of entries(zooms)) {
      if (zoom == null)
        continue;
      let newZoom = { ...zoom };
      const delta32 = scrollingStep * event.deltaY * (zoom.max - zoom.min);
      if (direction === module_support_exports.ChartAxisDirection.X && isScalingX) {
        newZoom.max += delta32;
        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, anchorPointX, origin3.x);
      } else if (direction === module_support_exports.ChartAxisDirection.Y && isScalingY) {
        newZoom.max += delta32;
        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, anchorPointY, origin3.y);
      } else {
        continue;
      }
      newZooms[axisId] = { direction, zoom: constrainAxis(newZoom) };
    }
    return newZooms;
  }
  update(event, props, bbox, oldZoom) {
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const canvasX = event.offsetX + bbox.x;
    const canvasY = event.offsetY + bbox.y;
    const origin3 = pointToRatio(bbox, canvasX, canvasY);
    const dir = event.deltaY;
    let newZoom = definedZoomState(oldZoom);
    newZoom.x.max += isScalingX ? scrollingStep * dir * dx(oldZoom) : 0;
    newZoom.y.max += isScalingY ? scrollingStep * dir * dy(oldZoom) : 0;
    if (newZoom.x.max < newZoom.x.min || newZoom.y.max < newZoom.y.min)
      return;
    if (isScalingX) {
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX, origin3.x);
    }
    if (isScalingY) {
      newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY, origin3.y);
    }
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  updateDelta(delta32, props, oldZoom) {
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    let newZoom = definedZoomState(oldZoom);
    newZoom.x.max += isScalingX ? scrollingStep * -delta32 * dx(oldZoom) : 0;
    newZoom.y.max += isScalingY ? scrollingStep * -delta32 * dy(oldZoom) : 0;
    if (isScalingX) {
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX);
    }
    if (isScalingY) {
      newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY);
    }
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
};
var ZoomSelector = class {
  constructor(rect, getZoom, isZoomValid) {
    this.rect = rect;
    this.getZoom = getZoom;
    this.isZoomValid = isZoomValid;
    this.rect.visible = false;
  }
  update(event, props, bbox) {
    const canvasX = event.currentX + (bbox?.x ?? 0);
    const canvasY = event.currentY + (bbox?.y ?? 0);
    this.rect.visible = true;
    this.updateCoords(canvasX, canvasY, props, bbox);
    this.updateRect(bbox);
  }
  stop(innerBBox, bbox, currentZoom) {
    let zoom = definedZoomState();
    if (!innerBBox || !bbox)
      return zoom;
    if (this.coords) {
      zoom = this.createZoomFromCoords(bbox, currentZoom);
    }
    const multiplyX = bbox.width / innerBBox.width;
    const multiplyY = bbox.height / innerBBox.height;
    zoom = constrainZoom(multiplyZoom(zoom, multiplyX, multiplyY));
    this.reset();
    return zoom;
  }
  reset() {
    this.coords = void 0;
    this.rect.visible = false;
  }
  didUpdate() {
    return this.rect.visible && this.rect.width > 0 && this.rect.height > 0;
  }
  updateCoords(x, y, props, bbox) {
    if (!this.coords) {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
      return;
    }
    const { coords } = this;
    coords.x2 = x;
    coords.y2 = y;
    if (!bbox)
      return;
    const { isScalingX, isScalingY, keepAspectRatio } = props;
    const normal = this.getNormalisedDimensions();
    if (keepAspectRatio && isScalingX && isScalingY) {
      const aspectRatio = bbox.width / bbox.height;
      if (coords.y2 < coords.y1) {
        coords.y2 = Math.min(coords.y1 - normal.width / aspectRatio, coords.y1);
      } else {
        coords.y2 = Math.max(coords.y1 + normal.width / aspectRatio, coords.y1);
      }
    }
    if (!isScalingX) {
      coords.x1 = bbox.x;
      coords.x2 = bbox.x + bbox.width;
    }
    if (!isScalingY) {
      coords.y1 = bbox.y;
      coords.y2 = bbox.y + bbox.height;
    }
  }
  updateRect(bbox) {
    if (!bbox)
      return;
    const { rect } = this;
    const normal = this.getNormalisedDimensions();
    const { width: width2, height: height2 } = normal;
    let { x, y } = normal;
    x = Math.max(x, bbox.x);
    x -= Math.max(0, x + width2 - (bbox.x + bbox.width));
    y = Math.max(y, bbox.y);
    y -= Math.max(0, y + height2 - (bbox.y + bbox.height));
    rect.x = x;
    rect.y = y;
    rect.width = width2;
    rect.height = height2;
    const zoom = this.createZoomFromCoords(bbox, this.getZoom());
    if (this.isZoomValid(zoom)) {
      rect.updateValid();
    } else {
      rect.updateInvalid();
    }
  }
  createZoomFromCoords(bbox, currentZoom) {
    const oldZoom = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const origin3 = pointToRatio(bbox, normal.x, normal.y + normal.height);
    const xFactor = normal.width / bbox.width;
    const yFactor = normal.height / bbox.height;
    let newZoom = scaleZoom(oldZoom, xFactor, yFactor);
    const translateX = origin3.x * dx(oldZoom);
    const translateY = origin3.y * dy(oldZoom);
    newZoom = translateZoom(newZoom, translateX, translateY);
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  getNormalisedDimensions() {
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = this.coords ?? {};
    const x = x1 <= x2 ? x1 : x2;
    const y = y1 <= y2 ? y1 : y2;
    const width2 = x1 <= x2 ? x2 - x1 : x1 - x2;
    const height2 = y1 <= y2 ? y2 - y1 : y1 - y2;
    return { x, y, width: width2, height: height2 };
  }
};
var {
  ActionOnSet: ActionOnSet8,
  BaseProperties: BaseProperties21,
  ChartAxisDirection: ChartAxisDirection222,
  NativeWidget: NativeWidget22,
  PropertiesArray: PropertiesArray6,
  Toolbar: Toolbar22,
  ToolbarButtonProperties: ToolbarButtonProperties4,
  Property: Property61
} = module_support_exports;
var ZoomButtonProperties = class extends ToolbarButtonProperties4 {
};
__decorateClass2([
  Property61
], ZoomButtonProperties.prototype, "value", 2);
__decorateClass2([
  Property61
], ZoomButtonProperties.prototype, "section", 2);
var ZoomToolbar = class extends BaseProperties21 {
  constructor(ctx, getModuleProperties, canResetZoom, updateZoom, updateAxisZoom, resetZoom, isZoomValid) {
    super();
    this.ctx = ctx;
    this.getModuleProperties = getModuleProperties;
    this.canResetZoom = canResetZoom;
    this.updateZoom = updateZoom;
    this.updateAxisZoom = updateAxisZoom;
    this.resetZoom = resetZoom;
    this.isZoomValid = isZoomValid;
    this.enabled = false;
    this.buttons = new PropertiesArray6(ZoomButtonProperties);
    this.visible = "hover";
    this.verticalSpacing = 10;
    this.detectionRange = 38;
    this.cleanup = new CleanupRegistry();
    this.container = new NativeWidget22(createElement("div"));
    this.container.addClass("ag-charts-zoom-buttons");
    ctx.domManager.addChild("canvas-overlay", "zoom-buttons", this.container.getElement());
    this.toolbar = new Toolbar22(ctx, "ariaLabelZoomToolbar", "horizontal");
    this.container.addChild(this.toolbar);
    this.toolbar.getElement().style.transform = `translateY(54px)`;
    this.toggleVisibility(this.visible === "always");
    this.cleanup.register(
      this.toolbar.addToolbarListener("button-pressed", this.onButtonPress.bind(this)),
      this.toolbar.addToolbarListener("button-focused", this.onButtonFocus.bind(this)),
      ctx.widgets.containerWidget.addListener("mousemove", this.onHover.bind(this)),
      ctx.widgets.containerWidget.addListener("mouseleave", this.onLeave.bind(this)),
      ctx.eventsHub.on("layout:complete", this.onLayoutComplete.bind(this)),
      this.teardown.bind(this)
    );
  }
  destroy() {
    this.cleanup.flush();
  }
  toggleVisibleZoomed(isMaxZoom2) {
    if (this.visible !== "zoomed")
      return;
    this.toggleVisibility(!isMaxZoom2);
  }
  teardown() {
    this.ctx.domManager.removeChild("canvas-overlay", "zoom-buttons");
    this.container.destroy();
  }
  onLayoutComplete(event) {
    const { buttons: buttons2, container } = this;
    const { rect } = event.series;
    for (const b of buttons2) {
      if (b.tooltip == null && b.label == null) {
        const map = {
          "pan-end": "toolbarZoomPanEnd",
          "pan-left": "toolbarZoomPanLeft",
          "pan-right": "toolbarZoomPanRight",
          "pan-start": "toolbarZoomPanStart",
          "zoom-in": "toolbarZoomZoomIn",
          "zoom-out": "toolbarZoomZoomOut",
          reset: "toolbarZoomReset"
        };
        b.tooltip = map[b.value];
      }
    }
    this.toolbar.updateButtons(buttons2);
    this.toggleButtons();
    const height2 = container.getBounds().height;
    container.setBounds({ y: rect.y + rect.height - height2 });
  }
  onHover(event) {
    if (!this.enabled || this.visible !== "hover" || this.toolbar.isHidden())
      return;
    const {
      container,
      detectionRange,
      ctx: { scene }
    } = this;
    const {
      currentY,
      sourceEvent: { target }
    } = event;
    const element2 = container.getElement();
    const detectionY = element2.offsetTop - detectionRange;
    const visible = currentY > detectionY && currentY < scene.canvas.element.offsetHeight || target === element2;
    this.toggleVisibility(visible);
  }
  onLeave() {
    if (this.visible !== "hover")
      return;
    this.toggleVisibility(false);
  }
  toggleVisibility(visible, immediate = false) {
    const { container, toolbar: toolbar2, verticalSpacing } = this;
    toolbar2.toggleClass("ag-charts-zoom-buttons__toolbar--hidden", !visible);
    const element2 = toolbar2.getElement();
    element2.style.transitionDuration = immediate ? "0s" : "";
    element2.style.transform = visible ? "translateY(0)" : `translateY(${container.getBounds().height + verticalSpacing}px)`;
  }
  toggleButtons() {
    const zoom = definedZoomState(this.ctx.zoomManager.getZoom());
    if (this.previousZoom && isZoomEqual(this.previousZoom, zoom))
      return;
    this.previousZoom = zoom;
    for (const [index, button] of this.buttons.entries()) {
      let enabled = true;
      switch (button?.value) {
        case "pan-start":
          enabled = zoom.x.min > UNIT_MIN;
          break;
        case "pan-end":
          enabled = zoom.x.max < UNIT_MAX;
          break;
        case "pan-left":
          enabled = zoom.x.min > UNIT_MIN;
          break;
        case "pan-right":
          enabled = zoom.x.max < UNIT_MAX;
          break;
        case "zoom-out":
          enabled = !isZoomEqual(zoom, unitZoomState());
          break;
        case "zoom-in":
          enabled = this.isZoomValid(
            this.getNextZoomStateUnified("zoom-in", zoom, this.getModuleProperties())
          );
          break;
        case "reset":
          enabled = this.canResetZoom(zoom);
          break;
      }
      this.toolbar.toggleButtonEnabledByIndex(index, enabled);
    }
  }
  onButtonPress({ button }) {
    if (!this.enabled || this.toolbar.isHidden())
      return;
    const props = this.getModuleProperties();
    if (props.independentAxes && button.value !== "reset") {
      const axisZooms = this.ctx.zoomManager.getAxisZooms();
      for (const [axisId, { direction, zoom }] of entries(axisZooms)) {
        if (zoom == null)
          continue;
        this.onButtonPressAxis(button, props, axisId, direction, zoom);
      }
    } else {
      this.onButtonPressUnified(button, props);
    }
  }
  onButtonFocus(_event) {
    this.toggleVisibility(true, true);
  }
  onButtonPressAxis(event, props, axisId, direction, zoom) {
    const { isScalingX, isScalingY, scrollingStep } = props;
    let newZoom = { ...zoom };
    const delta32 = zoom.max - zoom.min;
    switch (event.value) {
      case "pan-start":
        newZoom.max = delta32;
        newZoom.min = 0;
        break;
      case "pan-end":
        newZoom.min = newZoom.max - delta32;
        newZoom.max = UNIT_MAX;
        break;
      case "pan-left":
        newZoom.min -= delta32 * scrollingStep;
        newZoom.max -= delta32 * scrollingStep;
        break;
      case "pan-right":
        newZoom.min += delta32 * scrollingStep;
        newZoom.max += delta32 * scrollingStep;
        break;
      case "zoom-in":
      case "zoom-out": {
        const isDirectionX = direction === ChartAxisDirection222.X;
        const isScalingDirection = isDirectionX && isScalingX || !isDirectionX && isScalingY;
        let scale2 = event.value === "zoom-in" ? 1 - scrollingStep : 1 + scrollingStep;
        if (!isScalingDirection)
          scale2 = 1;
        const placement = isDirectionX ? this.getAnchorPointX(props) : this.getAnchorPointY(props);
        newZoom.max = newZoom.min + (newZoom.max - newZoom.min) * scale2;
        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, placement);
        break;
      }
    }
    this.updateAxisZoom(axisId, direction, constrainAxis(newZoom));
  }
  onButtonPressUnified(event, props) {
    const { scrollingStep } = props;
    const oldZoom = definedZoomState(this.ctx.zoomManager.getZoom());
    let zoom = definedZoomState(oldZoom);
    switch (event.value) {
      case "reset":
        this.resetZoom();
        return;
      case "pan-start":
        zoom.x.max = dx(zoom);
        zoom.x.min = 0;
        break;
      case "pan-end":
        zoom.x.min = UNIT_MAX - dx(zoom);
        zoom.x.max = UNIT_MAX;
        break;
      case "pan-left":
        zoom = translateZoom(zoom, -dx(zoom) * scrollingStep, 0);
        break;
      case "pan-right":
        zoom = translateZoom(zoom, dx(zoom) * scrollingStep, 0);
        break;
      case "zoom-in":
      case "zoom-out": {
        zoom = this.getNextZoomStateUnified(event.value, oldZoom, props);
        break;
      }
    }
    this.updateZoom(constrainZoom(zoom));
  }
  getNextZoomStateUnified(button, oldZoom, props) {
    const { isScalingX, isScalingY, scrollingStep } = props;
    const scale2 = button === "zoom-in" ? 1 - scrollingStep : 1 + scrollingStep;
    const zoom = scaleZoom(oldZoom, isScalingX ? scale2 : 1, isScalingY ? scale2 : 1);
    zoom.x = scaleZoomAxisWithAnchor(zoom.x, oldZoom.x, this.getAnchorPointX(props));
    zoom.y = scaleZoomAxisWithAnchor(zoom.y, oldZoom.y, this.getAnchorPointY(props));
    return zoom;
  }
  getAnchorPointX(props) {
    const anchorPointX = this.anchorPointX ?? props.anchorPointX;
    return anchorPointX === "pointer" ? DEFAULT_ANCHOR_POINT_X : anchorPointX;
  }
  getAnchorPointY(props) {
    const anchorPointY = this.anchorPointY ?? props.anchorPointY;
    return anchorPointY === "pointer" ? DEFAULT_ANCHOR_POINT_Y : anchorPointY;
  }
};
__decorateClass2([
  Property61,
  ActionOnSet8({
    changeValue(enabled) {
      this.toolbar?.setHidden(!enabled);
    }
  })
], ZoomToolbar.prototype, "enabled", 2);
__decorateClass2([
  Property61
], ZoomToolbar.prototype, "buttons", 2);
__decorateClass2([
  Property61,
  ActionOnSet8({
    changeValue(visible, oldValue) {
      if (oldValue == null)
        return;
      this.toggleVisibility(visible === "always");
    }
  })
], ZoomToolbar.prototype, "visible", 2);
__decorateClass2([
  Property61
], ZoomToolbar.prototype, "anchorPointX", 2);
__decorateClass2([
  Property61
], ZoomToolbar.prototype, "anchorPointY", 2);
var N = 1e6;
function clientToNormal({ min, max }, a, Rx, Rw) {
  if (Rw === 0)
    return 0;
  return N * ((a - Rx) / Rw * (max - min) + min);
}
function solveTwoUnknowns(x1, x2, a1, a2, Rx, Rw) {
  [x1, x2] = [Math.min(x1, x2), Math.max(x1, x2)];
  [a1, a2] = [Math.min(a1, a2), Math.max(a1, a2)];
  const t1 = N * (a1 - Rx) / Rw;
  const t2 = N * (a2 - Rx) / Rw;
  const c = (a1 - Rx) / (a2 - Rx);
  const min = (x1 - c * x2) / (N - t1 + c * (t2 - N));
  const max = (x2 + (t2 - N) * min) / t2;
  return { min, max };
}
function isRangeOverlapping(centerA, radiusA, centerB, radiusB) {
  if (radiusA === 0)
    radiusA = 30;
  if (radiusB === 0)
    radiusB = 30;
  const minA = centerA - radiusA;
  const maxA = centerA + radiusA;
  const minB = centerB - radiusB;
  const maxB = centerB + radiusB;
  return !(maxA < minB || maxB < minA);
}
var ZoomTwoFingers = class {
  constructor() {
    this.touchStart = {
      origins: [
        { identifier: 0, normalX: NaN, normalY: NaN },
        { identifier: 0, normalX: NaN, normalY: NaN }
      ]
    };
    this.initialZoom = { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };
    this.previous = { a1: NaN, a2: NaN, b1: NaN, b2: NaN };
  }
  start(event, target, zoom) {
    if (event.sourceEvent.targetTouches.length !== 2)
      return false;
    event.sourceEvent.preventDefault();
    const targetTouches = Array.from(event.sourceEvent.targetTouches);
    const { x: Rx, y: Ry, width: Rw, height: Rh } = target.getBoundingClientRect();
    this.initialZoom.x.min = zoom.x?.min ?? 0;
    this.initialZoom.x.max = zoom.x?.max ?? 1;
    this.initialZoom.y.min = zoom.y?.min ?? 0;
    this.initialZoom.y.max = zoom.y?.max ?? 1;
    this.touchStart.origins.forEach((t) => t.identifier = 0);
    this.previous.a1 = NaN;
    this.previous.a2 = NaN;
    this.previous.b1 = NaN;
    this.previous.b2 = NaN;
    for (const i of [0, 1]) {
      const a = targetTouches[i].clientX;
      const b = Ry + Rh - targetTouches[i].clientY;
      this.touchStart.origins[i].identifier = targetTouches[i].identifier;
      this.touchStart.origins[i].normalX = clientToNormal(this.initialZoom.x, a, Rx, Rw);
      this.touchStart.origins[i].normalY = clientToNormal(this.initialZoom.y, b, Ry, Rh);
    }
    const [tA, tB] = targetTouches;
    const [oA, oB] = this.touchStart.origins;
    const xOverlap = isRangeOverlapping(tA.clientX, tA.radiusX, tB.clientX, tB.radiusX);
    const yOverlap = isRangeOverlapping(tA.clientY, tA.radiusY, tB.clientY, tB.radiusY);
    if (yOverlap)
      oA.normalY = oB.normalY = (oA.normalY + oB.normalY) / 2;
    if (xOverlap)
      oA.normalX = oB.normalX = (oA.normalX + oB.normalX) / 2;
    return true;
  }
  update(event, target) {
    event.sourceEvent.preventDefault();
    const targetTouches = Array.from(event.sourceEvent.targetTouches);
    const { x: Rx, y: Ry, width: Rw, height: Rh } = target.getBoundingClientRect();
    const { origins } = this.touchStart;
    const touches = [0, 1].map((i) => targetTouches.find((t) => t.identifier === origins[i].identifier));
    const x1 = origins[0].normalX;
    const x2 = origins[1].normalX;
    const a1 = touches[0].clientX;
    const a2 = touches[1].clientX;
    const y1 = origins[0].normalY;
    const y2 = origins[1].normalY;
    const b1 = Ry + Rh - touches[0].clientY;
    const b2 = Ry + Rh - touches[1].clientY;
    return this.twitchTolerantZoomPan4(x1, x2, a1, a2, y1, y2, b1, b2, Rx, Ry, Rw, Rh);
  }
  end(event) {
    const identifiers = Array.from(event.sourceEvent.targetTouches).map((t) => t.identifier);
    return !identifiers.includes(this.touchStart.origins[0].identifier) || !identifiers.includes(this.touchStart.origins[1].identifier);
  }
  // Small touch deltas on an axis, which can defined as one fingers moving 1 pixel and the other not moving, can
  // cause the canvas to flicker between two zoompan views.
  //
  // For example, consider two fingers moving upwards slowly on the Y-axis with the following events (Y=0 is the top
  // of the screen):
  //
  //   [0]:  { finger1: { clientY: 101 }, finger2: { clientY: 201 } }
  //   [1]:  { finger1: { clientY: 101 }, finger2: { clientY: 200 } }
  //   [2]:  { finger1: { clientY: 100 }, finger2: { clientY: 200 } }
  //
  // The following transitions cause these changes to the zoompan respectively.
  //
  //   [0] => [1] : yMin decreases, yMax increases
  //   [1] => [2] : yMin increases, yMax decreases
  //
  // At highly-zoomed views, this sudden shift in yMin/yMax in the [1] => [2] transition is very noticeable. When many
  // of these kind of a transitions occur, the chart flickers between pan states instead of smoothly panning. Note
  // however that, if we didn't receive event [1], our transition would like this:
  //
  //   [0] => [2] : yMin increases, yMax increases
  //
  // ... which is a smooth panning transition. Therefore to prevent flickering, we skip event [1].
  twitchTolerantZoomPan4(x1, x2, a1, a2, y1, y2, b1, b2, Rx, Ry, Rw, Rh) {
    const { initialZoom, previous } = this;
    const x = twitchTolerantZoomPan2(x1, x2, a1, a2, previous, "a1", "a2", Rx, Rw, initialZoom.x);
    const y = twitchTolerantZoomPan2(y1, y2, b1, b2, previous, "b1", "b2", Ry, Rh, initialZoom.y);
    return { x, y };
  }
};
function twitchTolerantZoomPan2(x1, x2, a1, a2, previous, previousKey1, previousKey2, Rx, Rw, initialZoom) {
  if (x1 != x2) {
    const a1prev = previous[previousKey1];
    const a2prev = previous[previousKey2];
    const dx2 = Math.abs(a1 - a1prev) + Math.abs(a2 - a2prev);
    if (dx2 <= 1) {
      a1 = a1prev;
      a2 = a2prev;
    } else {
      previous[previousKey1] = a1;
      previous[previousKey2] = a2;
    }
    return solveTwoUnknowns(x1, x2, a1, a2, Rx, Rw);
  } else {
    const xn1 = clientToNormal(initialZoom, a1, Rx, Rw);
    const xn2 = clientToNormal(initialZoom, a2, Rx, Rw);
    const xavg = (xn1 + xn2) / 2;
    const dzoom = (x1 - xavg) / N;
    return { min: initialZoom.min + dzoom, max: initialZoom.max + dzoom };
  }
}
var { ActionOnSet: ActionOnSet9, ChartAxisDirection: ChartAxisDirection23, ChartUpdateType: ChartUpdateType3, Property: Property62, InteractionState: InteractionState5, ProxyProperty: ProxyProperty3 } = module_support_exports;
var round3 = (value) => roundTo(value, 10);
var CURSOR_ID = "zoom-cursor";
var TOOLTIP_ID = "zoom-tooltip";
var ZoomAutoScaling = class extends module_support_exports.BaseProperties {
  constructor(onChange) {
    super();
    this.onChange = onChange;
    this.enabled = false;
    this.padding = 0;
  }
};
__decorateClass2([
  Property62,
  ActionOnSet9({
    changeValue(enabled) {
      this.onChange({ enabled, padding: this.padding });
    }
  })
], ZoomAutoScaling.prototype, "enabled", 2);
__decorateClass2([
  Property62,
  ActionOnSet9({
    changeValue(padding2) {
      this.onChange({ enabled: this.enabled, padding: padding2 });
    }
  })
], ZoomAutoScaling.prototype, "padding", 2);
var Zoom = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.enableAxisDragging = true;
    this.enableAxisScrolling = false;
    this.enableDoubleClickToReset = true;
    this.enablePanning = true;
    this.enableScrolling = true;
    this.enableSelecting = false;
    this.enableTwoFingerZoom = true;
    this.panKey = "alt";
    this.axes = "x";
    this.scrollingStep = UNIT_SIZE / 10;
    this.keepAspectRatio = false;
    this.minVisibleItems = 2;
    this.anchorPointX = DEFAULT_ANCHOR_POINT_X;
    this.anchorPointY = DEFAULT_ANCHOR_POINT_Y;
    this.autoScaling = new ZoomAutoScaling((newValue) => {
      this.ctx.zoomManager.setAutoScaleYAxis(newValue.enabled, newValue.padding);
    });
    this.axisDraggingMode = "zoom";
    this.canResetZoom = (zoom) => {
      zoom ?? (zoom = this.getZoom());
      return !isZoomEqual(zoom, this.getResetZoom());
    };
    this.buttons = new ZoomToolbar(
      this.ctx,
      this.getModuleProperties.bind(this),
      this.canResetZoom,
      this.updateZoom.bind(this),
      this.updateAxisZoom.bind(this),
      this.resetZoom.bind(this),
      this.isZoomValid.bind(this)
    );
    this.axisDragger = new ZoomAxisDragger();
    this.panner = new ZoomPanner();
    this.scroller = new ZoomScroller();
    this.scrollPanner = new ZoomScrollPanner();
    this.twoFingers = new ZoomTwoFingers();
    this.deceleration = "short";
    this.dragState = 0;
    this.isState = (state) => this.ctx.interactionManager.isState(state);
    this.destroyContextMenuActions = void 0;
    this.isFirstWheelEvent = true;
    this.debouncedWheelReset = debounce(() => {
      this.isFirstWheelEvent = true;
    }, 100);
    const selectionRect = new ZoomRect();
    this.selector = new ZoomSelector(selectionRect, this.getZoom.bind(this), this.isZoomValid.bind(this));
    this.contextMenu = new ZoomContextMenu(
      ctx.eventsHub,
      ctx.contextMenuRegistry,
      ctx.zoomManager,
      this.getModuleProperties.bind(this),
      this.canResetZoom,
      () => this.paddedRect,
      this.updateZoom.bind(this),
      this.isZoomValid.bind(this)
    );
    this.domProxy = new ZoomDOMProxy({
      onAxisDragStart: (direction) => this.onAxisDragStart(direction),
      onAxisDragMove: (id, direction, event) => this.onAxisDragMove(id, direction, event),
      onAxisDragEnd: () => this.onAxisDragEnd(),
      onAxisDoubleClick: (id) => this.onAxisDoubleClick(id),
      onAxisWheel: (id, direction, event) => this.onAxisWheel(id, direction, event)
    });
    if (ctx.widgets.seriesDragInterpreter) {
      this.cleanup.register(
        ctx.widgets.seriesDragInterpreter.events.on("dblclick", (event) => this.onSeriesAreaDoubleClick(event)),
        ctx.widgets.seriesDragInterpreter.events.on("drag-move", (event) => this.onSeriesAreaDragMove(event)),
        ctx.widgets.seriesDragInterpreter.events.on("drag-start", (event) => this.onSeriesAreaDragStart(event)),
        ctx.widgets.seriesDragInterpreter.events.on("drag-end", () => this.onSeriesAreaDragEnd())
      );
    }
    this.cleanup.register(
      ctx.scene.attachNode(selectionRect),
      ctx.eventsHub.on("series:keynav-zoom", (event) => this.onNavZoom(event)),
      ctx.widgets.seriesWidget.addListener("wheel", (event) => this.onWheel(event)),
      ctx.widgets.seriesWidget.addListener("touchstart", (event, current) => this.onTouchStart(event, current)),
      ctx.widgets.seriesWidget.addListener("touchmove", (event, current) => this.onTouchMove(event, current)),
      ctx.widgets.seriesWidget.addListener("touchend", (event) => this.onTouchEnd(event)),
      ctx.widgets.seriesWidget.addListener("touchcancel", (event) => this.onTouchEnd(event)),
      ctx.updateService.addListener("process-data", (event) => this.onProcessData(event)),
      ctx.eventsHub.on("layout:complete", (event) => this.onLayoutComplete(event)),
      ctx.eventsHub.on("zoom:change", (event) => this.onZoomChange(event)),
      ctx.eventsHub.on("zoom:pan-start", (event) => this.onZoomPanStart(event)),
      this.panner.addListener("update", (event) => this.onPanUpdate(event)),
      () => this.teardown()
    );
  }
  teardown() {
    this.ctx.zoomManager.setZoomModuleEnabled(false);
    this.buttons.destroy();
    this.destroyContextMenuActions?.();
    this.domProxy.destroy();
  }
  onEnabledChange(enabled) {
    this.ctx.zoomManager.setZoomModuleEnabled(enabled);
    if (this.contextMenu) {
      this.destroyContextMenuActions?.();
      this.destroyContextMenuActions = this.contextMenu.registerActions(enabled);
    }
  }
  isIgnoredTouch(event) {
    if (event?.device !== "touch") {
      return false;
    }
    if (this.ctx.chartService.touch.dragAction !== "drag") {
      return true;
    }
    if (this.enableSelecting) {
      return false;
    }
    if (!this.enablePanning) {
      return true;
    }
    return isMaxZoom(this.getZoom());
  }
  onSeriesAreaDoubleClick(event) {
    const { enabled, enableDoubleClickToReset } = this;
    if (!enabled || !enableDoubleClickToReset)
      return;
    if (event?.preventZoomDblClick || !this.isState(InteractionState5.ZoomClickable))
      return;
    this.resetZoom();
  }
  onSeriesAreaDragStart(event) {
    const {
      enabled,
      enablePanning,
      enableSelecting,
      ctx: { domManager, zoomManager }
    } = this;
    if (!enabled || !this.isState(InteractionState5.ZoomDraggable) || this.dragState !== 0 || this.isIgnoredTouch(event)) {
      return;
    }
    this.panner.stopInteractions();
    let newDragState = 0;
    const panKeyPressed = this.isPanningKeyPressed(event.sourceEvent);
    if (enablePanning && (!enableSelecting || panKeyPressed)) {
      domManager.updateCursor(CURSOR_ID, "grabbing");
      newDragState = 2;
      this.panner.start();
    } else if (enableSelecting && !panKeyPressed) {
      newDragState = 3;
    }
    if ((this.dragState = newDragState) !== 0) {
      zoomManager.fireZoomPanStartEvent("zoom");
    }
  }
  onSeriesAreaDragMove(event) {
    const {
      dragState,
      enabled,
      paddedRect,
      panner,
      selector,
      ctx: { interactionManager, tooltipManager, updateService }
    } = this;
    if (!enabled || !paddedRect || !this.isState(InteractionState5.ZoomDraggable) || this.isIgnoredTouch(event)) {
      return;
    }
    interactionManager.pushState(module_support_exports.InteractionState.ZoomDrag);
    if (event.device === "touch") {
      event.sourceEvent.preventDefault();
    }
    switch (dragState) {
      case 2:
        panner.update(event);
        break;
      case 3:
        selector.update(event, this.getModuleProperties(), paddedRect);
        break;
      case 0:
        return;
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
    updateService.update(ChartUpdateType3.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onSeriesAreaDragEnd() {
    const {
      dragState,
      enabled,
      panner,
      selector,
      ctx: { domManager, interactionManager, tooltipManager }
    } = this;
    interactionManager.popState(module_support_exports.InteractionState.ZoomDrag);
    if (!enabled || dragState === 0)
      return;
    switch (dragState) {
      case 2:
        panner.stop();
        break;
      case 3: {
        if (!selector.didUpdate())
          break;
        const zoom = this.getZoom();
        const newZoom = selector.stop(this.seriesRect, this.paddedRect, zoom);
        this.updateZoom(newZoom);
        break;
      }
    }
    this.dragState = 0;
    domManager.updateCursor(CURSOR_ID);
    tooltipManager.removeTooltip(TOOLTIP_ID);
  }
  onAxisDoubleClick(id) {
    const {
      enabled,
      enableDoubleClickToReset,
      ctx: { zoomManager }
    } = this;
    if (!enabled || !enableDoubleClickToReset || !this.isState(InteractionState5.ZoomClickable))
      return;
    zoomManager.resetAxisZoom("zoom", id);
  }
  onAxisDragStart(direction) {
    const {
      axisDraggingMode,
      domProxy,
      enabled,
      enableAxisDragging,
      panner,
      ctx: { zoomManager }
    } = this;
    if (!enabled || !enableAxisDragging)
      return;
    panner.stopInteractions();
    if (axisDraggingMode === "pan") {
      domProxy.setAxisCursor("grabbing");
      this.dragState = 2;
      this.panner.start(direction);
      zoomManager.fireZoomPanStartEvent("zoom");
    } else {
      this.dragState = 1;
    }
  }
  onAxisDragMove(axisId, direction, event) {
    const {
      anchorPointX,
      anchorPointY,
      axisDragger,
      dragState,
      enabled,
      enableAxisDragging,
      seriesRect,
      shouldFlipXY,
      ctx: { interactionManager, tooltipManager, updateService, zoomManager }
    } = this;
    if (!enabled || !enableAxisDragging || !seriesRect)
      return;
    interactionManager.pushState(module_support_exports.InteractionState.ZoomDrag);
    if (event.device === "touch") {
      event.sourceEvent.preventDefault();
    }
    const zoom = this.getZoom();
    if (dragState === 2) {
      this.panner.update({ currentX: event.offsetX, currentY: event.offsetY });
    } else {
      let anchor = direction === ChartAxisDirection23.X ? anchorPointX : anchorPointY;
      if (shouldFlipXY)
        anchor = direction === ChartAxisDirection23.X ? anchorPointY : anchorPointX;
      const axisZoom = zoomManager.getAxisZoom(axisId);
      const newZoom = axisDragger.update(event, direction, anchor, seriesRect, zoom, axisZoom);
      zoomManager.setAxisManuallyAdjusted("zoom", axisId);
      this.updateAxisZoom(axisId, direction, newZoom);
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
    updateService.update(ChartUpdateType3.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onAxisDragEnd() {
    const {
      axisDraggingMode,
      axisDragger,
      dragState,
      domProxy,
      enabled,
      enableAxisDragging,
      ctx: { domManager, interactionManager, tooltipManager }
    } = this;
    interactionManager.popState(module_support_exports.InteractionState.ZoomDrag);
    if (!enabled || !enableAxisDragging || dragState === 0)
      return;
    this.dragState = 0;
    if (axisDraggingMode === "pan") {
      domProxy.setAxisCursor("grab");
      this.panner.stop();
    }
    axisDragger.stop();
    domManager.updateCursor(CURSOR_ID);
    tooltipManager.removeTooltip(TOOLTIP_ID);
  }
  onNavZoom(event) {
    const { enabled, enableScrolling, scroller } = this;
    const isDefaultState = this.ctx.interactionManager.isState(module_support_exports.InteractionState.Default);
    if (!isDefaultState || !enabled || !enableScrolling)
      return;
    event.widgetEvent.sourceEvent.preventDefault();
    this.updateZoom(scroller.updateDelta(event.delta, this.getModuleProperties(), this.getZoom()));
  }
  onWheel(event) {
    const { enabled, enablePanning, enableScrolling, paddedRect } = this;
    if (!enabled || !enableScrolling || !paddedRect || !this.isState(InteractionState5.ZoomWheelable))
      return;
    const { deltaX, deltaY } = event.sourceEvent;
    const isHorizontalScrolling = deltaX != null && deltaY != null && Math.abs(deltaX) > Math.abs(deltaY);
    if (enablePanning && isHorizontalScrolling) {
      this.onWheelPanning(event);
    } else {
      this.onWheelScrolling(event);
    }
  }
  onWheelPanning(event) {
    const {
      scrollingStep,
      scrollPanner,
      seriesRect,
      ctx: { zoomManager }
    } = this;
    if (!seriesRect)
      return;
    event.sourceEvent.preventDefault();
    const newZooms = scrollPanner.update(event, scrollingStep, seriesRect, zoomManager.getAxisZooms());
    for (const [axisId, { direction, zoom }] of entries(newZooms)) {
      this.updateAxisZoom(axisId, direction, zoom);
    }
  }
  onWheelScrolling(event) {
    const zoom = this.getZoom();
    const isZoomCapped = event.deltaY > 0 && isMaxZoom(zoom);
    this.handleWheelScrolling(event, isZoomCapped);
  }
  onAxisWheel(axisId, axisDirection, event) {
    const {
      enableAxisScrolling,
      ctx: { zoomManager }
    } = this;
    if (!enableAxisScrolling)
      return;
    if (axisDirection !== ChartAxisDirection23.X && axisDirection !== ChartAxisDirection23.Y) {
      return;
    }
    const isScalingX = axisDirection === ChartAxisDirection23.X;
    const isScalingY = !isScalingX;
    const props = this.getModuleProperties({ isScalingX, isScalingY });
    const zoom = this.getZoom();
    const isZoomCapped = event.deltaY > 0 && zoom[axisDirection].min === UNIT_MIN && zoom[axisDirection].max === UNIT_MAX;
    zoomManager.setAxisManuallyAdjusted("zoom", axisId);
    this.handleWheelScrolling(event, isZoomCapped, props);
  }
  handleWheelScrolling(event, isZoomCapped, props = this.getModuleProperties()) {
    const {
      enableIndependentAxes,
      scroller,
      seriesRect,
      ctx: { zoomManager }
    } = this;
    if (!seriesRect)
      return;
    let updated = true;
    if (enableIndependentAxes === true) {
      const newZooms = scroller.updateAxes(event, props, seriesRect, zoomManager.getAxisZooms());
      for (const [axisId, { direction, zoom: axisZoom }] of entries(newZooms)) {
        updated && (updated = this.updateAxisZoom(axisId, direction, axisZoom));
      }
    } else {
      const newZoom = scroller.update(event, props, seriesRect, this.getZoom());
      if (newZoom == null)
        return;
      updated = this.updateUnifiedZoom(newZoom);
    }
    isZoomCapped || (isZoomCapped = event.deltaY < 0 && !updated);
    if (!this.isFirstWheelEvent || !isZoomCapped) {
      event.sourceEvent.preventDefault();
    }
    this.isFirstWheelEvent = false;
    this.debouncedWheelReset();
  }
  onTouchStart(event, current) {
    if (!this.enableTwoFingerZoom || this.dragState !== 0)
      return;
    if (this.twoFingers.start(event, current, this.getZoom())) {
      this.dragState = 4;
    }
  }
  onTouchMove(event, current) {
    if (!this.enableTwoFingerZoom || this.dragState !== 4)
      return;
    const newZoom = this.twoFingers.update(event, current);
    this.updateZoom(constrainZoom(newZoom));
  }
  onTouchEnd(event) {
    if (!this.enableTwoFingerZoom || this.dragState !== 4)
      return;
    event.sourceEvent.preventDefault();
    if (this.twoFingers.end(event)) {
      this.dragState = 0;
    }
  }
  onProcessData(event) {
    this.shouldFlipXY = event.series.shouldFlipXY;
  }
  onLayoutComplete(event) {
    this.domProxy.update(this.enableAxisDragging, this.enableAxisScrolling, this.ctx);
    if (!this.enabled)
      return;
    this.seriesRect = event.series.rect;
    this.paddedRect = event.series.paddedRect;
    if (this.enableAxisDragging) {
      this.toggleAxisDraggingCursors();
    }
  }
  onZoomChange(event) {
    if (event.callerId !== "zoom") {
      this.panner.stopInteractions();
    }
    const zoom = this.getZoom();
    this.buttons.toggleVisibleZoomed(isMaxZoom(zoom));
  }
  onZoomPanStart(event) {
    if (event.callerId === "zoom") {
      this.panner.stopInteractions();
    }
  }
  onPanUpdate(event) {
    const {
      panner,
      seriesRect,
      ctx: { tooltipManager, zoomManager }
    } = this;
    if (!seriesRect)
      return;
    const newZooms = panner.translateZooms(seriesRect, zoomManager.getAxisZooms(), event.deltaX, event.deltaY);
    for (const [axisId, { direction, zoom }] of entries(newZooms)) {
      this.updateAxisZoom(axisId, direction, zoom);
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
  }
  isPanningKeyPressed(event) {
    switch (this.panKey) {
      case "alt":
        return event.altKey;
      case "ctrl":
        return event.ctrlKey;
      case "shift":
        return event.shiftKey;
      case "meta":
        return event.metaKey;
    }
  }
  isScalingX() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "y" : this.axes === "x";
  }
  isScalingY() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "x" : this.axes === "y";
  }
  getAnchorPointX() {
    return this.shouldFlipXY ? this.anchorPointY : this.anchorPointX;
  }
  getAnchorPointY() {
    return this.shouldFlipXY ? this.anchorPointX : this.anchorPointY;
  }
  isZoomValid(newZoom) {
    const {
      minVisibleItems,
      ctx: { zoomManager }
    } = this;
    if (minVisibleItems === 0)
      return true;
    const zoom = this.getZoom();
    const zoomedInX = round3(dx(newZoom)) < round3(dx(zoom));
    const zoomedInY = round3(dy(newZoom)) < round3(dy(zoom));
    if (!zoomedInX && !zoomedInY)
      return true;
    return zoomManager.isVisibleItemsCountAtLeast(newZoom, minVisibleItems);
  }
  isAxisZoomValid(direction, axisZoom) {
    const {
      minVisibleItems,
      ctx: { zoomManager }
    } = this;
    const zoom = this.getZoom();
    const deltaAxis = axisZoom.max - axisZoom.min;
    const deltaOld = zoom[direction].max - zoom[direction].min;
    const newZoom = { ...zoom, [direction]: axisZoom };
    return deltaAxis >= deltaOld || zoomManager.isVisibleItemsCountAtLeast(newZoom, minVisibleItems);
  }
  resetZoom() {
    this.ctx.zoomManager.resetZoom("zoom");
  }
  updateSyncZoom(zoom) {
    this.updateZoom(zoom);
  }
  updateZoom(zoom) {
    if (this.enableIndependentAxes) {
      this.updatePrimaryAxisZooms(zoom);
    } else {
      this.updateUnifiedZoom(zoom);
    }
  }
  updateUnifiedZoom(zoom) {
    if (!this.isZoomValid(zoom)) {
      this.ctx.updateService.update(ChartUpdateType3.SCENE_RENDER, { skipAnimations: true });
      return false;
    }
    this.ctx.zoomManager.updateZoom("zoom", zoom);
    return true;
  }
  updatePrimaryAxisZooms(zoom) {
    this.updatePrimaryAxisZoom(zoom, ChartAxisDirection23.X);
    this.updatePrimaryAxisZoom(zoom, ChartAxisDirection23.Y);
  }
  updatePrimaryAxisZoom(zoom, direction) {
    const axisId = this.ctx.zoomManager.getPrimaryAxisId(direction);
    if (axisId == null)
      return;
    this.updateAxisZoom(axisId, direction, zoom[direction]);
  }
  updateAxisZoom(axisId, direction, axisZoom) {
    const {
      enableIndependentAxes,
      ctx: { zoomManager }
    } = this;
    if (!axisZoom)
      return false;
    const zoom = this.getZoom();
    if (enableIndependentAxes !== true) {
      zoom[direction] = axisZoom;
      return this.updateUnifiedZoom(zoom);
    }
    if (!this.isAxisZoomValid(direction, axisZoom))
      return false;
    zoomManager.updateAxisZoom("zoom", axisId, axisZoom);
    return true;
  }
  updateAxisCursor(opts) {
    if (!this.domProxy)
      return;
    const {
      enableAxisDragging = this.enableAxisDragging,
      enableAxisScrolling = this.enableAxisScrolling,
      axisDraggingMode = this.axisDraggingMode
    } = opts;
    if (enableAxisDragging) {
      this.domProxy.setAxisCursor(axisDraggingMode === "pan" ? "grab" : void 0);
    } else if (enableAxisScrolling) {
      this.domProxy.setAxisCursor("default");
    } else {
      this.domProxy.setAxisCursor(void 0);
    }
  }
  toggleAxisDraggingCursors() {
    const { anchorPointX, anchorPointY, domProxy } = this;
    const zoom = this.getZoom();
    let showCursorX = dx(zoom) !== UNIT_SIZE;
    let showCursorY = dy(zoom) !== UNIT_SIZE;
    if (!showCursorX) {
      const checkZoomX = scaleZoom(zoom, 0.999, 1);
      checkZoomX.x = scaleZoomAxisWithAnchor(checkZoomX.x, zoom.x, anchorPointX);
      showCursorX = this.isZoomValid(checkZoomX);
    }
    if (!showCursorY) {
      const checkZoomY = scaleZoom(zoom, 1, 0.999);
      checkZoomY.y = scaleZoomAxisWithAnchor(checkZoomY.y, zoom.y, anchorPointY);
      showCursorY = this.isZoomValid(checkZoomY);
    }
    domProxy.toggleAxisDraggingCursor(ChartAxisDirection23.X, showCursorX);
    domProxy.toggleAxisDraggingCursor(ChartAxisDirection23.Y, showCursorY);
  }
  getZoom() {
    return definedZoomState(this.ctx.zoomManager.getZoom());
  }
  getResetZoom() {
    return definedZoomState(this.ctx.zoomManager.getRestoredZoom());
  }
  getModuleProperties(overrides) {
    return {
      anchorPointX: overrides?.anchorPointX ?? this.getAnchorPointX(),
      anchorPointY: overrides?.anchorPointY ?? this.getAnchorPointY(),
      enabled: overrides?.enabled ?? this.enabled,
      independentAxes: overrides?.independentAxes ?? this.enableIndependentAxes === true,
      isScalingX: overrides?.isScalingX ?? this.isScalingX(),
      isScalingY: overrides?.isScalingY ?? this.isScalingY(),
      keepAspectRatio: overrides?.keepAspectRatio ?? this.keepAspectRatio,
      scrollingStep: overrides?.scrollingStep ?? this.scrollingStep
    };
  }
};
__decorateClass2([
  ActionOnSet9({
    newValue(enabled) {
      this.onEnabledChange(enabled);
    }
  }),
  Property62
], Zoom.prototype, "enabled", 2);
__decorateClass2([
  ActionOnSet9({
    changeValue(newValue) {
      this.updateAxisCursor({ enableAxisDragging: newValue });
    }
  }),
  Property62
], Zoom.prototype, "enableAxisDragging", 2);
__decorateClass2([
  ActionOnSet9({
    changeValue(newValue) {
      this.updateAxisCursor({ enableAxisScrolling: newValue });
    }
  }),
  Property62
], Zoom.prototype, "enableAxisScrolling", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "enableDoubleClickToReset", 2);
__decorateClass2([
  ActionOnSet9({
    changeValue(newValue) {
      this.ctx.zoomManager.setIndependentAxes(Boolean(newValue));
    }
  }),
  Property62
], Zoom.prototype, "enableIndependentAxes", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "enablePanning", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "enableScrolling", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "enableSelecting", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "enableTwoFingerZoom", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "panKey", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "axes", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "scrollingStep", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "keepAspectRatio", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "minVisibleItems", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "anchorPointX", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "anchorPointY", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "autoScaling", 2);
__decorateClass2([
  ActionOnSet9({
    changeValue(newValue) {
      this.updateAxisCursor({ axisDraggingMode: newValue });
    }
  }),
  Property62
], Zoom.prototype, "axisDraggingMode", 2);
__decorateClass2([
  Property62
], Zoom.prototype, "buttons", 2);
__decorateClass2([
  ProxyProperty3("panner.deceleration"),
  Property62
], Zoom.prototype, "deceleration", 2);
var buttons = {
  enabled: true,
  visible: "hover",
  buttons: [
    {
      icon: "zoom-out",
      value: "zoom-out",
      section: "scale"
    },
    {
      icon: "zoom-in",
      value: "zoom-in",
      section: "scale"
    },
    {
      icon: "pan-left",
      value: "pan-left",
      section: "pan"
    },
    {
      icon: "pan-right",
      value: "pan-right",
      section: "pan"
    },
    {
      icon: "reset",
      value: "reset",
      section: "reset"
    }
  ]
};
var ZoomModule = {
  type: "root",
  optionsKey: "zoom",
  packageType: "enterprise",
  chartTypes: ["cartesian", "topology"],
  moduleFactory: (ctx) => new Zoom(ctx),
  themeTemplate: {
    zoom: {
      anchorPointX: "end",
      anchorPointY: "middle",
      axes: "x",
      buttons,
      enabled: false,
      enableAxisDragging: true,
      enableDoubleClickToReset: true,
      enablePanning: true,
      enableScrolling: true,
      enableSelecting: false,
      enableTwoFingerZoom: true,
      deceleration: "short",
      minVisibleItems: 2,
      panKey: "alt",
      scrollingStep: 0.1,
      autoScaling: {
        enabled: { $eq: [{ $path: "../axes" }, "x"] },
        padding: 0.05
      }
    }
  }
};
function formatWithContext(ctx, formatter2, params) {
  return module_support_exports.callWithContext(ctx.chartService, formatter2, params);
}
var {
  AxisInterval: AxisInterval22,
  AxisLabel: AxisLabel22,
  ZIndexMap: ZIndexMap9,
  LinearScale: LinearScale3,
  BBox: BBox14,
  TranslatableGroup: TranslatableGroup4,
  Selection: Selection5,
  Text: Text22,
  CachedTextMeasurerPool: CachedTextMeasurerPool4,
  createIdsGenerator: createIdsGenerator2,
  findMinMax: findMinMax5,
  findRangeExtent: findRangeExtent2,
  estimateTickCount: estimateTickCount2
} = module_support_exports;
var _AxisTicks = class _AxisTicks2 {
  constructor(ctx, dataProvider) {
    this.ctx = ctx;
    this.dataProvider = dataProvider;
    this.id = createId(this);
    this.axisGroup = new TranslatableGroup4({ name: `${this.id}-AxisTicks`, zIndex: ZIndexMap9.AXIS });
    this.labelSelection = Selection5.select(this.axisGroup, Text22);
    this.interval = new AxisInterval22();
    this.label = new AxisLabel22();
    this.scale = new LinearScale3();
    this.placement = "bottom";
    this.translationX = 0;
    this.translationY = 0;
    this.padding = 0;
  }
  get horizontal() {
    return this.placement.startsWith("top") || this.placement.startsWith("bottom");
  }
  attachAxis(axisNode) {
    axisNode.appendChild(this.axisGroup);
  }
  calculateLayout() {
    const { placement, translationX, translationY, horizontal, label } = this;
    function unreachable(_a) {
      return void 0;
    }
    let textBaseline;
    let textAlign;
    switch (placement) {
      case "top":
      case "top-right":
      case "top-left":
        textBaseline = "bottom";
        textAlign = "center";
        label.mirrored = false;
        label.parallel = true;
        break;
      case "bottom":
      case "bottom-right":
      case "bottom-left":
        textBaseline = "top";
        textAlign = "center";
        label.mirrored = false;
        label.parallel = true;
        break;
      case "right":
      case "right-top":
      case "right-bottom":
      case "left":
      case "left-top":
      case "left-bottom":
        textBaseline = "middle";
        textAlign = "left";
        label.mirrored = true;
        label.parallel = false;
        break;
      default:
        unreachable(placement);
    }
    const boxes = [];
    const tickGenerationResult = this.generateTicks();
    const { ticks } = tickGenerationResult;
    this.labelSelection.update(ticks, void 0, (datum) => datum.tickId);
    this.axisGroup.setProperties({ translationX, translationY });
    this.labelSelection.each((node, datum) => {
      node.fontFamily = label.fontFamily;
      node.fontSize = label.fontSize;
      node.fontStyle = label.fontStyle;
      node.fontWeight = label.fontWeight;
      node.fill = label.color;
      node.textBaseline = textBaseline;
      node.textAlign = textAlign;
      node.text = datum.tickLabel;
      node.x = horizontal ? datum.translation : 0;
      node.y = horizontal ? 0 : datum.translation;
      boxes.push(node.getBBox());
    });
    return boxes.length > 0 ? BBox14.merge(boxes).translate(translationX, translationY) : void 0;
  }
  tickFormatter(domain, _ticks, _primary, fractionDigits) {
    const { ctx } = this;
    const { formatManager } = ctx;
    const boundSeries = this.dataProvider.data.flatMap((d) => d.series);
    return (value, index) => {
      const formatParams = {
        type: "number",
        value,
        datum: void 0,
        seriesId: void 0,
        legendItemName: void 0,
        key: void 0,
        source: "gradient-legend",
        property: "color",
        domain,
        boundSeries,
        fractionDigits
      };
      return this.label.formatValue((fn, params) => formatWithContext(ctx, fn, params), formatParams, index) ?? formatManager.format((fn, params) => formatWithContext(ctx, fn, params), formatParams) ?? formatManager.defaultFormat(formatParams);
    };
  }
  inRange(x, tolerance = 1e-3) {
    const [min, max] = findMinMax5(this.scale.range);
    return x >= min - tolerance && x <= max + tolerance;
  }
  generateTicks() {
    const { minSpacing, maxSpacing } = this.interval;
    const { maxTickCount, minTickCount, tickCount } = estimateTickCount2(
      findRangeExtent2(this.scale.range),
      1,
      minSpacing,
      maxSpacing,
      _AxisTicks2.DefaultTickCount,
      _AxisTicks2.DefaultMinSpacing
    );
    const tickData = this.getTicksData({
      nice: true,
      interval: this.interval.step,
      tickCount,
      minTickCount,
      maxTickCount
    });
    if (this.placement === "bottom" || this.placement === "top") {
      const measurer22 = CachedTextMeasurerPool4.getMeasurer({ font: this.label });
      const { domain } = this.scale;
      const reversed = domain[0] > domain[1];
      const direction = reversed ? -1 : 1;
      let lastTickPosition = -Infinity * direction;
      tickData.ticks = tickData.ticks.filter((data) => {
        if (Math.sign(data.translation - lastTickPosition) !== direction)
          return false;
        lastTickPosition = data.translation + measurer22.textWidth(data.tickLabel, true) * direction;
        return true;
      });
    }
    return tickData;
  }
  getTicksData(tickParams) {
    const ticks = [];
    const domain = tickParams.nice ? this.scale.niceDomain(tickParams) : this.scale.domain;
    const rawTicks = this.scale.ticks(tickParams, domain)?.ticks ?? [];
    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);
    const idGenerator = createIdsGenerator2();
    const tickFormatter = this.tickFormatter(domain, rawTicks, false, fractionDigits);
    for (let index = 0; index < rawTicks.length; index++) {
      const tick = rawTicks[index];
      const translation = this.scale.convert(tick);
      if (!this.inRange(translation))
        continue;
      const tickLabel = tickFormatter(tick, index);
      if (tickLabel == null || tickLabel === "")
        continue;
      const tickId = idGenerator(tickLabel);
      ticks.push({ tick, tickId, tickLabel, translation });
    }
    return { rawTicks, fractionDigits, ticks };
  }
};
_AxisTicks.DefaultTickCount = 5;
_AxisTicks.DefaultMinSpacing = 10;
var AxisTicks = _AxisTicks;
var {
  BaseProperties: BaseProperties222,
  ZIndexMap: ZIndexMap10,
  ProxyProperty: ProxyProperty4,
  Property: Property63,
  LayoutElement: LayoutElement5,
  Group: Group8,
  Rect: Rect6,
  Marker: Marker22,
  TranslatableGroup: TranslatableGroup5,
  BBox: BBox15,
  expandLegendPosition: expandLegendPosition2
} = module_support_exports;
var GradientBar = class extends BaseProperties222 {
  constructor() {
    super(...arguments);
    this.thickness = 16;
    this.preferredLength = 100;
  }
};
__decorateClass2([
  Property63
], GradientBar.prototype, "thickness", 2);
__decorateClass2([
  Property63
], GradientBar.prototype, "preferredLength", 2);
var GradientLegendScale = class extends module_support_exports.BaseProperties {
  constructor(axisTicks) {
    super();
    this.axisTicks = axisTicks;
  }
};
__decorateClass2([
  ProxyProperty4("axisTicks.label")
], GradientLegendScale.prototype, "label", 2);
__decorateClass2([
  ProxyProperty4("axisTicks.interval")
], GradientLegendScale.prototype, "interval", 2);
__decorateClass2([
  ProxyProperty4("axisTicks.padding")
], GradientLegendScale.prototype, "padding", 2);
var fillGradientDefaults3 = {
  type: "gradient",
  bounds: "item",
  gradient: "linear",
  colorStops: [{ color: "black" }],
  rotation: 0,
  reverse: false
};
var fillPatternDefaults3 = {
  type: "pattern",
  pattern: "forward-slanted-lines",
  width: 8,
  height: 8,
  padding: 1,
  fill: "black",
  fillOpacity: 1,
  backgroundFill: "white",
  backgroundFillOpacity: 1,
  stroke: "black",
  strokeOpacity: 1,
  strokeWidth: 1,
  rotation: 0,
  scale: 1
};
var fillImageDefaults3 = {
  type: "image",
  backgroundFill: "black",
  backgroundFillOpacity: 1,
  rotation: 0,
  repeat: "no-repeat",
  fit: "contain",
  width: 8,
  height: 8
};
var GradientLegend = class extends module_support_exports.BaseProperties {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId(this);
    this.legendGroup = new TranslatableGroup5({ name: "legend", zIndex: ZIndexMap10.LEGEND });
    this.containerNode = this.legendGroup.appendChild(new Rect6({ name: "legend-container" }));
    this.gradientRect = new Rect6();
    this.arrow = new Marker22({ shape: "triangle" });
    this.ticksGroup = new Group8({ name: "legend-axis-group" });
    this.cleanup = new CleanupRegistry();
    this.enabled = false;
    this.position = "bottom";
    this.reverseOrder = false;
    this.gradient = new GradientBar();
    this.spacing = 20;
    this.border = new module_support_exports.Border(this.containerNode);
    this.cornerRadius = 0;
    this.fillOpacity = 1;
    this.padding = 4;
    this.data = [];
    this.highlightManager = ctx.highlightManager;
    this.axisTicks = new AxisTicks(ctx, this);
    this.axisTicks.attachAxis(this.ticksGroup);
    this.scale = new GradientLegendScale(this.axisTicks);
    this.legendGroup.append([this.gradientRect, this.arrow, this.ticksGroup]);
    this.cleanup.register(
      ctx.eventsHub.on("highlight:change", () => this.onChartHoverChange()),
      ctx.layoutManager.registerElement(LayoutElement5.Legend, (e) => this.onStartLayout(e)),
      () => this.legendGroup.remove()
    );
  }
  isVertical() {
    const { placement } = expandLegendPosition2(this.position);
    return placement.startsWith("right") || placement.startsWith("left");
  }
  destroy() {
    this.cleanup.flush();
  }
  attachLegend(scene) {
    scene.appendChild(this.legendGroup);
  }
  onStartLayout(ctx) {
    const [data] = this.data;
    if (!this.enabled || !data?.enabled || data.legendType !== "gradient") {
      this.legendGroup.visible = false;
      return;
    }
    const { colorRange } = this.normalizeColorArrays(data);
    const gradientRectBBox = this.updateGradientRect(ctx.layoutBox, colorRange);
    const axisBBox = this.updateAxis(data, gradientRectBBox) ?? new BBox15(0, 0, 0, 0);
    const legendBBox = BBox15.merge([gradientRectBBox, axisBBox]);
    const { strokeWidth, padding: padding2 } = this.getContainerStyles();
    legendBBox.grow(padding2).grow(strokeWidth);
    const { left, top } = this.getMeasurements(ctx.layoutBox, legendBBox);
    this.updateContainer(legendBBox);
    this.updateArrow();
    this.legendGroup.visible = true;
    this.legendGroup.translationX = left;
    this.legendGroup.translationY = top;
  }
  normalizeColorArrays(data) {
    let colorDomain = data.colorDomain.slice();
    const colorRange = data.colorRange.slice();
    if (colorDomain.length === colorRange.length) {
      return { colorDomain, colorRange };
    }
    if (colorDomain.length > colorRange.length) {
      colorRange.splice(colorDomain.length);
    }
    const [d0, d1] = colorDomain;
    const count = colorRange.length;
    colorDomain = colorRange.map((_, i) => {
      if (i === 0) {
        return d0;
      } else if (i === count - 1) {
        return d1;
      }
      return d0 + (d1 - d0) * i / (count - 1);
    });
    return { colorDomain, colorRange };
  }
  updateGradientRect(shrinkRect, colorRange) {
    const { gradientRect, gradient: gradient2 } = this;
    const { preferredLength, thickness } = gradient2;
    const gradientRectBBox = new BBox15(0, 0, 0, 0);
    let angle2;
    if (this.isVertical()) {
      angle2 = 0;
      gradientRectBBox.width = thickness;
      gradientRectBBox.height = Math.min(shrinkRect.height, preferredLength);
    } else {
      angle2 = 90;
      gradientRectBBox.width = Math.min(shrinkRect.width, preferredLength);
      gradientRectBBox.height = thickness;
    }
    gradientRect.x = gradientRectBBox.x;
    gradientRect.y = gradientRectBBox.y;
    gradientRect.width = gradientRectBBox.width;
    gradientRect.height = gradientRectBBox.height;
    gradientRect.fill = {
      type: "gradient",
      gradient: "linear",
      colorSpace: "oklch",
      colorStops: colorRange.map((color6, i) => ({
        stop: i / (colorRange.length - 1),
        color: color6
      })),
      rotation: angle2
    };
    return gradientRectBBox;
  }
  updateAxis(data, gradientRectBBox) {
    const { axisTicks, gradient: gradient2, scale: scale2 } = this;
    const { placement } = expandLegendPosition2(this.position);
    const vertical = this.isVertical();
    const positiveAxis = this.reverseOrder !== vertical;
    axisTicks.placement = placement;
    const offset = gradient2.thickness + (scale2.padding ?? 0);
    axisTicks.translationX = vertical ? offset : gradientRectBBox.x;
    axisTicks.translationY = vertical ? gradientRectBBox.y : offset;
    axisTicks.scale.domain = positiveAxis ? data.colorDomain.slice().reverse() : data.colorDomain;
    axisTicks.scale.range = vertical ? [gradientRectBBox.x, gradientRectBBox.height] : [gradientRectBBox.y, gradientRectBBox.width];
    return axisTicks.calculateLayout();
  }
  updateContainer(bbox) {
    const containerStyles = this.getContainerStyles();
    module_support_exports.applyShapeStyle(this.containerNode, containerStyles);
    this.containerNode.cornerRadius = containerStyles.cornerRadius;
    this.containerNode.x = bbox.x;
    this.containerNode.y = bbox.y;
    this.containerNode.width = bbox.width;
    this.containerNode.height = bbox.height;
  }
  updateArrow() {
    const highlighted = this.highlightManager.getActiveHighlight();
    const { arrow } = this;
    if (highlighted?.colorValue == null) {
      arrow.visible = false;
      return;
    }
    const { scale: scale2, label } = this.axisTicks;
    const size = label.fontSize ?? 0;
    const t = scale2.convert(highlighted.colorValue);
    let { x, y } = this.gradientRect;
    let rotation = Math.PI;
    if (this.isVertical()) {
      x -= size / 2;
      y += t;
      rotation /= 2;
    } else {
      x += t;
      y -= size / 2;
    }
    arrow.visible = true;
    arrow.fill = label.color;
    arrow.rotation = rotation;
    arrow.size = size;
    arrow.translationX = x;
    arrow.translationY = y;
  }
  getMeasurements(shrinkRect, legendBBox) {
    function unreachable(_a) {
      return void 0;
    }
    let { x: left, y: top } = shrinkRect;
    const { width: width2, height: height2 } = legendBBox;
    const { placement, floating, xOffset, yOffset } = expandLegendPosition2(this.position);
    const containerStyles = this.getContainerStyles();
    left += containerStyles.strokeWidth + containerStyles.padding.left;
    top += containerStyles.strokeWidth + containerStyles.padding.top;
    switch (placement) {
      case "left":
        top += shrinkRect.height / 2 - height2 / 2;
        break;
      case "right":
        left += shrinkRect.width - width2;
        top += shrinkRect.height / 2 - height2 / 2;
        break;
      case "top":
        left += shrinkRect.width / 2 - width2 / 2;
        break;
      case "bottom":
        left += shrinkRect.width / 2 - width2 / 2;
        top += shrinkRect.height - height2;
        break;
      case "right-top":
      case "top-right":
        left += shrinkRect.width - width2;
        break;
      case "right-bottom":
      case "bottom-right":
        left += shrinkRect.width - width2;
        top += shrinkRect.height - height2;
        break;
      case "left-bottom":
      case "bottom-left":
        top += shrinkRect.height - height2;
        break;
      case "left-top":
      case "top-left":
        break;
      default:
        unreachable(placement);
    }
    if (!floating) {
      switch (placement) {
        case "left":
        case "left-top":
        case "left-bottom":
          shrinkRect.shrink(width2 + this.spacing, "left");
          break;
        case "right":
        case "right-top":
        case "right-bottom":
          shrinkRect.shrink(width2 + this.spacing, "right");
          break;
        case "top":
        case "top-left":
        case "top-right":
          shrinkRect.shrink(height2 + this.spacing, "top");
          break;
        case "bottom":
        case "bottom-left":
        case "bottom-right":
          shrinkRect.shrink(height2 + this.spacing, "bottom");
          break;
        default:
          unreachable(placement);
      }
    }
    left += xOffset;
    top += yOffset;
    return { top, left };
  }
  getContainerStyles() {
    const { stroke: stroke22, strokeOpacity, strokeWidth } = this.border;
    const { cornerRadius, fill, fillOpacity, padding: padding2 } = this;
    const isPaddingNumber = typeof padding2 === "number";
    return module_support_exports.getShapeStyle(
      {
        cornerRadius,
        fill,
        fillOpacity,
        padding: {
          top: isPaddingNumber ? padding2 : padding2.top ?? 0,
          right: isPaddingNumber ? padding2 : padding2.right ?? 0,
          bottom: isPaddingNumber ? padding2 : padding2.bottom ?? 0,
          left: isPaddingNumber ? padding2 : padding2.left ?? 0
        },
        stroke: stroke22,
        strokeOpacity,
        strokeWidth: this.border.enabled ? strokeWidth : 0
      },
      fillGradientDefaults3,
      fillPatternDefaults3,
      fillImageDefaults3
    );
  }
  onChartHoverChange() {
    if (!this.enabled)
      return;
    this.updateArrow();
  }
};
GradientLegend.className = "GradientLegend";
__decorateClass2([
  Property63
], GradientLegend.prototype, "enabled", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "position", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "reverseOrder", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "gradient", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "spacing", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "border", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "cornerRadius", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "fill", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "fillOpacity", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "padding", 2);
__decorateClass2([
  Property63
], GradientLegend.prototype, "scale", 2);
var GradientLegendModule = {
  type: "legend",
  optionsKey: "gradientLegend",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "topology", "standalone"],
  identifier: "gradient",
  moduleFactory: (ctx) => new GradientLegend(ctx),
  themeTemplate: {
    enabled: false,
    position: "bottom",
    spacing: 20,
    scale: {
      padding: 13,
      label: {
        color: { $ref: "textColor" },
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        minSpacing: 5
      },
      interval: {
        minSpacing: 15
      }
    },
    gradient: {
      preferredLength: 100,
      thickness: 16
    },
    reverseOrder: false
  },
  removable: "standalone-only"
};
function injectWatermark(domManager, text2) {
  const element2 = domManager.addChild("canvas-overlay", "watermark");
  const textElement = createElement("span");
  textElement.innerText = text2;
  element2.addEventListener("animationend", () => {
    domManager.removeChild("canvas-overlay", "watermark");
    domManager.removeStyles("watermark");
  });
  element2.classList.add("ag-watermark");
  element2.appendChild(textElement);
}
var {
  ordinalTimeAxisOptionsDefs: ordinalTimeAxisOptionsDefs2,
  angleNumberAxisOptionsDefs: angleNumberAxisOptionsDefs2,
  angleCategoryAxisOptionsDefs: angleCategoryAxisOptionsDefs2,
  radiusNumberAxisOptionsDefs: radiusNumberAxisOptionsDefs2,
  radiusCategoryAxisOptionsDefs: radiusCategoryAxisOptionsDefs2
} = module_support_exports;
var OrdinalTimeAxisModule2 = {
  type: "axis",
  name: "ordinal-time",
  chartType: "cartesian",
  enterprise: true,
  options: ordinalTimeAxisOptionsDefs2,
  create: (ctx) => new OrdinalTimeAxis(ctx)
};
var AngleNumberAxisModule2 = {
  type: "axis",
  name: "angle-number",
  chartType: "polar",
  enterprise: true,
  options: angleNumberAxisOptionsDefs2,
  create: (ctx) => new AngleNumberAxis(ctx)
};
var AngleCategoryAxisModule2 = {
  type: "axis",
  name: "angle-category",
  chartType: "polar",
  enterprise: true,
  options: angleCategoryAxisOptionsDefs2,
  create: (ctx) => new AngleCategoryAxis(ctx)
};
var RadiusNumberAxisModule2 = {
  type: "axis",
  name: "radius-number",
  chartType: "polar",
  enterprise: true,
  options: radiusNumberAxisOptionsDefs2,
  create: (ctx) => new RadiusNumberAxis(ctx)
};
var RadiusCategoryAxisModule2 = {
  type: "axis",
  name: "radius-category",
  chartType: "polar",
  enterprise: true,
  options: radiusCategoryAxisOptionsDefs2,
  create: (ctx) => new RadiusCategoryAxis(ctx)
};
var { Chart: Chart2 } = module_support_exports;
var StandaloneChart = class extends Chart2 {
  getChartType() {
    return "standalone";
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone().shrink(this.modulesManager.getModule("seriesArea").getPadding());
    this.seriesRect = seriesRect;
    this.animationRect = seriesRect;
    for (const group of [seriesRoot, annotationRoot]) {
      group.translationX = Math.floor(seriesRect.x);
      group.translationY = Math.floor(seriesRect.y);
    }
    seriesRoot.visible = this.series[0].visible;
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  getAriaLabel() {
    const seriesType = this.series[0]?.type;
    if (seriesType == null)
      return "";
    const caption = this.getCaptionText();
    switch (seriesType) {
      case "radial-gauge":
      case "linear-gauge": {
        const captions = [];
        if (caption.length !== 0) {
          captions.push(caption);
        }
        for (const series of this.series) {
          captions.push(series.getCaptionText());
        }
        return this.ctx.localeManager.t("ariaAnnounceGaugeChart", { caption: captions.join(". ") });
      }
      case "treemap":
      case "sunburst":
        return this.ctx.localeManager.t("ariaAnnounceHierarchyChart", { caption });
      default: {
        return this.ctx.localeManager.t("ariaAnnounceStandaloneChart", { caption });
      }
    }
  }
};
StandaloneChart.className = "StandaloneChart";
StandaloneChart.type = "standalone";
var { isAgStandaloneChartOptions: isAgStandaloneChartOptions2, standaloneChartOptionsDefs: standaloneChartOptionsDefs2 } = module_support_exports;
var StandaloneChartModule2 = {
  type: "chart",
  name: "standalone",
  enterprise: true,
  options: standaloneChartOptionsDefs2,
  detect: isAgStandaloneChartOptions2,
  create(options, resources) {
    return new StandaloneChart(options, resources);
  }
};
var { Chart: Chart22, MercatorScale: MercatorScale2, NumberAxis: NumberAxis2, Property: Property64 } = module_support_exports;
function isTopologySeries(series) {
  return series.type === "map-shape" || series.type === "map-line" || series.type === "map-marker" || series.type === "map-shape-background" || series.type === "map-line-background";
}
var TopologyChart = class extends Chart22 {
  constructor(options, resources) {
    super(options, resources);
    this.xAxis = new NumberAxis2(this.getModuleContext());
    this.xAxis.position = "bottom";
    this.yAxis = new NumberAxis2(this.getModuleContext());
    this.yAxis.position = "left";
    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);
  }
  getChartType() {
    return "topology";
  }
  async updateData() {
    await super.updateData();
    const options = this.getOptions();
    if (this.topology !== options.topology) {
      this.topology = options.topology;
    }
    const { topology } = this;
    this.series.forEach((series) => {
      if (isTopologySeries(series)) {
        series.setChartTopology(topology);
      }
    });
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone().shrink(this.modulesManager.getModule("seriesArea").getPadding());
    this.seriesRect = seriesRect;
    this.animationRect = seriesRect;
    const mapSeries = this.series.filter(isTopologySeries);
    const combinedBbox = mapSeries.reduce((combined, series) => {
      if (!series.visible)
        return combined;
      const bbox = series.topologyBounds;
      if (bbox == null)
        return combined;
      if (combined == null)
        return bbox;
      return combined.merge(bbox);
    }, void 0);
    let scale2;
    if (combinedBbox != null) {
      const { lon0, lat0, lon1, lat1 } = combinedBbox;
      const domain = [
        [lon0, lat0],
        [lon1, lat1]
      ];
      const bounds = MercatorScale2.bounds(domain);
      const { width: width2, height: height2 } = seriesRect;
      const viewBoxScale = Math.min(width2 / bounds.width, height2 / bounds.height);
      const viewBoxWidth = bounds.width * viewBoxScale;
      const viewBoxHeight = bounds.height * viewBoxScale;
      const viewBoxOriginX = (width2 - viewBoxWidth) / 2;
      const viewBoxOriginY = (height2 - viewBoxHeight) / 2;
      const x0 = viewBoxOriginX;
      const y0 = viewBoxOriginY;
      const x1 = viewBoxOriginX + viewBoxWidth;
      const y1 = viewBoxOriginY + viewBoxHeight;
      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);
      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);
      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);
      const xStart = x0 - xSpan * xZoom.min;
      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));
      const yStart = y0 - ySpan * (1 - yZoom.max);
      scale2 = new MercatorScale2(domain, [
        [xStart, yStart],
        [xStart + xSpan, yStart + ySpan]
      ]);
    }
    mapSeries.forEach((series) => {
      series.scale = scale2;
    });
    const seriesVisible = this.series.some((s) => s.visible);
    seriesRoot.visible = seriesVisible;
    for (const group of [seriesRoot, annotationRoot]) {
      group.translationX = Math.floor(seriesRect.x);
      group.translationY = Math.floor(seriesRect.y);
      group.setClipRect(seriesRect.clone());
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: seriesVisible, rect: seriesRect, paddedRect: layoutBox }
    });
  }
};
TopologyChart.className = "TopologyChart";
TopologyChart.type = "topology";
__decorateClass2([
  Property64
], TopologyChart.prototype, "topology", 2);
var { isAgTopologyChartOptions: isAgTopologyChartOptions2, topologyChartOptionsDefs: topologyChartOptionsDefs2 } = module_support_exports;
var TopologyChartModule2 = {
  type: "chart",
  name: "topology",
  enterprise: true,
  options: topologyChartOptionsDefs2,
  detect: isAgTopologyChartOptions2,
  create(options, resources) {
    return new TopologyChart(options, resources);
  }
};
var {
  annotationCalloutStylesDefs: annotationCalloutStylesDefs2,
  annotationNoteStylesDefs: annotationNoteStylesDefs2,
  annotationTextStylesDef: annotationTextStylesDef2,
  annotationCommentStylesDefs: annotationCommentStylesDefs2,
  annotationMeasurerStylesDefs: annotationMeasurerStylesDefs2,
  annotationShapeStylesDefs: annotationShapeStylesDefs2,
  annotationChannelTextDefs: annotationChannelTextDefs2,
  annotationCrossLineStyleDefs: annotationCrossLineStyleDefs2,
  annotationFibonacciStylesDefs: annotationFibonacciStylesDefs2,
  annotationLineStyleDefs: annotationLineStyleDefs2,
  annotationLineTextDefs: annotationLineTextDefs2,
  annotationDisjointChannelStyleDefs: annotationDisjointChannelStyleDefs2,
  annotationParallelChannelStyleDefs: annotationParallelChannelStyleDefs2
} = module_support_exports;
var serializableDate2 = optionsDefs(
  {
    __type: required(constant("date")),
    value: or(string, number)
  },
  "a serializable date object"
);
var xValue = or(string, number, serializableDate2);
var annotationValue = or(
  xValue,
  optionsDefs({
    value: xValue,
    groupPercentage: numberRange(-1, 2)
  })
);
var channelAnnotationTextOptionsDef = {
  ...annotationChannelTextDefs2,
  label: string
};
var lineAnnotationTextOptionsDef = {
  ...annotationLineTextDefs2,
  label: string
};
var annotationPointOptionsDef = {
  x: annotationValue,
  y: number
};
var annotationInitialStateOptionsDef = typeUnion(
  {
    line: {
      ...annotationLineStyleDefs2,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef,
      text: lineAnnotationTextOptionsDef
    },
    "horizontal-line": {
      ...annotationCrossLineStyleDefs2,
      value: annotationValue,
      text: lineAnnotationTextOptionsDef
    },
    "vertical-line": {
      ...annotationCrossLineStyleDefs2,
      value: annotationValue,
      text: lineAnnotationTextOptionsDef
    },
    "disjoint-channel": {
      ...annotationDisjointChannelStyleDefs2,
      startHeight: number,
      endHeight: number,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef,
      text: channelAnnotationTextOptionsDef
    },
    "parallel-channel": {
      ...annotationParallelChannelStyleDefs2,
      height: number,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef,
      text: channelAnnotationTextOptionsDef
    },
    "fibonacci-retracement": {
      ...annotationFibonacciStylesDefs2,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef,
      text: lineAnnotationTextOptionsDef,
      reverse: boolean
    },
    "fibonacci-retracement-trend-based": {
      ...annotationFibonacciStylesDefs2,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef,
      endRetracement: annotationPointOptionsDef,
      text: lineAnnotationTextOptionsDef,
      reverse: boolean
    },
    callout: {
      ...annotationCalloutStylesDefs2,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef,
      text: string
    },
    comment: {
      ...annotationCommentStylesDefs2,
      ...annotationPointOptionsDef,
      text: string
    },
    note: {
      ...annotationNoteStylesDefs2,
      ...annotationPointOptionsDef,
      text: string
    },
    text: {
      ...annotationTextStylesDef2,
      ...annotationPointOptionsDef,
      text: string
    },
    arrow: {
      ...annotationLineStyleDefs2,
      text: lineAnnotationTextOptionsDef,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef
    },
    "arrow-up": {
      ...annotationShapeStylesDefs2,
      ...annotationPointOptionsDef
    },
    "arrow-down": {
      ...annotationShapeStylesDefs2,
      ...annotationPointOptionsDef
    },
    "date-range": {
      ...annotationMeasurerStylesDefs2,
      extendAbove: boolean,
      extendBelow: boolean,
      text: lineAnnotationTextOptionsDef,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef
    },
    "price-range": {
      ...annotationMeasurerStylesDefs2,
      extendLeft: boolean,
      extendRight: boolean,
      text: lineAnnotationTextOptionsDef,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef
    },
    "date-price-range": {
      ...annotationMeasurerStylesDefs2,
      text: lineAnnotationTextOptionsDef,
      start: annotationPointOptionsDef,
      end: annotationPointOptionsDef
    }
  },
  "an annotation initial state object"
);
var initialStateOptionsDef = {
  chartType: union("candlestick", "hollow-candlestick", "ohlc", "line", "step-line", "hlc", "high-low"),
  annotations: arrayOfDefs(annotationInitialStateOptionsDef),
  legend: arrayOfDefs(
    {
      visible: boolean,
      seriesId: string,
      itemId: string,
      legendItemName: string
    },
    "legend state array"
  ),
  zoom: {
    rangeX: {
      start: or(number, serializableDate2),
      end: or(number, serializableDate2)
    },
    rangeY: {
      start: or(number, serializableDate2),
      end: or(number, serializableDate2)
    },
    ratioX: {
      start: and(ratio, lessThan("end")),
      end: and(ratio, greaterThan("start"))
    },
    ratioY: {
      start: and(ratio, lessThan("end")),
      end: and(ratio, greaterThan("start"))
    },
    autoScaledAxes: arrayOf(constant("y"))
  }
};
var { annotationOptionsDef: annotationOptionsDef2 } = module_support_exports;
var AnnotationsModule2 = {
  type: "plugin",
  name: "annotations",
  chartType: "cartesian",
  options: annotationOptionsDef2,
  create() {
    return null;
  }
};
var NavigatorModule2 = {
  type: "plugin",
  name: "navigator",
  chartType: "cartesian",
  options: navigatorOptionsDef2,
  create() {
    return null;
  }
};
var InitialStateModule = {
  type: "plugin",
  name: "initialState",
  options: initialStateOptionsDef,
  create() {
    return null;
  }
};
function computeNodeGraph(nodes, links, includeCircularReferences) {
  if (!includeCircularReferences) {
    links = removeCircularLinks(links);
  }
  const nodeGraph = /* @__PURE__ */ new Map();
  for (const datum of nodes) {
    nodeGraph.set(datum.id, {
      datum,
      linksBefore: [],
      linksAfter: [],
      maxPathLengthBefore: -1,
      maxPathLengthAfter: -1
    });
  }
  let maxPathLength = 0;
  nodeGraph.forEach((node, id) => {
    maxPathLength = Math.max(
      maxPathLength,
      computePathLength(nodeGraph, links, node, id, -1, []) + computePathLength(nodeGraph, links, node, id, 1, []) + 1
    );
  });
  return { links, nodeGraph, maxPathLength };
}
function findCircularLinks(links, link, into, stack) {
  const stackIndex = stack.indexOf(link);
  if (stackIndex !== -1) {
    for (let i = stackIndex; i < stack.length; i += 1) {
      into.add(stack[i]);
    }
    return;
  }
  stack.push(link);
  const { toNode } = link;
  for (const next of links) {
    if (next.fromNode === toNode) {
      findCircularLinks(links, next, into, stack);
    }
  }
  stack.pop();
}
function removeCircularLinks(links) {
  const circularLinks = /* @__PURE__ */ new Set();
  for (const link of links) {
    findCircularLinks(links, link, circularLinks, []);
  }
  if (circularLinks.size !== 0) {
    logger_exports.warnOnce("Some links formed circular references. These will be removed from the output.");
  }
  return circularLinks.size === 0 ? links : links.filter((link) => !circularLinks.has(link));
}
function computePathLength(nodeGraph, links, node, id, direction, stack) {
  if (stack.includes(id)) {
    return Infinity;
  }
  let maxPathLength = direction === -1 ? node.maxPathLengthBefore : node.maxPathLengthAfter;
  if (maxPathLength === -1) {
    maxPathLength = 0;
    const connectedLinks = direction === -1 ? node.linksBefore : node.linksAfter;
    for (const link of links) {
      const { fromNode, toNode } = link;
      const linkId = direction === -1 ? toNode.id : fromNode.id;
      const nextNodeId = direction === -1 ? fromNode.id : toNode.id;
      const nextNode = id === linkId ? nodeGraph.get(nextNodeId) : void 0;
      if (nextNode == null)
        continue;
      connectedLinks.push({ node: nextNode, link });
      stack?.push(id);
      maxPathLength = Math.max(
        maxPathLength,
        computePathLength(nodeGraph, links, nextNode, nextNodeId, direction, stack) + 1
      );
      stack?.pop();
    }
    if (direction === -1) {
      node.maxPathLengthBefore = maxPathLength;
    } else {
      node.maxPathLengthAfter = maxPathLength;
    }
  }
  return maxPathLength;
}
var { Series: Series3, DataController: DataController2, keyProperty: keyProperty7, valueProperty: valueProperty10, Selection: Selection6, Group: Group9, TransformableText: TransformableText2 } = module_support_exports;
var FlowProportionSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    const { datumIndex } = datum;
    const nodeDatum = series.contextNodeData?.nodeData.find(
      (d) => d.datumIndex.type === datumIndex.type && d.datumIndex.index === datumIndex.index
    );
    this.size = nodeDatum?.size;
    this.label = nodeDatum?.type === 1 ? nodeDatum?.label : void 0;
  }
};
var FlowProportionSeries = class extends Series3 {
  constructor() {
    super(...arguments);
    this.NodeEvent = FlowProportionSeriesNodeEvent;
    this.nodeCount = 0;
    this.linkCount = 0;
    this.linksDataModel = void 0;
    this.linksProcessedData = void 0;
    this.nodesDataModel = void 0;
    this.nodesProcessedData = void 0;
    this.processedNodes = /* @__PURE__ */ new Map();
    this.linkGroup = this.contentGroup.appendChild(new Group9({ name: "linkGroup" }));
    this.nodeGroup = this.contentGroup.appendChild(new Group9({ name: "nodeGroup" }));
    this.focusLinkGroup = this.highlightGroup.appendChild(new Group9({ name: "linkGroup" }));
    this.focusNodeGroup = this.highlightGroup.appendChild(new Group9({ name: "nodeGroup" }));
    this.highlightLinkGroup = this.highlightGroup.appendChild(new Group9({ name: "linkGroup" }));
    this.highlightNodeGroup = this.highlightGroup.appendChild(new Group9({ name: "nodeGroup" }));
    this.labelSelection = Selection6.select(
      this.labelGroup,
      TransformableText2
    );
    this.linkSelection = Selection6.select(
      this.linkGroup,
      () => this.linkFactory()
    );
    this.nodeSelection = Selection6.select(
      this.nodeGroup,
      () => this.nodeFactory()
    );
    this.focusLinkSelection = Selection6.select(
      this.focusLinkGroup,
      () => this.linkFactory()
    );
    this.focusNodeSelection = Selection6.select(
      this.focusNodeGroup,
      () => this.nodeFactory()
    );
    this.highlightLinkSelection = Selection6.select(
      this.highlightLinkGroup,
      () => this.linkFactory()
    );
    this.highlightNodeSelection = Selection6.select(
      this.highlightNodeGroup,
      () => this.nodeFactory()
    );
  }
  get nodes() {
    return this.properties.nodes;
  }
  async processData(dataController) {
    const { data, nodes } = this;
    if (data == null)
      return;
    const { fromKey, toKey, sizeKey, idKey, labelKey } = this.properties;
    const nodesDataController = new DataController2("standalone", dataController.suppressFieldDotNotation);
    const nodesDataModelPromise = nodes != null ? nodesDataController.request(this.id, nodes, {
      props: [
        keyProperty7(idKey, void 0, { id: "idValue", includeProperty: false }),
        ...labelKey != null ? [valueProperty10(labelKey, void 0, { id: "labelValue", includeProperty: false })] : []
      ],
      groupByKeys: true
    }) : null;
    const linksDataModelPromise = dataController.request(this.id, data, {
      props: [
        valueProperty10(fromKey, void 0, { id: "fromValue", includeProperty: false }),
        valueProperty10(toKey, void 0, { id: "toValue", includeProperty: false }),
        ...sizeKey != null ? [valueProperty10(sizeKey, void 0, { id: "sizeValue", includeProperty: false, missingValue: 0 })] : []
      ],
      groupByKeys: false
    });
    if (nodes != null) {
      nodesDataController.execute();
    }
    const [nodesDataModel, linksDataModel] = await Promise.all([nodesDataModelPromise, linksDataModelPromise]);
    this.nodesDataModel = nodesDataModel?.dataModel;
    this.nodesProcessedData = nodesDataModel?.processedData;
    this.linksDataModel = linksDataModel?.dataModel;
    this.linksProcessedData = linksDataModel?.processedData;
    const processedNodes = /* @__PURE__ */ new Map();
    if (nodesDataModel == null) {
      const fromIdValues = linksDataModel.dataModel.resolveColumnById(
        this,
        "fromValue",
        linksDataModel.processedData
      );
      const toIdValues = linksDataModel.dataModel.resolveColumnById(
        this,
        "toValue",
        linksDataModel.processedData
      );
      const createImplicitNode = (id) => {
        const datumIndex = processedNodes.size;
        const label = id;
        return {
          series: this,
          itemId: void 0,
          datum: {},
          // Must be a referential object for tooltips
          datumIndex: { type: 1, index: datumIndex },
          type: 1,
          index: datumIndex,
          linksBefore: [],
          linksAfter: [],
          id,
          size: 0,
          label
        };
      };
      linksDataModel.processedData.dataSources.get(this.id)?.forEach((_datum, datumIndex) => {
        const fromId = fromIdValues[datumIndex];
        const toId = toIdValues[datumIndex];
        if (fromId == null || toId == null)
          return;
        if (!processedNodes.has(fromId)) {
          processedNodes.set(fromId, createImplicitNode(fromId));
        }
        if (!processedNodes.has(toId)) {
          processedNodes.set(toId, createImplicitNode(toId));
        }
      });
    } else {
      const nodeIdValues = nodesDataModel.dataModel.resolveColumnById(
        this,
        "idValue",
        nodesDataModel.processedData
      );
      const labelValues = labelKey != null ? nodesDataModel.dataModel.resolveColumnById(
        this,
        "labelValue",
        nodesDataModel.processedData
      ) : void 0;
      nodesDataModel.processedData.dataSources.get(this.id)?.forEach((datum, datumIndex) => {
        const id = nodeIdValues[datumIndex];
        const label = labelValues?.[datumIndex];
        processedNodes.set(id, {
          series: this,
          itemId: void 0,
          datum,
          datumIndex: { type: 1, index: datumIndex },
          type: 1,
          index: datumIndex,
          linksBefore: [],
          linksAfter: [],
          id,
          size: 0,
          label
        });
      });
    }
    this.processedNodes = processedNodes;
  }
  getNodeGraph(createNode, createLink, { includeCircularReferences }) {
    const { linksDataModel, linksProcessedData } = this;
    if (linksDataModel == null || linksProcessedData == null) {
      const { links: links2, nodeGraph: nodeGraph2, maxPathLength: maxPathLength2 } = computeNodeGraph(
        (/* @__PURE__ */ new Map()).values(),
        [],
        includeCircularReferences
      );
      this.nodeCount = 0;
      this.linkCount = 0;
      return { nodeGraph: nodeGraph2, links: links2, maxPathLength: maxPathLength2 };
    }
    const { sizeKey } = this.properties;
    const fromIdValues = linksDataModel.resolveColumnById(this, "fromValue", linksProcessedData);
    const toIdValues = linksDataModel.resolveColumnById(this, "toValue", linksProcessedData);
    const sizeValues = sizeKey != null ? linksDataModel.resolveColumnById(this, "sizeValue", linksProcessedData) : void 0;
    const nodesById = /* @__PURE__ */ new Map();
    this.processedNodes.forEach((datum) => {
      const node = createNode(datum);
      nodesById.set(datum.id, node);
    });
    const baseLinks = [];
    linksProcessedData.dataSources.get(this.id)?.forEach((datum, datumIndex) => {
      const fromId = fromIdValues[datumIndex];
      const toId = toIdValues[datumIndex];
      const size = sizeValues != null ? sizeValues[datumIndex] : 1;
      const fromNode = nodesById.get(fromId);
      const toNode = nodesById.get(toId);
      if (size <= 0 || fromNode == null || toNode == null)
        return;
      const link = createLink({
        series: this,
        itemId: void 0,
        datum,
        datumIndex: { type: 0, index: datumIndex },
        type: 0,
        index: datumIndex,
        fromNode,
        toNode,
        size
      });
      baseLinks.push(link);
    });
    const { links, nodeGraph, maxPathLength } = computeNodeGraph(
      nodesById.values(),
      baseLinks,
      includeCircularReferences
    );
    nodeGraph.forEach((node) => {
      node.datum.linksBefore = node.linksBefore.map((linkedNode) => linkedNode.link);
      node.datum.linksAfter = node.linksAfter.map((linkedNode) => linkedNode.link);
    });
    this.nodeCount = nodeGraph.size;
    this.linkCount = links.length;
    return { nodeGraph, links, maxPathLength };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  update(opts) {
    const { seriesRect } = opts;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width ?? 0,
      seriesRectHeight: seriesRect?.height ?? 0
    };
    if (this._nodeDataDependencies == null || this._nodeDataDependencies.seriesRectWidth !== newNodeDataDependencies.seriesRectWidth || this._nodeDataDependencies.seriesRectHeight !== newNodeDataDependencies.seriesRectHeight) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    this.updateSelections();
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedDatum?.series === this && highlightedDatum.type == null) {
      const { itemId } = highlightedDatum;
      highlightedDatum = itemId != null ? nodeData.find((node) => node.type === 1 && node.id === itemId) : void 0;
    } else if (highlightedDatum?.series !== this) {
      highlightedDatum = void 0;
    }
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = highlightedDatum != null ? this.properties.highlight.unhighlightedItem.opacity ?? 1 : 1;
    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection: this.labelSelection });
    this.updateLabelNodes({ labelSelection: this.labelSelection });
    this.linkSelection = this.updateLinkSelection({
      nodeData: nodeData.filter(
        (d) => d.type === 0
        /* Link */
      ),
      datumSelection: this.linkSelection
    });
    this.updateLinkNodes({ datumSelection: this.linkSelection, isHighlight: false });
    this.nodeSelection = this.updateNodeSelection({
      nodeData: nodeData.filter(
        (d) => d.type === 1
        /* Node */
      ),
      datumSelection: this.nodeSelection
    });
    this.updateNodeNodes({ datumSelection: this.nodeSelection, isHighlight: false });
    let focusLinkSelection;
    let focusNodeSelection;
    let highlightLinkSelection;
    let highlightNodeSelection;
    if (highlightedDatum?.type === 1) {
      focusLinkSelection = nodeData.filter((node) => {
        return node.type === 0 && (node.toNode === highlightedDatum || node.fromNode === highlightedDatum);
      });
      focusNodeSelection = focusLinkSelection.map((link) => {
        return link.fromNode === highlightedDatum ? link.toNode : link.fromNode;
      });
      focusNodeSelection.push(highlightedDatum);
      highlightLinkSelection = [];
      highlightNodeSelection = [highlightedDatum];
    } else if (highlightedDatum?.type === 0) {
      focusLinkSelection = [highlightedDatum];
      focusNodeSelection = [highlightedDatum.fromNode, highlightedDatum.toNode];
      highlightLinkSelection = [highlightedDatum];
      highlightNodeSelection = [];
    } else {
      focusLinkSelection = [];
      focusNodeSelection = [];
      highlightLinkSelection = [];
      highlightNodeSelection = [];
    }
    this.focusLinkSelection = this.updateLinkSelection({
      nodeData: focusLinkSelection,
      datumSelection: this.focusLinkSelection
    });
    this.updateLinkNodes({ datumSelection: this.focusLinkSelection, isHighlight: false });
    this.focusNodeSelection = this.updateNodeSelection({
      nodeData: focusNodeSelection,
      datumSelection: this.focusNodeSelection
    });
    this.updateNodeNodes({ datumSelection: this.focusNodeSelection, isHighlight: false });
    this.highlightLinkSelection = this.updateLinkSelection({
      nodeData: highlightLinkSelection,
      datumSelection: this.highlightLinkSelection
    });
    this.updateLinkNodes({ datumSelection: this.highlightLinkSelection, isHighlight: true });
    this.highlightNodeSelection = this.updateNodeSelection({
      nodeData: highlightNodeSelection,
      datumSelection: this.highlightNodeSelection
    });
    this.updateNodeNodes({ datumSelection: this.highlightNodeSelection, isHighlight: true });
  }
  resetAnimation(_chartAnimationPhase) {
  }
  dataCount() {
    return NaN;
  }
  getSeriesDomain(_direction) {
    return [];
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  legendItemSymbol(_type, nodeIndex, format = {}) {
    const { fills, strokes } = this.properties;
    const {
      fill = fills[nodeIndex % fills.length],
      fillOpacity = 1,
      stroke: stroke22 = strokes[nodeIndex % strokes.length],
      strokeWidth = 0,
      strokeOpacity = 1,
      lineDash = [0],
      lineDashOffset = 0
    } = format;
    return {
      marker: {
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category")
      return [];
    const { showInLegend } = this.properties;
    return Array.from(
      this.processedNodes.values(),
      ({ id, label }, nodeIndex) => ({
        legendType: "category",
        id: this.id,
        itemId: id,
        seriesId: this.id,
        enabled: true,
        label: { text: label ?? id },
        symbol: this.legendItemSymbol(1, nodeIndex),
        hideInLegend: !showInLegend,
        isFixed: true
      })
    );
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistanceSquared = Infinity;
    let minDatum;
    this.linkSelection.each((node, datum) => {
      const distanceSquared2 = node.distanceSquared(x, y);
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    this.nodeSelection.each((node, datum) => {
      const distanceSquared2 = node.distanceSquared(x, y);
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  getDatumAriaText(datum, description) {
    if (datum.type === 0) {
      return this.ctx.localeManager.t("ariaAnnounceFlowProportionLink", {
        index: datum.index + 1,
        count: this.linkCount,
        from: datum.fromNode.id,
        to: datum.toNode.id,
        size: datum.size,
        sizeName: this.properties.sizeName ?? this.properties.sizeKey
      });
    } else if (datum.type === 1) {
      return this.ctx.localeManager.t("ariaAnnounceFlowProportionNode", {
        index: datum.index + 1,
        count: this.nodeCount,
        description
      });
    }
  }
  pickFocus(opts) {
    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;
    const currentNodeDatum = this.contextNodeData?.nodeData[opts.datumIndex - opts.datumIndexDelta];
    let nextNodeDatum = currentNodeDatum;
    if (depthDelta !== 0 || childDelta === 0)
      return;
    if (currentNodeDatum?.type === 0) {
      const allLinks = Array.from(this.linkSelection, (link) => link.datum);
      const selfIndex = allLinks.indexOf(currentNodeDatum);
      const nextIndex = selfIndex + childDelta;
      if (nextIndex >= 0 && nextIndex < allLinks.length) {
        nextNodeDatum = allLinks[nextIndex];
      } else if (nextIndex > 0) {
        nextNodeDatum = allLinks[allLinks.length - 1];
      } else {
        const allNodes = Array.from(this.nodeSelection, (node) => node.datum);
        nextNodeDatum = allNodes[allNodes.length - 1];
      }
    } else if (currentNodeDatum?.type === 1) {
      const allNodes = Array.from(this.nodeSelection, (node) => node.datum);
      const selfIndex = allNodes.indexOf(currentNodeDatum);
      const nextIndex = selfIndex + childDelta;
      if (nextIndex >= 0 && nextIndex < allNodes.length) {
        nextNodeDatum = allNodes[nextIndex];
      } else if (nextIndex < 0) {
        nextNodeDatum = allNodes[0];
      } else {
        const allLinks = Array.from(this.linkSelection, (link) => link.datum);
        nextNodeDatum = allLinks[0];
      }
    }
    if (nextNodeDatum == null)
      return;
    const nodeDatum = nextNodeDatum.type === 1 ? Array.from(this.nodeSelection).find((n) => n.datum === nextNodeDatum) : Array.from(this.linkSelection).find((n) => n.datum === nextNodeDatum);
    if (nodeDatum == null)
      return;
    const bounds = this.computeFocusBounds(nodeDatum.node);
    if (bounds == null)
      return;
    return {
      datum: nodeDatum.datum,
      datumIndex: this.contextNodeData?.nodeData.indexOf(nodeDatum.datum) ?? 0,
      otherIndex: 0,
      bounds,
      clipFocusBox: true
    };
  }
  getCategoryValue(_datumIndex) {
    return;
  }
  datumIndexForCategoryValue(_categoryValue) {
    return;
  }
};
var { Path: Path8, SceneChangeDetection: SceneChangeDetection6 } = module_support_exports;
function bezierControlPoints({
  radius,
  startAngle,
  endAngle,
  tension
}) {
  const cp0x = radius * Math.cos(startAngle);
  const cp0y = radius * Math.sin(startAngle);
  const cp3x = radius * Math.cos(endAngle);
  const cp3y = radius * Math.sin(endAngle);
  const cp1x = cp0x * tension;
  const cp1y = cp0y * tension;
  const cp2x = cp3x * tension;
  const cp2y = cp3y * tension;
  return {
    x: [cp0x, cp1x, cp2x, cp3x],
    y: [cp0y, cp1y, cp2y, cp3y]
  };
}
var ChordLink = class extends Path8 {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.startAngle1 = 0;
    this.endAngle1 = 0;
    this.startAngle2 = 0;
    this.endAngle2 = 0;
    this.tension = 1;
  }
  tensionedCurveTo(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {
    const { path, tension } = this;
    const scale2 = 1 - tension;
    path.cubicCurveTo(
      (cp1x - cp0x) * scale2 + cp0x,
      (cp1y - cp0y) * scale2 + cp0y,
      (cp2x - cp3x) * scale2 + cp3x,
      (cp2y - cp3y) * scale2 + cp3y,
      cp3x,
      cp3y
    );
  }
  updatePath() {
    const { path, centerX, centerY, radius } = this;
    let { startAngle1, endAngle1, startAngle2, endAngle2 } = this;
    if (startAngle1 > startAngle2) {
      [startAngle1, startAngle2] = [startAngle2, startAngle1];
      [endAngle1, endAngle2] = [endAngle2, endAngle1];
    }
    path.clear();
    const startX = centerX + radius * Math.cos(startAngle1);
    const startY = centerY + radius * Math.sin(startAngle1);
    path.moveTo(startX, startY);
    this.tensionedCurveTo(
      startX,
      startY,
      centerX,
      centerY,
      centerX,
      centerY,
      centerX + radius * Math.cos(endAngle2),
      centerY + radius * Math.sin(endAngle2)
    );
    path.arc(centerX, centerY, radius, endAngle2, startAngle2, true);
    this.tensionedCurveTo(
      centerX + radius * Math.cos(startAngle2),
      centerY + radius * Math.sin(startAngle2),
      centerX,
      centerY,
      centerX,
      centerY,
      centerX + radius * Math.cos(endAngle1),
      centerY + radius * Math.sin(endAngle1)
    );
    path.arc(centerX, centerY, radius, endAngle1, startAngle1, true);
    path.closePath();
  }
};
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "centerX", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "centerY", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "radius", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "startAngle1", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "endAngle1", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "startAngle2", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "endAngle2", 2);
__decorateClass2([
  SceneChangeDetection6()
], ChordLink.prototype, "tension", 2);
var {
  FillGradientDefaults: FillGradientDefaults7,
  FillPatternDefaults: FillPatternDefaults7,
  FillImageDefaults: FillImageDefaults7,
  BaseProperties: BaseProperties23,
  makeSeriesTooltip: makeSeriesTooltip8,
  SeriesProperties: SeriesProperties2,
  Property: Property65,
  Label: Label6
} = module_support_exports;
var ChordSeriesLabelProperties = class extends Label6 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
    this.maxWidth = 1;
  }
};
__decorateClass2([
  Property65
], ChordSeriesLabelProperties.prototype, "spacing", 2);
__decorateClass2([
  Property65
], ChordSeriesLabelProperties.prototype, "maxWidth", 2);
var ChordSeriesLinkProperties = class extends BaseProperties23 {
  constructor() {
    super(...arguments);
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tension = 0;
  }
  getStyle(fills, strokes, index) {
    const { fillOpacity, strokeWidth, strokeOpacity, lineDash, lineDashOffset, tension } = this;
    const fill = this.fill ?? fills[index % fills.length];
    const stroke22 = this.stroke ?? strokes[index % fills.length];
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      tension
    };
  }
};
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "fill", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "stroke", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "tension", 2);
__decorateClass2([
  Property65
], ChordSeriesLinkProperties.prototype, "itemStyler", 2);
var ChordSeriesNodeProperties = class extends BaseProperties23 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
    this.width = 1;
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
  getStyle(fills, strokes, index) {
    const { fillOpacity, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    const fill = this.fill ?? fills[index % fills.length];
    const stroke22 = this.stroke ?? strokes[index % fills.length];
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
};
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "spacing", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "width", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "fill", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "stroke", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property65
], ChordSeriesNodeProperties.prototype, "itemStyler", 2);
var ChordSeriesProperties = class extends SeriesProperties2 {
  constructor() {
    super();
    this.idKey = "";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.sizeKey = void 0;
    this.sizeName = void 0;
    this.nodes = void 0;
    this.fillGradientDefaults = new FillGradientDefaults7();
    this.fillPatternDefaults = new FillPatternDefaults7();
    this.fillImageDefaults = new FillImageDefaults7();
    this.fills = [];
    this.strokes = [];
    this.label = new ChordSeriesLabelProperties();
    this.link = new ChordSeriesLinkProperties();
    this.node = new ChordSeriesNodeProperties();
    this.tooltip = makeSeriesTooltip8();
    this.highlightStyle.deprecated = false;
  }
};
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "fromKey", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "toKey", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "sizeKey", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "nodes", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "fills", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "strokes", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "link", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "node", 2);
__decorateClass2([
  Property65
], ChordSeriesProperties.prototype, "tooltip", 2);
var {
  SeriesNodePickMode: SeriesNodePickMode6,
  CachedTextMeasurerPool: CachedTextMeasurerPool5,
  TextWrapper: TextWrapper5,
  TextUtils: TextUtils5,
  createDatumId: createDatumId6,
  angleBetween: angleBetween22,
  normalizeAngle360: normalizeAngle3604,
  isBetweenAngles: isBetweenAngles2,
  Sector: Sector3,
  evaluateBezier: evaluateBezier2,
  applyShapeStyle: applyShapeStyle7,
  getShapeStyle: getShapeStyle6,
  getLabelStyles: getLabelStyles2,
  BBox: BBox16,
  mergeDefaults: mergeDefaults10
} = module_support_exports;
var nodeMidAngle = (node) => node.startAngle + angleBetween22(node.startAngle, node.endAngle) / 2;
var ChordSeries = class extends FlowProportionSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode6.NEAREST_NODE, SeriesNodePickMode6.EXACT_SHAPE_MATCH]
    });
    this.properties = new ChordSeriesProperties();
  }
  isLabelEnabled() {
    return (this.properties.labelKey != null || this.nodes == null) && this.properties.label.enabled;
  }
  linkFactory() {
    return new ChordLink();
  }
  nodeFactory() {
    return new Sector3();
  }
  createNodeData() {
    const {
      id: seriesId,
      _nodeDataDependencies: { seriesRectWidth, seriesRectHeight } = { seriesRectWidth: 0, seriesRectHeight: 0 },
      properties
    } = this;
    const {
      fromKey,
      toKey,
      sizeKey,
      labelKey,
      label: { spacing: labelSpacing, maxWidth: labelMaxWidth, fontSize },
      node: { width: nodeWidth, spacing: nodeSpacing }
    } = properties;
    const centerX = seriesRectWidth / 2;
    const centerY = seriesRectHeight / 2;
    let labelData = [];
    const { nodeGraph, links } = this.getNodeGraph(
      (node) => ({
        ...node,
        centerX,
        centerY,
        innerRadius: NaN,
        outerRadius: NaN,
        startAngle: NaN,
        endAngle: NaN
      }),
      (link) => ({
        ...link,
        centerX,
        centerY,
        radius: NaN,
        startAngle1: NaN,
        endAngle1: NaN,
        startAngle2: NaN,
        endAngle2: NaN
      }),
      { includeCircularReferences: true }
    );
    let totalSize = 0;
    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }, id) => {
      const size = linksBefore.reduce((acc, { link }) => acc + link.size, 0) + linksAfter.reduce((acc, { link }) => acc + link.size, 0);
      if (size === 0) {
        nodeGraph.delete(id);
      } else {
        const { label } = properties;
        node.size = size;
        totalSize += node.size;
        const labelText = label.enabled ? this.getLabelText(
          node.label,
          node.datum,
          labelKey,
          "label",
          [],
          label,
          { datum: node.datum, value: node.label, fromKey, toKey, sizeKey, size: node.size }
        ) : void 0;
        node.label = labelText;
      }
    });
    let labelInset = 0;
    if (this.isLabelEnabled()) {
      const measurer22 = CachedTextMeasurerPool5.getMeasurer({ font: this.properties.label });
      let maxMeasuredLabelWidth = 0;
      nodeGraph.forEach(({ datum: node }) => {
        const { id, label } = node;
        if (label == null)
          return;
        const text2 = TextWrapper5.wrapText(label, {
          maxWidth: labelMaxWidth,
          font: this.properties.label,
          textWrap: "never"
        });
        const { width: width2 } = measurer22.measureText(text2);
        maxMeasuredLabelWidth = Math.max(width2, maxMeasuredLabelWidth);
        labelData.push({
          id,
          text: text2,
          centerX,
          centerY,
          angle: NaN,
          radius: NaN,
          size: node.size
        });
      });
      labelInset = maxMeasuredLabelWidth + labelSpacing;
    }
    const nodeCount = nodeGraph.size;
    let radius = Math.min(seriesRectWidth, seriesRectHeight) / 2 - nodeWidth - labelInset;
    let spacingSweep = nodeSpacing / radius;
    if (labelInset !== 0 && (nodeCount * spacingSweep >= 1.5 * Math.PI || radius <= 0)) {
      labelData = [];
      radius = Math.min(seriesRectWidth, seriesRectHeight) / 2 - nodeWidth;
      spacingSweep = nodeSpacing / radius;
    }
    if (nodeCount * spacingSweep >= 2 * Math.PI || radius <= 0) {
      logger_exports.warnOnce("There was insufficient space to display the Chord Series.");
      return;
    }
    const innerRadius = radius;
    const outerRadius = radius + nodeWidth;
    const sizeScale = Math.max((2 * Math.PI - nodeCount * spacingSweep) / totalSize, 0);
    let nodeAngle = 0;
    nodeGraph.forEach(({ datum: node }) => {
      node.innerRadius = innerRadius;
      node.outerRadius = outerRadius;
      node.startAngle = nodeAngle;
      node.endAngle = nodeAngle + node.size * sizeScale;
      nodeAngle = node.endAngle + spacingSweep;
      const midR = (node.innerRadius + node.outerRadius) / 2;
      const midAngle = nodeMidAngle(node);
      node.midPoint = {
        x: node.centerX + midR * Math.cos(midAngle),
        y: node.centerY + midR * Math.sin(midAngle)
      };
    });
    const nodeData = [];
    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }) => {
      const midAngle = nodeMidAngle(node);
      const combinedLinks = [
        ...linksBefore.map((l) => ({
          link: l.link,
          distance: angleBetween22(nodeMidAngle(l.node.datum), midAngle),
          after: false
        })),
        ...linksAfter.map((l) => ({
          link: l.link,
          distance: angleBetween22(nodeMidAngle(l.node.datum), midAngle),
          after: true
        }))
      ];
      let linkAngle = node.startAngle;
      combinedLinks.toSorted((a, b) => a.distance - b.distance).forEach(({ link, after }) => {
        const linkSweep = link.size * sizeScale;
        if (after) {
          link.startAngle1 = linkAngle;
          link.endAngle1 = linkAngle + linkSweep;
        } else {
          link.startAngle2 = linkAngle;
          link.endAngle2 = linkAngle + linkSweep;
        }
        linkAngle += link.size * sizeScale;
      });
      nodeData.push(node);
    });
    const { tension } = this.properties.link;
    links.forEach((link) => {
      link.radius = radius;
      const outer = bezierControlPoints({
        radius,
        startAngle: link.startAngle1,
        endAngle: link.endAngle2,
        tension
      });
      const inner = bezierControlPoints({
        radius,
        startAngle: link.startAngle2,
        endAngle: link.endAngle1,
        tension
      });
      const outerX = evaluateBezier2(...outer.x, 0.5);
      const outerY = evaluateBezier2(...outer.y, 0.5);
      const innerX = evaluateBezier2(...inner.x, 0.5);
      const innerY = evaluateBezier2(...inner.y, 0.5);
      link.midPoint = {
        x: link.centerX + (outerX + innerX) / 2,
        y: link.centerY + (outerY + innerY) / 2
      };
      nodeData.push(link);
    });
    labelData.forEach((label) => {
      const node = nodeGraph.get(label.id)?.datum;
      if (node == null)
        return;
      label.radius = outerRadius + labelSpacing;
      label.angle = normalizeAngle3604(node.startAngle + angleBetween22(node.startAngle, node.endAngle) / 2);
    });
    labelData.sort((a, b) => a.angle - b.angle);
    let minAngle = Infinity;
    let maxAngle = -Infinity;
    labelData = labelData.filter((label) => {
      const labelHeight = TextUtils5.getLineHeight(fontSize);
      const da = Math.atan2(labelHeight / 2, label.radius);
      const a0 = label.angle - da;
      const a1 = label.angle + da;
      if (isBetweenAngles2(minAngle, a0, a1))
        return false;
      if (isBetweenAngles2(maxAngle, a0, a1))
        return false;
      minAngle = Math.min(a0, minAngle);
      maxAngle = Math.max(a1, maxAngle);
      return true;
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateLabelSelection(opts) {
    const labels = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(labels);
  }
  updateLabelNodes(opts) {
    const params = {
      toKey: this.properties.toKey,
      fromKey: this.properties.fromKey,
      sizeKey: this.properties.sizeKey,
      size: NaN
    };
    opts.labelSelection.each((label, { size, text: text2, centerX, centerY, radius, angle: angle2 }) => {
      params.size = size;
      const style2 = getLabelStyles2(this, void 0, params, this.properties.label);
      const { fontStyle, fontWeight, fontSize, fontFamily, color: fill } = style2;
      label.visible = true;
      label.translationX = centerX + radius * Math.cos(angle2);
      label.translationY = centerY + radius * Math.sin(angle2);
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textBaseline = "middle";
      if (Math.cos(angle2) >= 0) {
        label.textAlign = "left";
        label.rotation = angle2;
      } else {
        label.textAlign = "right";
        label.rotation = angle2 - Math.PI;
      }
      label.setBoxing(style2);
    });
  }
  updateNodeSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId6([datum.type, datum.id]));
  }
  getNodeStyle({ datumIndex, datum, size = 0, label }, fromNodeDatumIndex, isHighlight) {
    const { id: seriesId, properties } = this;
    const { fills, strokes, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const { itemStyler } = properties.node;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults10(highlightStyle, properties.node.getStyle(fills, strokes, fromNodeDatumIndex));
    let style2 = getShapeStyle6(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && datumIndex != null) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId6(datumIndex, "node", isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            ...style2,
            size,
            label
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle6(
          mergeDefaults10(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    style2.opacity = 1;
    return style2;
  }
  updateNodeNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((sector, datum) => {
      const { datumIndex } = datum;
      const style2 = this.getNodeStyle(datum, datumIndex.index, isHighlight);
      applyShapeStyle7(sector, style2, fillBBox);
      sector.centerX = datum.centerX;
      sector.centerY = datum.centerY;
      sector.innerRadius = datum.innerRadius;
      sector.outerRadius = datum.outerRadius;
      sector.startAngle = datum.startAngle;
      sector.endAngle = datum.endAngle;
      sector.inset = sector.strokeWidth / 2;
    });
  }
  updateLinkSelection(opts) {
    return opts.datumSelection.update(
      opts.nodeData,
      void 0,
      (datum) => createDatumId6([datum.type, datum.index, datum.fromNode.id, datum.toNode.id])
    );
  }
  getLinkStyle({ datumIndex, datum }, fromNodeDatumIndex, isHighlight) {
    const { id: seriesId, properties } = this;
    const { fills, strokes, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const { itemStyler } = properties.link;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults10(
      highlightStyle,
      properties.link.getStyle(fills, strokes, fromNodeDatumIndex.index)
    );
    let style2 = getShapeStyle6(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && datumIndex != null) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId6(datumIndex, "link", isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(
            activeHighlight,
            isHighlight,
            fromNodeDatumIndex
          );
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle6(
          mergeDefaults10(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    style2.opacity = 1;
    return style2;
  }
  updateLinkNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((link, datum) => {
      const fromNodeDatumIndex = datum.fromNode.datumIndex;
      const style2 = this.getLinkStyle(datum, fromNodeDatumIndex, isHighlight);
      link.centerX = datum.centerX;
      link.centerY = datum.centerY;
      link.radius = datum.radius;
      link.startAngle1 = datum.startAngle1;
      link.endAngle1 = datum.endAngle1;
      link.startAngle2 = datum.startAngle2;
      link.endAngle2 = datum.endAngle2;
      link.tension = style2.tension;
      applyShapeStyle7(link, style2, fillBBox);
    });
  }
  getShapeFillBBox() {
    const width2 = this._nodeDataDependencies?.seriesRectWidth ?? 0;
    const height2 = this._nodeDataDependencies?.seriesRectHeight ?? 0;
    const size = Math.min(width2, height2);
    const x = (width2 - size) / 2;
    const y = (height2 - size) / 2;
    const bbox = new BBox16(x, y, width2, height2);
    return { series: bbox, axis: bbox };
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      linksProcessedData,
      nodesProcessedData,
      properties,
      ctx: { formatManager }
    } = this;
    const { fromKey, toKey, sizeKey, sizeName, tooltip } = properties;
    const seriesDatum = this.contextNodeData?.nodeData.find(
      (d) => d.datumIndex.type === datumIndex.type && d.datumIndex.index === datumIndex.index
    );
    if (seriesDatum == null)
      return;
    const nodeIndex = seriesDatum.type === 0 ? seriesDatum.fromNode.index : seriesDatum.index;
    const title = seriesDatum.type === 0 ? `${seriesDatum.fromNode.label} - ${seriesDatum.toNode.label}` : seriesDatum.label;
    const datum = datumIndex.type === 0 ? linksProcessedData?.dataSources.get(this.id)?.[datumIndex.index] : nodesProcessedData?.dataSources.get(this.id)?.[datumIndex.index];
    const size = seriesDatum.size;
    let format;
    if (seriesDatum.type === 0) {
      const fromNodeDatumIndex = seriesDatum.fromNode.datumIndex;
      format = this.getLinkStyle({ datumIndex, datum }, fromNodeDatumIndex, false);
    } else {
      const label = seriesDatum.label;
      format = this.getNodeStyle({ datumIndex, datum, size, label }, datumIndex.index, false);
    }
    const data = [];
    if (sizeKey != null) {
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: size,
        datum,
        seriesId,
        legendItemName: void 0,
        key: sizeKey,
        source: "tooltip",
        property: "size",
        domain: [],
        boundSeries: this.getFormatterContext("size"),
        fractionDigits: void 0
      });
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: content ?? String(size) });
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(seriesDatum.type, nodeIndex, format),
        data
      },
      {
        seriesId,
        datum,
        title,
        fromKey,
        toKey,
        sizeKey,
        sizeName,
        size,
        ...format
      }
    );
  }
  computeFocusBounds(node) {
    return node;
  }
  hasItemStylers() {
    return this.properties.node.itemStyler != null || this.properties.link.itemStyler != null;
  }
};
ChordSeries.className = "ChordSeries";
ChordSeries.type = "chord";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs8, chordSeriesThemeableOptionsDef: chordSeriesThemeableOptionsDef2 } = module_support_exports;
var chordSeriesOptionsDef = {
  ...chordSeriesThemeableOptionsDef2,
  ...commonSeriesOptionsDefs8,
  type: required(constant("chord")),
  fromKey: required(string),
  toKey: required(string),
  sizeKey: string,
  sizeName: string
};
chordSeriesOptionsDef.fillGradientDefaults = undocumented(fillGradientDefaults);
chordSeriesOptionsDef.fillPatternDefaults = undocumented(fillPatternDefaults);
chordSeriesOptionsDef.fillImageDefaults = undocumented(fillImageDefaults);
var ChordModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  solo: true,
  identifier: "chord",
  moduleFactory: (ctx) => new ChordSeries(ctx),
  themeTemplate: {
    series: {
      fills: { $palette: "fills" },
      strokes: { $palette: "strokes" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      highlightStyle: {
        series: {
          dimOpacity: 0.2
        }
      },
      highlight: module_support_exports.singleSeriesHighlightStyle(),
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" },
        spacing: 5,
        maxWidth: 100
      },
      node: {
        spacing: 8,
        width: 10,
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] }
      },
      link: {
        fillOpacity: 0.5,
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
        tension: 0.4
      }
    },
    legend: {
      enabled: false,
      toggleSeries: false
    }
  }
};
var ChordSeriesModule = {
  type: "series",
  name: "chord",
  chartType: "standalone",
  enterprise: true,
  options: chordSeriesOptionsDef,
  create: (ctx) => new ChordSeries(ctx)
};
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE7, CARTESIAN_POSITION: CARTESIAN_POSITION5 },
  ThemeSymbols: { DEFAULT_SHADOW_COLOUR: DEFAULT_SHADOW_COLOUR2 }
} = module_support_exports;
var isHorizontal = { $eq: [{ $path: ["/series/0/direction", void 0] }, "horizontal"] };
var labelOptions = {
  autoRotate: { $path: "/series/0/stageLabel/autoRotate" },
  autoRotateAngle: { $path: "/series/0/stageLabel/autoRotateAngle" },
  avoidCollisions: { $path: ["/series/0/stageLabel/avoidCollisions", true] },
  border: { $path: ["/series/0/stageLabel/border"] },
  color: { $path: ["/series/0/stageLabel/color", { $ref: "textColor" }] },
  cornerRadius: { $path: ["/series/0/stageLabel/cornerRadius"] },
  enabled: {
    $if: [
      { $eq: [{ $path: "/series/0/stageLabel/enabled" }, void 0] },
      true,
      { $path: "/series/0/stageLabel/enabled" }
    ]
  },
  fill: { $path: ["/series/0/stageLabel/fill"] },
  fillOpacity: { $path: ["/series/0/stageLabel/fillOpacity"] },
  fontSize: { $path: ["/series/0/stageLabel/fontSize", { $ref: "fontSize" }] },
  fontStyle: { $path: ["/series/0/stageLabel/fontStyle", { $ref: "fontStyle" }] },
  fontWeight: { $path: ["/series/0/stageLabel/fontWeight", { $ref: "fontWeight" }] },
  format: { $path: "/series/0/stageLabel/format" },
  formatter: { $path: "/series/0/stageLabel/formatter" },
  itemStyler: { $path: "/series/0/stageLabel/itemStyler" },
  minSpacing: { $path: "/series/0/stageLabel/minSpacing" },
  padding: { $path: ["/series/0/stageLabel/padding"] },
  rotation: { $path: ["/series/0/stageLabel/rotation", 0] }
};
var FUNNEL_SERIES_AXES = [
  {
    type: {
      $if: [isHorizontal, CARTESIAN_AXIS_TYPE7.NUMBER, CARTESIAN_AXIS_TYPE7.CATEGORY]
    },
    position: {
      $if: [
        isHorizontal,
        CARTESIAN_POSITION5.LEFT,
        {
          $if: [
            { $eq: [{ $path: ["/series/0/stageLabel/placement", void 0] }, "after"] },
            CARTESIAN_POSITION5.RIGHT,
            CARTESIAN_POSITION5.LEFT
          ]
        }
      ]
    },
    label: {
      $if: [isHorizontal, void 0, labelOptions]
    }
  },
  {
    type: {
      $if: [isHorizontal, CARTESIAN_AXIS_TYPE7.CATEGORY, CARTESIAN_AXIS_TYPE7.NUMBER]
    },
    position: {
      $if: [
        isHorizontal,
        {
          $if: [
            { $eq: [{ $path: ["/series/0/stageLabel/placement", void 0] }, "before"] },
            CARTESIAN_POSITION5.TOP,
            CARTESIAN_POSITION5.BOTTOM
          ]
        },
        CARTESIAN_POSITION5.BOTTOM
      ]
    },
    label: {
      $if: [isHorizontal, labelOptions, void 0]
    }
  }
];
var FUNNEL_SERIES_THEME = {
  series: {
    direction: "vertical",
    strokeWidth: { $isUserOption: ["./strokes/0", 2, 0] },
    spacingRatio: 0.25,
    fills: [{ $palette: "fill" }],
    strokes: [{ $palette: "stroke" }],
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "chartBackgroundColor" }
    },
    dropOff: {
      enabled: true,
      fillOpacity: 0.2,
      strokeWidth: { $isUserOption: ["./stroke", 2, 0] }
    },
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR2,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    },
    highlight: module_support_exports.singleSeriesHighlightStyle()
  },
  axes: {
    [CARTESIAN_AXIS_TYPE7.NUMBER]: {
      nice: false,
      gridLine: {
        enabled: false
      },
      crosshair: {
        enabled: false
      },
      label: {
        enabled: false
      }
    },
    [CARTESIAN_AXIS_TYPE7.CATEGORY]: {
      line: {
        enabled: false
      }
    }
  }
};
var { lineDistanceSquared: lineDistanceSquared2, BBox: BBox17, Path: Path9, SceneChangeDetection: SceneChangeDetection7 } = module_support_exports;
var delta3 = 1e-6;
function pointsEq2([ax, ay], [bx, by]) {
  return Math.abs(ax - bx) <= delta3 && Math.abs(ay - by) <= delta3;
}
var FunnelConnector = class extends Path9 {
  constructor() {
    super(...arguments);
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.x3 = 0;
    this.y3 = 0;
  }
  get midPoint() {
    const { x0, y0, x1, y1, x2, y2, x3, y3 } = this;
    return {
      x: (x0 + x1 + x2 + x3) / 4,
      y: (y0 + y1 + y2 + y3) / 4
    };
  }
  distanceSquared(x, y) {
    if (this.containsPoint(x, y))
      return 0;
    const { x0, y0, x1, y1, x2, y2, x3, y3 } = this;
    return Math.min(
      lineDistanceSquared2(x, y, x0, y0, x1, y1, Infinity),
      lineDistanceSquared2(x, y, x1, y1, x2, y2, Infinity),
      lineDistanceSquared2(x, y, x2, y2, x3, y3, Infinity),
      lineDistanceSquared2(x, y, x3, y3, x0, y0, Infinity)
    );
  }
  computeBBox() {
    const { x0, y0, x1, y1, x2, y2, x3, y3 } = this;
    const x = Math.min(x0, x1, x2, x3);
    const width2 = Math.max(x0, x1, x2, x3) - x;
    const y = Math.min(y0, y1, y2, y3);
    const height2 = Math.max(y0, y1, y2, y3) - y;
    return new BBox17(x, y, width2, height2);
  }
  updatePath() {
    const { path, x0, y0, x1, y1, x2, y2, x3, y3 } = this;
    const points = [
      [x0, y0],
      [x1, y1],
      [x2, y2],
      [x3, y3]
    ];
    path.clear();
    let start2;
    let current;
    points.forEach((p) => {
      if (start2 != null && pointsEq2(start2, p) || current != null && pointsEq2(current, p)) {
        return;
      }
      const [x, y] = p;
      if (start2 == null) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
      start2 ?? (start2 = p);
      current = p;
    });
    path.closePath();
  }
};
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "x0", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "y0", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "x1", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "y1", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "x2", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "y2", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "x3", 2);
__decorateClass2([
  SceneChangeDetection7()
], FunnelConnector.prototype, "y3", 2);
var { NODE_UPDATE_STATE_TO_PHASE_MAPPING: NODE_UPDATE_STATE_TO_PHASE_MAPPING2 } = module_support_exports;
function connectorStartingPosition(datum, _prevDatum, isVertical, _mode) {
  const { x0, y0, x1, y1, x2, y2, x3, y3, opacity } = datum;
  if (isVertical) {
    return {
      x0: (x0 + x3) / 2,
      y0: (y0 + y3) / 2,
      x1: (x1 + x2) / 2,
      y1: (y1 + y2) / 2,
      x2: (x1 + x2) / 2,
      y2: (y1 + y2) / 2,
      x3: (x0 + x3) / 2,
      y3: (y0 + y3) / 2,
      opacity
    };
  } else {
    return {
      x0: (x0 + x1) / 2,
      y0: (y0 + y1) / 2,
      x1: (x0 + x1) / 2,
      y1: (y0 + y1) / 2,
      x2: (x2 + x3) / 2,
      y2: (y2 + y3) / 2,
      x3: (x2 + x3) / 2,
      y3: (y2 + y3) / 2,
      opacity
    };
  }
}
function prepareConnectorAnimationFunctions(isVertical, mode) {
  const isRemoved = (datum) => datum == null;
  const fromFn = (connector, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(connector.previousDatum)) {
      status = "added";
    }
    let source;
    if (status === "added" && connector.previousDatum == null && mode === "fade") {
      source = { ...resetConnectorSelectionsFn(connector, datum), opacity: 0 };
    } else if (status === "unknown" || status === "added") {
      source = connectorStartingPosition(datum, connector.previousDatum, isVertical, mode);
    } else {
      source = {
        x0: connector.x0,
        y0: connector.y0,
        x1: connector.x1,
        y1: connector.y1,
        x2: connector.x2,
        y2: connector.y2,
        x3: connector.x3,
        y3: connector.y3,
        opacity: connector.opacity
      };
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING2[status];
    return { ...source, phase };
  };
  const toFn = (connector, datum, status) => {
    let source;
    if (status === "removed" && connector.datum == null && mode === "fade") {
      source = { ...resetConnectorSelectionsFn(connector, datum), opacity: 0 };
    } else if (status === "removed" || isRemoved(datum)) {
      source = connectorStartingPosition(datum, connector.previousDatum, isVertical, mode);
    } else {
      source = resetConnectorSelectionsFn(connector, datum);
    }
    return source;
  };
  return { fromFn, toFn };
}
function resetConnectorSelectionsFn(_node, datum) {
  const { x0, y0, x1, y1, x2, y2, x3, y3, opacity } = datum;
  return { x0, y0, x1, y1, x2, y2, x3, y3, opacity };
}
var {
  SeriesNodePickMode: SeriesNodePickMode7,
  SeriesZIndexMap: SeriesZIndexMap2,
  valueProperty: valueProperty11,
  keyProperty: keyProperty8,
  ChartAxisDirection: ChartAxisDirection24,
  updateLabelNode: updateLabelNode5,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL4,
  LARGEST_KEY_INTERVAL: LARGEST_KEY_INTERVAL22,
  diff: diff5,
  fixNumericExtent: fixNumericExtent7,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation4,
  resetMotion: resetMotion22,
  resetLabelFn: resetLabelFn4,
  animationValidation: animationValidation6,
  computeBarFocusBounds: computeBarFocusBounds6,
  ContinuousScale: ContinuousScale7,
  Group: Group10,
  Selection: Selection7,
  PointerEvents: PointerEvents4,
  motion: motion4,
  checkCrisp: checkCrisp3,
  createDatumId: createDatumId7,
  applyShapeStyle: applyShapeStyle8,
  getShapeStyle: getShapeStyle7,
  getShapeFill: getShapeFill4
} = module_support_exports;
var FunnelSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.stageKey;
    this.yKey = series.properties.valueKey;
  }
};
var BaseFunnelSeries = class extends module_support_exports.AbstractBarSeries {
  constructor({
    moduleCtx,
    animationResetFns
  }) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode7.AXIS_ALIGNED, SeriesNodePickMode7.EXACT_SHAPE_MATCH],
      propertyKeys: {
        x: ["stageKey"],
        y: ["valueKey"]
      },
      propertyNames: {
        x: [],
        y: []
      },
      categoryKey: "xValue",
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: animationResetFns.datum,
        label: resetLabelFn4
      }
    });
    this.NodeEvent = FunnelSeriesNodeEvent;
    this.connectorNodeGroup = this.contentGroup.appendChild(
      new Group10({
        name: `${this.id}-series-connectorNodes`,
        zIndex: SeriesZIndexMap2.BACKGROUND
      })
    );
    this.connectorSelection = Selection7.select(
      this.connectorNodeGroup,
      () => this.connectionFactory()
    );
    this.connectorNodeGroup.pointerEvents = PointerEvents4.None;
  }
  get pickModeAxis() {
    return "main-category";
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.connectorNodeGroup.zIndex = [SeriesZIndexMap2.BACKGROUND, zIndex];
    return true;
  }
  isVertical() {
    return !super.isVertical();
  }
  connectionFactory() {
    return new FunnelConnector();
  }
  async processData(dataController) {
    const { stageKey, valueKey } = this.properties;
    const { visible, id: seriesId } = this;
    const validation = (_value, _datum, index) => visible && this.ctx.legendManager.getItemEnabled({ seriesId, itemId: index });
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      if (this.processedData) {
        extraProps.push(diff5(this.id, this.processedData));
      }
      extraProps.push(animationValidation6());
    }
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const { processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty8(stageKey, xScaleType, { id: "xValue" }),
        valueProperty11(valueKey, yScaleType, { id: `yValue`, ...visibleProps, validation, invalidValue: 0 }),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL4, LARGEST_KEY_INTERVAL22] : [],
        ...extraProps
      ],
      groupByKeys: false
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const {
      processedData,
      dataModel,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    if (!processedData || !dataModel)
      return [];
    const {
      keys: [keys]
    } = processedData.domain;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if (keyDef?.def.type === "key" && keyDef?.def.valueType === "category") {
        if (!this.hasData)
          return [];
        return keys.filter((_key, index) => legendManager.getItemEnabled({ seriesId, itemId: index }));
      }
      return this.padBandExtent(keys);
    } else {
      const yExtent = this.domainForClippedRange(direction, ["yValue"], "xValue");
      const maxExtent = Math.max(...yExtent);
      const fixedYExtent = [-maxExtent, maxExtent];
      return fixNumericExtent7(fixedYExtent);
    }
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  createNodeData() {
    const {
      hasData,
      data,
      dataModel,
      groupScale,
      processedData,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(hasData && data && xAxis && yAxis && dataModel && processedData?.type === "ungrouped")) {
      return;
    }
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const barAlongX = this.getBarDirection() === ChartAxisDirection24.X;
    const { stageKey, valueKey } = this.properties;
    const { strokeWidth } = this.barStyle();
    const itemId = `${valueKey}`;
    const context = {
      itemId,
      nodeData: [],
      labelData: [],
      connectorData: [],
      scales: this.calculateScaling(),
      groupScale: this.getScaling(this.groupScale),
      visible: this.visible
    };
    const isVisible = this.visible;
    if (!isVisible)
      return context;
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale7.is(xScale) ? barWidth * -0.5 : 0;
    const crisp = checkCrisp3(
      xAxis?.scale,
      xAxis?.visibleRange,
      this.smallestDataInterval,
      this.largestDataInterval
    );
    let previousConnection;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const visible = isVisible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex });
      const xDatum = xValues[datumIndex];
      if (xDatum == null)
        return;
      const x = Math.round(xScale.convert(xDatum)) + groupScale.convert(String(groupIndex)) + barOffset;
      const yDatum = yValues[datumIndex];
      const yNegative = Math.round(yScale.convert(-yDatum));
      const yPositive = Math.round(yScale.convert(yDatum));
      const barHeight = Math.max(strokeWidth, Math.abs(yPositive - yNegative));
      const rect = {
        x: barAlongX ? Math.min(yPositive, yNegative) : x,
        y: barAlongX ? x : Math.min(yPositive, yNegative),
        width: barAlongX ? barHeight : barWidth,
        height: barAlongX ? barWidth : barHeight
      };
      const nodeMidPoint = {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      };
      const labelData = this.createLabelData({
        datumIndex,
        rect,
        barAlongX,
        yDatum,
        datum,
        visible
      });
      const nodeDatum = {
        index: datumIndex,
        series: this,
        itemId,
        datum,
        datumIndex,
        xValue: xDatum,
        yValue: yDatum,
        xKey: stageKey,
        yKey: valueKey,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        midPoint: nodeMidPoint,
        strokeWidth,
        crisp,
        label: labelData,
        visible
      };
      context.nodeData.push(nodeDatum);
      if (labelData != null) {
        context.labelData.push(labelData);
      }
      if (previousConnection != null) {
        const prevRect = previousConnection.rect;
        const startNodeDatum = previousConnection.nodeDatum;
        const startDatumIndex = previousConnection.datumIndex;
        if (barAlongX) {
          context.connectorData.push({
            datum: startNodeDatum,
            datumIndex: startDatumIndex,
            x0: prevRect.x,
            y0: prevRect.y + prevRect.height,
            x1: prevRect.x + prevRect.width,
            y1: prevRect.y + prevRect.height,
            x2: rect.x + rect.width,
            y2: rect.y,
            x3: rect.x,
            y3: rect.y,
            opacity: 1
          });
        } else {
          context.connectorData.push({
            datum: startNodeDatum,
            datumIndex: startDatumIndex,
            x0: prevRect.x + prevRect.width,
            y0: prevRect.y,
            x1: rect.x,
            y1: rect.y,
            x2: rect.x,
            y2: rect.y + rect.height,
            x3: prevRect.x + prevRect.width,
            y3: prevRect.y + prevRect.height,
            opacity: 1
          });
        }
      }
      if (visible) {
        previousConnection = {
          itemId,
          rect,
          nodeDatum,
          datumIndex
        };
      }
    });
    return context;
  }
  updateNodes(seriesHighlighted, nodeRefresh) {
    super.updateNodes(seriesHighlighted, nodeRefresh);
    const { connectorSelection } = this;
    const connectorData = this.contextNodeData?.connectorData ?? [];
    this.connectorSelection = this.updateConnectorSelection({ connectorSelection, connectorData });
    this.updateConnectorNodes({ connectorSelection });
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    const data = nodeData ?? [];
    return datumSelection.update(data, void 0, (datum) => this.getDatumId(datum));
  }
  updateConnectorSelection(opts) {
    const { connectorData, connectorSelection } = opts;
    return connectorSelection.update(
      this.connectorEnabled() ? connectorData : [],
      void 0,
      (connector) => this.getDatumId(connector.datum)
    );
  }
  updateConnectorNodes(opts) {
    const { fills, strokes, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = this.properties;
    const { fill, fillOpacity, stroke: stroke22, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.connectorStyle();
    const fillBBox = this.getShapeFillBBox();
    opts.connectorSelection.each((connector, datum) => {
      const { datumIndex } = datum;
      connector.setProperties(resetConnectorSelectionsFn(connector, datum));
      const connectorFill = getShapeFill4(
        fill ?? fills[datumIndex % fills.length],
        fillGradientDefaults5,
        fillPatternDefaults5,
        fillImageDefaults5
      );
      applyShapeStyle8(
        connector,
        {
          fill: connectorFill,
          stroke: stroke22 ?? strokes[datumIndex % strokes.length],
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillBBox
      );
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  updateLabelSelection(opts) {
    const labelData = this.properties.label.enabled ? opts.labelData : [];
    return opts.labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = PointerEvents4.None;
    });
  }
  updateLabelNodes(opts) {
    const params = {
      stageKey: this.properties.stageKey,
      valueKey: this.properties.valueKey
    };
    opts.labelSelection.each((textNode, datum) => {
      textNode.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
      updateLabelNode5(this, textNode, params, this.properties.label, datum);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { stageKey, valueKey, tooltip, legendItemName } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveKeysById(this, "xValue", processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    return this.formatTooltipWithContext(
      tooltip,
      {
        symbol: this.legendItemSymbol(datumIndex),
        data: [
          {
            label: this.getAxisValueText(xAxis, "tooltip", xValue2, datum, stageKey, legendItemName),
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, valueKey, legendItemName)
          }
        ]
      },
      { seriesId, datum, title: stageKey, stageKey, valueKey, ...this.tooltipStyle(datum, datumIndex) }
    );
  }
  resetAllAnimation(data) {
    super.resetAllAnimation(data);
    resetMotion22([this.connectorSelection], resetConnectorSelectionsFn);
  }
  animateEmptyUpdateReady({ labelSelection }) {
    const { connectorSelection } = this;
    const isVertical = this.isVertical();
    const mode = "normal";
    const connectorFns = prepareConnectorAnimationFunctions(isVertical, mode);
    motion4.fromToMotion(this.id, "connectors", this.ctx.animationManager, [connectorSelection], connectorFns);
    seriesLabelFadeInAnimation4(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    const { labelSelection: labelSelections } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    seriesLabelFadeInAnimation4(this, "labels", this.ctx.animationManager, labelSelections);
  }
  getDatumId(datum) {
    return createDatumId7(datum.xValue);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds6(this, this.contextNodeData?.nodeData[datumIndex]);
  }
  legendItemSymbol(datumIndex) {
    const {
      strokeWidth,
      fillOpacity,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.barStyle();
    const { fills, strokes } = this.properties;
    const fill = fills[datumIndex % fills.length] ?? "black";
    const stroke22 = strokes[datumIndex % strokes.length] ?? "black";
    return {
      marker: getShapeStyle7(
        {
          fill,
          fillOpacity,
          stroke: stroke22,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults5,
        fillPatternDefaults5,
        fillImageDefaults5
      )
    };
  }
  getLegendData(legendType) {
    const {
      id: seriesId,
      processedData,
      dataModel,
      ctx: { legendManager },
      visible
    } = this;
    if (!dataModel || !processedData || legendType !== "category") {
      return [];
    }
    const { showInLegend } = this.properties;
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    return (processedData.dataSources.get(this.id) ?? []).map((datum, datumIndex) => {
      const stageValue = xValues[datumIndex];
      if (stageValue == null)
        return;
      return {
        legendType: "category",
        id: seriesId,
        datum,
        itemId: datumIndex,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        label: { text: String(stageValue) },
        symbol: this.legendItemSymbol(datumIndex),
        skipAnimations: true,
        hideInLegend: !showInLegend
      };
    }).filter((datum) => datum != null);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
var {
  FillGradientDefaults: FillGradientDefaults8,
  FillPatternDefaults: FillPatternDefaults8,
  FillImageDefaults: FillImageDefaults8,
  Label: Label7,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties5,
  makeSeriesTooltip: makeSeriesTooltip9,
  AxisLabel: AxisLabel3,
  Property: Property66
} = module_support_exports;
var ConeFunnelSeriesLabel = class extends Label7 {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass2([
  Property66
], ConeFunnelSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Property66
], ConeFunnelSeriesLabel.prototype, "spacing", 2);
var ConeFunnelSeriesStageLabel = class extends AxisLabel3 {
};
__decorateClass2([
  Property66
], ConeFunnelSeriesStageLabel.prototype, "placement", 2);
var ConeFunnelProperties = class extends AbstractBarSeriesProperties5 {
  constructor() {
    super(...arguments);
    this.fills = [];
    this.fillGradientDefaults = new FillGradientDefaults8();
    this.fillPatternDefaults = new FillPatternDefaults8();
    this.fillImageDefaults = new FillImageDefaults8();
    this.fillOpacity = 1;
    this.strokes = [];
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.label = new ConeFunnelSeriesLabel();
    this.stageLabel = new ConeFunnelSeriesStageLabel();
    this.tooltip = makeSeriesTooltip9();
  }
};
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "stageKey", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "valueKey", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "fills", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "strokes", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "label", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "stageLabel", 2);
__decorateClass2([
  Property66
], ConeFunnelProperties.prototype, "tooltip", 2);
function resetLineSelectionsFn(_node, { x, y, width: width2, height: height2, opacity }) {
  return { x1: x, y1: y, x2: x + width2, y2: y + height2, opacity: opacity ?? 1 };
}
var { Line: Line6, ChartAxisDirection: ChartAxisDirection25 } = module_support_exports;
var ConeFunnelSeries = class extends BaseFunnelSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      animationResetFns: {
        datum: resetLineSelectionsFn
      }
    });
    this.properties = new ConeFunnelProperties();
  }
  get hasData() {
    const {
      id: seriesId,
      ctx: { legendManager }
    } = this;
    const visibleItems = this.data?.reduce(
      (accum, _, datumIndex) => accum + (legendManager.getItemEnabled({ seriesId, itemId: datumIndex }) ? 1 : 0),
      0
    );
    return visibleItems != null && visibleItems > 1;
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0 };
  }
  connectorEnabled() {
    return true;
  }
  barStyle() {
    return {
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 0,
      lineDash: [],
      lineDashOffset: 0,
      fillGradientDefaults: this.properties.fillGradientDefaults,
      fillPatternDefaults: this.properties.fillPatternDefaults,
      fillImageDefaults: this.properties.fillImageDefaults
    };
  }
  connectorStyle() {
    const {
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.properties;
    return {
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    };
  }
  nodeFactory() {
    return new Line6();
  }
  createLabelData({
    datumIndex,
    rect,
    barAlongX,
    yDatum,
    datum,
    visible
  }) {
    const { stageKey, valueKey, label } = this.properties;
    const { spacing, placement } = label;
    if (!label.enabled)
      return;
    let x;
    let y;
    let textAlign;
    let textBaseline;
    if (barAlongX) {
      x = rect.x + rect.width / 2;
      textAlign = "center";
      switch (placement) {
        case "before":
          y = rect.y - spacing;
          textBaseline = "bottom";
          break;
        case "after":
          y = rect.y + rect.height + spacing;
          textBaseline = "top";
          break;
        default:
          y = rect.y + rect.height / 2;
          textBaseline = "middle";
      }
    } else {
      y = rect.y + rect.height / 2;
      textBaseline = "middle";
      switch (placement) {
        case "before":
          x = rect.x - spacing;
          textAlign = "right";
          break;
        case "after":
          x = rect.x + rect.width + spacing;
          textAlign = "left";
          break;
        default:
          x = rect.x + rect.width / 2;
          textAlign = "center";
      }
    }
    const yDomain = this.getSeriesDomain(ChartAxisDirection25.Y);
    const text2 = this.getLabelText(
      yDatum,
      datum,
      valueKey,
      "y",
      yDomain,
      label,
      { itemId: valueKey, value: yDatum, datum, stageKey, valueKey }
    );
    return {
      x,
      y,
      textAlign,
      textBaseline,
      text: text2,
      itemId: valueKey,
      datum,
      datumIndex,
      series: this,
      visible
    };
  }
  updateDatumNodes(opts) {
    const highlightStyle = this.getHighlightStyle(opts.isHighlight);
    opts.datumSelection.each((line, datum) => {
      line.setProperties(resetLineSelectionsFn(line, datum));
      line.stroke = highlightStyle?.stroke;
      line.strokeWidth = highlightStyle?.strokeWidth ?? 0;
      line.strokeOpacity = highlightStyle?.strokeOpacity ?? 1;
      line.lineDash = highlightStyle?.lineDash;
      line.lineDashOffset = highlightStyle?.lineDashOffset ?? 0;
      line.opacity = highlightStyle?.opacity ?? 1;
    });
  }
  tooltipStyle(_datum, datumIndex) {
    const { fills, strokes } = this.properties;
    const fill = fills[datumIndex % fills.length] ?? "black";
    const stroke22 = strokes[datumIndex % strokes.length] ?? "black";
    const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.barStyle();
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset
    };
  }
  hasItemStylers() {
    return this.properties.label.itemStyler != null;
  }
};
ConeFunnelSeries.className = "ConeFunnelSeries";
ConeFunnelSeries.type = "cone-funnel";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs9, coneFunnelSeriesThemeableOptionsDef: coneFunnelSeriesThemeableOptionsDef2, without: without3 } = module_support_exports;
var coneFunnelSeriesOptionsDef = {
  ...without3(commonSeriesOptionsDefs9, ["showInLegend"]),
  ...coneFunnelSeriesThemeableOptionsDef2,
  type: required(constant("cone-funnel")),
  stageKey: required(string),
  valueKey: required(string)
};
var {
  ThemeConstants: { CARTESIAN_AXIS_TYPE: CARTESIAN_AXIS_TYPE8 }
} = module_support_exports;
var CONE_FUNNEL_SERIES_THEME = {
  series: {
    direction: "vertical",
    fills: {
      $if: [
        { $eq: [{ $palette: "type" }, "inbuilt"] },
        { $palette: "secondSequentialColors" },
        module_support_exports.SAFE_RANGE2_OPERATION
      ]
    },
    strokes: {
      $if: [
        { $eq: [{ $palette: "type" }, "inbuilt"] },
        { $palette: "secondSequentialColors" },
        module_support_exports.SAFE_RANGE2_OPERATION
      ]
    },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    strokeWidth: { $isUserOption: ["./strokes/0", 2, 0] },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" },
      placement: "before",
      spacing: 4
    },
    tooltip: {
      range: { $path: ["/tooltip/range", "nearest"] }
    },
    highlight: module_support_exports.singleSeriesHighlightStyle(false)
  },
  seriesArea: {
    padding: {
      top: 20,
      bottom: 20
    }
  },
  axes: {
    [CARTESIAN_AXIS_TYPE8.NUMBER]: {
      nice: false,
      gridLine: {
        enabled: false
      },
      crosshair: {
        enabled: false
      },
      label: {
        enabled: false
      }
    },
    [CARTESIAN_AXIS_TYPE8.CATEGORY]: {
      line: {
        enabled: false
      }
    }
  }
};
var ConeFunnelModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "cone-funnel",
  moduleFactory: (ctx) => new ConeFunnelSeries(ctx),
  solo: true,
  defaultAxes: FUNNEL_SERIES_AXES,
  themeTemplate: CONE_FUNNEL_SERIES_THEME
};
var ConeFunnelSeriesModule = {
  type: "series",
  name: "cone-funnel",
  chartType: "cartesian",
  enterprise: true,
  options: coneFunnelSeriesOptionsDef,
  create: (ctx) => new ConeFunnelSeries(ctx)
};
var {
  FillGradientDefaults: FillGradientDefaults9,
  FillPatternDefaults: FillPatternDefaults9,
  FillImageDefaults: FillImageDefaults9,
  Label: Label8,
  DropShadow: DropShadow4,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties6,
  BaseProperties: BaseProperties24,
  makeSeriesTooltip: makeSeriesTooltip10,
  AxisLabel: AxisLabel4,
  Property: Property67
} = module_support_exports;
var FunnelSeriesLabel = class extends Label8 {
};
var FunnelSeriesStageLabel = class extends AxisLabel4 {
};
__decorateClass2([
  Property67
], FunnelSeriesStageLabel.prototype, "placement", 2);
var FunnelDropOff = class extends BaseProperties24 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.fill = void 0;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "enabled", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "fill", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "fillOpacity", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "stroke", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "strokeWidth", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "lineDash", 2);
__decorateClass2([
  Property67
], FunnelDropOff.prototype, "lineDashOffset", 2);
var FunnelProperties = class extends AbstractBarSeriesProperties6 {
  constructor() {
    super(...arguments);
    this.fills = [];
    this.fillGradientDefaults = new FillGradientDefaults9();
    this.fillPatternDefaults = new FillPatternDefaults9();
    this.fillImageDefaults = new FillImageDefaults9();
    this.fillOpacity = 1;
    this.strokes = [];
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.spacingRatio = 0;
    this.dropOff = new FunnelDropOff();
    this.shadow = new DropShadow4().set({ enabled: false });
    this.label = new FunnelSeriesLabel();
    this.stageLabel = new FunnelSeriesStageLabel();
    this.tooltip = makeSeriesTooltip10();
  }
  getStyle(index) {
    const { fills, strokes, fillOpacity, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      fill: fills[index % fills.length],
      fillOpacity,
      stroke: strokes[index % strokes.length],
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property67
], FunnelProperties.prototype, "stageKey", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "valueKey", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "fills", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "strokes", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "spacingRatio", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "dropOff", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "shadow", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "label", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "stageLabel", 2);
__decorateClass2([
  Property67
], FunnelProperties.prototype, "tooltip", 2);
var {
  ChartAxisDirection: ChartAxisDirection26,
  resetBarSelectionsFn: resetBarSelectionsFn3,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions3,
  midpointStartingBarPosition: midpointStartingBarPosition22,
  createDatumId: createDatumId8,
  Rect: Rect7,
  motion: motion5,
  applyShapeStyle: applyShapeStyle9,
  getShapeStyle: getShapeStyle8,
  mergeDefaults: mergeDefaults11
} = module_support_exports;
var FunnelSeries = class extends BaseFunnelSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      animationResetFns: {
        datum: resetBarSelectionsFn3
      }
    });
    this.properties = new FunnelProperties();
  }
  getBandScalePadding() {
    return { inner: this.properties.spacingRatio, outer: 0 };
  }
  connectorEnabled() {
    return this.properties.dropOff.enabled;
  }
  barStyle() {
    const {
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.properties;
    return {
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    };
  }
  connectorStyle() {
    const { fill, fillOpacity, stroke: stroke22, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties.dropOff;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: this.properties.fillGradientDefaults,
      fillPatternDefaults: this.properties.fillPatternDefaults,
      fillImageDefaults: this.properties.fillImageDefaults
    };
  }
  nodeFactory() {
    return new Rect7();
  }
  createLabelData({
    datumIndex,
    rect,
    yDatum,
    datum,
    visible
  }) {
    const { valueKey, stageKey, label } = this.properties;
    if (!label.enabled)
      return;
    const yDomain = this.getSeriesDomain(ChartAxisDirection26.Y);
    const text2 = this.getLabelText(
      yDatum,
      datum,
      valueKey,
      "y",
      yDomain,
      label,
      { itemId: valueKey, value: yDatum, datum, stageKey, valueKey }
    );
    return {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2,
      textAlign: "center",
      textBaseline: "middle",
      text: text2,
      itemId: stageKey,
      datum,
      datumIndex,
      series: this,
      visible
    };
  }
  getItemStyle({ datum }, datumIndex, isHighlight) {
    const { id: seriesId, properties } = this;
    const { stageKey, valueKey, itemStyler } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults11(highlightStyle, properties.getStyle(datumIndex));
    let style2 = getShapeStyle8(
      baseStyle,
      properties.fillGradientDefaults,
      properties.fillPatternDefaults,
      properties.fillImageDefaults
    );
    if (itemStyler != null) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId8(datumIndex, isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            stageKey,
            valueKey,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle8(
          mergeDefaults11(overrides, style2),
          properties.fillGradientDefaults,
          properties.fillPatternDefaults,
          properties.fillImageDefaults
        );
      }
    }
    return style2;
  }
  updateDatumNodes(opts) {
    const { shadow } = this.properties;
    const { datumSelection, isHighlight } = opts;
    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection26.X;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((rect, datum) => {
      const { datumIndex } = datum;
      const style2 = this.getItemStyle(datum, datumIndex, isHighlight);
      applyShapeStyle9(rect, style2, fillBBox);
      rect.visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
    });
  }
  tooltipStyle(datum, datumIndex) {
    return this.getItemStyle({ datumIndex, datum }, datumIndex, false);
  }
  animateEmptyUpdateReady(params) {
    super.animateEmptyUpdateReady(params);
    const { datumSelection } = params;
    const isVertical = this.isVertical();
    const mode = "normal";
    const barFns = prepareBarAnimationFunctions3(midpointStartingBarPosition22(isVertical, mode));
    motion5.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], barFns);
  }
  animateWaitingUpdateReady(data) {
    super.animateWaitingUpdateReady(data);
    const { datumSelection: datumSelections } = data;
    const { processedData } = this;
    const dataDiff = processedData?.reduced?.diff?.[this.id];
    const fns = prepareBarAnimationFunctions3(midpointStartingBarPosition22(this.isVertical(), "fade"));
    motion5.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [datumSelections],
      fns,
      (_, datum) => datum.xValue,
      dataDiff
    );
  }
  hasItemStylers() {
    return this.properties.itemStyler != null || this.properties.label.itemStyler != null;
  }
};
FunnelSeries.className = "FunnelSeries";
FunnelSeries.type = "funnel";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs10, funnelSeriesThemeableOptionsDef: funnelSeriesThemeableOptionsDef2, without: without4 } = module_support_exports;
var funnelSeriesOptionsDef = {
  ...funnelSeriesThemeableOptionsDef2,
  ...without4(commonSeriesOptionsDefs10, ["showInLegend"]),
  type: required(constant("funnel")),
  stageKey: required(string),
  valueKey: required(string)
};
var FunnelModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "funnel",
  moduleFactory: (ctx) => new FunnelSeries(ctx),
  solo: true,
  defaultAxes: FUNNEL_SERIES_AXES,
  themeTemplate: FUNNEL_SERIES_THEME
};
var FunnelSeriesModule = {
  type: "series",
  name: "funnel",
  chartType: "cartesian",
  enterprise: true,
  options: funnelSeriesOptionsDef,
  create: (ctx) => new FunnelSeries(ctx)
};
var DatumUnion = class {
  *[Symbol.iterator]() {
    const { node, datum } = this;
    if (node && datum)
      yield { node, datum };
  }
  nodes() {
    return this.node ? [this.node] : [];
  }
  update(datumSelection, group, ctor, nodeUpdater) {
    const nodes = datumSelection.nodes();
    if (nodes.length === 0) {
      this.node?.remove();
      this.node = void 0;
    } else {
      if (this.node === void 0) {
        this.node = new ctor();
        this.node.fillOpacity = 0;
        this.node.strokeOpacity = 0;
        group.appendChild(this.node);
      }
      const first2 = nodes[0];
      const last = nodes.toReversed().find((n) => n.datum.datum.value > n.datum.datum.segmentStart) ?? nodes[nodes.length - 1];
      this.node.datum = this.datum = first2.datum;
      nodeUpdater(this.node, first2, last);
    }
  }
};
var fadeInFns = {
  fromFn: () => ({ opacity: 0, phase: "initial" }),
  toFn: () => ({ opacity: 1 })
};
function formatLabel(value, scale2) {
  if (value == null)
    return "";
  const { min, max } = scale2;
  const minLog10 = min !== 0 ? Math.ceil(Math.log10(Math.abs(min))) : 0;
  const maxLog10 = max !== 0 ? Math.ceil(Math.log10(Math.abs(max))) : 0;
  const dp = Math.max(2 - Math.max(minLog10, maxLog10), 0);
  return value.toFixed(dp);
}
function getLabelText(seriesId, ctx, datum, valueOverride) {
  if (datum.text != null)
    return datum.text;
  const value = valueOverride ?? datum.value;
  let labelFormat;
  if (datum?.formatter != null) {
    labelFormat = formatWithContext(ctx, datum.formatter, { seriesId, datum: void 0, value });
  }
  if (labelFormat != null)
    return String(labelFormat);
}
function lineMarker({ path, x, y, size }) {
  path.moveTo(x, y - size / 2);
  path.lineTo(x, y + size / 2);
}
function pickGaugeNearestDatum(self, point) {
  const it = iterate(self.datumUnion.nodes(), self.targetSelection.nodes());
  return self.pickNodeNearestDistantObject(point, it);
}
function pickGaugeFocus(self, opts) {
  const others = [
    { data: self.contextNodeData?.nodeData, selection: self.datumUnion },
    { data: self.contextNodeData?.targetData, selection: self.targetSelection }
  ].filter((v) => v.data && v.data.length > 0);
  const otherIndex = clamp(0, opts.otherIndex + opts.otherIndexDelta, others.length - 1);
  if (others.length === 0)
    return;
  const { data, selection } = others[otherIndex];
  if (data == null || data.length === 0)
    return;
  const datumIndex = clamp(0, opts.datumIndex, data.length - 1);
  const datum = data[datumIndex];
  for (const node of selection) {
    if (node.datum === datum) {
      const bounds = node.node;
      return { bounds, clipFocusBox: true, datum, datumIndex, otherIndex };
    }
  }
}
var { BaseProperties: BaseProperties25, Property: Property68 } = module_support_exports;
var GaugeSegmentationIntervalProperties = class extends BaseProperties25 {
  getSegments(scale2, maxTicks) {
    const { values, step, count } = this;
    const d0 = Math.min(...scale2.domain);
    const d1 = Math.max(...scale2.domain);
    let ticks;
    if (values != null) {
      const segments = values.filter((v) => v > d0 && v < d1).sort((a, b) => a - b);
      ticks = [d0, ...segments, d1];
    } else if (step != null) {
      const segments = [];
      for (let i = d0; i < d1; i += step) {
        segments.push(i);
      }
      segments.push(d1);
      ticks = segments;
    } else if (count != null) {
      const segments = count + 1;
      ticks = Array.from({ length: segments + 1 }, (_, i) => i / segments * (d1 - d0) + d0);
    } else {
      const segments = scale2.ticks({
        nice: true,
        interval: void 0,
        tickCount: void 0,
        minTickCount: 0,
        maxTickCount: Infinity
      })?.ticks?.filter((v) => v > d0 && v < d1);
      ticks = segments != null ? [d0, ...segments, d1] : void 0;
    }
    if (ticks != null && ticks.length > maxTicks) {
      logger_exports.warnOnce(
        `the configured segmentation results in more than 1 item per pixel, ignoring. Supply a segmentation configuration that results in larger segments or omit this configuration`
      );
      ticks = void 0;
    }
    ticks ?? (ticks = [d0, d1]);
    return ticks;
  }
};
__decorateClass2([
  Property68
], GaugeSegmentationIntervalProperties.prototype, "values", 2);
__decorateClass2([
  Property68
], GaugeSegmentationIntervalProperties.prototype, "step", 2);
__decorateClass2([
  Property68
], GaugeSegmentationIntervalProperties.prototype, "count", 2);
var GaugeSegmentationProperties = class extends BaseProperties25 {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.interval = new GaugeSegmentationIntervalProperties();
    this.spacing = 0;
  }
};
__decorateClass2([
  Property68
], GaugeSegmentationProperties.prototype, "enabled", 2);
__decorateClass2([
  Property68
], GaugeSegmentationProperties.prototype, "interval", 2);
__decorateClass2([
  Property68
], GaugeSegmentationProperties.prototype, "spacing", 2);
var { BaseProperties: BaseProperties26, makeSeriesTooltip: makeSeriesTooltip11, SeriesProperties: SeriesProperties22, PropertiesArray: PropertiesArray7, Property: Property69, Label: Label9, AxisLabel: AxisLabel5 } = module_support_exports;
var LinearGaugeDefaultTargetLabelProperties = class extends Label9 {
};
__decorateClass2([
  Property69
], LinearGaugeDefaultTargetLabelProperties.prototype, "spacing", 2);
var LinearGaugeTargetProperties = class extends BaseProperties26 {
  constructor() {
    super(...arguments);
    this.value = 0;
    this.label = new LinearGaugeDefaultTargetLabelProperties();
  }
};
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "text", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "value", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "shape", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "placement", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "spacing", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "size", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "rotation", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "fill", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "stroke", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property69
], LinearGaugeTargetProperties.prototype, "label", 2);
var LinearGaugeBarProperties = class extends BaseProperties26 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.thicknessRatio = 1;
    this.fills = new PropertiesArray7(module_support_exports.StopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "enabled", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "thickness", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "thicknessRatio", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "fills", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "fillMode", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "fill", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "stroke", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property69
], LinearGaugeBarProperties.prototype, "lineDashOffset", 2);
var LinearGaugeScaleIntervalProperties = class extends BaseProperties26 {
  constructor() {
    super(...arguments);
    this.values = void 0;
    this.step = void 0;
    this.minSpacing = 0;
    this.maxSpacing = 1e3;
  }
};
__decorateClass2([
  Property69
], LinearGaugeScaleIntervalProperties.prototype, "values", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleIntervalProperties.prototype, "step", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleIntervalProperties.prototype, "minSpacing", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleIntervalProperties.prototype, "maxSpacing", 2);
var LinearGaugeScaleLabelProperties = class extends AxisLabel5 {
  constructor() {
    super(...arguments);
    this.placement = void 0;
  }
};
__decorateClass2([
  Property69
], LinearGaugeScaleLabelProperties.prototype, "placement", 2);
var LinearGaugeScaleProperties = class extends BaseProperties26 {
  constructor() {
    super(...arguments);
    this.min = 0;
    this.max = 1;
    this.fills = new PropertiesArray7(module_support_exports.StopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.defaultFill = "black";
    this.interval = new LinearGaugeScaleIntervalProperties();
    this.label = new LinearGaugeScaleLabelProperties();
  }
};
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "min", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "max", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "fills", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "fillMode", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "fill", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "stroke", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "defaultFill", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "interval", 2);
__decorateClass2([
  Property69
], LinearGaugeScaleProperties.prototype, "label", 2);
var LinearGaugeLabelProperties = class extends AutoSizedLabel {
  constructor() {
    super(...arguments);
    this.placement = "inside-center";
    this.avoidCollisions = true;
  }
};
__decorateClass2([
  Property69
], LinearGaugeLabelProperties.prototype, "text", 2);
__decorateClass2([
  Property69
], LinearGaugeLabelProperties.prototype, "placement", 2);
__decorateClass2([
  Property69
], LinearGaugeLabelProperties.prototype, "avoidCollisions", 2);
var LinearGaugeSeriesProperties = class extends SeriesProperties22 {
  constructor() {
    super(...arguments);
    this.value = 0;
    this.segmentation = new GaugeSegmentationProperties();
    this.defaultColorRange = [];
    this.targets = new PropertiesArray7(LinearGaugeTargetProperties);
    this.defaultTarget = new LinearGaugeTargetProperties();
    this.defaultScale = new LinearGaugeScaleProperties();
    this.direction = "vertical";
    this.thickness = 1;
    this.cornerRadius = 0;
    this.cornerMode = "container";
    this.margin = 0;
    this.scale = new LinearGaugeScaleProperties();
    this.bar = new LinearGaugeBarProperties();
    this.label = new LinearGaugeLabelProperties();
    this.tooltip = makeSeriesTooltip11();
  }
};
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "value", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "segmentation", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "targets", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "defaultTarget", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "defaultScale", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "direction", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "thickness", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "cornerMode", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "margin", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "scale", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "bar", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property69
], LinearGaugeSeriesProperties.prototype, "tooltip", 2);
var { CachedTextMeasurerPool: CachedTextMeasurerPool6, BBox: BBox18 } = module_support_exports;
function datumRect(datum) {
  const { x0, y0, x1, y1, horizontalInset, verticalInset } = datum;
  const x = Math.min(x0, x1) + horizontalInset;
  const y = Math.min(y0, y1) + verticalInset;
  const width2 = Math.max(Math.abs(x1 - x0) - 2 * horizontalInset, 0);
  const height2 = Math.max(Math.abs(y1 - y0) - 2 * verticalInset, 0);
  return { x, y, width: width2, height: height2 };
}
function clipBBoxVisibility(datum, clipBBox) {
  if (clipBBox == null)
    return true;
  const rect = datumRect(datum);
  const delta32 = 1e-6;
  const x0 = rect.x + delta32;
  const y0 = rect.y + delta32;
  const x1 = rect.x + rect.width - delta32;
  const y1 = rect.y + rect.height - delta32;
  const clipX0 = clipBBox.x;
  const clipX1 = clipBBox.x + clipBBox.width;
  const clipY0 = clipBBox.y;
  const clipY1 = clipBBox.y + clipBBox.height;
  return Math.max(x0, clipX0) <= Math.min(x1, clipX1) && Math.max(y0, clipY0) <= Math.min(y1, clipY1);
}
function hasClipBBox(datum) {
  const { clipX0, clipX1, clipY0, clipY1 } = datum;
  return clipX0 != null && clipX1 != null || clipY0 != null && clipY1 != null;
}
function computeClipBBox(datum) {
  if (!hasClipBBox(datum))
    return;
  const { x0, y0, x1, y1 } = datum;
  const { x, y, width: width2, height: height2 } = datumRect(datum);
  let { clipX0, clipX1, clipY0, clipY1 } = datum;
  if (clipX0 == null || clipX1 == null) {
    clipX0 = x0;
    clipX1 = x1;
  }
  if (clipY0 == null || clipY1 == null) {
    clipY0 = y0;
    clipY1 = y1;
  }
  const clipX = Math.min(clipX0, clipX1);
  const clipY = Math.min(clipY0, clipY1);
  const clipWidth = Math.abs(clipX1 - clipX0);
  const clipHeight = Math.abs(clipY1 - clipY0);
  clipX0 = Math.max(x, clipX);
  clipY0 = Math.max(y, clipY);
  clipX1 = Math.min(x + width2, clipX + clipWidth);
  clipY1 = Math.min(y + height2, clipY + clipHeight);
  return new BBox18(
    Math.min(clipX0, clipX1),
    Math.min(clipY0, clipY1),
    Math.abs(clipX1 - clipX0),
    Math.abs(clipY1 - clipY0)
  );
}
function prepareLinearGaugeSeriesAnimationFunctions(initialLoad, horizontal) {
  const phase = initialLoad ? "initial" : "update";
  const node = {
    fromFn(sect, datum) {
      const previousDatum = sect.previousDatum;
      let { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1 } = previousDatum ?? datum;
      const { horizontalInset, verticalInset } = datum;
      const previousHadClipBBox = previousDatum != null && hasClipBBox(previousDatum);
      const nextHasClipBBox = hasClipBBox(datum);
      if (previousHadClipBBox && nextHasClipBBox) {
      } else if (!previousHadClipBBox && nextHasClipBBox) {
        ({ x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1 } = datum);
        if (initialLoad) {
          if (horizontal) {
            clipX1 = datum.clipX0;
          } else {
            clipY1 = datum.clipY0;
          }
        }
      } else if (previousHadClipBBox && !nextHasClipBBox) {
        ({ x0, y0, x1, y1 } = datum);
        clipX0 = void 0;
        clipY0 = void 0;
        clipX1 = void 0;
        clipY1 = void 0;
      } else if (initialLoad) {
        if (horizontal) {
          x1 = x0;
        } else {
          y1 = y0;
        }
      }
      return { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1, horizontalInset, verticalInset, phase };
    },
    toFn(_sect, datum) {
      const { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1, horizontalInset, verticalInset } = datum;
      return { x0, y0, x1, y1, clipX0, clipY0, clipX1, clipY1, horizontalInset, verticalInset };
    },
    applyFn(rect, params) {
      rect.setProperties(resetLinearGaugeSeriesResetRectFunction(rect, params));
    }
  };
  return { node };
}
function resetLinearGaugeSeriesResetRectFunction(_node, datum) {
  const { x, y, width: width2, height: height2 } = datumRect(datum);
  const clipBBox = computeClipBBox(datum);
  const visible = clipBBoxVisibility(datum, clipBBox);
  return { x, y, width: width2, height: height2, clipBBox, visible };
}
var horizontalTextAligns = {
  [
    "Before"
    /* Before */
  ]: "right",
  [
    "Center"
    /* Center */
  ]: "center",
  [
    "After"
    /* After */
  ]: "left"
};
var verticalTextBaselines = {
  [
    "Before"
    /* Before */
  ]: "top",
  [
    "Center"
    /* Center */
  ]: "middle",
  [
    "After"
    /* After */
  ]: "bottom"
};
var horizontalAlignFactors = {
  [
    "Before"
    /* Before */
  ]: -1,
  [
    "Center"
    /* Center */
  ]: -0.5,
  [
    "After"
    /* After */
  ]: 0
};
var verticalAlignFactors2 = {
  [
    "Before"
    /* Before */
  ]: 0,
  [
    "Center"
    /* Center */
  ]: -0.5,
  [
    "After"
    /* After */
  ]: -1
};
function formatLinearGaugeLabels(series, ctx, selection, opts, bboxes, datumOverrides) {
  const { seriesRect, gaugeRect, barRect } = bboxes;
  const { padding: padding2, horizontal } = opts;
  selection.each((label, labelDatum) => {
    const labelText = getLabelText(series.id, ctx, labelDatum, datumOverrides?.label);
    let boundingWidth;
    let boundingHeight;
    if (labelDatum.placement === "outside-start") {
      if (horizontal) {
        boundingWidth = gaugeRect.x;
        boundingHeight = seriesRect.height;
      } else {
        boundingWidth = seriesRect.width;
        boundingHeight = seriesRect.height - (gaugeRect.y + gaugeRect.height);
      }
    } else if (labelDatum.placement === "outside-end") {
      if (horizontal) {
        boundingWidth = seriesRect.width - (gaugeRect.x + gaugeRect.width);
        boundingHeight = seriesRect.height;
      } else {
        boundingWidth = seriesRect.width;
        boundingHeight = gaugeRect.y;
      }
    } else if (labelDatum.avoidCollisions) {
      boundingWidth = gaugeRect.width;
      boundingHeight = gaugeRect.height;
    }
    let layout;
    if (labelText == null) {
      return;
    } else if (boundingWidth != null && boundingHeight != null) {
      const sizeFittingHeight = () => ({
        width: boundingWidth,
        height: boundingHeight,
        meta: null
      });
      const labelMeta = formatSingleLabel(labelText, labelDatum, { padding: padding2 }, sizeFittingHeight);
      layout = labelMeta?.[0];
    } else {
      const font22 = {
        fontSize: labelDatum.fontSize,
        fontStyle: labelDatum.fontStyle,
        fontWeight: labelDatum.fontWeight,
        fontFamily: labelDatum.fontFamily,
        lineHeight: labelDatum.lineHeight
      };
      const { width: width2, height: height2 } = CachedTextMeasurerPool6.measureText(labelText, { font: font22 });
      layout = {
        text: labelText,
        fontSize: labelDatum.fontSize,
        lineHeight: getLineHeight(labelDatum, labelDatum.fontSize),
        width: width2,
        height: height2
      };
    }
    if (layout == null) {
      label.visible = false;
      return;
    }
    const scale0 = horizontal ? gaugeRect.x : gaugeRect.y + gaugeRect.height;
    const scale1 = horizontal ? gaugeRect.x + gaugeRect.width : gaugeRect.y;
    const bar0 = horizontal ? barRect.x : barRect.y + barRect.height;
    const bar1 = horizontal ? barRect.x + barRect.width : barRect.y;
    const offset = labelDatum.spacing * (horizontal ? 1 : -1);
    let bounds0;
    let bounds1;
    let s;
    let align2;
    switch (labelDatum.placement) {
      case "outside-start":
        bounds0 = -Infinity;
        bounds1 = Infinity;
        s = scale0 - offset;
        align2 = "Before";
        break;
      case "outside-end":
        bounds0 = -Infinity;
        bounds1 = Infinity;
        s = scale1 + offset;
        align2 = "After";
        break;
      case "inside-start":
        bounds0 = scale0;
        bounds1 = bar1;
        s = scale0 + offset;
        align2 = "After";
        break;
      case "inside-end":
        bounds0 = bar1;
        bounds1 = scale1;
        s = scale1 - offset;
        align2 = "Before";
        break;
      case "inside-center":
        bounds0 = scale0;
        bounds1 = scale1;
        s = (scale0 + scale1) / 2;
        align2 = "Center";
        break;
      case "bar-inside":
        bounds0 = bar0;
        bounds1 = bar1;
        s = (bar0 + bar1) / 2;
        align2 = "Center";
        break;
      case "bar-inside-end":
        bounds0 = bar0;
        bounds1 = bar1;
        s = bar1 - offset;
        align2 = "Before";
        break;
      case "bar-outside-end":
        bounds0 = bar1;
        bounds1 = scale1;
        s = bar1 + offset;
        align2 = "After";
        break;
      case "bar-end":
        bounds0 = -Infinity;
        bounds1 = Infinity;
        s = bar1;
        align2 = "Center";
        break;
    }
    const x = horizontal ? s : gaugeRect.x + gaugeRect.width / 2;
    const y = horizontal ? gaugeRect.y + gaugeRect.height / 2 : s;
    let s0;
    let s1;
    if (horizontal) {
      s0 = x + horizontalAlignFactors[align2] * layout.width;
      s1 = s0 + layout.width;
    } else {
      s0 = y + verticalAlignFactors2[align2] * layout.height;
      s1 = s0 + layout.height;
    }
    const inside = Math.min(s0, s1) >= Math.min(bounds0, bounds1) && Math.max(s0, s1) <= Math.max(bounds0, bounds1);
    if (labelDatum.avoidCollisions && !inside) {
      label.visible = false;
      return;
    }
    label.visible = true;
    label.text = layout.text;
    label.fontSize = layout.fontSize;
    label.lineHeight = layout.lineHeight;
    label.textAlign = horizontal ? horizontalTextAligns[align2] : "center";
    label.textBaseline = horizontal ? "middle" : verticalTextBaselines[align2];
    label.x = x;
    label.y = y;
  });
}
var {
  fromToMotion: fromToMotion22,
  resetMotion: resetMotion3,
  SeriesNodePickMode: SeriesNodePickMode8,
  StateMachine: StateMachine12,
  createDatumId: createDatumId9,
  CachedTextMeasurerPool: CachedTextMeasurerPool7,
  toRadians: toRadians4,
  BBox: BBox19,
  Group: Group11,
  PointerEvents: PointerEvents5,
  Selection: Selection8,
  Rect: Rect8,
  Text: Text3,
  TransformableText: TransformableText22,
  Marker: Marker3,
  LinearScale: LinearScale4,
  AxisTickGenerator: AxisTickGenerator22,
  NiceMode: NiceMode2,
  easing,
  getColorStops: getColorStops2,
  findRangeExtent: findRangeExtent22,
  tickFormat: tickFormat2,
  mergeDefaults: mergeDefaults12,
  applyShapeStyle: applyShapeStyle10
} = module_support_exports;
var horizontalTargetPlacementRotation = {
  before: 180,
  middle: 0,
  after: 0
};
var verticalTargetPlacementRotation = {
  before: 90,
  middle: 0,
  after: -90
};
var LinearGaugeAxis = class {
  constructor(gauge2, ctx) {
    this.gauge = gauge2;
    this.ctx = ctx;
  }
  get scale() {
    return this.gauge.scale;
  }
  get label() {
    return this.gauge.properties.scale.label;
  }
  get interval() {
    return this.gauge.properties.scale.interval;
  }
  tickFormatter(domain, ticks, _primary, _fractionDigits, _timeInterval) {
    const { format } = this.label;
    let tickFormatter;
    if (format != null) {
      tickFormatter = tickFormat2(ticks, typeof format === "string" ? format : void 0);
    }
    return (value, index) => {
      const { formatter: formatter2 } = this.label;
      let r = void 0;
      if (formatter2) {
        r ?? (r = formatWithContext(this.ctx, formatter2, { value, index, domain, boundSeries: void 0 }));
      }
      r ?? (r = tickFormatter?.(value));
      return r ?? this.gauge.formatLabel(value);
    };
  }
  inRange() {
    return true;
  }
};
var LinearGaugeSeries = class extends module_support_exports.Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode8.EXACT_SHAPE_MATCH, SeriesNodePickMode8.NEAREST_NODE]
    });
    this.properties = new LinearGaugeSeriesProperties();
    this.seriesRect = BBox19.NaN;
    this.gaugeRect = BBox19.NaN;
    this.scale = new LinearScale4();
    this.originX = 0;
    this.originY = 0;
    this.scaleGroup = this.contentGroup.appendChild(new Group11({ name: "scaleGroup" }));
    this.itemGroup = this.contentGroup.appendChild(new Group11({ name: "itemGroup" }));
    this.itemTargetGroup = this.contentGroup.appendChild(new Group11({ name: "itemTargetGroup" }));
    this.itemTargetLabelGroup = this.contentGroup.appendChild(new Group11({ name: "itemTargetLabelGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group11({ name: "itemLabelGroup" }));
    this.highlightTargetGroup = this.highlightGroup.appendChild(
      new Group11({ name: "itemTargetLabelGroup" })
    );
    this.tickGroup = this.contentGroup.appendChild(new Group11({ name: "tickGroup" }));
    this.scaleSelection = Selection8.select(
      this.scaleGroup,
      () => this.nodeFactory()
    );
    this.datumSelection = Selection8.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.targetSelection = Selection8.select(
      this.itemTargetGroup,
      () => this.markerFactory()
    );
    this.targetLabelSelection = Selection8.select(this.itemTargetLabelGroup, Text3);
    this.labelSelection = Selection8.select(
      this.itemLabelGroup,
      Text3
    );
    this.highlightTargetSelection = Selection8.select(this.highlightTargetGroup, () => this.markerFactory());
    this.tickSelection = Selection8.select(this.tickGroup, TransformableText22);
    this.datumUnion = new DatumUnion();
    this.axis = new LinearGaugeAxis(this, moduleCtx);
    this.tickGenerator = new AxisTickGenerator22(this.axis);
    this.animationState = new StateMachine12("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.animateEmptyUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      ready: {
        updateData: "waiting",
        clear: "clearing",
        resize: () => this.animateReadyResize(),
        reset: "empty",
        skip: "ready"
      },
      waiting: {
        update: {
          target: "ready",
          action: () => this.animateWaitingUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      clearing: {
        update: {
          target: "empty"
        },
        reset: "empty",
        skip: "ready"
      }
    });
    this.scaleGroup.pointerEvents = PointerEvents5.None;
    this.tickGroup.pointerEvents = PointerEvents5.None;
  }
  get range() {
    return this.horizontal ? [0, this.gaugeRect.width] : [0, this.gaugeRect.height];
  }
  get horizontal() {
    return this.properties.direction === "horizontal";
  }
  get hasData() {
    return true;
  }
  nodeFactory() {
    const rect = new Rect8();
    rect.crisp = true;
    return rect;
  }
  markerFactory() {
    return new Marker3();
  }
  processData() {
    this.nodeDataRefresh = true;
    this.animationState.transition("updateData");
  }
  formatLabel(value) {
    return formatLabel(value, this.properties.scale);
  }
  createLinearGradient(scale2, fills, fillMode) {
    const { properties, horizontal } = this;
    const { defaultColorRange } = properties;
    const colorStops = getColorStops2(fills, defaultColorRange, scale2.domain, fillMode);
    return {
      type: "gradient",
      gradient: "linear",
      colorSpace: "oklch",
      colorStops,
      rotation: horizontal ? 90 : 0
    };
  }
  getShapeFillBBox() {
    const { properties, originX, originY, horizontal, scale: scale2 } = this;
    const { thickness } = properties;
    const length2 = findRangeExtent22(scale2.range);
    return new BBox19(originX, originY, horizontal ? length2 : thickness, horizontal ? thickness : length2);
  }
  getTargets() {
    const { properties } = this;
    const defaultTarget = properties.defaultTarget;
    return Array.from(properties.targets).map((target) => {
      const {
        text: text2 = defaultTarget.text,
        value = defaultTarget.value ?? 0,
        shape = defaultTarget.shape ?? "triangle",
        rotation = defaultTarget.rotation ?? 0,
        strokeWidth = defaultTarget.strokeWidth ?? 0,
        placement = defaultTarget.placement ?? "middle",
        spacing = defaultTarget.spacing ?? 0,
        size = defaultTarget.size ?? 0,
        fill = defaultTarget.fill ?? "black",
        fillOpacity = defaultTarget.fillOpacity ?? 1,
        stroke: stroke22 = defaultTarget.stroke ?? "black",
        strokeOpacity = defaultTarget.strokeOpacity ?? 1,
        lineDash = defaultTarget.lineDash ?? [0],
        lineDashOffset = defaultTarget.lineDashOffset ?? 0
      } = target;
      const {
        enabled: labelEnabled = defaultTarget.label.enabled,
        color: labelColor = defaultTarget.label.color ?? "black",
        fontStyle: labelFontStyle = defaultTarget.label.fontStyle ?? "normal",
        fontWeight: labelFontWeight = defaultTarget.label.fontWeight ?? "normal",
        fontSize: labelFontSize = defaultTarget.label.fontSize,
        fontFamily: labelFontFamily = defaultTarget.label.fontFamily,
        spacing: labelSpacing = defaultTarget.label.spacing ?? 0
      } = target.label;
      return {
        text: text2,
        value,
        shape,
        placement,
        spacing,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        label: {
          enabled: labelEnabled,
          color: labelColor,
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          spacing: labelSpacing
        }
      };
    });
  }
  getTargetPoint(target) {
    const { properties, originX, originY, horizontal, scale: scale2, gaugeRect } = this;
    const { thickness } = properties;
    const { value, placement, spacing, size } = target;
    const mainOffset = scale2.convert(value);
    let crossOffset;
    switch (placement) {
      case "before":
        crossOffset = -(spacing + size / 2);
        break;
      case "after":
        crossOffset = thickness + spacing + size / 2;
        break;
      default:
        crossOffset = thickness / 2;
        break;
    }
    return {
      x: originX + gaugeRect.x + (horizontal ? mainOffset : crossOffset),
      y: originY + gaugeRect.y + (horizontal ? crossOffset : mainOffset)
    };
  }
  getTargetLabel(target) {
    const { size, placement, label } = target;
    const { spacing, color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    const lineHeight = void 0;
    const offset = size / 2 + spacing;
    let textAlign;
    let textBaseline;
    let offsetX = 0;
    let offsetY = 0;
    if (this.horizontal) {
      textAlign = "center";
      if (placement === "after") {
        textBaseline = "top";
        offsetY = offset;
      } else {
        textBaseline = "bottom";
        offsetY = -offset;
      }
    } else {
      textBaseline = "middle";
      if (placement === "before") {
        textAlign = "right";
        offsetX = -offset;
      } else {
        textAlign = "left";
        offsetX = offset;
      }
    }
    return {
      offsetX,
      offsetY,
      fill,
      textAlign,
      textBaseline,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      lineHeight
    };
  }
  labelDatum(label, value) {
    const {
      placement,
      avoidCollisions,
      spacing,
      text: text2,
      color: fill,
      fontSize,
      minimumFontSize,
      fontStyle,
      fontWeight,
      fontFamily,
      lineHeight,
      wrapping,
      overflowStrategy,
      formatter: formatter2 = (params) => this.formatLabel(params.value)
    } = label;
    return {
      placement,
      avoidCollisions,
      spacing,
      text: text2,
      value,
      fill,
      fontSize,
      minimumFontSize,
      fontStyle,
      fontWeight,
      fontFamily,
      lineHeight,
      wrapping,
      overflowStrategy,
      formatter: formatter2
    };
  }
  verticalLabelInset() {
    const { properties } = this;
    const { label } = properties;
    const lines = label.text?.split("\n");
    const labelSize = getLineHeight(label, label.fontSize) * (lines?.length ?? 1);
    return label.spacing + labelSize;
  }
  horizontalLabelInset() {
    const { scale: scale2, properties } = this;
    const { scale: scaleProps, label } = properties;
    const lines = label.text?.split("\n");
    const measurer22 = CachedTextMeasurerPool7.getMeasurer({ font: label });
    const ticks = scaleProps.interval.values ?? scale2.ticks({
      nice: false,
      interval: scaleProps.interval.step,
      minTickCount: 0,
      maxTickCount: 6,
      tickCount: 5
    })?.ticks ?? [];
    const linesOrTicks = lines ?? ticks?.map((tick) => getLabelText(this.id, this.ctx, this.labelDatum(label, tick)) ?? "");
    const labelSize = linesOrTicks.reduce((accum, text2) => {
      const { width: width2 } = measurer22.measureText(text2);
      return Math.max(accum, width2);
    }, 0);
    return label.spacing + labelSize;
  }
  createNodeData() {
    const { id: seriesId, properties, horizontal, scale: scale2, seriesRect } = this;
    const { value, segmentation, thickness, cornerRadius, cornerMode, bar, scale: scaleProps, label } = properties;
    scale2.domain = [scaleProps.min, scaleProps.max];
    scale2.range = horizontal ? [0, seriesRect.width] : [seriesRect.height, 0];
    let parallelFlipRotation;
    let sideFlag;
    if (horizontal) {
      sideFlag = 1;
      parallelFlipRotation = Math.PI / 2;
    } else if (scaleProps.label.placement === "before") {
      sideFlag = 1;
      parallelFlipRotation = 0;
    } else {
      sideFlag = -1;
      parallelFlipRotation = 0;
    }
    const regularFlipRotation = parallelFlipRotation - Math.PI / 2;
    let x0;
    let x1;
    let y0;
    let y1;
    if (horizontal) {
      x0 = 0;
      x1 = seriesRect.width;
      y0 = (seriesRect.height - thickness) / 2;
      y1 = y0 + thickness;
      if (label.placement === "outside-start") {
        x0 += this.horizontalLabelInset();
      } else if (label.placement === "outside-end") {
        x1 -= this.horizontalLabelInset();
      }
    } else {
      x0 = (seriesRect.width - thickness) / 2;
      x1 = x0 + thickness;
      y1 = 0;
      y0 = seriesRect.height;
      if (label.placement === "outside-start") {
        y0 -= this.verticalLabelInset();
      } else if (label.placement === "outside-end") {
        y1 += this.verticalLabelInset();
      }
    }
    this.gaugeRect = new BBox19(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));
    const originX = 0;
    const originY = 0;
    scale2.domain = [scaleProps.min, scaleProps.max];
    scale2.range = horizontal ? [x0, x1] : [y0, y1];
    const { ticks: tickData } = this.tickGenerator.generateTicks({
      domain: scale2.domain,
      range: this.range,
      reverse: false,
      primaryTickCount: void 0,
      defaultTickMinSpacing: 0,
      visibleRange: [0, 1],
      niceMode: NiceMode2.Off,
      labelX: 0,
      parallelFlipRotation,
      regularFlipRotation,
      sideFlag,
      sizeLimit: void 0,
      removeOverflowLabels: false
    }).tickData;
    const isReversed = false;
    const targets = this.getTargets();
    const nodeData = [];
    const targetData = [];
    const labelData = [];
    const scaleData = [];
    const [m0, m1] = scale2.range;
    const mainAxisSize = Math.abs(m1 - m0);
    const containerX = horizontal ? scale2.convert(value) : x1;
    const containerY = horizontal ? y1 : scale2.convert(value);
    const inset = segmentation.enabled ? segmentation.spacing / 2 : 0;
    const horizontalInset = horizontal ? inset : 0;
    const verticalInset = horizontal ? 0 : inset;
    const barThickness = Math.min(bar.thickness ?? Math.round(bar.thicknessRatio * thickness), thickness);
    const barInset = -(thickness - barThickness) / 2;
    const barXInset = horizontal ? 0 : barInset;
    const barYInset = horizontal ? barInset : 0;
    const cornersOnAllItems = cornerMode === "item";
    const maxTicks = Math.ceil(mainAxisSize);
    let segments = segmentation.enabled ? segmentation.interval.getSegments(scale2, maxTicks) : void 0;
    const barFill = bar.fill ?? this.createLinearGradient(scale2, bar.fills, bar.fillMode);
    const scaleFill = scaleProps.fill ?? (bar.enabled && scaleProps.fills.length === 0 ? scaleProps.defaultFill : void 0) ?? this.createLinearGradient(scale2, scaleProps.fills, scaleProps.fillMode);
    if (segments == null && cornersOnAllItems) {
      const segmentStart = Math.min(...scale2.domain);
      const segmentEnd = Math.max(...scale2.domain);
      const datum = { value, segmentStart, segmentEnd };
      if (bar.enabled) {
        const barAppliedCornerRadius = Math.min(cornerRadius, barThickness / 2, mainAxisSize / 2);
        const barCornerInset = barAppliedCornerRadius * (isReversed ? -1 : 1);
        const barCornerXInset = horizontal ? barCornerInset : 0;
        const barCornerYInset = horizontal ? 0 : barCornerInset;
        nodeData.push({
          series: this,
          itemId: `value`,
          datum,
          datumIndex: {
            type: 0
            /* Node */
          },
          type: 0,
          x0: originX + x0 - barCornerXInset - barXInset,
          y0: originY + y0 - barCornerYInset - barYInset,
          x1: originX + containerX + barCornerXInset + barXInset,
          y1: originY + containerY + barCornerYInset + barYInset,
          clipX0: void 0,
          clipY0: void 0,
          clipX1: void 0,
          clipY1: void 0,
          topLeftCornerRadius: cornerRadius,
          topRightCornerRadius: cornerRadius,
          bottomRightCornerRadius: cornerRadius,
          bottomLeftCornerRadius: cornerRadius,
          fill: barFill,
          horizontalInset,
          verticalInset
        });
      }
      const scaleAppliedCornerRadius = Math.min(cornerRadius, thickness / 2, mainAxisSize / 2);
      const scaleCornerInset = scaleAppliedCornerRadius * (isReversed ? -1 : 1);
      const scaleCornerXInset = horizontal ? scaleCornerInset : 0;
      const scaleCornerYInset = horizontal ? 0 : scaleCornerInset;
      scaleData.push({
        series: this,
        itemId: `scale`,
        datum,
        datumIndex: {
          type: 0
          /* Node */
        },
        type: 0,
        x0: originX + x0 - scaleCornerXInset,
        y0: originY + y0 - scaleCornerYInset,
        x1: originX + x1 + scaleCornerXInset,
        y1: originY + y1 + scaleCornerYInset,
        clipX0: void 0,
        clipY0: void 0,
        clipX1: void 0,
        clipY1: void 0,
        topLeftCornerRadius: cornerRadius,
        topRightCornerRadius: cornerRadius,
        bottomRightCornerRadius: cornerRadius,
        bottomLeftCornerRadius: cornerRadius,
        fill: scaleFill,
        horizontalInset,
        verticalInset
      });
    } else {
      segments ?? (segments = scale2.domain);
      const clipX0 = originX + x0 - barXInset;
      const clipY0 = originY + y0 - barYInset;
      const clipX1 = originX + containerX + barXInset;
      const clipY1 = originY + containerY + barYInset;
      for (let i = 0; i < segments.length - 1; i += 1) {
        const segmentStart = segments[i + 0];
        const segmentEnd = segments[i + 1];
        const datum = { value, segmentStart, segmentEnd };
        const isStart = i === 0;
        const isEnd = i === segments.length - 2;
        const itemStart = scale2.convert(segmentStart);
        const itemEnd = scale2.convert(segmentEnd);
        const startCornerRadius = cornersOnAllItems || isStart ? cornerRadius : 0;
        const endCornerRadius = cornersOnAllItems || isEnd ? cornerRadius : 0;
        const topLeftCornerRadius = horizontal ? startCornerRadius : endCornerRadius;
        const topRightCornerRadius = endCornerRadius;
        const bottomRightCornerRadius = horizontal ? endCornerRadius : startCornerRadius;
        const bottomLeftCornerRadius = startCornerRadius;
        if (bar.enabled) {
          nodeData.push({
            series: this,
            itemId: `value-${i}`,
            datum,
            datumIndex: {
              type: 0
              /* Node */
            },
            type: 0,
            x0: originX + (horizontal ? itemStart : x0),
            y0: originY + (horizontal ? y0 : itemStart),
            x1: originX + (horizontal ? itemEnd : x1),
            y1: originY + (horizontal ? y1 : itemEnd),
            clipX0,
            clipY0,
            clipX1,
            clipY1,
            topLeftCornerRadius,
            topRightCornerRadius,
            bottomRightCornerRadius,
            bottomLeftCornerRadius,
            fill: barFill,
            horizontalInset,
            verticalInset
          });
        }
        scaleData.push({
          series: this,
          itemId: `scale-${i}`,
          datum,
          datumIndex: {
            type: 0
            /* Node */
          },
          type: 0,
          x0: originX + (horizontal ? itemStart : x0),
          y0: originY + (horizontal ? y0 : itemStart),
          x1: originX + (horizontal ? itemEnd : x1),
          y1: originY + (horizontal ? y1 : itemEnd),
          clipX0: void 0,
          clipY0: void 0,
          clipX1: void 0,
          clipY1: void 0,
          topLeftCornerRadius,
          topRightCornerRadius,
          bottomRightCornerRadius,
          bottomLeftCornerRadius,
          fill: scaleFill,
          horizontalInset,
          verticalInset
        });
      }
    }
    if (label.enabled) {
      labelData.push(this.labelDatum(label, value));
    }
    const targetPlacementRotation2 = horizontal ? horizontalTargetPlacementRotation : verticalTargetPlacementRotation;
    for (let i = 0; i < targets.length; i += 1) {
      const target = targets[i];
      const {
        value: targetValue,
        text: text2,
        shape,
        size,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      } = target;
      const targetPoint = this.getTargetPoint(target);
      const targetRotation = toRadians4(target.rotation + targetPlacementRotation2[target.placement]);
      targetData.push({
        series: this,
        itemId: `target-${i}`,
        midPoint: targetPoint,
        datum: { value: targetValue },
        datumIndex: { type: 1, index: i },
        type: 1,
        value: targetValue,
        text: text2,
        x: targetPoint.x,
        y: targetPoint.y,
        shape,
        size,
        rotation: targetRotation,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        label: this.getTargetLabel(target)
      });
    }
    return {
      itemId: seriesId,
      nodeData,
      tickData,
      targetData,
      labelData,
      scaleData
    };
  }
  updateSelections(resize) {
    if (this.nodeDataRefresh || resize) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  highlightDatum(node) {
    if (node != null && node.series === this && node.type === 1) {
      return node;
    }
  }
  update({ seriesRect }) {
    const {
      datumSelection,
      labelSelection,
      targetSelection,
      targetLabelSelection,
      scaleSelection,
      highlightTargetSelection,
      tickSelection
    } = this;
    this.seriesRect = seriesRect ?? BBox19.NaN;
    const resize = this.checkResize(seriesRect);
    this.updateSelections(resize);
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    const targetData = this.contextNodeData?.targetData ?? [];
    const scaleData = this.contextNodeData?.scaleData ?? [];
    const tickData = this.contextNodeData?.tickData ?? [];
    const highlightTargetDatum = this.highlightDatum(this.ctx.highlightManager.getActiveHighlight());
    this.scaleSelection = this.updateScaleSelection({ scaleData, scaleSelection });
    this.updateScaleNodes({ scaleSelection });
    this.targetSelection = this.updateTargetSelection({ targetData, targetSelection });
    this.updateTargetNodes({ targetSelection, isHighlight: false });
    this.targetLabelSelection = this.updateTargetLabelSelection({ targetData, targetLabelSelection });
    this.updateTargetLabelNodes({ targetLabelSelection });
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection });
    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection });
    this.updateLabelNodes({ labelSelection });
    this.highlightTargetSelection = this.updateTargetSelection({
      targetData: highlightTargetDatum != null ? [highlightTargetDatum] : [],
      targetSelection: highlightTargetSelection
    });
    this.updateTargetNodes({ targetSelection: highlightTargetSelection, isHighlight: true });
    this.tickSelection = this.updateTickSelection({ tickData, tickSelection });
    this.updateTickNodes({ tickSelection });
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => {
      return createDatumId9(opts.nodeData.length, datum.itemId);
    });
  }
  updateDatumNodes(opts) {
    const { datumSelection } = opts;
    const { ctx, properties } = this;
    const { bar } = properties;
    const { fillOpacity, stroke: stroke22, strokeOpacity, lineDash, lineDashOffset } = bar;
    const strokeWidth = bar.strokeWidth;
    const animationDisabled = ctx.animationManager.isSkipped();
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((rect, datum) => {
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius, fill } = datum;
      rect.fill = fill;
      rect.fillBBox = fillBBox;
      rect.fillOpacity = fillOpacity;
      rect.stroke = stroke22;
      rect.strokeOpacity = strokeOpacity;
      rect.strokeWidth = strokeWidth;
      rect.lineDash = lineDash;
      rect.lineDashOffset = lineDashOffset;
      rect.topLeftCornerRadius = topLeftCornerRadius;
      rect.topRightCornerRadius = topRightCornerRadius;
      rect.bottomRightCornerRadius = bottomRightCornerRadius;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius;
      rect.pointerEvents = this.properties.bar.enabled ? module_support_exports.PointerEvents.All : module_support_exports.PointerEvents.None;
      if (animationDisabled || rect.previousDatum == null) {
        rect.setProperties(resetLinearGaugeSeriesResetRectFunction(rect, datum));
      }
    });
    this.datumUnion.update(datumSelection, this.itemGroup, module_support_exports.Rect, (node, first2, last) => {
      node.pointerEvents = module_support_exports.PointerEvents.None;
      node.clipBBox ?? (node.clipBBox = new BBox19(NaN, NaN, NaN, NaN));
      node.x = first2.x;
      node.y = first2.y;
      node.clipBBox.x = first2.clipBBox?.x ?? first2.x;
      node.clipBBox.y = first2.clipBBox?.y ?? first2.y;
      if (this.horizontal) {
        node.height = node.clipBBox.height = last.height;
        node.width = last === first2 ? last.width : last.x + last.width;
        node.clipBBox.width = node.width - (last.width - (last.clipBBox?.width ?? last.width));
        node.topLeftCornerRadius = first2.topLeftCornerRadius;
        node.bottomLeftCornerRadius = first2.bottomLeftCornerRadius;
        node.topRightCornerRadius = last.topRightCornerRadius;
        node.bottomRightCornerRadius = last.bottomRightCornerRadius;
      } else {
        node.width = node.clipBBox.width = last.width;
        node.height = last === first2 ? last.height : last.x + last.height;
        node.clipBBox.height = node.height - (last.height - (last.clipBBox?.height ?? last.height));
        node.topLeftCornerRadius = first2.topLeftCornerRadius;
        node.topRightCornerRadius = first2.topRightCornerRadius;
        node.bottomLeftCornerRadius = last.bottomLeftCornerRadius;
        node.bottomRightCornerRadius = last.bottomRightCornerRadius;
      }
    });
  }
  updateScaleSelection(opts) {
    return opts.scaleSelection.update(opts.scaleData, void 0, (datum) => {
      return createDatumId9(opts.scaleData.length, datum.itemId);
    });
  }
  updateScaleNodes(opts) {
    const { scaleSelection } = opts;
    const { scale: scale2 } = this.properties;
    const { fillOpacity, stroke: stroke22, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = scale2;
    const fillBBox = this.getShapeFillBBox();
    scaleSelection.each((rect, datum) => {
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius, fill } = datum;
      rect.fill = fill;
      rect.fillBBox = fillBBox;
      rect.fillOpacity = fillOpacity;
      rect.stroke = stroke22;
      rect.strokeOpacity = strokeOpacity;
      rect.strokeWidth = strokeWidth;
      rect.lineDash = lineDash;
      rect.lineDashOffset = lineDashOffset;
      rect.topLeftCornerRadius = topLeftCornerRadius;
      rect.topRightCornerRadius = topRightCornerRadius;
      rect.bottomRightCornerRadius = bottomRightCornerRadius;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius;
      rect.setProperties(resetLinearGaugeSeriesResetRectFunction(rect, datum));
    });
  }
  updateTargetSelection(opts) {
    return opts.targetSelection.update(opts.targetData, void 0, (target) => target.itemId);
  }
  updateTargetNodes(opts) {
    const { targetSelection, isHighlight } = opts;
    targetSelection.each((target, datum) => {
      const {
        x,
        y,
        shape,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      } = datum;
      const highlightStyle = this.getHighlightStyle(isHighlight, datum.datumIndex);
      const style2 = mergeDefaults12(highlightStyle, {
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        opacity: 1
      });
      applyShapeStyle10(target, style2);
      target.size = size;
      target.shape = shape === "line" ? lineMarker : shape;
      target.translationX = x;
      target.translationY = y;
      target.rotation = rotation;
    });
  }
  updateTargetLabelSelection(opts) {
    return opts.targetLabelSelection.update(opts.targetData);
  }
  updateTargetLabelNodes(opts) {
    const { targetLabelSelection } = opts;
    targetLabelSelection.each((label, target) => {
      const { x, y, text: text2 } = target;
      const { offsetX, offsetY, fill, fontStyle, fontWeight, fontSize, fontFamily, textAlign, textBaseline } = target.label;
      label.visible = true;
      label.x = x + offsetX;
      label.y = y + offsetY;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = textAlign;
      label.textBaseline = textBaseline;
    });
  }
  updateTickSelection(opts) {
    return opts.tickSelection.update(opts.tickData, void 0, (datum) => datum.tickId);
  }
  updateTickNodes(opts) {
    const { gaugeRect, properties } = this;
    const defaultScale = properties.defaultScale;
    const {
      enabled,
      color: color6,
      fontFamily = defaultScale.label.fontFamily,
      fontSize = defaultScale.label.fontSize,
      fontStyle,
      fontWeight = defaultScale.label.fontWeight,
      spacing
    } = properties.scale.label;
    let { placement } = properties.scale.label;
    const rotation = toRadians4(properties.scale.label.rotation ?? 0);
    let textAlign;
    let textBaseline;
    let textX;
    let textY;
    if (this.horizontal) {
      placement ?? (placement = "after");
      textAlign = "center";
      textBaseline = placement === "before" ? "bottom" : "top";
      textY = this.originY + gaugeRect.y + (placement === "before" ? -spacing : gaugeRect.height + spacing);
    } else {
      placement ?? (placement = "before");
      textAlign = placement === "before" ? "end" : "start";
      textBaseline = "middle";
      textX = this.originX + gaugeRect.x + (placement === "before" ? -spacing : gaugeRect.width + spacing);
    }
    opts.tickSelection.each((label, datum) => {
      if (!enabled) {
        label.visible = false;
        return;
      }
      const x = textX ?? datum.translation;
      const y = textY ?? datum.translation;
      label.visible = true;
      label.text = datum.tickLabel;
      label.fill = color6;
      label.fontFamily = fontFamily;
      label.fontSize = fontSize;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.textBaseline = textBaseline;
      label.textAlign = textAlign;
      label.x = x;
      label.y = y;
      label.rotationCenterX = x;
      label.rotationCenterY = y;
      label.rotation = rotation;
    });
  }
  updateLabelSelection(opts) {
    return opts.labelSelection.update(opts.labelData, void 0, (_datum) => "primary");
  }
  updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const animationDisabled = this.ctx.animationManager.isSkipped();
    labelSelection.each((label, datum) => {
      label.fill = datum.fill;
      label.fontStyle = datum.fontStyle;
      label.fontWeight = datum.fontWeight;
      label.fontFamily = datum.fontFamily;
    });
    if (animationDisabled || this.labelsHaveExplicitText()) {
      this.formatLabelText();
    }
  }
  labelsHaveExplicitText() {
    for (const { datum } of this.labelSelection) {
      if (datum.text == null) {
        return false;
      }
    }
    return true;
  }
  formatLabelText(datum) {
    const { labelSelection, horizontal, scale: scale2, seriesRect, gaugeRect } = this;
    const { x, y, width: width2, height: height2 } = gaugeRect;
    const value = datum?.label ?? this.properties.value;
    let barRect;
    if (horizontal) {
      const xValue2 = scale2.convert(value);
      barRect = new BBox19(x, y, xValue2 - x, height2);
    } else {
      const yValue = scale2.convert(value);
      barRect = new BBox19(x, yValue, width2, height2 - yValue);
    }
    const bboxes = { seriesRect, gaugeRect, barRect };
    const { margin: padding2 } = this.properties;
    formatLinearGaugeLabels(this, this.ctx, labelSelection, { padding: padding2, horizontal }, bboxes, datum);
  }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    resetMotion3([this.datumSelection], resetLinearGaugeSeriesResetRectFunction);
    this.formatLabelText();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  animateLabelText(params = {}) {
    const { animationManager } = this.ctx;
    let labelFrom = 0;
    let labelTo = 0;
    this.labelSelection.each((label, datum) => {
      label.opacity = 1;
      labelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
      labelTo = datum.value;
    });
    if (this.labelsHaveExplicitText()) {
    } else if (labelFrom === labelTo) {
      this.formatLabelText({ label: labelTo });
    } else {
      const animationId = `${this.id}_labels`;
      animationManager.animate({
        id: animationId,
        groupId: "label",
        from: { label: labelFrom },
        to: { label: labelTo },
        phase: params.phase ?? "update",
        ease: easing.easeOut,
        onUpdate: (datum) => this.formatLabelText(datum),
        onStop: () => this.formatLabelText({ label: labelTo })
      });
    }
  }
  animateEmptyUpdateReady() {
    const { animationManager } = this.ctx;
    const { node } = prepareLinearGaugeSeriesAnimationFunctions(true, this.horizontal);
    fromToMotion22(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
    fromToMotion22(this.id, "label", animationManager, [this.labelSelection], fadeInFns, () => "primary");
    this.animateLabelText({ from: 0, phase: "initial" });
  }
  animateWaitingUpdateReady() {
    const { animationManager } = this.ctx;
    const { node } = prepareLinearGaugeSeriesAnimationFunctions(false, this.horizontal);
    fromToMotion22(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
    this.animateLabelText();
  }
  animateReadyResize() {
    this.resetAllAnimation();
  }
  getSeriesDomain() {
    return [0, 1];
  }
  dataCount() {
    return NaN;
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, properties } = this;
    const { tooltip } = properties;
    let value;
    let text2;
    if (datumIndex.type === 0) {
      value = properties.value;
      text2 = properties.label.text;
    } else {
      ({ value, text: text2 } = properties.targets[datumIndex.index]);
    }
    if (value == null)
      return;
    return this.formatTooltipWithContext(
      tooltip,
      {
        data: [{ label: text2, fallbackLabel: "Value", value: this.formatLabel(value) }]
      },
      { seriesId, title: void 0, datum: void 0, value }
    );
  }
  pickNodeClosestDatum(point) {
    return pickGaugeNearestDatum(this, point);
  }
  pickFocus(opts) {
    return pickGaugeFocus(this, opts);
  }
  getCaptionText() {
    return this.formatLabel(this.properties.value);
  }
  getCategoryValue(_datumIndex) {
    return;
  }
  datumIndexForCategoryValue(_categoryValue) {
    return;
  }
  hasItemStylers() {
    return false;
  }
};
LinearGaugeSeries.className = "LinearGaugeSeries";
LinearGaugeSeries.type = "linear-gauge";
var LinearGaugeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  identifier: "linear-gauge",
  moduleFactory: (ctx) => new LinearGaugeSeries(ctx),
  themeTemplate: {
    minWidth: 200,
    minHeight: 200,
    tooltip: {
      enabled: false
    },
    series: {
      thickness: 50,
      defaultColorRange: {
        $if: [
          { $eq: [{ $palette: "type" }, "inbuilt"] },
          { $interpolate: [{ $palette: "secondDivergingColors" }, 5] },
          module_support_exports.SAFE_RANGE2_OPERATION
        ]
      },
      scale: {
        // @ts-expect-error undocumented option
        defaultFill: { $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] },
        // TODO: mix backgroundColor and foregroundColor?
        stroke: { $path: ["/2", module_support_exports.SAFE_STROKE_FILL_OPERATION, { $palette: "hierarchyColors" }] },
        // TODO: mix backgroundColor and foregroundColor?
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
        label: {
          spacing: 11
        }
      },
      bar: {
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] }
      },
      segmentation: {
        enabled: false,
        interval: {},
        spacing: 1
      },
      defaultTarget: {
        fill: { $ref: "foregroundColor" },
        stroke: { $ref: "foregroundColor" },
        size: 10,
        shape: "triangle",
        placement: "after",
        spacing: 5,
        label: {
          enabled: true,
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $ref: "fontSize" },
          fontFamily: { $ref: "fontFamily" },
          color: { $ref: "textColor" },
          spacing: 5
        }
      },
      defaultScale: {
        label: {
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $ref: "fontSize" },
          fontFamily: { $ref: "fontFamily" },
          color: { $ref: "textColor" }
        }
      },
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        enabled: false,
        placement: "inside-start",
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        fontSize: { $rem: 2 },
        minimumFontSize: module_support_exports.FONT_SIZE.SMALL,
        spacing: 18,
        color: { $ref: "chartBackgroundColor" }
      },
      margin: 4,
      tooltip: {
        range: { $path: ["/tooltip/range", 10] }
      }
    }
  }
};
var LinearGaugeSeriesModule = {
  type: "series",
  name: "linear-gauge",
  chartType: "standalone",
  enterprise: true,
  options: module_support_exports.linearGaugeSeriesOptionsDef,
  create: (ctx) => new LinearGaugeSeries(ctx)
};
var MAP_THEME_DEFAULTS = {
  zoom: {
    axes: "xy",
    anchorPointX: "pointer",
    anchorPointY: "pointer",
    buttons: {
      // @ts-expect-error undocumented options
      anchorPointX: "middle",
      anchorPointY: "middle"
    }
  },
  legend: {
    enabled: false
  },
  gradientLegend: {
    enabled: false,
    ...module_support_exports.LEGEND_CONTAINER_THEME
  }
};
function applyMapPalette(object2) {
  const clone2 = module_support_exports.deepClone(object2);
  module_support_exports.jsonWalk(clone2, (value) => {
    if (typeof value === "object" && "$palette" in value) {
      value["$mapPalette"] = value["$palette"];
      delete value["$palette"];
    }
  });
  return clone2;
}
var delta22 = 1e-9;
function lineSegmentDistanceToPointSquared(a, b, x, y) {
  const [ax, ay] = a;
  const [bx, by] = b;
  const abx = bx - ax;
  const aby = by - ay;
  const l = abx * abx + aby * aby;
  let x0;
  let y0;
  if (Math.abs(l) < delta22) {
    x0 = ax;
    y0 = ay;
  } else {
    let t = ((x - ax) * abx + (y - ay) * aby) / l;
    t = Math.max(0, Math.min(1, t));
    x0 = ax + t * (bx - ax);
    y0 = ay + t * (by - ay);
  }
  const dx2 = x - x0;
  const dy2 = y - y0;
  return dx2 * dx2 + dy2 * dy2;
}
function lineStringDistance(lineString, x, y) {
  let minDistanceSquared = Infinity;
  let p0 = lineString[lineString.length - 1];
  for (const p1 of lineString) {
    minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));
    p0 = p1;
  }
  return Math.sqrt(minDistanceSquared);
}
function lineStringLength(lineSegment) {
  let [x0, y0] = lineSegment[0];
  let totalDistance = 0;
  for (let i = 1; i < lineSegment.length; i += 1) {
    const [x1, y1] = lineSegment[i];
    const distance2 = Math.hypot(x1 - x0, y1 - y0);
    totalDistance += distance2;
    x0 = x1;
    y0 = y1;
  }
  return totalDistance;
}
function lineStringCenter(lineSegment) {
  if (lineSegment.length === 0)
    return;
  const targetDistance = lineStringLength(lineSegment) / 2;
  let [x0, y0] = lineSegment[0];
  let totalDistance = 0;
  for (let i = 1; i < lineSegment.length; i += 1) {
    const [x1, y1] = lineSegment[i];
    const segmentDistance = Math.hypot(x1 - x0, y1 - y0);
    const nextDistance = totalDistance + segmentDistance;
    if (nextDistance > targetDistance) {
      const ratio3 = (targetDistance - totalDistance) / segmentDistance;
      const point = [x0 + (x1 - x0) * ratio3, y0 + (y1 - y0) * ratio3];
      const angle2 = Math.atan2(y1 - y0, x1 - x0);
      return { point, angle: angle2 };
    }
    totalDistance = nextDistance;
    x0 = x1;
    y0 = y1;
  }
}
var { LonLatBBox: LonLatBBox2 } = module_support_exports;
function polygonBbox(polygon, into) {
  polygon.forEach((coordinates) => {
    const [lon, lat] = coordinates;
    into = LonLatBBox2.extend(into, lon, lat, lon, lat);
  });
  return into;
}
function polygonCentroid(polygon) {
  if (polygon.length === 0)
    return;
  let x = 0;
  let y = 0;
  let k = 0;
  let [x0, y0] = polygon[polygon.length - 1];
  for (const [x1, y1] of polygon) {
    const c = x0 * y1 - x1 * y0;
    k += c;
    x += (x0 + x1) * c;
    y += (y0 + y1) * c;
    x0 = x1;
    y0 = y1;
  }
  k *= 3;
  return [x / k, y / k];
}
function polygonDistance(polygons, x, y) {
  let inside = false;
  let minDistanceSquared = Infinity;
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    let [x0, y0] = p0;
    for (const p1 of polygon) {
      const [x1, y1] = p1;
      if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) {
        inside = !inside;
      }
      minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));
      p0 = p1;
      x0 = x1;
      y0 = y1;
    }
  }
  return (inside ? -1 : 1) * Math.sqrt(minDistanceSquared);
}
var { Path: Path10, ExtendedPath2D: ExtendedPath2D4, BBox: BBox20, SceneChangeDetection: SceneChangeDetection8, SceneObjectChangeDetection: SceneObjectChangeDetection2, objectsEqual: objectsEqual2 } = module_support_exports;
var GeoGeometry = class extends Path10 {
  constructor() {
    super(...arguments);
    this.projectedGeometry = void 0;
    this.renderMode = 3;
    this.strokePath = new ExtendedPath2D4();
  }
  computeBBox() {
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
    return this.bbox?.clone();
  }
  updatePath() {
    const { projectedGeometry } = this;
    this.strokePath.clear();
    this.path.clear();
    this.bbox = projectedGeometry != null ? this.drawGeometry(projectedGeometry, void 0) : void 0;
  }
  drawPath(ctx) {
    super.drawPath(ctx);
    this.renderStroke(ctx, this.strokePath.getPath2D());
  }
  containsPoint(x, y) {
    const { projectedGeometry } = this;
    if (projectedGeometry == null)
      return false;
    if (!this.getBBox().containsPoint(x, y))
      return false;
    return this.geometryDistance(projectedGeometry, x, y) <= 0;
  }
  distanceSquared(x, y) {
    const { projectedGeometry } = this;
    if (projectedGeometry == null)
      return Infinity;
    const distance2 = this.geometryDistance(projectedGeometry, x, y);
    return distance2 > 0 ? distance2 * distance2 : 0;
  }
  geometryDistance(geometry, x, y) {
    const { renderMode, strokeWidth } = this;
    const drawPolygons = (renderMode & 1) !== 0;
    const drawLines = (renderMode & 2) !== 0;
    const minStrokeDistance = Math.max(strokeWidth / 2, 1) + 1;
    switch (geometry.type) {
      case "GeometryCollection":
        return geometry.geometries.reduce(
          (minDistance, g) => Math.min(minDistance, this.geometryDistance(g, x, y)),
          Infinity
        );
      case "MultiPolygon":
        return drawPolygons ? geometry.coordinates.reduce(
          (minDistance, polygon) => Math.min(minDistance, Math.max(polygonDistance(polygon, x, y), 0)),
          Infinity
        ) : Infinity;
      case "Polygon":
        return drawPolygons ? Math.max(polygonDistance(geometry.coordinates, x, y), 0) : Infinity;
      case "MultiLineString":
        return drawLines ? geometry.coordinates.reduce((minDistance, lineString) => {
          return Math.min(
            minDistance,
            Math.max(lineStringDistance(lineString, x, y) - minStrokeDistance, 0)
          );
        }, Infinity) : Infinity;
      case "LineString":
        return drawLines ? Math.max(lineStringDistance(geometry.coordinates, x, y) - minStrokeDistance, 0) : Infinity;
      case "MultiPoint":
      case "Point":
      default:
        return Infinity;
    }
  }
  drawGeometry(geometry, bbox) {
    const { renderMode, path, strokePath } = this;
    const drawPolygons = (renderMode & 1) !== 0;
    const drawLines = (renderMode & 2) !== 0;
    switch (geometry.type) {
      case "GeometryCollection":
        geometry.geometries.forEach((g) => {
          bbox = this.drawGeometry(g, bbox);
        });
        break;
      case "MultiPolygon":
        if (drawPolygons) {
          geometry.coordinates.forEach((coordinates) => {
            bbox = this.drawPolygon(path, coordinates, bbox);
          });
        }
        break;
      case "Polygon":
        if (drawPolygons) {
          bbox = this.drawPolygon(path, geometry.coordinates, bbox);
        }
        break;
      case "LineString":
        if (drawLines) {
          bbox = this.drawLineString(strokePath, geometry.coordinates, bbox, false);
        }
        break;
      case "MultiLineString":
        if (drawLines) {
          geometry.coordinates.forEach((coordinates) => {
            bbox = this.drawLineString(strokePath, coordinates, bbox, false);
          });
        }
        break;
      case "Point":
      case "MultiPoint":
        break;
    }
    return bbox;
  }
  drawPolygon(path, polygons, bbox) {
    if (polygons.length < 1)
      return bbox;
    bbox = this.drawLineString(path, polygons[0], bbox, true);
    for (let i = 1; i < polygons.length; i += 1) {
      const enclave = polygons[i];
      this.drawLineString(path, enclave, void 0, true);
    }
    return bbox;
  }
  drawLineString(path, coordinates, bbox, isClosed) {
    if (coordinates.length < 2)
      return bbox;
    const end2 = isClosed ? coordinates.length - 1 : coordinates.length;
    for (let i = 0; i < end2; i += 1) {
      const [x, y] = coordinates[i];
      if (i === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
      if (bbox == null) {
        bbox = new BBox20(x, y, 0, 0);
      } else {
        const { x: x0, y: y0 } = bbox;
        const x1 = x0 + bbox.width;
        const y1 = y0 + bbox.height;
        bbox.x = Math.min(x0, x);
        bbox.y = Math.min(y0, y);
        bbox.width = Math.max(x1, x) - bbox.x;
        bbox.height = Math.max(y1, y) - bbox.y;
      }
    }
    if (isClosed) {
      path.closePath();
    }
    return bbox;
  }
};
__decorateClass2([
  SceneObjectChangeDetection2({ equals: objectsEqual2 })
], GeoGeometry.prototype, "projectedGeometry", 2);
__decorateClass2([
  SceneChangeDetection8()
], GeoGeometry.prototype, "renderMode", 2);
var { LonLatBBox: LonLatBBox22 } = module_support_exports;
function geometryBbox(geometry, into) {
  if (geometry.bbox != null) {
    const [lon0, lat0, lon1, lat1] = geometry.bbox;
    into = LonLatBBox22.extend(into, lon0, lat0, lon1, lat1);
    return into;
  }
  switch (geometry.type) {
    case "GeometryCollection":
      geometry.geometries.forEach((g) => {
        into = geometryBbox(g, into);
      });
      break;
    case "MultiPolygon":
      geometry.coordinates.forEach((c) => {
        if (c.length > 0) {
          into = polygonBbox(c[0], into);
        }
      });
      break;
    case "Polygon":
      if (geometry.coordinates.length > 0) {
        into = polygonBbox(geometry.coordinates[0], into);
      }
      break;
    case "MultiLineString":
      geometry.coordinates.forEach((c) => {
        into = polygonBbox(c, into);
      });
      break;
    case "LineString":
      into = polygonBbox(geometry.coordinates, into);
      break;
    case "MultiPoint":
      geometry.coordinates.forEach((p) => {
        const [lon, lat] = p;
        into = LonLatBBox22.extend(into, lon, lat, lon, lat);
      });
      break;
    case "Point": {
      const [lon, lat] = geometry.coordinates;
      into = LonLatBBox22.extend(into, lon, lat, lon, lat);
      break;
    }
  }
  return into;
}
function largestPolygon(geometry) {
  switch (geometry.type) {
    case "GeometryCollection": {
      let maxArea;
      let maxPolygon;
      geometry.geometries.forEach((g) => {
        const polygon = largestPolygon(g);
        if (polygon == null)
          return;
        const bbox = polygonBbox(polygon[0], void 0);
        if (bbox == null)
          return;
        const area2 = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);
        if (maxArea == null || area2 > maxArea) {
          maxArea = area2;
          maxPolygon = polygon;
        }
      });
      return maxPolygon;
    }
    case "MultiPolygon": {
      let maxArea;
      let maxPolygon;
      geometry.coordinates.forEach((polygon) => {
        const bbox = polygonBbox(polygon[0], void 0);
        if (bbox == null)
          return;
        const area2 = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);
        if (maxArea == null || area2 > maxArea) {
          maxArea = area2;
          maxPolygon = polygon;
        }
      });
      return maxPolygon;
    }
    case "Polygon":
      return geometry.coordinates;
    case "MultiLineString":
    case "LineString":
    case "MultiPoint":
    case "Point":
      return;
  }
}
function largestLineString(geometry) {
  switch (geometry.type) {
    case "GeometryCollection": {
      let maxLength;
      let maxLineString;
      geometry.geometries.forEach((g) => {
        const lineString = largestLineString(g);
        if (lineString == null)
          return;
        const length2 = lineStringLength(lineString);
        if (length2 == null)
          return;
        if (maxLength == null || length2 > maxLength) {
          maxLength = length2;
          maxLineString = lineString;
        }
      });
      return maxLineString;
    }
    case "MultiLineString": {
      let maxLength = 0;
      let maxLineString;
      geometry.coordinates.forEach((lineString) => {
        const length2 = lineStringLength(lineString);
        if (length2 > maxLength) {
          maxLength = length2;
          maxLineString = lineString;
        }
      });
      return maxLineString;
    }
    case "LineString":
      return geometry.coordinates;
    case "MultiPolygon":
    case "Polygon":
    case "MultiPoint":
    case "Point":
      return;
  }
}
function containsType(geometry, type) {
  if (geometry == null)
    return false;
  switch (geometry.type) {
    case "GeometryCollection":
      return geometry.geometries.some((g) => containsType(g, type));
    case "MultiPolygon":
    case "Polygon":
      return (type & 1) !== 0;
    case "MultiLineString":
    case "LineString":
      return (type & 2) !== 0;
    case "MultiPoint":
    case "Point":
      return (type & 4) !== 0;
  }
}
function projectGeometry(geometry, scale2) {
  switch (geometry.type) {
    case "GeometryCollection":
      return {
        type: "GeometryCollection",
        geometries: geometry.geometries.map((g) => projectGeometry(g, scale2))
      };
    case "Polygon":
      return {
        type: "Polygon",
        coordinates: projectPolygon(geometry.coordinates, scale2)
      };
    case "MultiPolygon":
      return {
        type: "MultiPolygon",
        coordinates: projectMultiPolygon(geometry.coordinates, scale2)
      };
    case "MultiLineString":
      return {
        type: "MultiLineString",
        coordinates: projectPolygon(geometry.coordinates, scale2)
      };
    case "LineString":
      return {
        type: "LineString",
        coordinates: projectLineString(geometry.coordinates, scale2)
      };
    case "MultiPoint":
      return {
        type: "MultiPoint",
        coordinates: projectLineString(geometry.coordinates, scale2)
      };
    case "Point":
      return {
        type: "Point",
        coordinates: scale2.convert(geometry.coordinates)
      };
  }
}
function projectMultiPolygon(multiPolygon, scale2) {
  return multiPolygon.map((polygon) => projectPolygon(polygon, scale2));
}
function projectPolygon(polygon, scale2) {
  return polygon.map((lineString) => projectLineString(lineString, scale2));
}
function projectLineString(lineString, scale2) {
  return lineString.map((lonLat) => scale2.convert(lonLat));
}
function prepareMapMarkerAnimationFunctions() {
  const fromFn = (marker, _datum, status) => {
    if (status === "removed") {
      return { scalingX: 1, scalingY: 1 };
    } else if (marker.previousDatum == null) {
      return { scalingX: 0, scalingY: 0 };
    }
    return { scalingX: marker.scalingX, scalingY: marker.scalingY };
  };
  const toFn = (_marker, _datum, status) => {
    if (status === "removed") {
      return { scalingX: 0, scalingY: 0 };
    }
    return { scalingX: 1, scalingY: 1 };
  };
  return { fromFn, toFn };
}
function findFocusedGeoGeometry(series, opts) {
  const datum = series.contextNodeData?.nodeData[opts.datumIndex];
  if (datum === void 0)
    return void 0;
  for (const node of series.datumSelection.nodes()) {
    if (node.datum === datum) {
      return node;
    }
  }
  return void 0;
}
var TopologySeriesProperties = class extends module_support_exports.SeriesProperties {
};
var TopologySeries = class extends module_support_exports.DataModelSeries {
  addChartEventListeners() {
    this.cleanup.register(
      this.ctx.eventsHub.on("legend:item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.eventsHub.on("legend:item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
};
var { Property: Property70, SeriesProperties: SeriesProperties3, makeSeriesTooltip: makeSeriesTooltip12, Label: Label10 } = module_support_exports;
var MapLineSeriesProperties = class extends SeriesProperties3 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = "";
    this.topologyIdKey = "name";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.maxStrokeWidth = void 0;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.label = new Label10();
    this.tooltip = makeSeriesTooltip12();
  }
};
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "legendItemName", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "sizeKey", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "sizeDomain", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "maxStrokeWidth", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property70
], MapLineSeriesProperties.prototype, "tooltip", 2);
var {
  getMissCount: getMissCount22,
  getLabelStyles: getLabelStyles22,
  createDatumId: createDatumId10,
  SeriesNodePickMode: SeriesNodePickMode9,
  valueProperty: valueProperty12,
  CachedTextMeasurerPool: CachedTextMeasurerPool8,
  ColorScale: ColorScale22,
  LinearScale: LinearScale5,
  Selection: Selection9,
  Text: Text4,
  Transformable: Transformable22
} = module_support_exports;
var MapLineSeries = class extends TopologySeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      propertyKeys: {
        size: ["colorKey"],
        color: ["colorKey"],
        label: ["labelKey"]
      },
      propertyNames: {
        size: ["sizeName"],
        color: ["colorName"],
        label: ["labelName"]
      },
      pickModes: [SeriesNodePickMode9.EXACT_SHAPE_MATCH, SeriesNodePickMode9.NEAREST_NODE],
      usesPlacedLabels: true
    });
    this.properties = new MapLineSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale22();
    this.sizeScale = new LinearScale5();
    this.datumSelection = Selection9.select(
      this.contentGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection9.select(this.labelGroup, Text4);
    this.highlightDatumSelection = Selection9.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    this._previousDatumMidPoint = void 0;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get hasData() {
    return super.hasData && this.topology != null;
  }
  renderToOffscreenCanvas() {
    return true;
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [1, zIndex];
    this.highlightGroup.zIndex = [2, zIndex];
    return true;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 2;
    geoGeometry.lineJoin = "round";
    geoGeometry.lineCap = "round";
    return geoGeometry;
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, topology, sizeScale, colorScale } = this;
    const { topologyIdKey, idKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;
    const featureById = /* @__PURE__ */ new Map();
    topology?.features.forEach((feature) => {
      const property = feature.properties?.[topologyIdKey];
      if (property == null || !containsType(
        feature.geometry,
        2
        /* LineString */
      ))
        return;
      featureById.set(property, feature);
    });
    const sizeScaleType = this.sizeScale.type;
    const colorScaleType = this.colorScale.type;
    const mercatorScaleType = this.scale?.type;
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props: [
        valueProperty12(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
        valueProperty12(idKey, mercatorScaleType, {
          id: "featureValue",
          includeProperty: false,
          processor: () => (datum) => featureById.get(datum)
        }),
        ...labelKey != null ? [valueProperty12(labelKey, "category", { id: "labelValue" })] : [],
        ...sizeKey != null ? [valueProperty12(sizeKey, sizeScaleType, { id: "sizeValue" })] : [],
        ...colorKey != null ? [valueProperty12(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    const featureValues = dataModel.resolveColumnById(
      this,
      `featureValue`,
      processedData
    );
    this.topologyBounds = featureValues.reduce((current, feature) => {
      const geometry = feature?.geometry;
      if (geometry == null)
        return current;
      return geometryBbox(geometry, current);
    }, void 0);
    if (sizeKey != null) {
      const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
      const processedSize = processedData.domain.values[sizeIdx] ?? [];
      sizeScale.domain = sizeDomain ?? processedSize;
    }
    if (colorRange != null && this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      colorScale.domain = processedData.domain.values[colorKeyIdx];
      colorScale.range = colorRange;
      colorScale.update();
    }
    if (topology == null) {
      logger_exports.warnOnce(`no topology was provided for [MapLineSeries]; nothing will be rendered.`);
    }
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.input.count;
    const missCount = getMissCount22(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelDatum(datum, labelValue, projectedGeometry, measurer22) {
    if (labelValue == null || projectedGeometry == null)
      return;
    const lineString = largestLineString(projectedGeometry);
    if (lineString == null)
      return;
    const { idKey, idName, sizeKey, sizeName, colorKey, colorName, labelKey, labelName, label } = this.properties;
    if (labelKey == null || !label.enabled)
      return;
    const labelText = this.getLabelText(
      labelValue,
      datum,
      labelKey,
      "label",
      [],
      label,
      {
        value: labelValue,
        datum,
        idKey,
        idName,
        sizeKey,
        sizeName,
        colorKey,
        colorName,
        labelKey,
        labelName
      }
    );
    if (labelText == null)
      return;
    const labelSize = measurer22.measureText(String(labelText));
    const labelCenter = lineStringCenter(lineString);
    if (labelCenter == null)
      return;
    const [x, y] = labelCenter.point;
    const { width: width2, height: height2 } = labelSize;
    return {
      point: { x, y, size: 0 },
      label: { width: width2, height: height2, text: labelText },
      anchor: void 0,
      placement: void 0
    };
  }
  createNodeData() {
    const { id: seriesId, dataModel, processedData, sizeScale, properties, scale: scale2 } = this;
    const { idKey, sizeKey, colorKey, labelKey, label, legendItemName } = properties;
    if (dataModel == null || processedData == null)
      return;
    const idValues = dataModel.resolveColumnById(this, `idValue`, processedData);
    const featureValues = dataModel.resolveColumnById(
      this,
      `featureValue`,
      processedData
    );
    const labelValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const sizeValues = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const colorValues = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData) : void 0;
    const maxStrokeWidth = properties.maxStrokeWidth ?? properties.strokeWidth;
    sizeScale.range = [Math.min(properties.strokeWidth, maxStrokeWidth), maxStrokeWidth];
    const measurer22 = CachedTextMeasurerPool8.getMeasurer({ font: label });
    const projectedGeometries = /* @__PURE__ */ new Map();
    processedData.dataSources.get(this.id)?.forEach((_datum, datumIndex) => {
      const id = idValues[datumIndex];
      const geometry = featureValues[datumIndex]?.geometry ?? void 0;
      const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
      if (id != null && projectedGeometry != null) {
        projectedGeometries.set(id, projectedGeometry);
      }
    });
    const nodeData = [];
    const labelData = [];
    const missingGeometries = [];
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const idValue = idValues[datumIndex];
      const colorValue = colorValues?.[datumIndex];
      const sizeValue = sizeValues?.[datumIndex];
      const labelValue = labelValues?.[datumIndex];
      const projectedGeometry = projectedGeometries.get(idValue);
      if (projectedGeometry == null) {
        missingGeometries.push(idValue);
      }
      const labelDatum = this.getLabelDatum(datum, labelValue, projectedGeometry, measurer22);
      if (labelDatum != null) {
        labelData.push(labelDatum);
      }
      nodeData.push({
        series: this,
        itemId: idKey,
        datum,
        datumIndex,
        idValue,
        labelValue,
        colorValue,
        sizeValue,
        projectedGeometry,
        legendItemName
      });
    });
    const missingGeometriesCap = 10;
    if (missingGeometries.length > missingGeometriesCap) {
      const excessItems = missingGeometries.length - missingGeometriesCap;
      missingGeometries.length = missingGeometriesCap;
      missingGeometries.push(`(+${excessItems} more)`);
    }
    if (missingGeometries.length > 0) {
      logger_exports.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
    }
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  update() {
    const { datumSelection, highlightDatumSelection } = this;
    this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.labelGroup.visible = this.visible;
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const { legendItemName } = this.properties;
    const matchingLegendItemName = legendItemName != null && highlightedDatum?.datum == null && legendItemName === highlightedDatum?.legendItemName;
    if (highlightedDatum != null && (highlightedDatum.series !== this && !matchingLegendItemName || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection, isHighlight: false });
    this.highlightDatumSelection = this.updateDatumSelection({
      nodeData: highlightedDatum != null ? [highlightedDatum] : [],
      datumSelection: highlightDatumSelection
    });
    this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId10(datum.idValue));
  }
  getItemBaseStyle(isHighlight, datum) {
    const { properties } = this;
    const highlightStyle = this.getHighlightStyle(isHighlight, datum?.datumIndex);
    return {
      stroke: highlightStyle?.stroke ?? properties.stroke,
      strokeWidth: highlightStyle?.strokeWidth ?? properties.strokeWidth,
      strokeOpacity: highlightStyle?.strokeOpacity ?? properties.strokeOpacity,
      lineDash: highlightStyle?.lineDash ?? properties.lineDash,
      lineDashOffset: highlightStyle?.lineDashOffset ?? properties.lineDashOffset,
      opacity: highlightStyle?.opacity ?? 1
    };
  }
  getItemStyleOverrides(datumId, datum, colorValue, sizeValue, format, highlighted, datumIndex) {
    const { id: seriesId, properties, colorScale, sizeScale } = this;
    const { colorRange, itemStyler } = properties;
    let overrides;
    if (!highlighted && colorValue != null) {
      overrides ?? (overrides = {});
      overrides.stroke = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange?.[0] ?? properties.stroke;
    }
    if (sizeValue != null) {
      overrides ?? (overrides = {});
      overrides.strokeWidth = sizeScale.convert(sizeValue, { clamp: true });
    }
    if (itemStyler != null) {
      const itemStyle = this.cachedDatumCallback(
        createDatumId10(datumId, highlighted ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted,
            highlightState,
            ...format,
            ...overrides
          });
        }
      );
      overrides ?? (overrides = {});
      Object.assign(overrides, itemStyle);
    }
    return overrides;
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    datumSelection.each((geoGeometry, nodeDatum) => {
      const { datum, datumIndex, colorValue, sizeValue, projectedGeometry } = nodeDatum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      const format = this.getItemBaseStyle(isHighlight, nodeDatum);
      const overrides = this.getItemStyleOverrides(
        String(datumIndex),
        datum,
        colorValue,
        sizeValue,
        format,
        isHighlight,
        datumIndex
      );
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      geoGeometry.stroke = overrides?.stroke ?? format.stroke;
      geoGeometry.strokeWidth = overrides?.strokeWidth ?? format.strokeWidth;
      geoGeometry.strokeOpacity = overrides?.strokeOpacity ?? format.strokeOpacity;
      geoGeometry.lineDash = overrides?.lineDash ?? format.lineDash;
      geoGeometry.lineDashOffset = overrides?.lineDashOffset ?? format.lineDashOffset;
    });
  }
  updatePlacedLabelData(labelData) {
    this.labelSelection = this.labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = module_support_exports.PointerEvents.None;
    });
    this.updateLabelNodes({ labelSelection: this.labelSelection });
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((label, { x, y, width: width2, height: height2, text: text2 }, datumIndex) => {
      const style2 = getLabelStyles22(
        this,
        void 0,
        this.properties,
        this.properties.label
      );
      const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = style2;
      label.visible = true;
      label.x = x + width2 / 2;
      label.y = y + height2 / 2;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = "center";
      label.textBaseline = "middle";
      label.fillOpacity = this.getHighlightStyle(false, datumIndex).opacity ?? 1;
      label.setBoxing(style2);
    });
  }
  resetAnimation() {
  }
  getLabelData() {
    if (!this.isLabelEnabled())
      return [];
    return this.contextNodeData?.labelData ?? [];
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistanceSquared = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distanceSquared2 = node.distanceSquared(x, y);
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  datumMidPoint(datum) {
    const { _previousDatumMidPoint } = this;
    if (_previousDatumMidPoint?.datum === datum) {
      return _previousDatumMidPoint.point;
    }
    const projectedGeometry = datum.projectedGeometry;
    const lineString = projectedGeometry != null ? largestLineString(projectedGeometry) : void 0;
    const center2 = lineString != null ? lineStringCenter(lineString)?.point : void 0;
    const point = center2 != null ? { x: center2[0], y: center2[1] } : void 0;
    this._previousDatumMidPoint = { datum, point };
    return point;
  }
  legendItemSymbol(datumIndex) {
    const { dataModel, processedData, properties } = this;
    const { strokeWidth, strokeOpacity, lineDash } = properties;
    let { stroke: stroke22 } = properties;
    if (datumIndex != null && this.isColorScaleValid()) {
      const colorValues = dataModel.resolveColumnById(this, "colorValue", processedData);
      const colorValue = colorValues[datumIndex];
      stroke22 = this.colorScale.convert(colorValue);
    }
    return {
      marker: {
        fill: void 0,
        fillOpacity: 0,
        stroke: void 0,
        strokeWidth: 0,
        strokeOpacity: 0,
        lineDash: [0],
        lineDashOffset: 0,
        enabled: false
      },
      line: {
        stroke: stroke22,
        strokeWidth,
        strokeOpacity,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const { id: seriesId, visible } = this;
    const { title, legendItemName, idKey, idName, colorKey, colorRange, showInLegend } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId,
        series: this.getFormatterContext("color"),
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: seriesId,
        itemId: seriesId,
        seriesId,
        enabled: visible,
        label: { text: legendItemName ?? title ?? idName ?? idKey },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      properties,
      ctx: { formatManager }
    } = this;
    const {
      idKey,
      idName,
      colorKey,
      colorName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      title,
      legendItemName,
      tooltip
    } = properties;
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const idValues = dataModel.resolveColumnById(this, `idValue`, processedData);
    const sizeValue = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData)[datumIndex] : void 0;
    const colorValue = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData)[datumIndex] : void 0;
    const data = [];
    if (this.isLabelEnabled() && labelKey != null && labelKey !== idKey) {
      const labelValue = dataModel.resolveColumnById(this, `labelValue`, processedData)[datumIndex];
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value: labelValue,
        datum,
        seriesId,
        legendItemName,
        key: labelKey,
        source: "tooltip",
        property: "label",
        domain: [],
        boundSeries: this.getFormatterContext("label")
      });
      data.push({ label: labelName, fallbackLabel: labelKey, value: content ?? labelValue });
    }
    if (sizeValue != null && sizeKey != null) {
      const domain = dataModel.getDomain(this, `sizeValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: sizeValue,
        datum,
        seriesId,
        legendItemName,
        key: sizeKey,
        source: "tooltip",
        property: "size",
        domain,
        boundSeries: this.getFormatterContext("size"),
        fractionDigits: void 0
      });
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: content ?? String(sizeValue) });
    }
    if (colorValue != null && colorKey != null) {
      const domain = dataModel.getDomain(this, `colorValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: colorValue,
        datum,
        seriesId,
        legendItemName,
        key: colorKey,
        source: "tooltip",
        property: "color",
        domain,
        boundSeries: this.getFormatterContext("color"),
        fractionDigits: void 0
      });
      data.push({ label: colorName, fallbackLabel: colorKey, value: content ?? String(colorValue) });
    }
    const format = this.getItemBaseStyle(false);
    Object.assign(
      format,
      this.getItemStyleOverrides(String(datumIndex), datumIndex, colorValue, sizeValue, format, false, datumIndex)
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: idValues[datumIndex],
        title: title ?? legendItemName,
        symbol: this.legendItemSymbol(datumIndex),
        data
      },
      {
        seriesId,
        datum,
        title,
        idKey,
        idName,
        colorKey,
        colorName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        ...format
      }
    );
  }
  computeFocusBounds(opts) {
    const geometry = findFocusedGeoGeometry(this, opts);
    return geometry ? Transformable22.toCanvas(this.contentGroup, geometry.getBBox()) : void 0;
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
MapLineSeries.className = "MapLineSeries";
MapLineSeries.type = "map-line";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs11, mapLineSeriesThemeableOptionsDef: mapLineSeriesThemeableOptionsDef2, without: without5 } = module_support_exports;
var mapLineSeriesOptionsDef = {
  ...without5(commonSeriesOptionsDefs11, ["highlightStyle", "highlight"]),
  ...mapLineSeriesThemeableOptionsDef2,
  type: required(constant("map-line")),
  idKey: required(string),
  sizeKey: string,
  colorKey: string,
  labelKey: string,
  idName: string,
  sizeName: string,
  colorName: string,
  labelName: string,
  topology: geoJson,
  topologyIdKey: string,
  legendItemName: string,
  title: string
};
mapLineSeriesOptionsDef.colorRange = undocumented(and(arrayOf(color), arrayLength(1)));
var MapLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-line",
  moduleFactory: (ctx) => new MapLineSeries(ctx),
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      stroke: applyMapPalette(module_support_exports.SAFE_STROKE_FILL_OPERATION),
      // @ts-expect-error undocumented option
      colorRange: {
        $if: [
          { $eq: [{ $mapPalette: "type" }, "inbuilt"] },
          { $mapPalette: "divergingColors" },
          applyMapPalette(module_support_exports.SAFE_RANGE2_OPERATION)
        ]
      },
      strokeWidth: 1,
      maxStrokeWidth: 3,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        enabled: true,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      highlight: applyMapPalette(module_support_exports.multiSeriesHighlightStyle(false))
    },
    tooltip: {
      range: "exact"
    }
  }
};
var MapLineSeriesModule = {
  type: "series",
  name: "map-line",
  chartType: "topology",
  enterprise: true,
  options: mapLineSeriesOptionsDef,
  create: (ctx) => new MapLineSeries(ctx)
};
var { Property: Property71, SeriesProperties: SeriesProperties4, makeSeriesTooltip: makeSeriesTooltip13 } = module_support_exports;
var MapLineBackgroundSeriesProperties = class extends SeriesProperties4 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tooltip = makeSeriesTooltip13();
  }
};
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property71
], MapLineBackgroundSeriesProperties.prototype, "tooltip", 2);
var { createDatumId: createDatumId11, Group: Group12, Selection: Selection10, PointerEvents: PointerEvents6 } = module_support_exports;
var MapLineBackgroundSeries = class extends TopologySeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      pickModes: []
    });
    this.properties = new MapLineBackgroundSeriesProperties();
    this._chartTopology = void 0;
    this.itemGroup = this.contentGroup.appendChild(new Group12({ name: "itemGroup" }));
    this.datumSelection = Selection10.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.itemGroup.pointerEvents = PointerEvents6.None;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get focusable() {
    return false;
  }
  setOptionsData() {
  }
  setChartData() {
  }
  get hasData() {
    return false;
  }
  renderToOffscreenCanvas() {
    return true;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [0, zIndex, 0];
    this.highlightGroup.zIndex = [0, zIndex, 1];
    return true;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 2;
    geoGeometry.lineJoin = "round";
    geoGeometry.lineCap = "round";
    geoGeometry.pointerEvents = PointerEvents6.None;
    return geoGeometry;
  }
  processData() {
    const { topology } = this;
    this.topologyBounds = topology?.features.reduce((current, feature) => {
      const geometry = feature.geometry;
      if (geometry == null)
        return current;
      return geometryBbox(geometry, current);
    }, void 0);
    if (topology == null) {
      logger_exports.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);
    }
  }
  createNodeData() {
    const { id: seriesId, topology, scale: scale2 } = this;
    if (topology == null)
      return;
    const nodeData = [];
    const labelData = [];
    topology.features.forEach((feature, index) => {
      const { geometry } = feature;
      const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
      if (projectedGeometry == null)
        return;
      nodeData.push({
        series: this,
        itemId: index,
        datum: feature,
        datumIndex: 0,
        index,
        projectedGeometry
      });
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  update() {
    const { datumSelection } = this;
    this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.labelGroup.visible = this.visible;
    const { nodeData = [] } = this.contextNodeData ?? {};
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId11(datum.index));
  }
  updateDatumNodes(opts) {
    const { properties } = this;
    const { datumSelection } = opts;
    const { stroke: stroke22, strokeOpacity, lineDash, lineDashOffset } = properties;
    const strokeWidth = properties.strokeWidth;
    datumSelection.each((geoGeometry, datum) => {
      const { projectedGeometry } = datum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      geoGeometry.stroke = stroke22;
      geoGeometry.strokeWidth = strokeWidth;
      geoGeometry.strokeOpacity = strokeOpacity;
      geoGeometry.lineDash = lineDash;
      geoGeometry.lineDashOffset = lineDashOffset;
    });
  }
  resetAnimation() {
  }
  getLegendData() {
    return [];
  }
  getTooltipContent(_seriesDatum) {
    return;
  }
  computeFocusBounds(_opts) {
    return void 0;
  }
  hasItemStylers() {
    return false;
  }
};
MapLineBackgroundSeries.className = "MapLineBackgroundSeries";
MapLineBackgroundSeries.type = "map-line-background";
var { mapLineBackgroundSeriesThemeableOptionsDef: mapLineBackgroundSeriesThemeableOptionsDef2 } = module_support_exports;
var mapLineBackgroundSeriesOptionsDef = {
  ...mapLineBackgroundSeriesThemeableOptionsDef2,
  type: required(constant("map-line-background")),
  topology: geoJson
};
var MapLineBackgroundModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-line-background",
  moduleFactory: (ctx) => new MapLineBackgroundSeries(ctx),
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      stroke: { $path: ["/1", { $mapPalette: "stroke" }, { $mapPalette: "secondHierarchyColors" }] },
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0
    }
  }
};
var MapLineBackgroundSeriesModule = {
  type: "series",
  name: "map-line-background",
  chartType: "topology",
  enterprise: true,
  options: mapLineBackgroundSeriesOptionsDef,
  create: (ctx) => new MapLineBackgroundSeries(ctx)
};
var __MINI_CHART_SERIES_OPTIONS2 = void 0;
var __VERIFY_MINI_CHART_SERIES_OPTIONS2 = void 0;
__VERIFY_MINI_CHART_SERIES_OPTIONS2 = __MINI_CHART_SERIES_OPTIONS2;
var __THEME_OVERRIDES2 = void 0;
var __VERIFY_THEME_OVERRIDES2 = void 0;
__VERIFY_THEME_OVERRIDES2 = __THEME_OVERRIDES2;
var __THEMEABLE_OPTIONS2 = void 0;
var __VERIFY_THEMEABLE_OPTIONS2 = void 0;
__VERIFY_THEMEABLE_OPTIONS2 = __THEMEABLE_OPTIONS2;
var __AXIS_LABEL_OPTIONS2 = void 0;
var __VERIFY_AXIS_LABEL_OPTIONS2 = void 0;
__VERIFY_AXIS_LABEL_OPTIONS2 = __AXIS_LABEL_OPTIONS2;
function polygonPointSearch(polygons, precision, valueFn) {
  const bbox = polygonBbox(polygons[0], void 0);
  if (bbox == null)
    return;
  const boundingXCenter = (bbox.lon0 + bbox.lon1) / 2;
  const boundingYCenter = (bbox.lat0 + bbox.lat1) / 2;
  const boundingWidth = Math.abs(bbox.lon1 - bbox.lon0);
  const boundingHeight = Math.abs(bbox.lat1 - bbox.lat0);
  const centroid = polygonCentroid(polygons[0]);
  const [cx, cy] = centroid;
  const centroidDistanceToPolygon = -polygonDistance(polygons, cx, cy);
  let bestResult;
  const cellValue = (distanceToPolygon, distanceToCentroid) => {
    const centroidDriftFactor = 0.5;
    const centroidDrift = Math.max(distanceToCentroid - centroidDistanceToPolygon, 0);
    return distanceToPolygon - centroidDriftFactor * centroidDrift;
  };
  const createLabelPlacement = (x2, y2, stride) => {
    const { distance: distance22, maxDistance } = valueFn(polygons, x2, y2, stride);
    const distanceToCentroid = Math.hypot(cx - x2, cy - y2);
    const maxXTowardsCentroid = Math.min(Math.max(cx, x2 - stride / 2), x2 + stride / 2);
    const maxYTowardsCentroid = Math.min(Math.max(cy, y2 - stride / 2), y2 + stride / 2);
    const minDistanceToCentroid = Math.hypot(cx - maxXTowardsCentroid, cy - maxYTowardsCentroid);
    const value = cellValue(distance22, distanceToCentroid);
    const maxValue = cellValue(maxDistance, minDistanceToCentroid);
    return { distance: distance22, maxDistance, value, maxValue, x: x2, y: y2, stride };
  };
  const appendLabelPlacement = (into, x2, y2, stride) => {
    const labelPlacement = createLabelPlacement(x2, y2, stride);
    if (labelPlacement.maxDistance >= 0) {
      into.push(labelPlacement);
    }
  };
  const initialStride = Math.min(boundingWidth, boundingHeight) / 2;
  let queue = {
    value: createLabelPlacement(boundingXCenter, boundingYCenter, initialStride),
    next: null
  };
  while (queue != null) {
    const item = queue.value;
    const { distance: distance22, value, maxValue, x: x2, y: y2, stride } = item;
    queue = queue.next;
    if (distance22 > 0 && (bestResult == null || value > bestResult.value)) {
      bestResult = item;
    }
    if (bestResult != null && maxValue - bestResult.value <= precision) {
      continue;
    }
    const nextStride = stride / 2;
    const newLabelPlacements = [];
    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 - nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 - nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 + nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 + nextStride, nextStride);
    newLabelPlacements.sort(labelPlacementCmp);
    queue = insertListItemsSorted(queue, newLabelPlacements, labelPlacementCmp);
  }
  if (bestResult == null)
    return;
  const { distance: distance2, x, y } = bestResult;
  return { x, y, distance: distance2 };
}
var labelPlacementCmp = (a, b) => b.maxValue - a.maxValue;
function polygonMarkerCenter(polygons, precision) {
  const result = polygonPointSearch(polygons, precision, (p, x2, y2, stride) => {
    const distance2 = -polygonDistance(p, x2, y2);
    const maxDistance = distance2 + stride * Math.SQRT2;
    return { distance: distance2, maxDistance };
  });
  if (result == null)
    return;
  const { x, y } = result;
  return [x, y];
}
function markerPositions(geometry, precision) {
  let center2;
  switch (geometry.type) {
    case "GeometryCollection":
      return geometry.geometries.flatMap((g) => markerPositions(g, precision));
    case "MultiPoint":
      return geometry.coordinates;
    case "Point":
      return [geometry.coordinates];
    case "MultiPolygon": {
      const polygon = largestPolygon(geometry);
      center2 = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;
      break;
    }
    case "Polygon": {
      const polygon = geometry.coordinates;
      center2 = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;
      break;
    }
    case "MultiLineString": {
      const lineString = largestLineString(geometry);
      center2 = lineString != null ? lineStringCenter(lineString)?.point : void 0;
      break;
    }
    case "LineString": {
      const lineString = geometry.coordinates;
      center2 = lineStringCenter(lineString)?.point;
      break;
    }
  }
  return center2 != null ? [center2] : [];
}
var { BBox: BBox21 } = module_support_exports;
function getTopologyShapeFillBBox(scale2) {
  if (!scale2)
    return;
  const { range: range22 } = scale2;
  const x = range22[0][0];
  const y = range22[0][1];
  const width2 = range22[1][0] - x;
  const height2 = range22[1][1] - y;
  const bbox = new BBox21(x, y, width2, height2);
  return {
    series: bbox,
    axis: bbox
  };
}
var {
  FillGradientDefaults: FillGradientDefaults10,
  FillPatternDefaults: FillPatternDefaults10,
  FillImageDefaults: FillImageDefaults10,
  Property: Property72,
  SeriesProperties: SeriesProperties5,
  makeSeriesTooltip: makeSeriesTooltip14,
  Label: Label11
} = module_support_exports;
var MapMarkerSeriesLabel = class extends Label11 {
  constructor() {
    super(...arguments);
    this.placement = "bottom";
  }
};
__decorateClass2([
  Property72
], MapMarkerSeriesLabel.prototype, "placement", 2);
var MapMarkerSeriesProperties = class extends SeriesProperties5 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = void 0;
    this.topologyIdKey = "name";
    this.idName = void 0;
    this.latitudeKey = void 0;
    this.latitudeName = void 0;
    this.longitudeKey = void 0;
    this.longitudeName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.shape = "circle";
    this.size = 6;
    this.fill = "black";
    this.fillGradientDefaults = new FillGradientDefaults10();
    this.fillPatternDefaults = new FillPatternDefaults10();
    this.fillImageDefaults = new FillImageDefaults10();
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.label = new MapMarkerSeriesLabel();
    this.tooltip = makeSeriesTooltip14();
  }
  getStyle() {
    const { size, shape, fill, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      size,
      shape,
      fill,
      fillOpacity,
      opacity: 1,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
};
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "legendItemName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "latitudeKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "latitudeName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "longitudeKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "longitudeName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "sizeKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "shape", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "size", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "maxSize", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "sizeDomain", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property72
], MapMarkerSeriesProperties.prototype, "tooltip", 2);
var {
  CachedTextMeasurerPool: CachedTextMeasurerPool9,
  fromToMotion: fromToMotion3,
  StateMachine: StateMachine13,
  getMissCount: getMissCount3,
  createDatumId: createDatumId12,
  SeriesNodePickMode: SeriesNodePickMode10,
  valueProperty: valueProperty13,
  computeMarkerFocusBounds: computeMarkerFocusBounds22,
  ColorScale: ColorScale3,
  LinearScale: LinearScale6,
  Group: Group13,
  Selection: Selection11,
  Text: Text5,
  Marker: Marker4,
  applyShapeStyle: applyShapeStyle11,
  getShapeStyle: getShapeStyle9,
  getLabelStyles: getLabelStyles3,
  LonLatBBox: LonLatBBox3,
  mergeDefaults: mergeDefaults13
} = module_support_exports;
var MapMarkerSeries = class extends TopologySeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      propertyKeys: {
        size: ["colorKey"],
        color: ["colorKey"],
        label: ["labelKey"]
      },
      propertyNames: {
        size: ["sizeName"],
        color: ["colorName"],
        label: ["labelName"]
      },
      pickModes: [SeriesNodePickMode10.EXACT_SHAPE_MATCH, SeriesNodePickMode10.NEAREST_NODE],
      usesPlacedLabels: true
    });
    this.properties = new MapMarkerSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale3();
    this.sizeScale = new LinearScale6();
    this.markerGroup = this.contentGroup.appendChild(new Group13({ name: "markerGroup" }));
    this.labelSelection = Selection11.select(this.labelGroup, Text5, false);
    this.markerSelection = Selection11.select(
      this.markerGroup,
      Marker4,
      false
    );
    this.highlightMarkerSelection = Selection11.select(this.highlightGroup, Marker4);
    this.animationState = new StateMachine13(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: () => this.animateMarkers()
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          resize: () => this.resetAllAnimation(),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: () => this.animateMarkers()
          },
          // chart.ts transitions to updateData on zoom change
          resize: {
            target: "ready",
            action: () => this.resetAllAnimation()
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: () => this.resetAllAnimation()
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get hasData() {
    const hasLatLon = this.properties.latitudeKey != null && this.properties.longitudeKey != null;
    return super.hasData && (this.topology != null || hasLatLon);
  }
  renderToOffscreenCanvas() {
    return true;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [3, zIndex];
    this.highlightGroup.zIndex = [4, zIndex];
    return true;
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, topology, sizeScale, colorScale } = this;
    const { topologyIdKey, idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;
    const featureById = /* @__PURE__ */ new Map();
    topology?.features.forEach((feature) => {
      const property = feature.properties?.[topologyIdKey];
      if (property == null)
        return;
      featureById.set(property, feature);
    });
    const sizeScaleType = this.sizeScale.type;
    const colorScaleType = this.colorScale.type;
    const mercatorScaleType = this.scale?.type;
    const hasLatLon = latitudeKey != null && longitudeKey != null;
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props: [
        ...idKey != null ? [
          valueProperty13(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
          valueProperty13(idKey, mercatorScaleType, {
            id: "featureValue",
            includeProperty: false,
            processor: () => (datum) => featureById.get(datum)
          })
        ] : [],
        ...hasLatLon ? [
          valueProperty13(latitudeKey, mercatorScaleType, { id: "latValue" }),
          valueProperty13(longitudeKey, mercatorScaleType, { id: "lonValue" })
        ] : [],
        ...labelKey ? [valueProperty13(labelKey, "category", { id: "labelValue" })] : [],
        ...sizeKey ? [valueProperty13(sizeKey, sizeScaleType, { id: "sizeValue" })] : [],
        ...colorKey ? [valueProperty13(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    const featureValues = idKey != null ? dataModel.resolveColumnById(this, `featureValue`, processedData) : void 0;
    const latValues = hasLatLon ? dataModel.resolveColumnById(this, `latValue`, processedData) : void 0;
    const lonValues = hasLatLon ? dataModel.resolveColumnById(this, `lonValue`, processedData) : void 0;
    this.topologyBounds = processedData.dataSources.get(this.id)?.reduce((current, _datum, datumIndex) => {
      const feature = featureValues?.[datumIndex];
      const geometry = feature?.geometry;
      if (geometry != null) {
        current = geometryBbox(geometry, current);
      }
      if (latValues != null && lonValues != null) {
        const lon = lonValues[datumIndex];
        const lat = latValues[datumIndex];
        current = LonLatBBox3.extend(current, lon, lat, lon, lat);
      }
      return current;
    }, void 0);
    if (sizeKey != null) {
      const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
      const processedSize = processedData.domain.values[sizeIdx] ?? [];
      sizeScale.domain = sizeDomain ?? processedSize;
    }
    if (colorRange != null && this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      colorScale.domain = processedData.domain.values[colorKeyIdx];
      colorScale.range = colorRange;
      colorScale.update();
    }
    this.animationState.transition("updateData");
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.input.count;
    const missCount = getMissCount3(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelDatum(datum, labelValue, x, y, size, measurer22) {
    if (labelValue == null)
      return;
    const {
      idKey,
      idName,
      latitudeKey,
      latitudeName,
      longitudeKey,
      longitudeName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      label,
      shape
    } = this.properties;
    if (labelKey == null || !label.enabled)
      return;
    const { placement } = label;
    const labelText = this.getLabelText(
      labelValue,
      datum,
      labelKey,
      "label",
      [],
      label,
      {
        value: labelValue,
        datum,
        idKey,
        idName,
        latitudeKey,
        latitudeName,
        longitudeKey,
        longitudeName,
        sizeKey,
        sizeName,
        colorKey,
        colorName,
        labelKey,
        labelName
      }
    );
    if (labelText == null)
      return;
    const { width: width2, height: height2 } = measurer22.measureText(String(labelText));
    const anchor = Marker4.anchor(shape);
    return {
      point: { x, y, size },
      label: { width: width2, height: height2, text: labelText },
      anchor,
      placement
    };
  }
  createNodeData() {
    const { id: seriesId, dataModel, processedData, sizeScale, properties, scale: scale2 } = this;
    const { idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, label, legendItemName } = properties;
    if (dataModel == null || processedData == null || scale2 == null)
      return;
    const hasLatLon = latitudeKey != null && longitudeKey != null;
    const idValues = idKey != null ? dataModel.resolveColumnById(this, `idValue`, processedData) : void 0;
    const featureValues = idKey != null ? dataModel.resolveColumnById(this, `featureValue`, processedData) : void 0;
    const latValues = hasLatLon ? dataModel.resolveColumnById(this, `latValue`, processedData) : void 0;
    const lonValues = hasLatLon ? dataModel.resolveColumnById(this, `lonValue`, processedData) : void 0;
    const labelValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const sizeValues = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const colorValues = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData) : void 0;
    const markerMaxSize = properties.maxSize ?? properties.size;
    sizeScale.range = [Math.min(properties.size, markerMaxSize), markerMaxSize];
    const measurer22 = CachedTextMeasurerPool9.getMeasurer({ font: label });
    let projectedGeometries;
    if (idValues != null && featureValues != null) {
      projectedGeometries = /* @__PURE__ */ new Map();
      processedData.dataSources.get(this.id)?.forEach((_datum, datumIndex) => {
        const id = idValues[datumIndex];
        const geometry = featureValues[datumIndex]?.geometry ?? void 0;
        const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
        if (id != null && projectedGeometry != null) {
          projectedGeometries.set(id, projectedGeometry);
        }
      });
    }
    const nodeData = [];
    const labelData = [];
    const missingGeometries = [];
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const idValue = idValues?.[datumIndex];
      const lonValue = lonValues?.[datumIndex];
      const latValue = latValues?.[datumIndex];
      const colorValue = colorValues?.[datumIndex];
      const sizeValue = sizeValues?.[datumIndex];
      const labelValue = labelValues?.[datumIndex];
      const size = sizeValue != null ? sizeScale.convert(sizeValue, { clamp: true }) : properties.size;
      const projectedGeometry = idValue != null ? projectedGeometries?.get(idValue) : void 0;
      if (idValue != null && projectGeometry == null) {
        missingGeometries.push(idValue);
      }
      if (lonValue != null && latValue != null) {
        const [x, y] = scale2.convert([lonValue, latValue]);
        const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, measurer22);
        if (labelDatum) {
          labelData.push(labelDatum);
        }
        nodeData.push({
          series: this,
          itemId: latitudeKey,
          datum,
          datumIndex,
          index: -1,
          idValue,
          lonValue,
          latValue,
          labelValue,
          sizeValue,
          colorValue,
          point: { x, y, size },
          midPoint: { x, y },
          legendItemName
        });
      } else if (projectedGeometry != null) {
        markerPositions(projectedGeometry, 1).forEach(([x, y], index) => {
          const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, measurer22);
          if (labelDatum) {
            labelData.push(labelDatum);
          }
          nodeData.push({
            series: this,
            itemId: latitudeKey,
            datum,
            datumIndex,
            index,
            idValue,
            lonValue,
            latValue,
            labelValue,
            sizeValue,
            colorValue,
            point: { x, y, size },
            midPoint: { x, y },
            legendItemName
          });
        });
      }
    });
    const missingGeometriesCap = 10;
    if (missingGeometries.length > missingGeometriesCap) {
      const excessItems = missingGeometries.length - missingGeometriesCap;
      missingGeometries.length = missingGeometriesCap;
      missingGeometries.push(`(+${excessItems} more)`);
    }
    if (missingGeometries.length > 0) {
      logger_exports.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
    }
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  checkScaleChange() {
    if (this.previousScale === this.scale)
      return false;
    this.previousScale = this.scale;
    return true;
  }
  update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    const scaleChange = this.checkScaleChange();
    const { markerSelection, highlightMarkerSelection } = this;
    this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.labelGroup.visible = this.visible;
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const { legendItemName } = this.properties;
    const matchingLegendItemName = legendItemName != null && highlightedDatum?.datum == null && legendItemName === highlightedDatum?.legendItemName;
    if (highlightedDatum != null && (highlightedDatum.series !== this && !matchingLegendItemName || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    this.markerSelection = this.updateMarkerSelection({ markerData: nodeData, markerSelection });
    this.updateMarkerNodes({ markerSelection, isHighlight: false, highlightedDatum });
    this.highlightMarkerSelection = this.updateMarkerSelection({
      markerData: highlightedDatum != null ? [highlightedDatum] : [],
      markerSelection: highlightMarkerSelection
    });
    this.updateMarkerNodes({
      markerSelection: highlightMarkerSelection,
      isHighlight: true,
      highlightedDatum
    });
    if (scaleChange || resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updatePlacedLabelData(labelData) {
    this.labelSelection = this.labelSelection.update(labelData, (text2) => {
      text2.pointerEvents = module_support_exports.PointerEvents.None;
    });
    this.updateLabelNodes({ labelSelection: this.labelSelection });
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((label, { x, y, width: width2, height: height2, text: text2 }, datumIndex) => {
      const style2 = getLabelStyles3(
        this,
        void 0,
        this.properties,
        this.properties.label
      );
      const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = style2;
      label.visible = true;
      label.x = x + width2 / 2;
      label.y = y + height2 / 2;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = "center";
      label.textBaseline = "middle";
      label.fillOpacity = this.getHighlightStyle(false, datumIndex).opacity ?? 1;
      label.setBoxing(style2);
    });
  }
  updateMarkerSelection(opts) {
    const { markerData, markerSelection } = opts;
    return markerSelection.update(
      markerData,
      void 0,
      (datum) => createDatumId12([datum.index, datum.idValue, datum.lonValue, datum.latValue])
    );
  }
  getMarkerItemStyle({ datumIndex, datum, colorValue, sizeValue }, isHighlight) {
    const { id: seriesId, properties, colorScale, sizeScale } = this;
    const { colorRange, itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults13(highlightStyle, properties.getStyle());
    if (!isHighlight && colorValue != null) {
      baseStyle.fill = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange?.[0] ?? baseStyle.fill;
    }
    if (sizeValue != null) {
      baseStyle.size = sizeScale.convert(sizeValue, { clamp: true });
    }
    let style2 = getShapeStyle9(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && datumIndex != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId12(datumIndex, isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle9(
          mergeDefaults13(overrides, baseStyle),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateMarkerNodes(opts) {
    const { markerSelection, isHighlight, highlightedDatum } = opts;
    const fillBBox = getTopologyShapeFillBBox(this.scale);
    markerSelection.each((marker, markerDatum) => {
      const { datum, point } = markerDatum;
      const style2 = this.getMarkerItemStyle(markerDatum, isHighlight);
      marker.shape = style2.shape;
      marker.size = style2.size;
      applyShapeStyle11(marker, style2, fillBBox);
      marker.x = point.x;
      marker.y = point.y;
      marker.scalingCenterX = point.x;
      marker.scalingCenterY = point.y;
      marker.zIndex = !isHighlight && highlightedDatum != null && datum === highlightedDatum.datum ? 1 : 0;
    });
  }
  isProcessedDataAnimatable() {
    return true;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.ctx.animationManager.skipCurrentBatch();
    this.labelSelection.cleanup();
    this.markerSelection.cleanup();
    this.highlightMarkerSelection.cleanup();
  }
  animateMarkers() {
    const { animationManager } = this.ctx;
    const fns = prepareMapMarkerAnimationFunctions();
    fromToMotion3(this.id, "markers", animationManager, [this.markerSelection, this.highlightMarkerSelection], fns);
  }
  getLabelData() {
    if (!this.isLabelEnabled())
      return [];
    return this.contextNodeData?.labelData ?? [];
  }
  pickNodeClosestDatum(p) {
    const { x: x0, y: y0 } = p;
    let minDistanceSquared = Infinity;
    let minDatum;
    this.contextNodeData?.nodeData.forEach((datum) => {
      const { x, y, size } = datum.point;
      const dx2 = Math.max(Math.abs(x - x0) - size, 0);
      const dy2 = Math.max(Math.abs(y - y0) - size, 0);
      const distanceSquared2 = dx2 * dx2 + dy2 * dy2;
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  legendItemSymbol(datumIndex) {
    const { dataModel, processedData, properties } = this;
    const { shape, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = properties;
    let { fill } = properties;
    if (datumIndex != null && this.isColorScaleValid()) {
      const colorValues = dataModel.resolveColumnById(this, "colorValue", processedData);
      const colorValue = colorValues[datumIndex];
      fill = this.colorScale.convert(colorValue);
    }
    return {
      marker: getShapeStyle9(
        {
          shape,
          fill,
          fillOpacity,
          stroke: stroke22,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        },
        this.properties.fillGradientDefaults,
        this.properties.fillPatternDefaults,
        this.properties.fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const { id: seriesId, visible } = this;
    const { title, legendItemName, idName, idKey, colorKey, colorRange, showInLegend } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId,
        series: this.getFormatterContext("color"),
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: seriesId,
        itemId: seriesId,
        seriesId,
        enabled: visible,
        label: { text: legendItemName ?? title ?? idName ?? idKey ?? seriesId },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      properties,
      ctx: { formatManager }
    } = this;
    const {
      idKey,
      idName,
      latitudeKey,
      latitudeName,
      longitudeKey,
      longitudeName,
      colorKey,
      colorName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      title,
      legendItemName,
      tooltip
    } = properties;
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const sizeValue = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData)[datumIndex] : void 0;
    const colorValue = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData)[datumIndex] : void 0;
    const data = [];
    if (this.isLabelEnabled() && labelKey != null && labelKey !== idKey) {
      const labelValue = dataModel.resolveColumnById(this, `labelValue`, processedData)[datumIndex];
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value: labelValue,
        datum,
        seriesId,
        legendItemName,
        key: labelKey,
        source: "tooltip",
        property: "label",
        domain: [],
        boundSeries: this.getFormatterContext("label")
      });
      data.push({ label: labelName, fallbackLabel: labelKey, value: content ?? labelValue });
    }
    if (sizeKey != null && sizeValue != null) {
      const domain = dataModel.getDomain(this, `sizeValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: sizeValue,
        datum,
        seriesId,
        legendItemName,
        key: sizeKey,
        source: "tooltip",
        property: "size",
        domain,
        boundSeries: this.getFormatterContext("size"),
        fractionDigits: void 0
      });
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: content ?? String(sizeValue) });
    }
    if (colorKey != null && colorValue != null) {
      const domain = dataModel.getDomain(this, `colorValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: colorValue,
        datum,
        seriesId,
        legendItemName,
        key: colorKey,
        source: "tooltip",
        property: "color",
        domain,
        boundSeries: this.getFormatterContext("color"),
        fractionDigits: void 0
      });
      data.push({ label: colorName, fallbackLabel: colorKey, value: content ?? String(colorValue) });
    }
    let heading;
    if (idKey != null) {
      heading = dataModel.resolveColumnById(this, `idValue`, processedData)[datumIndex];
    } else if (latitudeKey != null && longitudeKey != null) {
      const latValue = dataModel.resolveColumnById(this, `latValue`, processedData)[datumIndex];
      const lonValue = dataModel.resolveColumnById(this, `lonValue`, processedData)[datumIndex];
      heading = `${Math.abs(latValue).toFixed(4)}\xB0 ${latValue >= 0 ? "N" : "S"}, ${Math.abs(lonValue).toFixed(4)}\xB0 ${lonValue >= 0 ? "W" : "E"}`;
    }
    const format = this.getMarkerItemStyle({ datumIndex, datum, colorValue, sizeValue }, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading,
        title: title ?? legendItemName,
        symbol: this.legendItemSymbol(datumIndex),
        data
      },
      {
        seriesId,
        datum,
        title,
        idKey,
        idName,
        latitudeKey,
        latitudeName,
        longitudeKey,
        longitudeName,
        colorKey,
        colorName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        ...format
      }
    );
  }
  getFormattedMarkerStyle(markerDatum) {
    const format = this.getMarkerItemStyle(markerDatum, false);
    return { size: format.size, shape: format.shape };
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds22(this, opts);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
MapMarkerSeries.className = "MapMarkerSeries";
MapMarkerSeries.type = "map-marker";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs12, mapMarkerSeriesThemeableOptionsDef: mapMarkerSeriesThemeableOptionsDef2, without: without6 } = module_support_exports;
var mapMarkerSeriesOptionsDef = {
  ...without6(commonSeriesOptionsDefs12, ["highlightStyle", "highlight"]),
  ...mapMarkerSeriesThemeableOptionsDef2,
  type: required(constant("map-marker")),
  idKey: string,
  latitudeKey: string,
  longitudeKey: string,
  sizeKey: string,
  colorKey: string,
  labelKey: string,
  idName: string,
  latitudeName: string,
  longitudeName: string,
  sizeName: string,
  colorName: string,
  labelName: string,
  topology: geoJson,
  topologyIdKey: string,
  legendItemName: string,
  title: string
};
var MapMarkerModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-marker",
  moduleFactory: (ctx) => new MapMarkerSeries(ctx),
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      shape: "circle",
      maxSize: 30,
      fill: { $mapPalette: "fill" },
      stroke: { $mapPalette: "stroke" },
      colorRange: {
        $if: [
          { $eq: [{ $mapPalette: "type" }, "inbuilt"] },
          { $mapPalette: "divergingColors" },
          applyMapPalette(module_support_exports.SAFE_RANGE2_OPERATION)
        ]
      },
      // @ts-expect-error undocumented option
      fillGradientDefaults: applyMapPalette(module_support_exports.FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS),
      fillPatternDefaults: applyMapPalette(module_support_exports.FILL_PATTERN_DEFAULTS),
      fillImageDefaults: applyMapPalette(module_support_exports.FILL_IMAGE_DEFAULTS),
      fillOpacity: 0.5,
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      highlight: applyMapPalette(module_support_exports.multiSeriesHighlightStyle())
    },
    tooltip: {
      range: "exact"
    }
  }
};
var MapMarkerSeriesModule = {
  type: "series",
  name: "map-marker",
  chartType: "topology",
  enterprise: true,
  options: mapMarkerSeriesOptionsDef,
  create: (ctx) => new MapMarkerSeries(ctx),
  validate(options, optionsDefs2, path) {
    const result = validate(options, optionsDefs2, path);
    const { cleared, invalid } = result;
    if (cleared?.idKey == null && (cleared?.latitudeKey == null || cleared?.longitudeKey == null)) {
      const extendPath2 = (key) => path ? `${path}.${key}` : key;
      const message = `Either \`${extendPath2("idKey")}\` or both \`${extendPath2("latitudeKey")}\` and \`${extendPath2("longitudeKey")}\` are required.`;
      invalid.push(new ValidationError("required", message, null, path));
    }
    return result;
  }
};
function preferredLabelCenter(polygons, { aspectRatio, precision }) {
  const result = polygonPointSearch(polygons, precision, (p, cx, cy, stride) => {
    const width2 = maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(p, cx, cy, aspectRatio);
    const maxWidth2 = width2 + 2 * stride * aspectRatio;
    const distance22 = width2 * Math.SQRT2;
    const maxDistance = maxWidth2 * Math.SQRT2;
    return { distance: distance22, maxDistance };
  });
  if (result == null)
    return;
  const { x, y, distance: distance2 } = result;
  const maxWidth = distance2 / Math.SQRT2;
  return { x, y, maxWidth };
}
function maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(a, b, cx, cy, aspectRatio) {
  const [ax, ay] = a;
  const [bx, by] = b;
  const positiveM = 1 / aspectRatio;
  const abx = bx - ax;
  const aby = by - ay;
  const [topPointX, topPointY] = ay <= by ? a : b;
  const [leftPointX, leftPointY] = ax <= bx ? a : b;
  const [bottomPointX, bottomPointY] = ay <= by ? b : a;
  const [rightPointX, rightPointY] = ax <= bx ? b : a;
  let maxWidth = Infinity;
  if (abx !== 0) {
    const abm = aby / abx;
    for (let i = 0; i <= 1; i += 1) {
      const m = i === 0 ? positiveM : -positiveM;
      const x = (abm * ax - ay - m * cx + cy) / (abm - m);
      if (x >= leftPointX && x <= rightPointX) {
        const width2 = Math.abs(cx - x) * 2;
        maxWidth = Math.min(maxWidth, width2);
      }
    }
  } else {
    for (let i = 0; i <= 1; i += 1) {
      const m = i === 0 ? positiveM : -positiveM;
      const y = m * (ax - cx) + cy;
      if (y >= topPointY && y <= bottomPointY) {
        const height2 = Math.abs(cy - y) * 2;
        const width2 = height2 * aspectRatio;
        maxWidth = Math.min(maxWidth, width2);
      }
    }
  }
  const positiveMRecip = aspectRatio;
  const centerToTopMRecip = Math.abs((topPointX - cx) / (topPointY - cy));
  const centerToBottomMRecip = Math.abs((bottomPointX - cx) / (bottomPointY - cy));
  if (bottomPointY < cy && centerToBottomMRecip < positiveMRecip) {
    const height2 = Math.abs(cy - bottomPointY) * 2;
    const width2 = height2 * aspectRatio;
    maxWidth = Math.min(maxWidth, width2);
  } else if (topPointY > cy && centerToTopMRecip < positiveMRecip) {
    const height2 = Math.abs(cy - topPointY) * 2;
    const width2 = height2 * aspectRatio;
    maxWidth = Math.min(maxWidth, width2);
  }
  const centerToLeftM = Math.abs((leftPointY - cy) / (leftPointX - cx));
  const centerToRightM = Math.abs((rightPointY - cy) / (rightPointX - cx));
  if (rightPointX < cx && centerToRightM < positiveM) {
    const width2 = Math.abs(cx - rightPointX) * 2;
    maxWidth = Math.min(maxWidth, width2);
  } else if (leftPointX > cx && centerToLeftM < positiveM) {
    const width2 = Math.abs(cx - leftPointX) * 2;
    maxWidth = Math.min(maxWidth, width2);
  }
  return maxWidth;
}
function maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(polygons, cx, cy, aspectRatio) {
  let inside = false;
  let minWidth = Infinity;
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    let [x0, y0] = p0;
    for (const p1 of polygon) {
      const [x1, y1] = p1;
      if (y1 > cy !== y0 > cy && cx < (x0 - x1) * (cy - y1) / (y0 - y1) + x1) {
        inside = !inside;
      }
      const width2 = maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(p0, p1, cx, cy, aspectRatio);
      minWidth = Math.min(minWidth, width2);
      p0 = p1;
      x0 = x1;
      y0 = y1;
    }
  }
  return (inside ? 1 : -1) * minWidth;
}
function applyX(into, cx, x) {
  if (x >= cx) {
    into.maxX = Math.min(into.maxX, x - cx);
  }
  if (x <= cx) {
    into.minX = Math.max(into.minX, x - cx);
  }
}
function xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(into, a, b, cx, cy, height2) {
  const ry0 = cy - height2 / 2;
  const ry1 = cy + height2 / 2;
  const [ax, ay] = a;
  const [bx, by] = b;
  const abx = bx - ax;
  const aby = by - ay;
  const [leftPointX, leftPointY] = ax <= bx ? a : b;
  const [rightPointX, rightPointY] = ax <= bx ? b : a;
  if (abx !== 0) {
    const abm = aby / abx;
    for (let i = 0; i <= 1; i += 1) {
      const y = i === 0 ? ry0 : ry1;
      const x = (y - ay) / abm + ax;
      if (x >= leftPointX && x <= rightPointX) {
        applyX(into, cx, x);
      }
    }
  } else if (Math.max(ry0, Math.min(ay, by)) <= Math.min(ry1, Math.max(ay, by))) {
    applyX(into, cx, ax);
  }
  if (rightPointX < cx && rightPointY >= ry0 && rightPointY <= ry1) {
    applyX(into, cx, rightPointX);
  } else if (leftPointX > cx && leftPointY >= ry0 && leftPointY <= ry1) {
    applyX(into, cx, leftPointX);
  }
  return into;
}
function maxWidthInPolygonForRectOfHeight(polygons, cx, cy, height2) {
  const result = {
    minX: -Infinity,
    maxX: Infinity
  };
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    for (const p1 of polygon) {
      xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(result, p0, p1, cx, cy, height2);
      p0 = p1;
    }
  }
  const { minX, maxX } = result;
  if (Number.isFinite(minX) && Number.isFinite(maxX)) {
    return { x: cx + (minX + maxX) / 2, width: maxX - minX };
  } else {
    return { x: cx, width: 0 };
  }
}
var { Property: Property73, SeriesProperties: SeriesProperties6, makeSeriesTooltip: makeSeriesTooltip15, FillGradientDefaults: FillGradientDefaults11, FillPatternDefaults: FillPatternDefaults11, FillImageDefaults: FillImageDefaults11 } = module_support_exports;
var MapShapeSeriesProperties = class extends SeriesProperties6 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = "";
    this.idName = void 0;
    this.topologyIdKey = "name";
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.fill = "black";
    this.fillGradientDefaults = new FillGradientDefaults11();
    this.fillPatternDefaults = new FillPatternDefaults11();
    this.fillImageDefaults = new FillImageDefaults11();
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.padding = 0;
    this.label = new AutoSizedSecondaryLabel();
    this.tooltip = makeSeriesTooltip15();
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "legendItemName", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "padding", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property73
], MapShapeSeriesProperties.prototype, "tooltip", 2);
var {
  getMissCount: getMissCount4,
  createDatumId: createDatumId13,
  SeriesNodePickMode: SeriesNodePickMode11,
  valueProperty: valueProperty14,
  CachedTextMeasurerPool: CachedTextMeasurerPool10,
  TextUtils: TextUtils6,
  ColorScale: ColorScale4,
  Group: Group14,
  Selection: Selection12,
  Text: Text6,
  PointerEvents: PointerEvents7,
  applyShapeStyle: applyShapeStyle12,
  getShapeStyle: getShapeStyle10,
  getLabelStyles: getLabelStyles4,
  mergeDefaults: mergeDefaults14
} = module_support_exports;
var fixedScale = module_support_exports.MercatorScale.fixedScale();
var MapShapeSeries = class extends TopologySeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      propertyKeys: {
        color: ["colorKey"],
        label: ["labelKey"]
      },
      propertyNames: {
        color: ["colorName"],
        label: ["labelName"]
      },
      pickModes: [SeriesNodePickMode11.EXACT_SHAPE_MATCH, SeriesNodePickMode11.NEAREST_NODE]
    });
    this.properties = new MapShapeSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale4();
    this.itemGroup = this.contentGroup.appendChild(new Group14({ name: "itemGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group14({ name: "itemLabelGroup" }));
    this.datumSelection = Selection12.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection12.select(
      this.itemLabelGroup,
      Text6
    );
    this.highlightDatumSelection = Selection12.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    this.previousLabelLayouts = void 0;
    this._previousDatumMidPoint = void 0;
    this.itemLabelGroup.pointerEvents = PointerEvents7.None;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get hasData() {
    return super.hasData && this.topology != null;
  }
  renderToOffscreenCanvas() {
    return true;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [1, zIndex];
    this.highlightGroup.zIndex = [2, zIndex];
    return true;
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 1;
    geoGeometry.lineJoin = "round";
    return geoGeometry;
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, topology, colorScale } = this;
    const { topologyIdKey, idKey, colorKey, labelKey, colorRange } = this.properties;
    const featureById = /* @__PURE__ */ new Map();
    topology?.features.forEach((feature) => {
      const property = feature.properties?.[topologyIdKey];
      if (property == null || !containsType(
        feature.geometry,
        1
        /* Polygon */
      ))
        return;
      featureById.set(property, feature);
    });
    const colorScaleType = this.colorScale.type;
    const mercatorScaleType = this.scale?.type;
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props: [
        valueProperty14(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
        valueProperty14(idKey, mercatorScaleType, {
          id: "featureValue",
          includeProperty: false,
          processor: () => (datum) => featureById.get(datum)
        }),
        ...labelKey ? [valueProperty14(labelKey, "category", { id: "labelValue" })] : [],
        ...colorKey ? [valueProperty14(colorKey, colorScaleType, { id: "colorValue" })] : []
      ]
    });
    const featureValues = dataModel.resolveColumnById(
      this,
      `featureValue`,
      processedData
    );
    this.topologyBounds = featureValues.reduce((current, feature) => {
      const geometry = feature?.geometry;
      if (geometry == null)
        return current;
      return geometryBbox(geometry, current);
    }, void 0);
    if (colorRange != null && this.isColorScaleValid()) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
      colorScale.domain = processedData.domain.values[colorKeyIdx];
      colorScale.range = colorRange;
      colorScale.update();
    }
    if (topology == null) {
      logger_exports.warnOnce(`no topology was provided for [MapShapeSeries]; nothing will be rendered.`);
    }
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.input.count;
    const missCount = getMissCount4(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelLayout(datum, labelValue, measurer22, geometry, previousLabelLayout) {
    if (labelValue == null || geometry == null)
      return;
    const { idKey, idName, colorKey, colorName, labelKey, labelName, padding: padding2, label } = this.properties;
    if (labelKey == null || !label.enabled)
      return;
    const labelText = this.getLabelText(
      labelValue,
      datum,
      labelKey,
      "label",
      [],
      label,
      {
        value: labelValue,
        datum,
        idKey,
        idName,
        colorKey,
        colorName,
        labelKey,
        labelName
      }
    );
    if (labelText == null)
      return;
    const baseSize = measurer22.measureText(String(labelText));
    const numLines = labelText.split("\n").length;
    const aspectRatio = (baseSize.width + 2 * padding2) / (numLines * TextUtils6.getLineHeight(label.fontSize) + 2 * padding2);
    if (previousLabelLayout?.geometry === geometry && previousLabelLayout?.labelText === labelText && previousLabelLayout?.aspectRatio === aspectRatio) {
      return previousLabelLayout;
    }
    const fixedGeometry = projectGeometry(geometry, fixedScale);
    const fixedPolygon = largestPolygon(fixedGeometry);
    if (fixedPolygon == null)
      return;
    const labelPlacement = preferredLabelCenter(fixedPolygon, {
      aspectRatio,
      precision: 1e-3
    });
    if (labelPlacement == null)
      return;
    const { x, y, maxWidth } = labelPlacement;
    return { geometry, labelText, aspectRatio, x, y, maxWidth, fixedPolygon };
  }
  getLabelDatum(labelLayout, scaling) {
    const { scale: scale2 } = this;
    if (scale2 == null)
      return;
    const { padding: padding2, label } = this.properties;
    const { labelText, aspectRatio, x: untruncatedX, y, maxWidth, fixedPolygon } = labelLayout;
    const maxSizeWithoutTruncation = {
      width: Math.ceil(maxWidth * scaling),
      height: Math.ceil(maxWidth * scaling / aspectRatio),
      meta: untruncatedX
    };
    const labelFormatting = formatSingleLabel(labelText, label, { padding: padding2 }, (height2, allowTruncation) => {
      if (!allowTruncation)
        return maxSizeWithoutTruncation;
      const result = maxWidthInPolygonForRectOfHeight(fixedPolygon, untruncatedX, y, height2 / scaling);
      return {
        width: result.width * scaling,
        height: height2,
        meta: result.x
      };
    });
    if (labelFormatting == null)
      return;
    const [{ text: text2, fontSize, lineHeight, width: width2 }, formattingX] = labelFormatting;
    if (text2 === TextUtils6.EllipsisChar)
      return;
    const x = width2 < maxSizeWithoutTruncation.width ? untruncatedX : formattingX;
    const position = this.scale.convert(fixedScale.invert([x, y]));
    return {
      x: position[0],
      y: position[1],
      text: text2,
      fontSize,
      lineHeight
    };
  }
  createNodeData() {
    const { id: seriesId, dataModel, processedData, properties, scale: scale2, previousLabelLayouts } = this;
    const { idKey, colorKey, labelKey, label, legendItemName } = properties;
    if (dataModel == null || processedData == null)
      return;
    const scaling = scale2 != null ? (scale2.range[1][0] - scale2.range[0][0]) / scale2.bounds.width : NaN;
    const idValues = dataModel.resolveColumnById(this, `idValue`, processedData);
    const featureValues = dataModel.resolveColumnById(
      this,
      `featureValue`,
      processedData
    );
    const labelValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const colorValues = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData) : void 0;
    const measurer22 = CachedTextMeasurerPool10.getMeasurer({ font: label });
    const labelLayouts = /* @__PURE__ */ new Map();
    this.previousLabelLayouts = labelLayouts;
    const nodeData = [];
    const labelData = [];
    const missingGeometries = [];
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const idValue = idValues[datumIndex];
      const colorValue = colorValues?.[datumIndex];
      const labelValue = labelValues?.[datumIndex];
      const geometry = featureValues[datumIndex]?.geometry ?? void 0;
      if (geometry == null) {
        missingGeometries.push(idValue);
      }
      const labelLayout = this.getLabelLayout(
        datum,
        labelValue,
        measurer22,
        geometry,
        previousLabelLayouts?.get(idValue)
      );
      if (labelLayout != null) {
        labelLayouts.set(idValue, labelLayout);
      }
      const labelDatum = labelLayout != null && scale2 != null ? this.getLabelDatum(labelLayout, scaling) : void 0;
      if (labelDatum != null) {
        labelData.push(labelDatum);
      }
      const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
      nodeData.push({
        series: this,
        itemId: idKey,
        datum,
        datumIndex,
        idValue,
        colorValue,
        labelValue,
        projectedGeometry,
        legendItemName
      });
    });
    const missingGeometriesCap = 10;
    if (missingGeometries.length > missingGeometriesCap) {
      const excessItems = missingGeometries.length - missingGeometriesCap;
      missingGeometries.length = missingGeometriesCap;
      missingGeometries.push(`(+${excessItems} more)`);
    }
    if (missingGeometries.length > 0) {
      logger_exports.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
    }
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  update() {
    const { datumSelection, labelSelection, highlightDatumSelection } = this;
    this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.labelGroup.visible = this.visible;
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const { legendItemName } = this.properties;
    const matchingLegendItemName = legendItemName != null && highlightedDatum?.datum == null && legendItemName === highlightedDatum?.legendItemName;
    if (highlightedDatum != null && (highlightedDatum.series !== this && !matchingLegendItemName || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection, isHighlight: false });
    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection });
    this.updateLabelNodes({ labelSelection });
    this.highlightDatumSelection = this.updateDatumSelection({
      nodeData: highlightedDatum != null ? [highlightedDatum] : [],
      datumSelection: highlightDatumSelection
    });
    this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId13(datum.idValue));
  }
  getItemStyle({ datumIndex, datum, colorValue }, isHighlight) {
    const { id: seriesId, properties, colorScale } = this;
    const { colorRange, itemStyler } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults14(highlightStyle, properties.getStyle());
    if (!isHighlight && colorValue != null) {
      baseStyle.fill = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange?.[0] ?? baseStyle.fill;
    }
    let style2 = getShapeStyle10(
      baseStyle,
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    if (itemStyler != null && datumIndex != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId13(datumIndex, isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle10(
          mergeDefaults14(overrides, style2),
          this.properties.fillGradientDefaults,
          this.properties.fillPatternDefaults,
          this.properties.fillImageDefaults
        );
      }
    }
    return style2;
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const fillBBox = getTopologyShapeFillBBox(this.scale);
    datumSelection.each((geoGeometry, nodeDatum) => {
      const { projectedGeometry } = nodeDatum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      const style2 = this.getItemStyle(nodeDatum, isHighlight);
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      applyShapeStyle12(geoGeometry, style2, fillBBox);
    });
  }
  updateLabelSelection(opts) {
    const labels = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(labels);
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((label, { x, y, text: text2, fontSize, lineHeight }, datumIndex) => {
      const style2 = getLabelStyles4(
        this,
        void 0,
        this.properties,
        this.properties.label
      );
      const { color: fill, fontStyle, fontWeight, fontFamily } = style2;
      label.visible = true;
      label.x = x;
      label.y = y;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.lineHeight = lineHeight;
      label.fontFamily = fontFamily;
      label.textAlign = "center";
      label.textBaseline = "middle";
      label.fillOpacity = this.getHighlightStyle(false, datumIndex).opacity ?? 1;
      label.setBoxing(style2);
    });
  }
  resetAnimation() {
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistanceSquared = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distanceSquared2 = node.distanceSquared(x, y);
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  datumMidPoint(datum) {
    const { _previousDatumMidPoint } = this;
    if (_previousDatumMidPoint?.datum === datum) {
      return _previousDatumMidPoint.point;
    }
    const projectedGeometry = datum.projectedGeometry;
    const polygon = projectedGeometry != null ? largestPolygon(projectedGeometry) : void 0;
    const center2 = polygon != null ? polygonMarkerCenter(polygon, 2) : void 0;
    const point = center2 != null ? { x: center2[0], y: center2[1] } : void 0;
    this._previousDatumMidPoint = { datum, point };
    return point;
  }
  legendItemSymbol(datumIndex) {
    const { dataModel, processedData, properties } = this;
    const { fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = properties;
    let { fill } = properties;
    if (datumIndex != null && this.isColorScaleValid()) {
      const colorValues = dataModel.resolveColumnById(this, "colorValue", processedData);
      const colorValue = colorValues[datumIndex];
      fill = this.colorScale.convert(colorValue);
    }
    return {
      marker: getShapeStyle10(
        {
          fill,
          fillOpacity,
          stroke: stroke22,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        },
        this.properties.fillGradientDefaults,
        this.properties.fillPatternDefaults,
        this.properties.fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const { id: seriesId, visible } = this;
    const { title, legendItemName, idKey, idName, colorKey, colorRange, showInLegend } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId,
        series: this.getFormatterContext("color"),
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: seriesId,
        itemId: seriesId,
        seriesId,
        enabled: visible,
        label: { text: legendItemName ?? title ?? idName ?? idKey },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      properties,
      ctx: { formatManager }
    } = this;
    const { idKey, idName, colorKey, colorName, labelKey, labelName, legendItemName, title, tooltip } = properties;
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const idValue = dataModel.resolveColumnById(this, `idValue`, processedData)[datumIndex];
    const colorValue = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData)[datumIndex] : void 0;
    const data = [];
    if (this.isLabelEnabled() && labelKey != null && labelKey !== idKey) {
      const labelValue = dataModel.resolveColumnById(this, `labelValue`, processedData)[datumIndex];
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "category",
        value: labelValue,
        datum,
        seriesId,
        legendItemName,
        key: labelKey,
        source: "tooltip",
        property: "label",
        domain: [],
        boundSeries: this.getFormatterContext("label")
      });
      data.push({ label: labelName, fallbackLabel: labelKey, value: content ?? labelValue });
    }
    if (colorValue != null) {
      const domain = dataModel.getDomain(this, `colorValue`, "value", processedData);
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: colorValue,
        datum,
        seriesId,
        legendItemName,
        key: colorKey,
        source: "tooltip",
        property: "color",
        domain,
        boundSeries: this.getFormatterContext("color"),
        fractionDigits: void 0
      });
      data.push({ label: colorName, fallbackLabel: colorKey, value: content ?? String(colorValue) });
    }
    const format = this.getItemStyle({ datum, datumIndex, colorValue }, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: idValue,
        title: title ?? legendItemName,
        symbol: this.legendItemSymbol(datumIndex),
        data
      },
      { seriesId, datum, title, idKey, idName, colorKey, colorName, labelKey, labelName, ...format }
    );
  }
  computeFocusBounds(opts) {
    return findFocusedGeoGeometry(this, opts);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
MapShapeSeries.className = "MapShapeSeries";
MapShapeSeries.type = "map-shape";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs13, mapShapeSeriesThemeableOptionsDef: mapShapeSeriesThemeableOptionsDef2, without: without7 } = module_support_exports;
var mapShapeSeriesOptionsDef = {
  ...without7(commonSeriesOptionsDefs13, ["highlightStyle", "highlight"]),
  ...mapShapeSeriesThemeableOptionsDef2,
  type: required(constant("map-shape")),
  idKey: required(string),
  colorKey: string,
  labelKey: string,
  idName: string,
  colorName: string,
  labelName: string,
  topology: geoJson,
  topologyIdKey: string,
  legendItemName: string,
  title: string
};
var MapShapeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-shape",
  moduleFactory: (ctx) => new MapShapeSeries(ctx),
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      fill: { $mapPalette: "fill" },
      stroke: { $ref: "chartBackgroundColor" },
      colorRange: {
        $if: [
          { $eq: [{ $mapPalette: "type" }, "inbuilt"] },
          { $mapPalette: "divergingColors" },
          applyMapPalette(module_support_exports.SAFE_RANGE2_OPERATION)
        ]
      },
      // @ts-expect-error undocumented option
      fillGradientDefaults: applyMapPalette(module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS),
      fillPatternDefaults: applyMapPalette(module_support_exports.FILL_PATTERN_DEFAULTS),
      fillImageDefaults: applyMapPalette(module_support_exports.FILL_IMAGE_DEFAULTS),
      fillOpacity: 1,
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0,
      padding: 2,
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        color: { $ref: "chartBackgroundColor" },
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: "bold",
        overflowStrategy: "hide"
      },
      highlight: applyMapPalette(module_support_exports.multiSeriesHighlightStyle(true))
    },
    tooltip: {
      range: "exact"
    }
  }
};
var MapShapeSeriesModule = {
  type: "series",
  name: "map-shape",
  chartType: "topology",
  enterprise: true,
  options: mapShapeSeriesOptionsDef,
  create: (ctx) => new MapShapeSeries(ctx)
};
var { FillGradientDefaults: FillGradientDefaults12, FillPatternDefaults: FillPatternDefaults12, FillImageDefaults: FillImageDefaults12, Property: Property74, SeriesProperties: SeriesProperties7, makeSeriesTooltip: makeSeriesTooltip16 } = module_support_exports;
var MapShapeBackgroundSeriesProperties = class extends SeriesProperties7 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.fill = "black";
    this.fillGradientDefaults = new FillGradientDefaults12();
    this.fillPatternDefaults = new FillPatternDefaults12();
    this.fillImageDefaults = new FillImageDefaults12();
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tooltip = makeSeriesTooltip16();
  }
};
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property74
], MapShapeBackgroundSeriesProperties.prototype, "tooltip", 2);
var { createDatumId: createDatumId14, Selection: Selection13, Group: Group15, PointerEvents: PointerEvents8, getShapeStyle: getShapeStyle11 } = module_support_exports;
var MapShapeBackgroundSeries = class extends TopologySeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      pickModes: []
    });
    this.properties = new MapShapeBackgroundSeriesProperties();
    this._chartTopology = void 0;
    this.itemGroup = this.contentGroup.appendChild(new Group15({ name: "itemGroup" }));
    this.datumSelection = Selection13.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.itemGroup.pointerEvents = PointerEvents8.None;
  }
  get topology() {
    return this.properties.topology ?? this._chartTopology;
  }
  get focusable() {
    return false;
  }
  setOptionsData() {
  }
  setChartData() {
  }
  getNodeData() {
    return;
  }
  get hasData() {
    return false;
  }
  renderToOffscreenCanvas() {
    return true;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [0, zIndex, 0];
    this.highlightGroup.zIndex = [0, zIndex, 1];
    return true;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 1;
    geoGeometry.lineJoin = "round";
    geoGeometry.pointerEvents = PointerEvents8.None;
    return geoGeometry;
  }
  processData() {
    const { topology } = this;
    this.topologyBounds = topology?.features.reduce((current, feature) => {
      const geometry = feature.geometry;
      if (geometry == null)
        return current;
      return geometryBbox(geometry, current);
    }, void 0);
    if (topology == null) {
      logger_exports.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);
    }
  }
  createNodeData() {
    const { id: seriesId, topology, scale: scale2 } = this;
    if (topology == null)
      return;
    const nodeData = [];
    const labelData = [];
    topology.features.forEach((feature, index) => {
      const { geometry } = feature;
      const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
      if (projectedGeometry == null)
        return;
      nodeData.push({
        series: this,
        itemId: index,
        datum: feature,
        datumIndex: 0,
        index,
        projectedGeometry
      });
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  update() {
    const { datumSelection } = this;
    this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.labelGroup.visible = this.visible;
    const { nodeData = [] } = this.contextNodeData ?? {};
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId14(datum.index));
  }
  updateDatumNodes(opts) {
    const { properties } = this;
    const { datumSelection } = opts;
    const { fill, fillOpacity, stroke: stroke22, strokeOpacity, lineDash, lineDashOffset } = properties;
    const strokeWidth = properties.strokeWidth;
    datumSelection.each((geoGeometry, datum) => {
      const { projectedGeometry } = datum;
      if (projectedGeometry == null) {
        geoGeometry.visible = false;
        geoGeometry.projectedGeometry = void 0;
        return;
      }
      geoGeometry.visible = true;
      geoGeometry.projectedGeometry = projectedGeometry;
      const styles = getShapeStyle11(
        { fill, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset },
        this.properties.fillGradientDefaults,
        this.properties.fillPatternDefaults,
        this.properties.fillImageDefaults
      );
      geoGeometry.setProperties(styles);
    });
  }
  resetAnimation() {
  }
  getLegendData() {
    return [];
  }
  getTooltipContent(_seriesDatum) {
    return;
  }
  pickFocus() {
    return void 0;
  }
  computeFocusBounds(_opts) {
    return void 0;
  }
  hasItemStylers() {
    return false;
  }
};
MapShapeBackgroundSeries.className = "MapShapeBackgroundSeries";
MapShapeBackgroundSeries.type = "map-shape-background";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs14, mapShapeBackgroundSeriesThemeableOptionsDef: mapShapeBackgroundSeriesThemeableOptionsDef2 } = module_support_exports;
var mapShapeBackgroundSeriesOptionsDef = {
  ...mapShapeBackgroundSeriesThemeableOptionsDef2,
  ...commonSeriesOptionsDefs14,
  type: required(constant("map-shape-background")),
  topology: geoJson
};
var MapShapeBackgroundModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-shape-background",
  moduleFactory: (ctx) => new MapShapeBackgroundSeries(ctx),
  themeTemplate: {
    ...MAP_THEME_DEFAULTS,
    series: {
      fill: { $path: ["/1", { $mapPalette: "fill" }, { $mapPalette: "hierarchyColors" }] },
      stroke: { $ref: "chartBackgroundColor" },
      strokeWidth: 1,
      // @ts-expect-error undocumented-option
      fillGradientDefaults: applyMapPalette(module_support_exports.FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS),
      fillPatternDefaults: applyMapPalette(module_support_exports.FILL_PATTERN_HIERARCHY_DEFAULTS),
      fillImageDefaults: applyMapPalette(module_support_exports.FILL_IMAGE_DEFAULTS)
    }
  }
};
var MapShapeBackgroundSeriesModule = {
  type: "series",
  name: "map-shape-background",
  chartType: "topology",
  enterprise: true,
  options: mapShapeBackgroundSeriesOptionsDef,
  create: (ctx) => new MapShapeBackgroundSeries(ctx)
};
var {
  DEFAULT_POLAR_DIRECTION_KEYS: DEFAULT_POLAR_DIRECTION_KEYS2,
  DEFAULT_POLAR_DIRECTION_NAMES: DEFAULT_POLAR_DIRECTION_NAMES2,
  ChartAxisDirection: ChartAxisDirection27,
  PolarAxis: PolarAxis2,
  diff: diff6,
  fixNumericExtent: fixNumericExtent8,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty22,
  keyProperty: keyProperty9,
  normaliseGroupTo: normaliseGroupTo2,
  resetLabelFn: resetLabelFn5,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation5,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation2,
  valueProperty: valueProperty15,
  animationValidation: animationValidation7,
  createDatumId: createDatumId15,
  SeriesNodePickMode: SeriesNodePickMode12,
  normalizeAngle360: normalizeAngle3605,
  CategoryScale: CategoryScale3,
  motion: motion6,
  applyShapeStyle: applyShapeStyle13,
  isGradientFill: isGradientFill22,
  getShapeStyle: getShapeStyle12,
  updateLabelNode: updateLabelNode6,
  mergeDefaults: mergeDefaults15
} = module_support_exports;
var RadialColumnSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialColumnSeriesBase = class extends module_support_exports.PolarSeries {
  constructor(moduleCtx, {
    animationResetFns
  }) {
    super({
      moduleCtx,
      categoryKey: "angleValue",
      propertyKeys: DEFAULT_POLAR_DIRECTION_KEYS2,
      propertyNames: DEFAULT_POLAR_DIRECTION_NAMES2,
      canHaveAxes: true,
      pickModes: [SeriesNodePickMode12.NEAREST_NODE, SeriesNodePickMode12.EXACT_SHAPE_MATCH],
      animationResetFns: {
        ...animationResetFns,
        label: resetLabelFn5
      }
    });
    this.NodeEvent = RadialColumnSeriesNodeEvent;
    this.groupScale = new CategoryScale3();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection27.Angle) {
      return dataModel.getDomain(this, "angleValue", "key", processedData);
    } else {
      const yExtent = dataModel.getDomain(this, "radiusValue-end", "value", processedData);
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]] : [];
      return fixNumericExtent8(fixedYExtent);
    }
  }
  async processData(dataController) {
    const { angleKey, radiusKey, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const stackGroupId = this.getStackId();
    const stackGroupTrailingId = `${stackGroupId}-trailing`;
    const extraProps = [];
    if (isDefined(normalizedTo)) {
      extraProps.push(normaliseGroupTo2([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo)));
    }
    if (animationEnabled && this.processedData) {
      extraProps.push(diff6(this.id, this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation7());
    }
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const radiusScaleType = this.axes[ChartAxisDirection27.Radius]?.scale.type;
    const angleScaleType = this.axes[ChartAxisDirection27.Angle]?.scale.type;
    await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty9(angleKey, angleScaleType, { id: "angleValue" }),
        valueProperty15(radiusKey, radiusScaleType, {
          id: "radiusValue-raw",
          invalidValue: null,
          ...visibleProps
        }),
        ...groupAccumulativeValueProperty22(
          radiusKey,
          "normal",
          "current",
          {
            id: `radiusValue-end`,
            rangeId: `radiusValue-range`,
            invalidValue: null,
            groupId: stackGroupId,
            separateNegative: true,
            ...visibleProps
          },
          radiusScaleType
        ),
        ...groupAccumulativeValueProperty22(
          radiusKey,
          "trailing",
          "current",
          {
            id: `radiusValue-start`,
            invalidValue: null,
            groupId: stackGroupTrailingId,
            separateNegative: true,
            ...visibleProps
          },
          radiusScaleType
        ),
        ...extraProps
      ],
      groupByKeys: true,
      groupByData: false
    });
    this.animationState.transition("updateData");
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (r !== cache.r || cx !== cache.cx || cy !== cache.cy) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  isRadiusAxisReversed() {
    return this.axes[ChartAxisDirection27.Radius]?.isReversed();
  }
  maybeRefreshNodeData() {
    const circleChanged = this.didCircleChange();
    if (!circleChanged && !this.nodeDataRefresh)
      return;
    const { nodeData = [] } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection27.Radius];
    return radiusAxis instanceof PolarAxis2 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  createNodeData() {
    const { processedData, dataModel, groupScale } = this;
    if (!dataModel || !processedData || processedData.type !== "grouped")
      return;
    const angleAxis = this.axes[ChartAxisDirection27.Angle];
    const radiusAxis = this.axes[ChartAxisDirection27.Radius];
    const angleScale = angleAxis?.scale;
    const radiusScale = radiusAxis?.scale;
    if (!angleScale || !radiusScale) {
      return;
    }
    const angleValues = dataModel.resolveKeysById(this, `angleValue`, processedData);
    const radiusStartValues = dataModel.resolveColumnById(this, `radiusValue-start`, processedData);
    const radiusEndValues = dataModel.resolveColumnById(this, `radiusValue-end`, processedData);
    const radiusRawValues = dataModel.resolveColumnById(this, `radiusValue-raw`, processedData);
    const radiusRangeIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-range`);
    let groupPaddingInner = 0;
    let groupPaddingOuter = 0;
    if (angleAxis instanceof AngleCategoryAxis) {
      groupPaddingInner = angleAxis.groupPaddingInner;
      groupPaddingOuter = angleAxis.paddingInner;
    }
    const groupAngleStep = angleScale.bandwidth ?? 0;
    const paddedGroupAngleStep = groupAngleStep * (1 - groupPaddingOuter);
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
    groupScale.range = [-paddedGroupAngleStep / 2, paddedGroupAngleStep / 2];
    groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
    const radiusAxisReversed = this.isRadiusAxisReversed();
    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
    const axisTotalRadius = axisOuterRadius + axisInnerRadius;
    const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
    const radiusDomain = this.getSeriesDomain(ChartAxisDirection27.Radius);
    const getLabelNodeDatum = (datum, radiusDatum, x, y) => {
      const labelText = this.getLabelText(
        radiusDatum,
        datum,
        radiusKey,
        "radius",
        radiusDomain,
        label,
        { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName }
      );
      if (labelText) {
        return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
      }
    };
    const nodeData = [];
    const context = { itemId: radiusKey, nodeData, labelData: nodeData };
    if (!this.visible)
      return context;
    const { dataSources } = processedData;
    const rawData = dataSources.get(this.id) ?? [];
    for (const { datumIndex, group } of dataModel.forEachGroupDatum(this, processedData)) {
      const datum = rawData[datumIndex];
      const angleDatum = angleValues[datumIndex];
      if (angleDatum == null)
        return;
      const radiusDatum = radiusRawValues[datumIndex];
      const isPositive = radiusDatum >= 0 && !Object.is(radiusDatum, -0);
      const innerRadiusDatum = radiusStartValues[datumIndex];
      const outerRadiusDatum = radiusEndValues[datumIndex];
      const radiusRange = group.aggregation[radiusRangeIndex][isPositive ? 1 : 0] ?? 0;
      const negative = isPositive === radiusAxisReversed;
      if (innerRadiusDatum === void 0 || outerRadiusDatum === void 0)
        return;
      let startAngle;
      let endAngle;
      if (rawData.length === 1) {
        startAngle = -0.5 * Math.PI;
        endAngle = 1.5 * Math.PI;
      } else {
        const groupAngle = angleScale.convert(angleDatum);
        startAngle = normalizeAngle3605(groupAngle + groupScale.convert(String(groupIndex)));
        endAngle = normalizeAngle3605(startAngle + groupScale.bandwidth);
      }
      const angle2 = startAngle + groupScale.bandwidth / 2;
      const innerRadius = axisTotalRadius - radiusScale.convert(innerRadiusDatum);
      const outerRadius = axisTotalRadius - radiusScale.convert(outerRadiusDatum);
      const midRadius = (innerRadius + outerRadius) / 2;
      const stackInnerRadius = axisTotalRadius - radiusScale.convert(0);
      const stackOuterRadius = axisTotalRadius - radiusScale.convert(radiusRange);
      const x = Math.cos(angle2) * midRadius;
      const y = Math.sin(angle2) * midRadius;
      const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, radiusDatum, x, y) : void 0;
      const columnWidth = this.getColumnWidth(startAngle, endAngle);
      nodeData.push({
        series: this,
        datum,
        datumIndex,
        point: { x, y, size: 0 },
        midPoint: { x, y },
        label: labelNodeDatum,
        angleValue: angleDatum,
        radiusValue: radiusDatum,
        negative,
        innerRadius,
        outerRadius,
        stackInnerRadius,
        stackOuterRadius,
        startAngle,
        endAngle,
        midAngle: angle2,
        axisInnerRadius,
        axisOuterRadius,
        columnWidth,
        index: datumIndex
      });
    }
    return { itemId: radiusKey, nodeData, labelData: nodeData };
  }
  getColumnWidth(_startAngle, _endAngle) {
    return NaN;
  }
  update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    this.maybeRefreshNodeData();
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    this.updateSectorSelection(this.itemSelection, false);
    this.updateSectorSelection(this.highlightSelection, true);
    this.updateLabels();
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  getItemStyle(nodeDatum, isHighlight) {
    const { id: seriesId, properties } = this;
    const { angleKey, radiusKey, itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, nodeDatum.datumIndex);
    const baseStyle = mergeDefaults15(highlightStyle, properties.getStyle());
    let style2 = getShapeStyle12(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && nodeDatum != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId15(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(
            activeHighlight,
            isHighlight,
            nodeDatum.datumIndex
          );
          return this.callWithContext(itemStyler, {
            seriesId,
            datum: nodeDatum.datum,
            highlighted: isHighlight,
            highlightState,
            angleKey,
            radiusKey,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle12(
          mergeDefaults15(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateSectorSelection(selection, isHighlight) {
    let selectionData = [];
    if (isHighlight) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      if (activeHighlight?.datum && activeHighlight.series === this) {
        selectionData.push(activeHighlight);
      }
    } else {
      selectionData = this.nodeData;
    }
    const radiusAxisReversed = this.isRadiusAxisReversed();
    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
    const fillBBox = this.getShapeFillBBox();
    selection.update(selectionData, void 0, (datum) => this.getDatumId(datum)).each((node, nodeDatum) => {
      const { midPoint } = nodeDatum;
      const style2 = this.getItemStyle(nodeDatum, isHighlight);
      const fill = style2.fill;
      const itemBounds = isGradientFill22(fill) && fill.bounds === "item";
      const fillParams = itemBounds ? { centerX: midPoint?.x ?? 0, centerY: midPoint?.y ?? 0 } : { centerX: 0, centerY: 0, innerRadius: axisInnerRadius, outerRadius: axisOuterRadius };
      this.updateItemPath(node, nodeDatum, isHighlight);
      applyShapeStyle13(node, style2, fillBBox, fillParams);
      node.cornerRadius = style2.cornerRadius;
      node.lineJoin = "round";
    });
  }
  updateLabels() {
    const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      const highlightState = this.getHighlightStateString(activeHighlight, false, datum.datumIndex);
      updateLabelNode6(this, node, this.properties, this.properties.label, datum.label, false, highlightState);
      node.fillOpacity = this.getHighlightStyle(false, datum.datumIndex).opacity ?? 1;
    });
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getColumnTransitionFunctions();
    motion6.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation5(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getColumnTransitionFunctions();
    motion6.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation2(this, "labels", animationManager, this.labelSelection);
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { angleKey, angleName, radiusKey, radiusName, tooltip } = properties;
    const angleAxis = axes[ChartAxisDirection27.Angle];
    const radiusAxis = axes[ChartAxisDirection27.Radius];
    const nodeDatum = this.nodeData?.[datumIndex];
    if (!dataModel || !processedData || !angleAxis || !radiusAxis || !nodeDatum)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const angleValue = dataModel.resolveKeysById(this, `angleValue`, processedData)[datumIndex];
    const radiusValue = dataModel.resolveColumnById(this, `radiusValue-raw`, processedData)[datumIndex];
    if (angleValue == null)
      return;
    const format = this.getItemStyle(nodeDatum, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(angleAxis, "tooltip", angleValue, datum, angleKey, void 0),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: radiusName,
            fallbackLabel: radiusKey,
            value: this.getAxisValueText(radiusAxis, "tooltip", radiusValue, datum, radiusKey, void 0)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: angleName,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        ...format
      }
    );
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke22,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.properties;
    const markerStyle = getShapeStyle12(
      {
        fill: fill ?? "rgba(0, 0, 0, 0)",
        stroke: stroke22 ?? "rgba(0, 0, 0, 0)",
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      },
      fillGradientDefaults5,
      fillPatternDefaults5,
      fillImageDefaults5
    );
    if (module_support_exports.isGradientFill(markerStyle.fill)) {
      markerStyle.fill = { ...markerStyle.fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return {
      marker: markerStyle
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id: seriesId, visible } = this;
    const { radiusKey, radiusName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId: radiusKey,
        seriesId,
        enabled: visible,
        label: {
          text: radiusName ?? radiusKey
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  getDatumId(datum) {
    return createDatumId15(datum.angleValue);
  }
  computeLabelsBBox() {
    return null;
  }
};
var {
  SeriesProperties: SeriesProperties8,
  FillGradientDefaults: FillGradientDefaults13,
  FillPatternDefaults: FillPatternDefaults13,
  FillImageDefaults: FillImageDefaults13,
  makeSeriesTooltip: makeSeriesTooltip17,
  Property: Property75,
  Label: Label12
} = module_support_exports;
var RadialColumnSeriesBaseProperties = class extends SeriesProperties8 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillGradientDefaults = new FillGradientDefaults13();
    this.fillPatternDefaults = new FillPatternDefaults13();
    this.fillImageDefaults = new FillImageDefaults13();
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.label = new Label12();
    this.tooltip = makeSeriesTooltip17();
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "angleKey", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "angleName", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "radiusKey", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "radiusName", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "fill", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "stroke", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "rotation", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "stackGroup", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "normalizedTo", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "label", 2);
__decorateClass2([
  Property75
], RadialColumnSeriesBaseProperties.prototype, "tooltip", 2);
var { motion: motion7 } = module_support_exports;
function createAngleMotionCalculator() {
  const angles = {
    startAngle: /* @__PURE__ */ new Map(),
    endAngle: /* @__PURE__ */ new Map()
  };
  const angleKeys = ["startAngle", "endAngle"];
  const calculate = (node, datum, status) => {
    angleKeys.forEach((key) => {
      const map = angles[key];
      let from22 = (status === "removed" || status === "updated" ? node : datum)[key];
      let to2 = (status === "removed" ? node : datum)[key];
      if (isNaN(to2)) {
        to2 = node.previousDatum?.[key] ?? NaN;
      }
      const diff8 = from22 - to2;
      if (Math.abs(diff8) > Math.PI) {
        from22 -= Math.sign(diff8) * 2 * Math.PI;
      }
      map.set(datum, { from: from22, to: to2 });
    });
  };
  const getAngles = (datum, fromToKey) => {
    return {
      startAngle: angles.startAngle.get(datum)[fromToKey],
      endAngle: angles.endAngle.get(datum)[fromToKey]
    };
  };
  const from3 = (datum) => getAngles(datum, "from");
  const to = (datum) => getAngles(datum, "to");
  return { calculate, from: from3, to };
}
function fixRadialColumnAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.startAngle) || isNaN(node.previousDatum.endAngle)) {
      return "added";
    }
    if (isNaN(datum.startAngle) || isNaN(datum.endAngle)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialColumnAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (node, datum, status) => {
    status = fixRadialColumnAnimationStatus(node, datum, status);
    angles.calculate(node, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed" || status === "updated") {
      innerRadius = node.innerRadius;
      outerRadius = node.outerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      columnWidth = datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    const phase = motion7.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return {
      innerRadius,
      outerRadius,
      columnWidth,
      axisInnerRadius,
      axisOuterRadius,
      startAngle,
      endAngle,
      phase
    };
  };
  const toFn = (node, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed") {
      innerRadius = node.innerRadius;
      outerRadius = node.innerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = isNaN(datum.innerRadius) ? axisZeroRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? axisZeroRadius : datum.outerRadius;
      columnWidth = isNaN(datum.columnWidth) ? node.columnWidth : datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
  };
  return { toFn, fromFn };
}
function resetRadialColumnSelectionFn(_node, {
  innerRadius,
  outerRadius,
  columnWidth,
  axisInnerRadius,
  axisOuterRadius,
  startAngle,
  endAngle
}) {
  return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
}
var { SectorBox: SectorBox2, motion: motion8 } = module_support_exports;
function getRadii(datum) {
  const { negative, innerRadius, outerRadius, stackInnerRadius, stackOuterRadius } = datum;
  return {
    innerRadius: negative ? stackOuterRadius : stackInnerRadius,
    outerRadius: negative ? stackInnerRadius : stackOuterRadius,
    clipInnerRadius: negative ? outerRadius : innerRadius,
    clipOuterRadius: negative ? innerRadius : outerRadius
  };
}
function prepareNightingaleAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (sect, datum, status) => {
    status = fixRadialColumnAnimationStatus(sect, datum, status);
    angles.calculate(sect, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed" || status === "updated") {
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
      clipSector = sect.clipSector;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
    }
    clipSector ?? (clipSector = new SectorBox2(startAngle, endAngle, innerRadius, outerRadius));
    const phase = motion8.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { innerRadius, outerRadius, startAngle, endAngle, clipSector, phase };
  };
  const toFn = (_sect, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed") {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      clipSector = new SectorBox2(startAngle, endAngle, innerRadius, outerRadius);
    } else {
      let clipInnerRadius, clipOuterRadius;
      ({ innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum));
      if (isNaN(innerRadius))
        innerRadius = axisZeroRadius;
      if (isNaN(outerRadius))
        outerRadius = axisZeroRadius;
      if (isNaN(clipInnerRadius))
        clipInnerRadius = axisZeroRadius;
      if (isNaN(clipOuterRadius))
        clipOuterRadius = axisZeroRadius;
      clipSector = new SectorBox2(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
    }
    return { innerRadius, outerRadius, startAngle, endAngle, clipSector };
  };
  return { toFn, fromFn };
}
function resetNightingaleSelectionFn(_sect, datum) {
  const { startAngle, endAngle } = datum;
  const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);
  const clipSector = new SectorBox2(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
  return { innerRadius, outerRadius, startAngle, endAngle, clipSector };
}
var { Sector: Sector4, SectorBox: SectorBox22, PolarZIndexMap: PolarZIndexMap2 } = module_support_exports;
var NightingaleSeries = class extends RadialColumnSeriesBase {
  // TODO: Enable once the options contract has been revisited
  // @TempValidate
  // sectorSpacing = 1;
  constructor(moduleCtx) {
    super(moduleCtx, { animationResetFns: { item: resetNightingaleSelectionFn } });
    this.properties = new RadialColumnSeriesBaseProperties();
  }
  setZIndex(zIndex) {
    super.setZIndex(zIndex);
    this.contentGroup.zIndex = [0, PolarZIndexMap2.FOREGROUND, zIndex];
    this.highlightGroup.zIndex = [0, PolarZIndexMap2.HIGHLIGHT, zIndex];
    this.labelGroup.zIndex = [0, PolarZIndexMap2.LABEL, zIndex];
    return true;
  }
  getStackId() {
    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;
    return `nightingale-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new Sector4();
  }
  updateItemPath(node, datum, highlight5) {
    const { negative } = datum;
    node.centerX = 0;
    node.centerY = 0;
    node.startOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;
    node.endOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;
    node.startInnerCornerRadius = negative ? this.properties.cornerRadius : 0;
    node.endInnerCornerRadius = negative ? this.properties.cornerRadius : 0;
    if (highlight5) {
      const { startAngle, endAngle } = datum;
      const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);
      node.innerRadius = innerRadius;
      node.outerRadius = outerRadius;
      node.startAngle = startAngle;
      node.endAngle = endAngle;
      node.clipSector = new SectorBox22(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
    }
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareNightingaleAnimationFunctions(axisZeroRadius);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
NightingaleSeries.className = "NightingaleSeries";
NightingaleSeries.type = "nightingale";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs15, nightingaleSeriesThemeableOptionsDef: nightingaleSeriesThemeableOptionsDef2 } = module_support_exports;
var nightingaleSeriesOptionsDef = {
  ...commonSeriesOptionsDefs15,
  ...nightingaleSeriesThemeableOptionsDef2,
  type: required(constant("nightingale")),
  angleKey: required(string),
  radiusKey: required(string),
  angleName: string,
  radiusName: string,
  grouped: boolean,
  stacked: boolean,
  stackGroup: string,
  normalizedTo: number
};
var {
  ThemeConstants: { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE2, POLAR_AXIS_SHAPE: POLAR_AXIS_SHAPE2 }
} = module_support_exports;
var NIGHTINGALE_SERIES_THEME = {
  series: {
    fill: { $palette: "fill" },
    stroke: {
      $if: [{ $eq: [{ $palette: "type" }, "inbuilt"] }, { $ref: "chartBackgroundColor" }, { $palette: "stroke" }]
    },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_RADIAL_SERIES_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    strokeWidth: 1,
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" }
    },
    highlight: module_support_exports.multiSeriesHighlightStyle()
  },
  axes: {
    [POLAR_AXIS_TYPE2.ANGLE_CATEGORY]: {
      shape: { $findFirstSiblingNotOperation: POLAR_AXIS_SHAPE2.CIRCLE },
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        spacing: 10
      }
    },
    [POLAR_AXIS_TYPE2.RADIUS_NUMBER]: {
      shape: { $findFirstSiblingNotOperation: POLAR_AXIS_SHAPE2.CIRCLE }
    }
  }
};
var {
  ThemeConstants: { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE22 }
} = module_support_exports;
var NightingaleModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "nightingale",
  moduleFactory: (ctx) => new NightingaleSeries(ctx),
  defaultAxes: [{ type: POLAR_AXIS_TYPE22.ANGLE_CATEGORY }, { type: POLAR_AXIS_TYPE22.RADIUS_NUMBER }],
  themeTemplate: NIGHTINGALE_SERIES_THEME,
  stackable: true,
  groupable: true,
  stackedByDefault: true
};
var NightingaleSeriesModule = {
  type: "series",
  name: "nightingale",
  chartType: "polar",
  enterprise: true,
  options: nightingaleSeriesOptionsDef,
  create: (ctx) => new NightingaleSeries(ctx)
};
var {
  SeriesProperties: SeriesProperties9,
  FillGradientDefaults: FillGradientDefaults14,
  FillPatternDefaults: FillPatternDefaults14,
  FillImageDefaults: FillImageDefaults14,
  makeSeriesTooltip: makeSeriesTooltip18,
  Property: Property76,
  Label: Label13,
  DropShadow: DropShadow5
} = module_support_exports;
var PyramidSeriesLabel = class extends Label13 {
};
var PyramidSeriesStageLabel = class extends Label13 {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass2([
  Property76
], PyramidSeriesStageLabel.prototype, "spacing", 2);
__decorateClass2([
  Property76
], PyramidSeriesStageLabel.prototype, "placement", 2);
var PyramidProperties = class extends SeriesProperties9 {
  constructor() {
    super(...arguments);
    this.fills = [];
    this.fillGradientDefaults = new FillGradientDefaults14();
    this.fillPatternDefaults = new FillPatternDefaults14();
    this.fillImageDefaults = new FillImageDefaults14();
    this.fillOpacity = 1;
    this.strokes = [];
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.direction = "vertical";
    this.reverse = void 0;
    this.spacing = 0;
    this.aspectRatio = void 0;
    this.shadow = new DropShadow5().set({ enabled: false });
    this.label = new PyramidSeriesLabel();
    this.stageLabel = new PyramidSeriesStageLabel();
    this.tooltip = makeSeriesTooltip18();
  }
  getStyle(index = 0) {
    const { fills, strokes, fillOpacity, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      fill: fills[index % fills.length],
      fillOpacity,
      stroke: strokes[index % strokes.length],
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property76
], PyramidProperties.prototype, "stageKey", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "valueKey", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "fills", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "strokes", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "direction", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "reverse", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "spacing", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "aspectRatio", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "shadow", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "label", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "stageLabel", 2);
__decorateClass2([
  Property76
], PyramidProperties.prototype, "tooltip", 2);
function applyPyramidDatum(connector, { x, y, top, right, bottom, left }) {
  connector.x0 = x - top / 2;
  connector.x1 = x + top / 2;
  connector.x2 = x + bottom / 2;
  connector.x3 = x - bottom / 2;
  connector.y0 = y - left / 2;
  connector.y1 = y - right / 2;
  connector.y2 = y + right / 2;
  connector.y3 = y + left / 2;
}
function preparePyramidAnimationFunctions(direction) {
  const fromFn = (_connector, datum) => {
    const { x, y } = datum;
    let { top, right, bottom, left } = datum;
    if (direction === "vertical") {
      top = 0;
      bottom = 0;
    } else {
      left = 0;
      right = 0;
    }
    return { x, y, top, right, bottom, left };
  };
  const toFn = (_connector, datum) => {
    const { x, y, top, right, bottom, left } = datum;
    return { x, y, top, right, bottom, left };
  };
  const applyFn = applyPyramidDatum;
  return { fromFn, toFn, applyFn };
}
var {
  StateMachine: StateMachine14,
  valueProperty: valueProperty16,
  SeriesNodePickMode: SeriesNodePickMode13,
  CachedTextMeasurerPool: CachedTextMeasurerPool11,
  TextUtils: TextUtils7,
  createDatumId: createDatumId16,
  BBox: BBox222,
  Group: Group16,
  Selection: Selection14,
  Text: Text7,
  PointerEvents: PointerEvents9,
  applyShapeStyle: applyShapeStyle14,
  mergeDefaults: mergeDefaults16,
  fromToMotion: fromToMotion4,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation6,
  getShapeStyle: getShapeStyle13,
  getLabelStyles: getLabelStyles5
} = module_support_exports;
var PyramidSeries = class extends module_support_exports.DataModelSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      pickModes: [SeriesNodePickMode13.EXACT_SHAPE_MATCH, SeriesNodePickMode13.NEAREST_NODE]
    });
    this.properties = new PyramidProperties();
    this.itemGroup = this.contentGroup.appendChild(new Group16({ name: "itemGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group16({ name: "itemLabelGroup" }));
    this.stageLabelGroup = this.contentGroup.appendChild(new Group16({ name: "stageLabelGroup" }));
    this.datumSelection = Selection14.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection14.select(
      this.itemLabelGroup,
      Text7
    );
    this.stageLabelSelection = Selection14.select(this.stageLabelGroup, Text7);
    this.highlightDatumSelection = Selection14.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    this.animationState = new StateMachine14(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: () => this.animateEmptyUpdateReady()
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          clear: "empty",
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
    this.itemLabelGroup.pointerEvents = PointerEvents9.None;
    this.stageLabelGroup.pointerEvents = PointerEvents9.None;
  }
  addChartEventListeners() {
    this.cleanup.register(this.ctx.eventsHub.on("legend:item-click", (event) => this.onLegendItemClick(event)));
  }
  nodeFactory() {
    return new FunnelConnector();
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const {
      id: seriesId,
      visible,
      ctx: { legendManager }
    } = this;
    const { stageKey, valueKey } = this.properties;
    const xScaleType = "category";
    const yScaleType = "number";
    const validation = (_value, _datum, index) => visible && legendManager.getItemEnabled({ seriesId, itemId: index });
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty16(stageKey, xScaleType, { id: "xValue" }),
        valueProperty16(valueKey, yScaleType, { id: `yValue`, ...visibleProps, validation, invalidValue: 0 })
      ]
    });
  }
  createNodeData() {
    const {
      id: seriesId,
      dataModel,
      processedData,
      properties,
      visible,
      ctx: { legendManager }
    } = this;
    const {
      stageKey,
      valueKey,
      direction,
      reverse = direction === "horizontal",
      spacing,
      aspectRatio,
      label,
      stageLabel
    } = properties;
    if (dataModel == null || processedData == null)
      return;
    const horizontal = direction === "horizontal";
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const xDomain = dataModel.getDomain(this, "xValue", "value", processedData);
    const yDomain = dataModel.getDomain(this, "yValue", "value", processedData);
    const textMeasurer = CachedTextMeasurerPool11.getMeasurer({ font: stageLabel });
    let textAlign;
    let textBaseline;
    if (horizontal) {
      textAlign = "center";
      textBaseline = stageLabel.placement === "before" ? "bottom" : "top";
    } else {
      textAlign = stageLabel.placement === "after" ? "left" : "right";
      textBaseline = "middle";
    }
    const stageLabelData = stageLabel.enabled ? [] : void 0;
    let maxLabelWidth = 0;
    let maxLabelHeight = 0;
    let yTotal = 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const xValue2 = xValues[datumIndex];
      const yValue = yValues[datumIndex];
      const enabled = visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex });
      yTotal += yValue;
      if (stageLabelData == null)
        return;
      const text2 = this.getLabelText(
        xValue2,
        datum,
        stageKey,
        "x",
        xDomain,
        this.properties.stageLabel,
        { datum, value: yValue, stageKey, valueKey }
      );
      const { width: width2 } = textMeasurer.measureText(text2);
      const height2 = text2.split("\n").length * TextUtils7.getLineHeight(label.fontSize);
      maxLabelWidth = Math.max(maxLabelWidth, width2);
      maxLabelHeight = Math.max(maxLabelHeight, height2);
      stageLabelData.push({
        x: NaN,
        y: NaN,
        text: text2,
        textAlign,
        textBaseline,
        visible: enabled
      });
    });
    const seriesRectWidth = this._nodeDataDependencies?.seriesRectWidth ?? 0;
    const seriesRectHeight = this._nodeDataDependencies?.seriesRectHeight ?? 0;
    const totalSpacing = spacing * (processedData.input.count - 1);
    let bounds;
    if (horizontal) {
      const verticalInset = maxLabelHeight + stageLabel.spacing;
      bounds = new BBox222(
        0,
        stageLabel.placement === "before" ? verticalInset : 0,
        seriesRectWidth,
        seriesRectHeight - verticalInset
      );
    } else {
      const horizontalInset = maxLabelWidth + stageLabel.spacing;
      bounds = new BBox222(
        stageLabel.placement === "after" ? 0 : horizontalInset,
        0,
        seriesRectWidth - horizontalInset,
        seriesRectHeight
      );
    }
    if (aspectRatio != null && aspectRatio !== 0) {
      const directionalAspectRatio = direction === "horizontal" ? 1 / aspectRatio : aspectRatio;
      const constrainedWidth = Math.min(bounds.width, bounds.height * directionalAspectRatio);
      const constrainedHeight = constrainedWidth / directionalAspectRatio;
      bounds = new BBox222(
        bounds.x + (bounds.width - constrainedWidth) / 2,
        bounds.y + (bounds.height - constrainedHeight) / 2,
        constrainedWidth,
        constrainedHeight
      );
    }
    let labelX;
    let labelY;
    if (horizontal) {
      labelY = stageLabel.placement === "before" ? bounds.y - stageLabel.spacing : bounds.y + bounds.height + stageLabel.spacing;
    } else {
      labelX = stageLabel.placement === "after" ? bounds.x + bounds.width + stageLabel.spacing : bounds.x - stageLabel.spacing;
    }
    const availableWidth = bounds.width - (horizontal ? totalSpacing : 0);
    const availableHeight = bounds.height - (horizontal ? 0 : totalSpacing);
    if (availableWidth < 0 || availableHeight < 0)
      return;
    const nodeData = [];
    const labelData = [];
    let yStart = 0;
    rawData.forEach((datum, datumIndex) => {
      const xValue2 = xValues[datumIndex];
      const yValue = yValues[datumIndex];
      const enabled = visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex });
      const yEnd = yStart + yValue;
      const yMidRatio = (yStart + yEnd) / (2 * yTotal);
      const yRangeRatio = (yEnd - yStart) / yTotal;
      const xOffset = horizontal ? availableWidth * yMidRatio + spacing * datumIndex : availableWidth * 0.5;
      const yOffset = horizontal ? availableHeight * 0.5 : availableHeight * yMidRatio + spacing * datumIndex;
      const x = bounds.x + xOffset;
      const y = bounds.y + yOffset;
      if (stageLabelData != null) {
        const stageLabelDatum = stageLabelData[datumIndex];
        stageLabelDatum.x = labelX ?? x;
        stageLabelDatum.y = labelY ?? y;
      }
      let top;
      let right;
      let bottom;
      let left;
      if (horizontal) {
        const barWidth = availableWidth * yRangeRatio;
        top = barWidth;
        bottom = barWidth;
        const y0 = (xOffset + barWidth / 2) * (availableHeight / bounds.width);
        const y1 = (xOffset - barWidth / 2) * (availableHeight / bounds.width);
        right = reverse ? bounds.height - y0 : y0;
        left = reverse ? bounds.height - y1 : y1;
      } else {
        const barHeight = availableHeight * yRangeRatio;
        right = barHeight;
        left = barHeight;
        const x0 = (yOffset - barHeight / 2) * (availableWidth / bounds.height);
        const x1 = (yOffset + barHeight / 2) * (availableWidth / bounds.height);
        top = reverse ? bounds.width - x0 : x0;
        bottom = reverse ? bounds.width - x1 : x1;
      }
      const text2 = this.getLabelText(
        yValue,
        datum,
        valueKey,
        "y",
        yDomain,
        label,
        {
          datum,
          value: yValue,
          stageKey,
          valueKey
        }
      );
      const labelDatum = {
        x,
        y,
        text: text2,
        textAlign: "center",
        textBaseline: "middle",
        visible: enabled
      };
      labelData.push(labelDatum);
      nodeData.push({
        series: this,
        itemId: valueKey,
        datum,
        datumIndex,
        index: datumIndex,
        xValue: xValue2,
        yValue,
        x,
        y,
        top,
        right,
        bottom,
        left,
        label: labelDatum,
        enabled,
        midPoint: {
          x,
          y
        }
      });
      yStart = yEnd;
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData,
      stageLabelData,
      bounds
    };
  }
  updateSelections() {
    if (this.nodeDataRefresh) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  update({ seriesRect }) {
    this.checkResize(seriesRect);
    const { datumSelection, labelSelection, stageLabelSelection, highlightDatumSelection } = this;
    this.updateSelections();
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
      highlightedDatum = void 0;
    }
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    const stageLabelData = this.contextNodeData?.stageLabelData ?? [];
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection, isHighlight: false });
    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection });
    this.updateLabelNodes({ labelSelection, labelProperties: this.properties.label });
    this.stageLabelSelection = this.updateStageLabelSelection({ stageLabelData, stageLabelSelection });
    this.updateLabelNodes({
      labelSelection: stageLabelSelection,
      labelProperties: this.properties.stageLabel
    });
    this.highlightDatumSelection = this.updateDatumSelection({
      nodeData: highlightedDatum != null ? [highlightedDatum] : [],
      datumSelection: highlightDatumSelection
    });
    this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
    this.animationState.transition("update");
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData);
  }
  getItemStyle({ datumIndex, datum }, isHighlight) {
    const { id: seriesId, properties } = this;
    const { stageKey, valueKey, itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults16(highlightStyle, properties.getStyle(datumIndex));
    let style2 = getShapeStyle13(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && datumIndex != null) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId16(datumIndex, isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            stageKey,
            valueKey,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle13(
          mergeDefaults16(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateDatumNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const { properties } = this;
    const { shadow } = properties;
    const bounds = this.contextNodeData?.bounds;
    const fillBBox = bounds ? { series: bounds, axis: bounds } : void 0;
    datumSelection.each((connector, nodeDatum) => {
      const style2 = this.getItemStyle(nodeDatum, isHighlight);
      applyShapeStyle14(connector, style2, fillBBox);
      applyPyramidDatum(connector, nodeDatum);
      connector.fillShadow = shadow;
    });
  }
  updateLabelSelection(opts) {
    return opts.labelSelection.update(this.properties.label.enabled ? opts.labelData : []);
  }
  updateStageLabelSelection(opts) {
    return opts.stageLabelSelection.update(opts.stageLabelData);
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((label, nodeDatum, datumIndex) => {
      const { visible, x, y, text: text2, textAlign, textBaseline } = nodeDatum;
      const style2 = getLabelStyles5(this, void 0, this.properties, opts.labelProperties);
      const { color: fill, fontSize, fontStyle, fontWeight, fontFamily } = style2;
      label.visible = visible;
      label.x = x;
      label.y = y;
      label.text = text2;
      label.fill = fill;
      label.fillOpacity = this.getHighlightStyle(false, datumIndex).opacity ?? 1;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = textAlign;
      label.textBaseline = textBaseline;
      label.setBoxing(style2);
    });
  }
  computeFocusBounds(opts) {
    const datum = this.getNodeData()?.[opts.datumIndex];
    if (datum === void 0)
      return;
    for (const node of this.datumSelection) {
      if (node.datum === datum) {
        return node.node;
      }
    }
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { stageKey, valueKey, tooltip } = properties;
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue2 = dataModel.resolveColumnById(this, "xValue", processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    if (xValue2 == null)
      return;
    const label = this.getLabelText(
      xValue2,
      datum,
      stageKey,
      "x",
      dataModel.getDomain(this, "xValue", "value", processedData),
      this.properties.stageLabel,
      { datum, value: xValue2, stageKey, valueKey }
    );
    const value = this.getLabelText(
      yValue,
      datum,
      valueKey,
      "y",
      dataModel.getDomain(this, "yValue", "value", processedData),
      this.properties.stageLabel,
      { datum, value: yValue, stageKey, valueKey }
    );
    const format = this.getItemStyle({ datumIndex, datum }, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        symbol: this.legendItemSymbol(datumIndex),
        data: [{ label, value }]
      },
      {
        seriesId,
        datum,
        title: void 0,
        stageKey,
        valueKey,
        ...format
      }
    );
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistanceSquared = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distanceSquared2 = node.distanceSquared(x, y);
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  legendItemSymbol(datumIndex) {
    const { fills, strokes, strokeWidth, fillOpacity, strokeOpacity, lineDash, lineDashOffset } = this.properties;
    const fill = fills[datumIndex % fills.length] ?? "black";
    const stroke22 = strokes[datumIndex % strokes.length] ?? "black";
    return {
      marker: getShapeStyle13(
        {
          fill,
          fillOpacity,
          stroke: stroke22,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        },
        this.properties.fillGradientDefaults,
        this.properties.fillPatternDefaults,
        this.properties.fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    const {
      processedData,
      dataModel,
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    if (!dataModel || !processedData || legendType !== "category") {
      return [];
    }
    const { showInLegend } = this.properties;
    const legendData = [];
    const stageValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((_datum, datumIndex) => {
      const stageValue = stageValues[datumIndex];
      legendData.push({
        legendType: "category",
        id: seriesId,
        itemId: datumIndex,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        label: { text: stageValue },
        symbol: this.legendItemSymbol(datumIndex),
        hideInLegend: !showInLegend
      });
    });
    return legendData;
  }
  animateReset() {
    this.ctx.animationManager.skipCurrentBatch();
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
  }
  animateEmptyUpdateReady() {
    const { datumSelection, labelSelection, properties } = this;
    const fns = preparePyramidAnimationFunctions(properties.direction);
    fromToMotion4(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelection);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
PyramidSeries.className = "PyramidSeries";
PyramidSeries.type = "pyramid";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs16, pyramidSeriesThemeableOptionsDef: pyramidSeriesThemeableOptionsDef2 } = module_support_exports;
var pyramidSeriesOptionsDef = {
  ...pyramidSeriesThemeableOptionsDef2,
  ...commonSeriesOptionsDefs16,
  type: required(constant("pyramid")),
  stageKey: required(string),
  valueKey: required(string)
};
var {
  ThemeSymbols: { DEFAULT_SHADOW_COLOUR: DEFAULT_SHADOW_COLOUR22 }
} = module_support_exports;
var PYRAMID_SERIES_THEME = {
  series: {
    direction: "vertical",
    strokeWidth: { $isUserOption: ["./strokes/0", 2, 0] },
    spacing: 2,
    fills: { $palette: "fills" },
    strokes: { $palette: "strokes" },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "chartBackgroundColor" }
    },
    stageLabel: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: true,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" },
      spacing: 12
    },
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR22,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    },
    highlight: module_support_exports.singleSeriesHighlightStyle()
  }
};
var PyramidModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  identifier: "pyramid",
  moduleFactory: (ctx) => new PyramidSeries(ctx),
  solo: true,
  themeTemplate: PYRAMID_SERIES_THEME
};
var PyramidSeriesModule = {
  type: "series",
  name: "pyramid",
  chartType: "standalone",
  enterprise: true,
  options: pyramidSeriesOptionsDef,
  create: (ctx) => new PyramidSeries(ctx)
};
var {
  ThemeConstants: { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE3 }
} = module_support_exports;
var BASE_RADAR_SERIES_THEME = {
  series: {
    stroke: { $palette: "stroke" },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" }
    },
    marker: {
      enabled: true,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      fillOpacity: 1,
      shape: "circle",
      size: 6,
      strokeOpacity: 1,
      strokeWidth: { $isUserOption: ["./stroke", 1, 0] }
    },
    highlight: module_support_exports.multiSeriesHighlightStyle(),
    tooltip: {
      range: { $path: ["/tooltip/range", "nearest"] }
    }
  },
  axes: {
    [POLAR_AXIS_TYPE3.ANGLE_CATEGORY]: {
      label: {
        spacing: 10
      }
    }
  }
};
var RADAR_LINE_SERIES_THEME = module_support_exports.mergeDefaults(
  {
    series: {
      stroke: module_support_exports.SAFE_STROKE_FILL_OPERATION,
      strokeWidth: 2
    }
  },
  BASE_RADAR_SERIES_THEME
);
var RADAR_AREA_SERIES_THEME = module_support_exports.mergeDefaults(
  {
    series: {
      fill: { $palette: "fill" },
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      strokeWidth: 2,
      marker: {
        enabled: false
      }
    }
  },
  BASE_RADAR_SERIES_THEME
);
var { Label: Label14, SeriesMarker: SeriesMarker22, SeriesProperties: SeriesProperties10, makeSeriesTooltip: makeSeriesTooltip19, Property: Property77 } = module_support_exports;
var RadarSeriesProperties = class extends SeriesProperties10 {
  constructor() {
    super(...arguments);
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.marker = new SeriesMarker22();
    this.label = new Label14();
    this.tooltip = makeSeriesTooltip19();
    this.connectMissingData = false;
  }
};
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "angleKey", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "angleName", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "radiusName", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "rotation", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "marker", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Property77
], RadarSeriesProperties.prototype, "connectMissingData", 2);
var {
  DEFAULT_POLAR_DIRECTION_KEYS: DEFAULT_POLAR_DIRECTION_KEYS22,
  DEFAULT_POLAR_DIRECTION_NAMES: DEFAULT_POLAR_DIRECTION_NAMES22,
  ChartAxisDirection: ChartAxisDirection28,
  PolarAxis: PolarAxis22,
  SeriesNodePickMode: SeriesNodePickMode14,
  valueProperty: valueProperty17,
  fixNumericExtent: fixNumericExtent9,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation7,
  markerFadeInAnimation: markerFadeInAnimation22,
  resetMarkerFn: resetMarkerFn22,
  animationValidation: animationValidation8,
  computeMarkerFocusBounds: computeMarkerFocusBounds3,
  extent: extent22,
  BBox: BBox23,
  Group: Group17,
  Path: Path11,
  PointerEvents: PointerEvents10,
  Selection: Selection15,
  Text: Text8,
  Marker: Marker5,
  mergeDefaults: mergeDefaults17,
  getShapeStyle: getShapeStyle14,
  updateLabelNode: updateLabelNode7
} = module_support_exports;
var RadarSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadarSeries = class extends module_support_exports.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: "angleValue",
      propertyKeys: DEFAULT_POLAR_DIRECTION_KEYS22,
      propertyNames: DEFAULT_POLAR_DIRECTION_NAMES22,
      pickModes: [SeriesNodePickMode14.NEAREST_NODE, SeriesNodePickMode14.EXACT_SHAPE_MATCH],
      canHaveAxes: true,
      animationResetFns: {
        item: resetMarkerFn22
      },
      clipFocusBox: false
    });
    this.properties = new RadarSeriesProperties();
    this.NodeEvent = RadarSeriesNodeEvent;
    this.lineGroup = this.contentGroup.appendChild(new Group17({ name: "radar-line" }));
    this.lineSelection = Selection15.select(
      this.lineGroup,
      Path11
    );
    this.resetInvalidToZero = false;
    this.circleCache = { r: 0, cx: 0, cy: 0 };
    this.lineGroup.zIndex = 0;
    this.itemGroup.zIndex = 1;
  }
  nodeFactory() {
    return new Marker5();
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection28.Angle) {
      return dataModel.getDomain(this, `angleValue`, "value", processedData);
    } else {
      const domain = dataModel.getDomain(this, `radiusValue`, "value", processedData);
      const ext = extent22(domain.length === 0 ? domain : [0].concat(domain));
      return fixNumericExtent9(ext);
    }
  }
  async processData(dataController) {
    const { angleKey, radiusKey } = this.properties;
    const extraProps = [];
    if (!this.ctx.animationManager.isSkipped()) {
      extraProps.push(animationValidation8());
    }
    const radiusScaleType = this.axes[ChartAxisDirection28.Radius]?.scale.type;
    const angleScaleType = this.axes[ChartAxisDirection28.Angle]?.scale.type;
    await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty17(angleKey, angleScaleType, { id: "angleValue" }),
        valueProperty17(radiusKey, radiusScaleType, { id: "radiusValue", invalidValue: void 0 }),
        ...extraProps
      ]
    });
    this.animationState.transition("updateData");
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection28.Radius];
    return radiusAxis instanceof PolarAxis22 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  maybeRefreshNodeData() {
    const didCircleChange = this.didCircleChange();
    if (!didCircleChange && !this.nodeDataRefresh)
      return;
    const { nodeData = [] } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  createNodeData() {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel)
      return;
    const { angleKey, radiusKey, angleName, radiusName, marker, label } = this.properties;
    const angleScale = this.axes[ChartAxisDirection28.Angle]?.scale;
    const radiusScale = this.axes[ChartAxisDirection28.Radius]?.scale;
    if (!angleScale || !radiusScale) {
      return;
    }
    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);
    const radiusValues = dataModel.resolveColumnById(this, `radiusValue`, processedData);
    const axisInnerRadius = this.getAxisInnerRadius();
    const radiusDomain = this.getSeriesDomain(ChartAxisDirection28.Radius);
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const nodeData = rawData.map((datum, datumIndex) => {
      const angleDatum = angleValues[datumIndex];
      const radiusDatum = radiusValues[datumIndex];
      const angle2 = angleScale.convert(angleDatum);
      const radius = this.radius + axisInnerRadius - radiusScale.convert(radiusDatum);
      const cos = Math.cos(angle2);
      const sin = Math.sin(angle2);
      const x = cos * radius;
      const y = sin * radius;
      let labelNodeDatum;
      if (label.enabled) {
        const labelText = this.getLabelText(
          radiusDatum,
          datum,
          radiusKey,
          "radius",
          radiusDomain,
          label,
          { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName }
        );
        if (labelText) {
          let textAlign = "right";
          if (isNumberEqual(cos, 0)) {
            textAlign = "center";
          } else if (cos > 0) {
            textAlign = "left";
          }
          let textBaseline = "bottom";
          if (isNumberEqual(sin, 0)) {
            textBaseline = "middle";
          } else if (sin > 0) {
            textBaseline = "top";
          }
          labelNodeDatum = {
            x: x + cos * marker.size,
            y: y + sin * marker.size,
            text: labelText,
            textAlign,
            textBaseline
          };
        }
      }
      return {
        series: this,
        datum,
        datumIndex,
        index: datumIndex,
        point: { x, y, size: marker.size },
        midPoint: { x, y },
        label: labelNodeDatum,
        angleValue: angleDatum,
        radiusValue: radiusDatum,
        missing: !isFiniteNumber(angle2) || !isFiniteNumber(radius)
      };
    });
    return { itemId: radiusKey, nodeData, labelData: nodeData };
  }
  update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const { series } = this.ctx.highlightManager?.getActiveHighlight() ?? {};
    this.highlightGroup.visible = (animationEnabled || this.visible) && series === this;
    this.maybeRefreshNodeData();
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    this.updatePathSelections();
    this.updateMarkerSelection();
    this.updatePathNodes();
    this.updateMarkers(this.itemSelection, false);
    this.updateMarkers(this.highlightSelection, true);
    this.updateLabels();
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.lineSelection.update(pathData);
  }
  updateMarkerSelection() {
    if (this.properties.marker.isDirty()) {
      this.itemSelection.clear();
      this.itemSelection.cleanup();
      this.itemSelection = Selection15.select(this.itemGroup, () => this.nodeFactory(), false);
    }
    this.itemSelection.update(this.properties.marker.enabled ? this.nodeData : []);
  }
  getMarkerFill(highlightedStyle) {
    return highlightedStyle?.fill ?? this.properties.marker.fill;
  }
  getDatumStylerProperties(datum) {
    const { id: seriesId, properties } = this;
    const { angleKey, radiusKey } = properties;
    return {
      seriesId,
      datum,
      angleKey,
      radiusKey
    };
  }
  updateMarkers(selection, isHighlight) {
    const { visible } = this;
    const { marker, stroke: stroke22, strokeWidth, strokeOpacity } = this.properties;
    let selectionData = [];
    if (visible && marker.shape && marker.enabled) {
      if (isHighlight) {
        const highlighted = this.ctx.highlightManager?.getActiveHighlight();
        if (highlighted?.datum) {
          selectionData = [highlighted];
        }
      } else {
        selectionData = this.nodeData;
      }
    }
    const fillBBox = this.getShapeFillBBox();
    selection.update(selectionData).each((node, datum) => {
      const style2 = this.getMarkerStyle(
        marker,
        datum,
        this.getDatumStylerProperties(datum),
        isHighlight,
        void 0,
        {
          stroke: stroke22,
          strokeWidth,
          strokeOpacity
        }
      );
      this.applyMarkerStyle(style2, node, datum.point, fillBBox);
    });
  }
  updateLabels() {
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (datum.label) {
        const isHighlight = false;
        node.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
        const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
        const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
        updateLabelNode7(
          this,
          node,
          this.properties,
          this.properties.label,
          datum.label,
          isHighlight,
          highlightState
        );
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { angleKey, angleName, radiusKey, radiusName, tooltip, marker } = properties;
    const angleAxis = axes[ChartAxisDirection28.Angle];
    const radiusAxis = axes[ChartAxisDirection28.Radius];
    if (!dataModel || !processedData || !angleAxis || !radiusAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const angleValue = dataModel.resolveColumnById(this, `angleValue`, processedData)[datumIndex];
    const radiusValue = dataModel.resolveColumnById(this, `radiusValue`, processedData)[datumIndex];
    if (angleValue == null)
      return;
    const activeStyle = this.getMarkerStyle(
      marker,
      { datum, datumIndex },
      this.getDatumStylerProperties(datum),
      false
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(angleAxis, "tooltip", angleValue, datum, angleKey, void 0),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: radiusName,
            fallbackLabel: radiusKey,
            value: this.getAxisValueText(radiusAxis, "tooltip", radiusValue, datum, radiusKey, void 0)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: angleName,
        angleKey,
        radiusKey,
        angleName,
        radiusName,
        ...activeStyle
      }
    );
  }
  legendItemSymbol() {
    const { stroke: stroke22, strokeWidth, strokeOpacity, lineDash, marker } = this.properties;
    const markerStyle = getShapeStyle14(
      {
        shape: marker.shape,
        enabled: marker.enabled || strokeWidth <= 0,
        fill: this.getMarkerFill() ?? marker.stroke ?? stroke22 ?? "rgba(0, 0, 0, 0)",
        stroke: marker.stroke ?? stroke22 ?? "rgba(0, 0, 0, 0)",
        fillOpacity: marker.fillOpacity,
        strokeOpacity: marker.strokeOpacity,
        strokeWidth: marker.strokeWidth,
        lineDash: marker.lineDash,
        lineDashOffset: marker.lineDashOffset
      },
      marker.fillGradientDefaults,
      marker.fillPatternDefaults,
      marker.fillImageDefaults
    );
    return {
      marker: markerStyle,
      line: {
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { radiusKey, radiusName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId: radiusKey,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: radiusKey }),
        label: {
          text: radiusName ?? radiusKey
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  pickNodeClosestDatum(hitPoint) {
    const { nodeData, centerX: cx, centerY: cy } = this;
    const { x, y } = hitPoint;
    const radius = this.radius;
    const distanceFromCenter = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
    if (distanceFromCenter > radius + this.properties.marker.size) {
      return;
    }
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const distance2 = Math.sqrt((hitPoint.x - datumX - cx) ** 2 + (hitPoint.y - datumY - cy) ** 2);
      if (distance2 < minDistance) {
        minDistance = distance2;
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      const distance2 = Math.max(minDistance - (closestDatum.point?.size ?? 0), 0);
      return { datum: closestDatum, distance: distance2 };
    }
  }
  computeLabelsBBox() {
    const { label } = this.properties;
    this.maybeRefreshNodeData();
    const textBoxes = [];
    const tempText2 = new Text8();
    this.nodeData.forEach((nodeDatum) => {
      if (!label.enabled || !nodeDatum.label) {
        return;
      }
      tempText2.text = nodeDatum.label.text;
      tempText2.x = nodeDatum.label.x;
      tempText2.y = nodeDatum.label.y;
      tempText2.setFont(label);
      tempText2.setAlign(nodeDatum.label);
      const box = tempText2.getBBox();
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox23.merge(textBoxes);
  }
  getLineNode() {
    return this.lineSelection?.at(0);
  }
  beforePathAnimation() {
    this.updatePathNodes();
  }
  updatePathNodes() {
    const lineNode = this.getLineNode();
    if (!lineNode)
      return;
    const { strokeWidth, stroke: stroke22, strokeOpacity, lineDash, lineDashOffset, opacity } = mergeDefaults17(
      this.getHighlightStyle(),
      this.properties
    );
    lineNode.setProperties({
      fill: void 0,
      lineJoin: "round",
      lineCap: "round",
      pointerEvents: PointerEvents10.None,
      opacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
  }
  getLinePoints() {
    const { nodeData, resetInvalidToZero } = this;
    const { connectMissingData } = this.properties;
    if (nodeData.length === 0) {
      return [];
    }
    const radiusAxis = this.axes[ChartAxisDirection28.Radius];
    const angleAxis = this.axes[ChartAxisDirection28.Angle];
    const reversedAngleAxis = angleAxis?.isReversed();
    const reversedRadiusAxis = radiusAxis?.isReversed();
    const data = reversedRadiusAxis && !reversedAngleAxis ? [...nodeData].reverse() : nodeData;
    const points = [];
    let prevPointInvalid = false;
    let firstValid;
    data.forEach((datum, index) => {
      let { x, y } = datum.point;
      const isPointInvalid = isNaN(x) || isNaN(y);
      if (!isPointInvalid) {
        firstValid ?? (firstValid = datum);
      }
      if (isPointInvalid && !connectMissingData) {
        x = 0;
        y = 0;
      }
      const moveTo = index === 0 || !resetInvalidToZero && !connectMissingData && (isPointInvalid || prevPointInvalid);
      points.push({ x, y, moveTo });
      prevPointInvalid = isPointInvalid;
    });
    if (firstValid !== void 0) {
      points.push({ x: firstValid.point.x, y: firstValid.point.y, moveTo: false });
    }
    return points;
  }
  animateSinglePath(pathNode, points, ratio3) {
    const { path } = pathNode;
    path.clear(true);
    const axisInnerRadius = this.getAxisInnerRadius();
    const radiusAxis = this.axes[ChartAxisDirection28.Radius];
    const reversedRadiusAxis = radiusAxis?.isReversed();
    const radiusZero = reversedRadiusAxis ? this.radius + axisInnerRadius - radiusAxis?.scale.convert(0) : axisInnerRadius;
    points.forEach((point) => {
      const { x: x1, y: y1, arc, radius = 0, startAngle = 0, endAngle = 0, moveTo } = point;
      const angle2 = Math.atan2(y1, x1);
      const x0 = radiusZero * Math.cos(angle2);
      const y0 = radiusZero * Math.sin(angle2);
      const t = ratio3;
      const x = x0 * (1 - t) + x1 * t;
      const y = y0 * (1 - t) + y1 * t;
      if (arc) {
        path.arc(x1, y1, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    pathNode.checkPathDirty();
  }
  animatePaths(ratio3) {
    const linePoints = this.getLinePoints();
    const lineNode = this.getLineNode();
    if (!lineNode)
      return;
    this.animateSinglePath(lineNode, linePoints, ratio3);
  }
  animateEmptyUpdateReady() {
    const { itemSelection, labelSelection } = this;
    const { animationManager } = this.ctx;
    this.beforePathAnimation();
    animationManager.animate({
      id: `${this.id}_'path`,
      groupId: this.id,
      from: 0,
      to: 1,
      phase: "initial",
      collapsable: false,
      onUpdate: (ratio3) => this.animatePaths(ratio3),
      onStop: () => this.animatePaths(1)
    });
    markerFadeInAnimation22(this, animationManager, "added", itemSelection);
    seriesLabelFadeInAnimation7(this, "labels", animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    super.animateWaitingUpdateReady(data);
    this.resetPaths();
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetPaths();
  }
  resetPaths() {
    const lineNode = this.getLineNode();
    if (lineNode) {
      const { path: linePath } = lineNode;
      const linePoints = this.getLinePoints();
      lineNode.fill = void 0;
      lineNode.stroke = this.properties.stroke;
      lineNode.strokeWidth = this.properties.strokeWidth;
      lineNode.strokeOpacity = this.properties.strokeOpacity;
      lineNode.lineDash = this.properties.lineDash;
      lineNode.lineDashOffset = this.properties.lineDashOffset;
      linePath.clear(true);
      for (const { x, y, moveTo } of linePoints) {
        if (moveTo) {
          linePath.moveTo(x, y);
        } else {
          linePath.lineTo(x, y);
        }
      }
      lineNode.checkPathDirty();
    }
  }
  getFormattedMarkerStyle(datum) {
    const { angleKey, radiusKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, datum, { angleKey, radiusKey }, true);
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds3(this, opts);
  }
};
RadarSeries.className = "RadarSeries";
var { FillGradientDefaults: FillGradientDefaults15, FillPatternDefaults: FillPatternDefaults15, FillImageDefaults: FillImageDefaults15, Property: Property78 } = module_support_exports;
var RadarAreaSeriesProperties = class extends RadarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillGradientDefaults = new FillGradientDefaults15();
    this.fillPatternDefaults = new FillPatternDefaults15();
    this.fillImageDefaults = new FillImageDefaults15();
    this.fillOpacity = 1;
  }
};
__decorateClass2([
  Property78
], RadarAreaSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Property78
], RadarAreaSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property78
], RadarAreaSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property78
], RadarAreaSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property78
], RadarAreaSeriesProperties.prototype, "fillOpacity", 2);
var {
  Group: Group18,
  Path: Path12,
  PointerEvents: PointerEvents11,
  Selection: Selection16,
  ChartAxisDirection: ChartAxisDirection29,
  applyShapeStyle: applyShapeStyle15,
  getShapeFill: getShapeFill5,
  getShapeStyle: getShapeStyle15,
  mergeDefaults: mergeDefaults18
} = module_support_exports;
var RadarAreaSeries = class extends RadarSeries {
  constructor(moduleCtx) {
    super(moduleCtx);
    this.properties = new RadarAreaSeriesProperties();
    this.areaGroup = this.contentGroup.appendChild(new Group18({ name: "radar-area" }));
    this.areaSelection = Selection16.select(
      this.areaGroup,
      Path12
    );
    this.resetInvalidToZero = true;
    this.areaGroup.zIndex = -1;
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.areaSelection.update(pathData);
    super.updatePathSelections();
  }
  getAreaNode() {
    return this.areaSelection.at(0);
  }
  getMarkerFill(highlightedStyle) {
    return highlightedStyle?.fill ?? this.properties.marker.fill ?? this.properties.fill;
  }
  updatePathNodes() {
    super.updatePathNodes();
    const { fill, fillOpacity, opacity } = mergeDefaults18(this.getHighlightStyle(), this.properties);
    const { fill: seriesFill, fillOpacity: seriesFillOpacity } = getShapeStyle15(
      { fill, fillOpacity },
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    const areaNode = this.getAreaNode();
    if (areaNode) {
      applyShapeStyle15(
        areaNode,
        {
          fill: seriesFill,
          fillOpacity: seriesFillOpacity,
          stroke: void 0
        },
        this.getShapeFillBBox()
      );
      areaNode.setProperties({
        lineJoin: "round",
        pointerEvents: PointerEvents11.None,
        opacity
      });
    }
  }
  animatePaths(ratio3) {
    super.animatePaths(ratio3);
    const areaNode = this.getAreaNode();
    if (areaNode) {
      this.animateSinglePath(areaNode, this.getAreaPoints(), ratio3);
    }
  }
  getAreaPoints() {
    const points = this.getLinePoints();
    const getPolarAxis = (direction) => {
      const axis = this.axes[direction];
      return axis instanceof module_support_exports.PolarAxis ? axis : void 0;
    };
    const radiusAxis = getPolarAxis(ChartAxisDirection29.Radius);
    const angleAxis = getPolarAxis(ChartAxisDirection29.Angle);
    const reversedRadiusAxis = radiusAxis?.isReversed();
    if (!reversedRadiusAxis) {
      return points;
    }
    const zeroLinePoints = angleAxis?.getAxisLinePoints()?.points ?? [];
    return points.concat(...zeroLinePoints);
  }
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
  resetPaths() {
    super.resetPaths();
    const areaNode = this.getAreaNode();
    if (areaNode) {
      const { path: areaPath } = areaNode;
      const areaPoints = this.getAreaPoints();
      const fill = getShapeFill5(
        this.properties.fill,
        this.properties.fillGradientDefaults,
        this.properties.fillPatternDefaults,
        this.properties.fillImageDefaults
      );
      const fillBBox = this.getShapeFillBBox();
      applyShapeStyle15(
        areaNode,
        {
          fill,
          stroke: void 0,
          fillOpacity: this.properties.fillOpacity,
          lineDash: this.properties.lineDash,
          lineDashOffset: this.properties.lineDashOffset
        },
        fillBBox
      );
      areaNode.lineJoin = areaNode.lineCap = "round";
      areaPath.clear(true);
      areaPoints.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
        if (arc) {
          areaPath.arc(x, y, radius, startAngle, endAngle);
        } else if (moveTo) {
          areaPath.moveTo(x, y);
        } else {
          areaPath.lineTo(x, y);
        }
      });
      areaPath.closePath();
      areaNode.checkPathDirty();
    }
  }
};
RadarAreaSeries.className = "RadarAreaSeries";
RadarAreaSeries.type = "radar-area";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs17, radarAreaSeriesThemeableOptionsDef: radarAreaSeriesThemeableOptionsDef2 } = module_support_exports;
var radarAreaSeriesOptionsDef = {
  ...commonSeriesOptionsDefs17,
  ...radarAreaSeriesThemeableOptionsDef2,
  type: required(constant("radar-area")),
  angleKey: required(string),
  radiusKey: required(string),
  angleName: string,
  radiusName: string
};
var {
  ThemeConstants: { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE4 }
} = module_support_exports;
var RadarAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-area",
  moduleFactory: (ctx) => new RadarAreaSeries(ctx),
  defaultAxes: [{ type: POLAR_AXIS_TYPE4.ANGLE_CATEGORY }, { type: POLAR_AXIS_TYPE4.RADIUS_NUMBER }],
  themeTemplate: RADAR_AREA_SERIES_THEME
};
var RadarAreaSeriesModule = {
  type: "series",
  name: "radar-area",
  chartType: "polar",
  enterprise: true,
  options: radarAreaSeriesOptionsDef,
  create: (ctx) => new RadarAreaSeries(ctx)
};
var RadarLineSeries = class extends RadarSeries {
  hasItemStylers() {
    return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
  }
  updatePathSelections() {
    this.lineSelection.update(this.visible ? [true] : []);
  }
};
RadarLineSeries.className = "RadarLineSeries";
RadarLineSeries.type = "radar-line";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs18, radarLineSeriesThemeableOptionsDef: radarLineSeriesThemeableOptionsDef2 } = module_support_exports;
var radarLineSeriesOptionsDef = {
  ...commonSeriesOptionsDefs18,
  ...radarLineSeriesThemeableOptionsDef2,
  type: required(constant("radar-line")),
  angleKey: required(string),
  radiusKey: required(string),
  angleName: string,
  radiusName: string
};
var { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE5 } = module_support_exports.ThemeConstants;
var RadarLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-line",
  moduleFactory: (ctx) => new RadarLineSeries(ctx),
  defaultAxes: [{ type: POLAR_AXIS_TYPE5.ANGLE_CATEGORY }, { type: POLAR_AXIS_TYPE5.RADIUS_NUMBER }],
  themeTemplate: RADAR_LINE_SERIES_THEME
};
var RadarLineSeriesModule = {
  type: "series",
  name: "radar-line",
  chartType: "polar",
  enterprise: true,
  options: radarLineSeriesOptionsDef,
  create: (ctx) => new RadarLineSeries(ctx)
};
var {
  SeriesProperties: SeriesProperties11,
  FillGradientDefaults: FillGradientDefaults16,
  FillPatternDefaults: FillPatternDefaults16,
  FillImageDefaults: FillImageDefaults16,
  makeSeriesTooltip: makeSeriesTooltip20,
  Property: Property79,
  Label: Label15
} = module_support_exports;
var RadialBarSeriesProperties = class extends SeriesProperties11 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillGradientDefaults = new FillGradientDefaults16();
    this.fillPatternDefaults = new FillPatternDefaults16();
    this.fillImageDefaults = new FillImageDefaults16();
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.label = new Label15();
    this.tooltip = makeSeriesTooltip20();
  }
  getStyle() {
    const { fill, fillOpacity, stroke: stroke22, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "angleKey", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "angleName", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "radiusName", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "rotation", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property79
], RadialBarSeriesProperties.prototype, "tooltip", 2);
var { SectorBox: SectorBox3, motion: motion9 } = module_support_exports;
function fixRadialBarAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.innerRadius) || isNaN(node.previousDatum.outerRadius)) {
      return "added";
    }
    if (isNaN(datum.innerRadius) || isNaN(datum.outerRadius)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialBarSeriesAnimationFunctions(axisZeroAngle) {
  const fromFn = (sect, datum, status) => {
    status = fixRadialBarAnimationStatus(sect, datum, status);
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed" || status === "updated") {
      startAngle = sect.startAngle;
      endAngle = sect.endAngle;
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
      clipSector = sect.clipSector;
    } else {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    }
    clipSector ?? (clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius));
    const phase = motion9.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { startAngle, endAngle, innerRadius, outerRadius, clipSector, phase };
  };
  const toFn = (sect, datum, status) => {
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed") {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
      clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius);
    } else {
      startAngle = datum.startAngle;
      endAngle = datum.endAngle;
      innerRadius = isNaN(datum.innerRadius) ? sect.innerRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? sect.outerRadius : datum.outerRadius;
      clipSector = datum.clipSector;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, clipSector };
  };
  return { toFn, fromFn };
}
function resetRadialBarSelectionsFn(_node, datum) {
  return {
    centerX: 0,
    centerY: 0,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    clipSector: datum.clipSector
  };
}
var {
  DEFAULT_POLAR_DIRECTION_KEYS: DEFAULT_POLAR_DIRECTION_KEYS3,
  DEFAULT_POLAR_DIRECTION_NAMES: DEFAULT_POLAR_DIRECTION_NAMES3,
  ChartAxisDirection: ChartAxisDirection30,
  PolarAxis: PolarAxis3,
  diff: diff7,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty3,
  keyProperty: keyProperty10,
  normaliseGroupTo: normaliseGroupTo22,
  valueProperty: valueProperty18,
  fixNumericExtent: fixNumericExtent10,
  resetLabelFn: resetLabelFn6,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation8,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation22,
  animationValidation: animationValidation9,
  angleBetween: angleBetween3,
  createDatumId: createDatumId17,
  CategoryScale: CategoryScale4,
  Sector: Sector5,
  SectorBox: SectorBox4,
  motion: motion10,
  isGradientFill: isGradientFill3,
  applyShapeStyle: applyShapeStyle16,
  getShapeStyle: getShapeStyle16,
  updateLabelNode: updateLabelNode8,
  mergeDefaults: mergeDefaults19
} = module_support_exports;
var RadialBarSeriesNodeEvent = class extends module_support_exports.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialBarSeries = class extends module_support_exports.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: "radiusValue",
      propertyKeys: DEFAULT_POLAR_DIRECTION_KEYS3,
      propertyNames: DEFAULT_POLAR_DIRECTION_NAMES3,
      canHaveAxes: true,
      animationResetFns: {
        item: resetRadialBarSelectionsFn,
        label: resetLabelFn6
      }
    });
    this.properties = new RadialBarSeriesProperties();
    this.NodeEvent = RadialBarSeriesNodeEvent;
    this.groupScale = new CategoryScale4();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  get defaultShapeStyle() {
    const angleScale = this.axes[ChartAxisDirection30.Angle]?.scale;
    return {
      ...this.properties.fillGradientDefaults.toJson(),
      rotation: module_support_exports.toDegrees(angleScale.range[0]) + 90
    };
  }
  nodeFactory() {
    return new Sector5();
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection30.Angle) {
      const xExtent = dataModel.getDomain(this, "angleValue-end", "value", processedData);
      const fixedXExtent = [xExtent[0] > 0 ? 0 : xExtent[0], xExtent[1] < 0 ? 0 : xExtent[1]];
      return fixNumericExtent10(fixedXExtent);
    } else {
      return dataModel.getDomain(this, "radiusValue", "key", processedData);
    }
  }
  async processData(dataController) {
    const { angleKey, radiusKey, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const stackGroupId = this.getStackId();
    const stackGroupTrailingId = `${stackGroupId}-trailing`;
    const extraProps = [];
    if (isDefined(normalizedTo)) {
      extraProps.push(normaliseGroupTo22([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo)));
    }
    if (animationEnabled) {
      if (this.processedData) {
        extraProps.push(diff7(this.id, this.processedData));
      }
      extraProps.push(animationValidation9());
    }
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const radiusScaleType = this.axes[ChartAxisDirection30.Radius]?.scale.type;
    const angleScaleType = this.axes[ChartAxisDirection30.Angle]?.scale.type;
    await this.requestDataModel(dataController, this.data, {
      props: [
        keyProperty10(radiusKey, radiusScaleType, { id: "radiusValue" }),
        valueProperty18(angleKey, angleScaleType, {
          id: "angleValue-raw",
          invalidValue: null,
          ...visibleProps
        }),
        ...groupAccumulativeValueProperty3(
          angleKey,
          "normal",
          "current",
          {
            id: `angleValue-end`,
            rangeId: `angleValue-range`,
            invalidValue: null,
            groupId: stackGroupId,
            separateNegative: true,
            ...visibleProps
          },
          angleScaleType
        ),
        ...groupAccumulativeValueProperty3(
          angleKey,
          "trailing",
          "current",
          {
            id: `angleValue-start`,
            invalidValue: null,
            groupId: stackGroupTrailingId,
            separateNegative: true,
            ...visibleProps
          },
          angleScaleType
        ),
        ...extraProps
      ],
      groupByKeys: true,
      groupByData: false
    });
    this.animationState.transition("updateData");
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  maybeRefreshNodeData() {
    const circleChanged = this.didCircleChange();
    if (!circleChanged && !this.nodeDataRefresh)
      return;
    const { nodeData = [] } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.nodeDataRefresh = false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection30.Radius];
    return radiusAxis instanceof PolarAxis3 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  createNodeData() {
    const { processedData, dataModel } = this;
    if (!dataModel || !processedData || processedData.type !== "grouped")
      return;
    const angleAxis = this.axes[ChartAxisDirection30.Angle];
    const radiusAxis = this.axes[ChartAxisDirection30.Radius];
    const angleScale = angleAxis?.scale;
    const radiusScale = radiusAxis?.scale;
    if (!angleScale || !radiusScale) {
      return;
    }
    const radiusValues = dataModel.resolveKeysById(this, "radiusValue", processedData);
    const angleStartValues = dataModel.resolveColumnById(this, `angleValue-start`, processedData);
    const angleEndValues = dataModel.resolveColumnById(this, `angleValue-end`, processedData);
    const angleRawValues = dataModel.resolveColumnById(this, `angleValue-raw`, processedData);
    const angleRangeIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-range`);
    let groupPaddingInner = 0;
    if (radiusAxis instanceof RadiusCategoryAxis) {
      groupPaddingInner = radiusAxis.groupPaddingInner;
    }
    const { groupScale } = this;
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
    groupScale.range = [0, Math.abs(radiusScale.bandwidth ?? 0)];
    groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
    const barWidth = groupScale.bandwidth >= 1 ? groupScale.bandwidth : groupScale.rawBandwidth;
    const angleAxisReversed = angleAxis.isReversed();
    const radiusAxisReversed = radiusAxis.isReversed();
    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
    const axisTotalRadius = axisOuterRadius + axisInnerRadius;
    const angleDomain = this.getSeriesDomain(ChartAxisDirection30.Angle);
    const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
    const getLabelNodeDatum = (datum, angleDatum, x, y) => {
      const labelText = this.getLabelText(
        angleDatum,
        datum,
        angleKey,
        "angle",
        angleDomain,
        label,
        { value: angleDatum, datum, angleKey, radiusKey, angleName, radiusName }
      );
      if (labelText) {
        return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
      }
    };
    const nodeData = [];
    const context = { itemId: radiusKey, nodeData, labelData: nodeData };
    if (!this.visible)
      return context;
    const { dataSources } = processedData;
    const rawData = dataSources.get(this.id) ?? [];
    for (const { datumIndex, group } of dataModel.forEachGroupDatum(this, processedData)) {
      const datum = rawData[datumIndex];
      const radiusDatum = radiusValues[datumIndex];
      if (radiusDatum == null)
        return;
      const angleDatum = angleRawValues[datumIndex];
      const angleStartDatum = angleStartValues[datumIndex];
      const angleEndDatum = angleEndValues[datumIndex];
      const isPositive = angleDatum >= 0 && !Object.is(angleDatum, -0);
      const angleRange = group.aggregation[angleRangeIndex][isPositive ? 1 : 0];
      const reversed = isPositive === angleAxisReversed;
      let startAngle = angleScale.convert(angleStartDatum, { clamp: true });
      let endAngle = angleScale.convert(angleEndDatum, { clamp: true });
      let rangeStartAngle = angleScale.convert(0, { clamp: true });
      let rangeEndAngle = angleScale.convert(angleRange, { clamp: true });
      if (reversed) {
        [rangeStartAngle, rangeEndAngle] = [rangeEndAngle, rangeStartAngle];
        [startAngle, endAngle] = [endAngle, startAngle];
      }
      const dataRadius = axisTotalRadius - radiusScale.convert(radiusDatum);
      const innerRadius = dataRadius + groupScale.convert(String(groupIndex));
      const outerRadius = innerRadius + barWidth;
      const midRadius = (innerRadius + outerRadius) / 2;
      const midAngle = startAngle + angleBetween3(startAngle, endAngle) / 2;
      const x = Math.cos(midAngle) * midRadius;
      const y = Math.sin(midAngle) * midRadius;
      const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, angleDatum, x, y) : void 0;
      const clipSector = new SectorBox4(startAngle, endAngle, innerRadius, outerRadius);
      nodeData.push({
        series: this,
        datum,
        datumIndex,
        point: { x, y, size: 0 },
        midPoint: { x, y },
        label: labelNodeDatum,
        angleValue: angleDatum,
        radiusValue: radiusDatum,
        innerRadius,
        outerRadius,
        startAngle: rangeStartAngle,
        endAngle: rangeEndAngle,
        clipSector,
        reversed,
        index: datumIndex
      });
    }
    return context;
  }
  update({ seriesRect }) {
    const resize = this.checkResize(seriesRect);
    this.maybeRefreshNodeData();
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    this.updateSectorSelection(this.itemSelection, false);
    this.updateSectorSelection(this.highlightSelection, true);
    this.updateLabels();
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  getItemStyle(nodeDatum, isHighlight) {
    const { id: seriesId, properties } = this;
    const { angleKey, radiusKey, itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const highlightStyle = this.getHighlightStyle(isHighlight, nodeDatum.datumIndex);
    const baseStyle = mergeDefaults19(highlightStyle, properties.getStyle());
    let style2 = getShapeStyle16(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && nodeDatum != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId17(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(
            activeHighlight,
            isHighlight,
            nodeDatum.datumIndex
          );
          return this.callWithContext(itemStyler, {
            seriesId,
            datum: nodeDatum.datum,
            highlighted: isHighlight,
            highlightState,
            angleKey,
            radiusKey,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle16(
          mergeDefaults19(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateSectorSelection(selection, isHighlight) {
    let selectionData = [];
    if (isHighlight) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      if (activeHighlight?.datum && activeHighlight.series === this) {
        selectionData.push(activeHighlight);
      }
    } else {
      selectionData = this.nodeData;
    }
    const fillBBox = this.getShapeFillBBox();
    selection.update(selectionData, void 0, (datum) => this.getDatumId(datum)).each((node, nodeDatum) => {
      const datum = readDatum(nodeDatum);
      if (datum == null)
        return;
      const style2 = this.getItemStyle(nodeDatum, isHighlight);
      const cornerRadius = style2.cornerRadius;
      const fill = style2.fill;
      const fillParams = module_support_exports.isGradientFill(fill) && fill.bounds !== "item" ? { centerX: 0, centerY: 0 } : void 0;
      applyShapeStyle16(node, style2, fillBBox, fillParams);
      node.lineJoin = "round";
      node.inset = node.stroke != null ? node.strokeWidth / 2 : 0;
      node.startInnerCornerRadius = datum.reversed ? cornerRadius : 0;
      node.startOuterCornerRadius = datum.reversed ? cornerRadius : 0;
      node.endInnerCornerRadius = datum.reversed ? 0 : cornerRadius;
      node.endOuterCornerRadius = datum.reversed ? 0 : cornerRadius;
      if (isHighlight) {
        node.startAngle = nodeDatum.startAngle;
        node.endAngle = nodeDatum.endAngle;
        node.clipSector = nodeDatum.clipSector;
        node.innerRadius = nodeDatum.innerRadius;
        node.outerRadius = nodeDatum.outerRadius;
      }
    });
  }
  updateLabels() {
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      const isHighlight = false;
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
      updateLabelNode8(
        this,
        node,
        this.properties,
        this.properties.label,
        datum.label,
        isHighlight,
        highlightState
      );
      node.fillOpacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity ?? 1;
    });
  }
  getBarTransitionFunctions() {
    const angleScale = this.axes[ChartAxisDirection30.Angle]?.scale;
    let axisZeroAngle = 0;
    if (!angleScale) {
      return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
    }
    const d0 = Math.min(angleScale.domain[0], angleScale.domain[1]);
    const d1 = Math.max(angleScale.domain[0], angleScale.domain[1]);
    if (d0 <= 0 && d1 >= 0) {
      axisZeroAngle = angleScale.convert(0);
    }
    return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getBarTransitionFunctions();
    motion10.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation8(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getBarTransitionFunctions();
    motion10.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation22(this, "labels", animationManager, this.labelSelection);
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { angleKey, angleName, radiusKey, radiusName, tooltip } = properties;
    const angleAxis = axes[ChartAxisDirection30.Angle];
    const radiusAxis = axes[ChartAxisDirection30.Radius];
    const nodeDatum = this.nodeData?.[datumIndex];
    if (!dataModel || !processedData || !angleAxis || !radiusAxis || !nodeDatum)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const radiusValue = dataModel.resolveKeysById(this, `radiusValue`, processedData)[datumIndex];
    const angleValue = dataModel.resolveColumnById(this, `angleValue-raw`, processedData)[datumIndex];
    if (radiusValue == null)
      return;
    const format = this.getItemStyle(nodeDatum, false);
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: this.getAxisValueText(radiusAxis, "tooltip", radiusValue, datum, radiusKey, void 0),
        symbol: this.legendItemSymbol(),
        data: [
          {
            label: angleName,
            fallbackLabel: angleKey,
            value: this.getAxisValueText(angleAxis, "tooltip", angleValue, datum, angleKey, void 0)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: angleName,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        ...format
      }
    );
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke22,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      lineDashOffset,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = this.properties;
    const markerStyle = getShapeStyle16(
      {
        fill: fill ?? "rgba(0, 0, 0, 0)",
        stroke: stroke22 ?? "rgba(0, 0, 0, 0)",
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      },
      this.defaultShapeStyle,
      fillPatternDefaults5,
      fillImageDefaults5
    );
    if (isGradientFill3(markerStyle.fill)) {
      markerStyle.fill = { ...markerStyle.fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return {
      marker: markerStyle
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id: seriesId, visible } = this;
    const { angleKey, angleName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId: angleKey,
        seriesId,
        enabled: visible,
        label: {
          text: angleName ?? angleKey
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  getDatumId(datum) {
    return createDatumId17(datum.radiusValue);
  }
  computeLabelsBBox() {
    return null;
  }
  getStackId() {
    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;
    return `radialBar-stack-${groupIndex}-xValues`;
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
RadialBarSeries.className = "RadialBarSeries";
RadialBarSeries.type = "radial-bar";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs19, radialBarSeriesThemeableOptionsDef: radialBarSeriesThemeableOptionsDef2 } = module_support_exports;
var radialBarSeriesOptionsDef = {
  ...commonSeriesOptionsDefs19,
  ...radialBarSeriesThemeableOptionsDef2,
  type: required(constant("radial-bar")),
  angleKey: required(string),
  radiusKey: required(string),
  angleName: string,
  radiusName: string,
  grouped: boolean,
  stacked: boolean,
  stackGroup: string,
  normalizedTo: number
};
var {
  ThemeConstants: { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE6 }
} = module_support_exports;
var RADIAL_BAR_SERIES_THEME = {
  series: {
    fill: { $palette: "fill" },
    stroke: { $palette: "stroke" },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_CONIC_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    strokeWidth: { $isUserOption: ["./stroke", 1, 0] },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "chartBackgroundColor" }
    },
    highlight: module_support_exports.multiSeriesHighlightStyle()
  },
  axes: {
    [POLAR_AXIS_TYPE6.RADIUS_CATEGORY]: {
      innerRadiusRatio: 0.2,
      groupPaddingInner: 0.2,
      paddingInner: 0.2,
      paddingOuter: 0.1
    }
  }
};
var { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE7 } = module_support_exports.ThemeConstants;
var RadialBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-bar",
  moduleFactory: (ctx) => new RadialBarSeries(ctx),
  defaultAxes: [{ type: POLAR_AXIS_TYPE7.ANGLE_NUMBER }, { type: POLAR_AXIS_TYPE7.RADIUS_CATEGORY }],
  themeTemplate: RADIAL_BAR_SERIES_THEME,
  stackable: true,
  groupable: true
};
var RadialBarSeriesModule = {
  type: "series",
  name: "radial-bar",
  chartType: "polar",
  enterprise: true,
  options: radialBarSeriesOptionsDef,
  create: (ctx) => new RadialBarSeries(ctx)
};
var { Property: Property80 } = module_support_exports;
var RadialColumnSeriesProperties = class extends RadialColumnSeriesBaseProperties {
};
__decorateClass2([
  Property80
], RadialColumnSeriesProperties.prototype, "columnWidthRatio", 2);
__decorateClass2([
  Property80
], RadialColumnSeriesProperties.prototype, "maxColumnWidthRatio", 2);
var { ChartAxisDirection: ChartAxisDirection31, PolarAxis: PolarAxis4, RadialColumnShape: RadialColumnShape2, getRadialColumnWidth: getRadialColumnWidth2 } = module_support_exports;
var RadialColumnSeries = class extends RadialColumnSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, {
      animationResetFns: {
        item: resetRadialColumnSelectionFn
      }
    });
    this.properties = new RadialColumnSeriesProperties();
  }
  getStackId() {
    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;
    return `radarColumn-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new RadialColumnShape2();
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareRadialColumnAnimationFunctions(axisZeroRadius);
  }
  isRadiusAxisCircle() {
    const radiusAxis = this.axes[ChartAxisDirection31.Radius];
    return radiusAxis instanceof PolarAxis4 ? radiusAxis.shape === "circle" : false;
  }
  updateItemPath(node, datum, highlight5) {
    node.isBeveled = this.isRadiusAxisCircle();
    node.isRadiusAxisReversed = this.isRadiusAxisReversed();
    if (highlight5) {
      node.innerRadius = datum.innerRadius;
      node.outerRadius = datum.outerRadius;
      node.startAngle = datum.startAngle;
      node.endAngle = datum.endAngle;
      node.columnWidth = datum.columnWidth;
      node.axisInnerRadius = datum.axisInnerRadius;
      node.axisOuterRadius = datum.axisOuterRadius;
    }
  }
  getColumnWidth(startAngle, endAngle) {
    const { columnWidthRatio = 0.5, maxColumnWidthRatio = 0.5 } = this.properties;
    return getRadialColumnWidth2(startAngle, endAngle, this.radius, columnWidthRatio, maxColumnWidthRatio);
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
RadialColumnSeries.className = "RadialColumnSeries";
RadialColumnSeries.type = "radial-column";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs20, radialColumnSeriesThemeableOptionsDef: radialColumnSeriesThemeableOptionsDef2 } = module_support_exports;
var radialColumnSeriesOptionsDef = {
  ...commonSeriesOptionsDefs20,
  ...radialColumnSeriesThemeableOptionsDef2,
  type: required(constant("radial-column")),
  angleKey: required(string),
  radiusKey: required(string),
  angleName: string,
  radiusName: string,
  grouped: boolean,
  stacked: boolean,
  stackGroup: string,
  normalizedTo: number
};
var {
  ThemeConstants: { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE8, POLAR_AXIS_SHAPE: POLAR_AXIS_SHAPE22 }
} = module_support_exports;
var RADIAL_COLUMN_SERIES_THEME = {
  series: {
    fill: { $palette: "fill" },
    stroke: { $palette: "stroke" },
    // @ts-expect-error undocumented option
    fillGradientDefaults: module_support_exports.FILL_GRADIENT_RADIAL_SERIES_DEFAULTS,
    fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
    fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
    columnWidthRatio: 0.5,
    maxColumnWidthRatio: 0.5,
    strokeWidth: { $isUserOption: ["./stroke", 1, 0] },
    label: {
      ...module_support_exports.LABEL_BOXING_DEFAULTS,
      enabled: false,
      fontSize: { $ref: "fontSize" },
      fontFamily: { $ref: "fontFamily" },
      fontWeight: { $ref: "fontWeight" },
      color: { $ref: "textColor" }
    },
    highlight: module_support_exports.multiSeriesHighlightStyle()
  },
  axes: {
    [POLAR_AXIS_TYPE8.ANGLE_CATEGORY]: {
      shape: { $findFirstSiblingNotOperation: POLAR_AXIS_SHAPE22.CIRCLE },
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        spacing: 10
      }
    },
    [POLAR_AXIS_TYPE8.RADIUS_NUMBER]: {
      shape: { $findFirstSiblingNotOperation: POLAR_AXIS_SHAPE22.CIRCLE },
      innerRadiusRatio: 0.5
    }
  }
};
var { POLAR_AXIS_TYPE: POLAR_AXIS_TYPE9 } = module_support_exports.ThemeConstants;
var RadialColumnModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-column",
  moduleFactory: (ctx) => new RadialColumnSeries(ctx),
  defaultAxes: [{ type: POLAR_AXIS_TYPE9.ANGLE_CATEGORY }, { type: POLAR_AXIS_TYPE9.RADIUS_NUMBER }],
  themeTemplate: RADIAL_COLUMN_SERIES_THEME,
  stackable: true,
  groupable: true
};
var RadialColumnSeriesModule = {
  type: "series",
  name: "radial-column",
  chartType: "polar",
  enterprise: true,
  options: radialColumnSeriesOptionsDef,
  create: (ctx) => new RadialColumnSeries(ctx)
};
var { SvgPath: SvgPath2, Rotatable: Rotatable2, Translatable: Translatable2, Scalable: Scalable2 } = module_support_exports;
var RadialGaugeNeedle = class extends Rotatable2(Scalable2(Translatable2(SvgPath2))) {
  constructor() {
    super(...arguments);
    this.scalingCenterX = 0.5;
    this.scalingCenterY = 0.5;
    this.rotationCenterX = 0.5;
    this.rotationCenterY = 0.5;
  }
};
RadialGaugeNeedle.defaultPathData = "M0.50245 0.53745C0.481767 0.53745 0.465 0.520683 0.465 0.5C0.465 0.479317 0.481767 0.46255 0.50245 0.46255L1 0.500012L0.50245 0.53745Z";
var { BaseProperties: BaseProperties27, makeSeriesTooltip: makeSeriesTooltip21, SeriesProperties: SeriesProperties12, PropertiesArray: PropertiesArray8, AxisLabel: AxisLabel6, Property: Property81, Label: Label16 } = module_support_exports;
var RadialGaugeDefaultTargetLabelProperties = class extends Label16 {
};
__decorateClass2([
  Property81
], RadialGaugeDefaultTargetLabelProperties.prototype, "spacing", 2);
var RadialGaugeTargetProperties = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.label = new RadialGaugeDefaultTargetLabelProperties();
  }
};
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "text", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "value", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "shape", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "placement", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "spacing", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "size", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "rotation", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "fill", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "stroke", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property81
], RadialGaugeTargetProperties.prototype, "label", 2);
var RadialGaugeBarProperties = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.fills = new PropertiesArray8(module_support_exports.StopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "enabled", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "fills", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "fillMode", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "fill", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "stroke", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property81
], RadialGaugeBarProperties.prototype, "lineDashOffset", 2);
var RadialGaugeScaleIntervalProperties = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.values = void 0;
    this.step = void 0;
    this.minSpacing = 0;
    this.maxSpacing = 1e3;
  }
};
__decorateClass2([
  Property81
], RadialGaugeScaleIntervalProperties.prototype, "values", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleIntervalProperties.prototype, "step", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleIntervalProperties.prototype, "minSpacing", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleIntervalProperties.prototype, "maxSpacing", 2);
var RadialGaugeScaleLabelProperties = class extends AxisLabel6 {
};
var RadialGaugeScaleProperties = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.min = 0;
    this.max = 1;
    this.fills = new PropertiesArray8(module_support_exports.StopProperties);
    this.fillMode = "continuous";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.defaultFill = "black";
    this.interval = new RadialGaugeScaleIntervalProperties();
    this.label = new RadialGaugeScaleLabelProperties();
  }
};
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "min", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "max", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "fills", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "fillMode", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "fill", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "stroke", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "defaultFill", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "interval", 2);
__decorateClass2([
  Property81
], RadialGaugeScaleProperties.prototype, "label", 2);
var RadialGaugeNeedleProperties = class extends BaseProperties27 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.spacing = 0;
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "enabled", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "radiusRatio", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "spacing", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "fill", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "stroke", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property81
], RadialGaugeNeedleProperties.prototype, "lineDashOffset", 2);
var RadialGaugeLabelProperties = class extends AutoSizedLabel {
};
__decorateClass2([
  Property81
], RadialGaugeLabelProperties.prototype, "text", 2);
var RadialGaugeSecondaryLabelProperties = class extends AutoSizedSecondaryLabel {
};
__decorateClass2([
  Property81
], RadialGaugeSecondaryLabelProperties.prototype, "text", 2);
var RadialGaugeSeriesProperties = class extends SeriesProperties12 {
  constructor() {
    super(...arguments);
    this.startAngle = 0;
    this.endAngle = 0;
    this.segmentation = new GaugeSegmentationProperties();
    this.defaultColorRange = [];
    this.targets = new PropertiesArray8(RadialGaugeTargetProperties);
    this.defaultTarget = new RadialGaugeTargetProperties();
    this.outerRadiusRatio = 1;
    this.innerRadiusRatio = 1;
    this.cornerRadius = 0;
    this.cornerMode = "container";
    this.spacing = 0;
    this.scale = new RadialGaugeScaleProperties();
    this.bar = new RadialGaugeBarProperties();
    this.needle = new RadialGaugeNeedleProperties();
    this.label = new RadialGaugeLabelProperties();
    this.secondaryLabel = new RadialGaugeSecondaryLabelProperties();
    this.tooltip = makeSeriesTooltip21();
  }
};
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "value", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "startAngle", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "endAngle", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "segmentation", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "targets", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "defaultTarget", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "outerRadius", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "innerRadius", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "cornerMode", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "spacing", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "scale", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "bar", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "needle", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass2([
  Property81
], RadialGaugeSeriesProperties.prototype, "tooltip", 2);
var { SectorBox: SectorBox5 } = module_support_exports;
function computeClipSector(datum) {
  const { startAngle, endAngle, clipStartAngle, clipEndAngle, innerRadius, outerRadius } = datum;
  if (clipStartAngle == null || clipEndAngle == null)
    return;
  return new SectorBox5(
    Math.max(clipStartAngle, startAngle),
    Math.min(clipEndAngle, endAngle),
    innerRadius,
    outerRadius
  );
}
function clipSectorVisibility(startAngle, endAngle, clipSector) {
  return Math.max(startAngle, clipSector.startAngle) <= Math.min(endAngle, clipSector.endAngle);
}
function hasClipSector(datum) {
  return datum.clipStartAngle != null && datum.clipEndAngle != null;
}
function datumClipSector(datum, zero) {
  const { clipStartAngle, clipEndAngle, innerRadius, outerRadius } = datum;
  return new SectorBox5(clipStartAngle, zero ? clipStartAngle : clipEndAngle, innerRadius, outerRadius);
}
function prepareRadialGaugeSeriesAnimationFunctions(initialLoad, initialStartAngle) {
  const phase = initialLoad ? "initial" : "update";
  const node = {
    fromFn(sect, datum) {
      const previousDatum = sect.previousDatum;
      let { startAngle, endAngle } = previousDatum ?? datum;
      const previousClipSector = previousDatum != null && hasClipSector(previousDatum) ? datumClipSector(previousDatum, initialLoad) : void 0;
      const nextClipSector = hasClipSector(datum) ? datumClipSector(datum, initialLoad) : void 0;
      let clipSector;
      if (previousClipSector != null && nextClipSector != null) {
        clipSector = previousClipSector;
      } else if (previousClipSector == null && nextClipSector != null) {
        clipSector = nextClipSector;
        startAngle = datum.startAngle;
        endAngle = datum.endAngle;
      } else if (previousClipSector != null && nextClipSector == null) {
        clipSector = void 0;
        startAngle = datum.startAngle;
        endAngle = datum.endAngle;
      } else if (initialLoad) {
        endAngle = startAngle;
      }
      return { startAngle, endAngle, clipSector, phase };
    },
    toFn(_sect, datum) {
      const { startAngle, endAngle } = datum;
      let clipSector;
      if (hasClipSector(datum)) {
        clipSector = datumClipSector(datum, false);
      }
      return { startAngle, endAngle, clipSector };
    },
    applyFn(sect, params) {
      const { startAngle, endAngle } = params;
      let { clipSector } = params;
      if (clipSector != null) {
        clipSector = new SectorBox5(
          Math.max(startAngle, clipSector.startAngle),
          Math.min(endAngle, clipSector.endAngle),
          clipSector.innerRadius,
          clipSector.outerRadius
        );
      }
      const visible = clipSector == null || clipSectorVisibility(startAngle, endAngle, clipSector);
      sect.startAngle = startAngle;
      sect.endAngle = endAngle;
      sect.clipSector = clipSector;
      sect.visible = visible;
    }
  };
  const needle = {
    fromFn(needleNode) {
      let { angle: rotation } = needleNode.previousDatum ?? needleNode.datum;
      if (initialLoad) {
        rotation = initialStartAngle;
      }
      return { rotation, phase };
    },
    toFn(_needleNode, datum) {
      const { angle: rotation } = datum;
      return { rotation };
    }
  };
  return { node, needle };
}
function resetRadialGaugeSeriesResetSectorFunction(_node, datum) {
  const { startAngle, endAngle } = datum;
  const clipSector = computeClipSector(datum);
  const visible = clipSector == null || clipSectorVisibility(startAngle, endAngle, clipSector);
  return { startAngle, endAngle, clipSector, visible };
}
function resetRadialGaugeSeriesResetNeedleFunction(_node, datum) {
  const { angle: angle2 } = datum;
  return { rotation: angle2 };
}
var verticalAlignFactors3 = {
  top: 0,
  middle: 0.5,
  bottom: 1
};
function formatRadialGaugeLabels(series, ctx, selection, opts, innerRadius, datumOverrides) {
  const { padding: padding2, textAlign, verticalAlign } = opts;
  let labelDatum;
  let secondaryLabelDatum;
  selection.each((_node, datum) => {
    if (datum.label === "primary") {
      labelDatum = datum;
    } else if (datum.label === "secondary") {
      secondaryLabelDatum = datum;
    }
  });
  if (labelDatum == null)
    return;
  const labelText = getLabelText(series.id, ctx, labelDatum, datumOverrides?.label);
  if (labelText == null)
    return;
  const secondaryLabelText = secondaryLabelDatum != null ? getLabelText(series.id, ctx, secondaryLabelDatum, datumOverrides?.secondaryLabel) : void 0;
  const params = { padding: padding2 };
  const horizontalFactor = textAlign === "center" ? 2 : 1;
  const verticalFactor = verticalAlign === "middle" ? 2 : 1;
  const sizeFittingHeight = (height22) => ({
    width: Math.sqrt(Math.max(innerRadius ** 2 - (height22 / verticalFactor) ** 2, 0)) * horizontalFactor,
    height: Math.min(height22, verticalFactor * innerRadius),
    meta: null
  });
  let labelLayout;
  let secondaryLabelLayout;
  let height2;
  if (secondaryLabelDatum != null && secondaryLabelText != null) {
    const layout = formatStackedLabels(
      labelText,
      labelDatum,
      secondaryLabelText,
      secondaryLabelDatum,
      params,
      sizeFittingHeight
    );
    labelLayout = layout?.label;
    secondaryLabelLayout = layout?.secondaryLabel;
    height2 = layout?.height ?? 0;
  } else {
    const layout = formatSingleLabel(labelText, labelDatum, params, sizeFittingHeight);
    labelLayout = layout?.[0];
    secondaryLabelLayout = void 0;
    height2 = layout?.[0].height ?? 0;
  }
  const rectYOffset = height2 * verticalAlignFactors3[verticalAlign];
  selection.each((label, datum) => {
    let layout;
    if (datum.label === "primary") {
      layout = labelLayout;
    } else if (datum.label === "secondary") {
      layout = secondaryLabelLayout;
    }
    if (layout == null) {
      label.visible = false;
      return;
    }
    label.visible = true;
    label.text = layout.text;
    label.fontSize = layout.fontSize;
    label.lineHeight = layout.lineHeight;
    label.textAlign = textAlign;
    label.textBaseline = "middle";
    const rectOriginInLabelRect = datum.label === "primary" ? layout.height / 2 : height2 - layout.height / 2;
    label.y = datum.centerY + rectOriginInLabelRect - rectYOffset;
    label.x = datum.centerX;
  });
}
var {
  fromToMotion: fromToMotion5,
  resetMotion: resetMotion4,
  CachedTextMeasurerPool: CachedTextMeasurerPool12,
  SeriesNodePickMode: SeriesNodePickMode15,
  StateMachine: StateMachine15,
  createDatumId: createDatumId18,
  normalizeAngle360: normalizeAngle3606,
  normalizeAngle360Inclusive: normalizeAngle360Inclusive22,
  isBetweenAngles: isBetweenAngles22,
  sectorBox: sectorBox2,
  toDegrees: toDegrees2,
  toRadians: toRadians5,
  BBox: BBox24,
  Group: Group19,
  PointerEvents: PointerEvents12,
  Selection: Selection17,
  Sector: Sector6,
  SectorBox: SectorBox6,
  Text: Text9,
  Marker: Marker6,
  getColorStops: getColorStops22,
  tickFormat: tickFormat22,
  applyShapeStyle: applyShapeStyle17,
  mergeDefaults: mergeDefaults20
} = module_support_exports;
var targetPlacementRotation = {
  inside: 90,
  middle: 0,
  outside: -90
};
var outsideLabelPlacements = [
  { textAlign: "left", textBaseline: "top" },
  { textAlign: "right", textBaseline: "top" },
  { textAlign: "right", textBaseline: "bottom" },
  { textAlign: "left", textBaseline: "bottom" }
];
var insideLabelPlacements = [
  { textAlign: "right", textBaseline: "bottom" },
  { textAlign: "left", textBaseline: "bottom" },
  { textAlign: "left", textBaseline: "top" },
  { textAlign: "right", textBaseline: "top" }
];
var RadialGaugeSeries = class extends module_support_exports.Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode15.EXACT_SHAPE_MATCH, SeriesNodePickMode15.NEAREST_NODE]
    });
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.properties = new RadialGaugeSeriesProperties();
    this.scale = new LinearAngleScale();
    this.scaleGroup = this.contentGroup.appendChild(new Group19({ name: "scaleGroup" }));
    this.itemGroup = this.contentGroup.appendChild(new Group19({ name: "itemGroup" }));
    this.itemNeedleGroup = this.contentGroup.appendChild(new Group19({ name: "itemNeedleGroup" }));
    this.itemTargetGroup = this.contentGroup.appendChild(new Group19({ name: "itemTargetGroup" }));
    this.itemTargetLabelGroup = this.contentGroup.appendChild(new Group19({ name: "itemTargetLabelGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group19({ name: "itemLabelGroup" }));
    this.highlightTargetGroup = this.highlightGroup.appendChild(
      new Group19({ name: "itemTargetLabelGroup" })
    );
    this.tickGroup = this.contentGroup.appendChild(new Group19({ name: "tickGroup" }));
    this.scaleSelection = Selection17.select(
      this.scaleGroup,
      () => this.nodeFactory()
    );
    this.datumSelection = Selection17.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.needleSelection = Selection17.select(
      this.itemNeedleGroup,
      RadialGaugeNeedle
    );
    this.targetSelection = Selection17.select(
      this.itemTargetGroup,
      () => this.markerFactory()
    );
    this.targetLabelSelection = Selection17.select(this.itemTargetLabelGroup, Text9);
    this.labelSelection = Selection17.select(
      this.itemLabelGroup,
      Text9
    );
    this.highlightTargetSelection = Selection17.select(this.highlightTargetGroup, () => this.markerFactory());
    this.tickSelection = Selection17.select(this.tickGroup, module_support_exports.TransformableText);
    this.datumUnion = new DatumUnion();
    this.animationState = new StateMachine15("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.animateEmptyUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      ready: {
        updateData: "waiting",
        clear: "clearing",
        resize: () => this.animateReadyResize(),
        reset: "empty",
        skip: "ready"
      },
      waiting: {
        update: {
          target: "ready",
          action: () => this.animateWaitingUpdateReady()
        },
        reset: "empty",
        skip: "ready"
      },
      clearing: {
        update: {
          target: "empty"
        },
        reset: "empty",
        skip: "ready"
      }
    });
    this.scaleGroup.pointerEvents = PointerEvents12.None;
    this.tickGroup.pointerEvents = PointerEvents12.None;
    this.itemNeedleGroup.pointerEvents = PointerEvents12.None;
    this.itemLabelGroup.pointerEvents = PointerEvents12.None;
  }
  get hasData() {
    return this.properties.value != null;
  }
  nodeFactory() {
    return new Sector6();
  }
  markerFactory() {
    const marker = new Marker6();
    marker.size = 1;
    return marker;
  }
  processData() {
    this.nodeDataRefresh = true;
    this.animationState.transition("updateData");
  }
  formatLabel(value) {
    const { min, max } = this.properties.scale;
    return formatLabel(value, { min, max });
  }
  layoutScale() {
    const { scale: scale2, properties } = this;
    const { seriesRectWidth, seriesRectHeight } = this.nodeDataDependencies;
    const { scale: scaleProps, outerRadius } = this.properties;
    const { min, max, label, interval } = scaleProps;
    const startAngle = toRadians5(properties.startAngle - 90);
    const endAngle = toRadians5(properties.endAngle - 90);
    const sweepAngle = normalizeAngle360Inclusive22(endAngle - startAngle);
    const largerThanHalf = sweepAngle > Math.PI;
    const containsTop = largerThanHalf || isBetweenAngles22(1.5 * Math.PI, startAngle, endAngle);
    const containsRight = largerThanHalf || isBetweenAngles22(0 * Math.PI, startAngle, endAngle);
    const containsBottom = largerThanHalf || isBetweenAngles22(0.5 * Math.PI, startAngle, endAngle);
    const containsLeft = largerThanHalf || isBetweenAngles22(1 * Math.PI, startAngle, endAngle);
    let textAlign;
    if (containsLeft && !containsRight) {
      textAlign = "right";
    } else if (!containsLeft && containsRight) {
      textAlign = "left";
    } else {
      textAlign = "center";
    }
    let verticalAlign;
    if (containsTop && !containsBottom) {
      verticalAlign = "bottom";
    } else if (!containsTop && containsBottom) {
      verticalAlign = "top";
    } else {
      verticalAlign = "middle";
    }
    const unitBox = sectorBox2({
      startAngle,
      endAngle,
      innerRadius: 0,
      outerRadius: 0.5
    });
    const centerXOffset = -(unitBox.x + unitBox.width / 2) * 2;
    const centerYOffset = -(unitBox.y + unitBox.height / 2) * 2;
    const unitBoxSize = Math.min(seriesRectWidth / unitBox.width, seriesRectHeight / unitBox.height);
    scale2.domain = [min, max];
    scale2.range = [startAngle, endAngle];
    scale2.arcLength = unitBoxSize / 2;
    const { maxSpacing, minSpacing } = interval;
    const { arcLength } = scale2;
    const minTickCount = maxSpacing ? Math.floor(arcLength / maxSpacing) : 1;
    const maxTickCount = minSpacing ? Math.floor(arcLength / minSpacing) : Infinity;
    const preferredTickCount = Math.floor(4 / Math.PI * Math.abs(scale2.range[0] - scale2.range[1]));
    const tickCount = Math.max(minTickCount, Math.min(maxTickCount, preferredTickCount));
    const ticks = interval.values ?? scale2.ticks({
      nice: false,
      interval: interval.step,
      minTickCount,
      maxTickCount,
      tickCount
    })?.ticks ?? [];
    const tickFormatter = tickFormat22(ticks, typeof label.format === "string" ? label.format : void 0);
    const measurer22 = CachedTextMeasurerPool12.getMeasurer({ font: label });
    const tickData = ticks.map((value, index) => {
      let text2;
      if (label.formatter) {
        text2 = formatWithContext(this.ctx, label.formatter, {
          value,
          index,
          domain: scale2.domain,
          boundSeries: void 0
        });
      }
      text2 ?? (text2 = tickFormatter?.(value));
      if (text2 == null)
        return;
      const { width: width2, height: height2 } = measurer22.measureText(text2);
      return { index, value, text: text2, width: width2, height: height2 };
    }).filter((value) => value != null);
    const maxWidth = tickData.reduce((m, t) => Math.max(m, t.width), 0);
    const maxHeight = tickData.reduce((m, t) => Math.max(m, t.height), 0);
    const labelInset = label.enabled ? Math.max(maxWidth, maxHeight) + label.spacing : 0;
    const radiusBounds = Math.max(
      0.5 * unitBoxSize - labelInset,
      // seriesRect may have negative size
      0
    );
    const radius = outerRadius ?? radiusBounds;
    this.centerX = seriesRectWidth / 2 + centerXOffset * radius;
    this.centerY = seriesRectHeight / 2 + centerYOffset * radius;
    this.radius = radius;
    this.textAlign = textAlign;
    this.verticalAlign = verticalAlign;
    return tickData;
  }
  createConicGradient(fills, fillMode) {
    const { scale: scale2 } = this;
    const { domain, range: range22 } = scale2;
    const [startAngle, endAngle] = range22;
    const { defaultColorRange } = this.properties;
    const conicAngle = normalizeAngle3606((startAngle + endAngle) / 2 + Math.PI);
    const sweepAngle = normalizeAngle360Inclusive22(endAngle - startAngle);
    const colorStops = getColorStops22(fills, defaultColorRange, domain, fillMode).map(
      ({ color: color6, stop }) => {
        stop = Math.min(Math.max(stop, 0), 1);
        const angle2 = startAngle + sweepAngle * stop;
        stop = (angle2 - conicAngle) / (2 * Math.PI);
        stop = (stop % 1 + 1) % 1;
        return { stop, color: color6 };
      }
    );
    return {
      type: "gradient",
      gradient: "conic",
      colorSpace: "oklch",
      colorStops,
      rotation: toDegrees2(conicAngle) + 90
    };
  }
  getShapeFillBBox() {
    const { centerX, centerY, radius } = this;
    return new BBox24(centerX - radius, centerY - radius, 2 * radius, 2 * radius);
  }
  getTargets() {
    const { properties } = this;
    const defaultTarget = properties.defaultTarget;
    return Array.from(properties.targets).map((target) => {
      const {
        text: text2 = defaultTarget.text,
        value = defaultTarget.value ?? 0,
        shape = defaultTarget.shape ?? "triangle",
        rotation = defaultTarget.rotation ?? 0,
        strokeWidth = defaultTarget.strokeWidth ?? 0,
        placement = defaultTarget.placement ?? "middle",
        spacing = defaultTarget.spacing ?? 0,
        size = defaultTarget.size ?? 0,
        fill = defaultTarget.fill ?? "black",
        fillOpacity = defaultTarget.fillOpacity ?? 1,
        stroke: stroke22 = defaultTarget.stroke ?? "black",
        strokeOpacity = defaultTarget.strokeOpacity ?? 1,
        lineDash = defaultTarget.lineDash ?? [0],
        lineDashOffset = defaultTarget.lineDashOffset ?? 0
      } = target;
      const {
        enabled: labelEnabled = defaultTarget.label.enabled,
        color: labelColor = defaultTarget.label.color ?? "black",
        fontStyle: labelFontStyle = defaultTarget.label.fontStyle ?? "normal",
        fontWeight: labelFontWeight = defaultTarget.label.fontWeight ?? "normal",
        fontSize: labelFontSize = defaultTarget.label.fontSize,
        fontFamily: labelFontFamily = defaultTarget.label.fontFamily,
        spacing: labelSpacing = defaultTarget.label.spacing ?? 0
      } = target.label;
      return {
        text: text2,
        value,
        shape,
        placement,
        spacing,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        label: {
          enabled: labelEnabled,
          color: labelColor,
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          spacing: labelSpacing
        }
      };
    });
  }
  getTargetRadius(target) {
    const { radius, properties } = this;
    const { innerRadiusRatio, outerRadiusRatio } = properties;
    const { placement, spacing, size } = target;
    const outerRadius = radius * outerRadiusRatio;
    const innerRadius = radius * innerRadiusRatio;
    switch (placement) {
      case "inside":
        return Math.max(innerRadius - spacing - size / 2, 0);
      case "outside":
        return outerRadius + spacing + size / 2;
      default:
        return (innerRadius + outerRadius) / 2;
    }
  }
  getTargetLabel(target) {
    const { scale: scale2 } = this;
    const { value, size, placement, label } = target;
    const { spacing, color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    const lineHeight = void 0;
    const angle2 = scale2.convert(value);
    const quadrant = normalizeAngle3606(angle2) / (Math.PI / 2) | 0;
    const offset = size / 2 + spacing;
    let textAlign;
    let textBaseline;
    let offsetX;
    let offsetY;
    switch (placement) {
      case "outside":
        ({ textAlign, textBaseline } = outsideLabelPlacements[quadrant]);
        offsetX = offset * Math.cos(angle2);
        offsetY = offset * Math.sin(angle2);
        break;
      case "inside":
        ({ textAlign, textBaseline } = insideLabelPlacements[quadrant]);
        offsetX = -offset * Math.cos(angle2);
        offsetY = -offset * Math.sin(angle2);
        break;
      default:
        textAlign = "center";
        textBaseline = "bottom";
        offsetX = 0;
        offsetY = -offset;
        break;
    }
    return {
      offsetX,
      offsetY,
      fill,
      textAlign,
      textBaseline,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      lineHeight
    };
  }
  createNodeData() {
    const tickData = this.layoutScale();
    const { id: seriesId, scale: scale2, properties, radius, centerX, centerY } = this;
    const {
      value,
      innerRadiusRatio,
      outerRadiusRatio,
      segmentation,
      cornerRadius,
      cornerMode,
      needle,
      bar,
      scale: scaleProps,
      label,
      secondaryLabel
    } = properties;
    const { outerRadius = radius * outerRadiusRatio, innerRadius = radius * innerRadiusRatio } = properties;
    const targets = this.getTargets();
    const nodeData = [];
    const targetData = [];
    const needleData = [];
    const labelData = [];
    const scaleData = [];
    const cornersOnAllItems = cornerMode === "item";
    const containerStartAngle = scale2.convert(scale2.domain[0]);
    const containerEndAngle = scale2.convert(value);
    const maxTicks = Math.ceil(normalizeAngle360Inclusive22(containerEndAngle - containerStartAngle) * radius);
    let segments = segmentation.enabled ? segmentation.interval.getSegments(scale2, maxTicks) : void 0;
    const barFill = !bar.enabled ? "rgba(0,0,0,0)" : bar.fill ?? this.createConicGradient(bar.fills, bar.fillMode);
    const scaleFill = scaleProps.fill ?? (bar.enabled && scaleProps.fills.length === 0 ? scaleProps.defaultFill : void 0) ?? this.createConicGradient(scaleProps.fills, scaleProps.fillMode);
    if (segments == null && cornersOnAllItems) {
      const segmentStart = Math.min(...scale2.domain);
      const segmentEnd = Math.max(...scale2.domain);
      const datum = { value, segmentStart, segmentEnd };
      const appliedCornerRadius = Math.min(cornerRadius, (outerRadius - innerRadius) / 2);
      const angleInset = appliedCornerRadius / ((innerRadius + outerRadius) / 2);
      nodeData.push({
        series: this,
        itemId: `value`,
        datum,
        datumIndex: {
          type: 0
          /* Node */
        },
        type: 0,
        centerX,
        centerY,
        outerRadius,
        innerRadius,
        startAngle: containerStartAngle - angleInset,
        endAngle: containerEndAngle + angleInset,
        clipStartAngle: void 0,
        clipEndAngle: void 0,
        startCornerRadius: cornerRadius,
        endCornerRadius: cornerRadius,
        fill: barFill
      });
      scaleData.push({
        series: this,
        itemId: `scale`,
        datum,
        datumIndex: {
          type: 0
          /* Node */
        },
        type: 0,
        centerX,
        centerY,
        outerRadius,
        innerRadius,
        startAngle: scale2.range[0] - angleInset,
        endAngle: scale2.range[1] + angleInset,
        clipStartAngle: void 0,
        clipEndAngle: void 0,
        startCornerRadius: cornerRadius,
        endCornerRadius: cornerRadius,
        fill: scaleFill
      });
    } else {
      segments ?? (segments = scale2.domain);
      for (let i = 0; i < segments.length - 1; i++) {
        const segmentStart = segments[i];
        const segmentEnd = segments[i + 1];
        const datum = { value, segmentStart, segmentEnd };
        const isStart = i === 0;
        const isEnd = i === segments.length - 2;
        const itemStartAngle = scale2.convert(segmentStart);
        const itemEndAngle = scale2.convert(segmentEnd);
        nodeData.push({
          series: this,
          itemId: `value-${i}`,
          datum,
          datumIndex: {
            type: 0
            /* Node */
          },
          type: 0,
          centerX,
          centerY,
          outerRadius,
          innerRadius,
          startAngle: itemStartAngle,
          endAngle: itemEndAngle,
          clipStartAngle: containerStartAngle,
          clipEndAngle: containerEndAngle,
          startCornerRadius: cornersOnAllItems || isStart ? cornerRadius : 0,
          endCornerRadius: cornersOnAllItems || isEnd ? cornerRadius : 0,
          fill: barFill
        });
        scaleData.push({
          series: this,
          itemId: `scale-${i}`,
          datum,
          datumIndex: {
            type: 0
            /* Node */
          },
          type: 0,
          centerX,
          centerY,
          outerRadius,
          innerRadius,
          startAngle: itemStartAngle,
          endAngle: itemEndAngle,
          clipStartAngle: void 0,
          clipEndAngle: void 0,
          startCornerRadius: cornersOnAllItems || isStart ? cornerRadius : 0,
          endCornerRadius: cornersOnAllItems || isEnd ? cornerRadius : 0,
          fill: scaleFill
        });
      }
    }
    if (!needle.enabled && label.enabled) {
      const {
        text: text2,
        color: fill,
        fontSize,
        minimumFontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        formatter: formatter2 = (params) => this.formatLabel(params.value)
      } = label;
      labelData.push({
        label: "primary",
        centerX,
        centerY,
        text: text2,
        value,
        fill,
        fontSize,
        minimumFontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        formatter: formatter2
      });
    }
    if (!needle.enabled && secondaryLabel.enabled) {
      const {
        text: text2,
        color: fill,
        fontSize,
        minimumFontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        formatter: formatter2
      } = secondaryLabel;
      labelData.push({
        label: "secondary",
        centerX,
        centerY,
        text: text2,
        value,
        fill,
        fontSize,
        minimumFontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        lineHeight,
        formatter: formatter2
      });
    }
    if (needle.enabled) {
      let needleRadius = needle.radiusRatio != null ? radius * needle.radiusRatio : innerRadius;
      needleRadius = Math.max(needleRadius - needle.spacing, 0);
      const needleAngle = scale2.convert(value);
      needleData.push({
        centerX,
        centerY,
        radius: needleRadius,
        angle: needleAngle,
        series: this
      });
    }
    for (let i = 0; i < targets.length; i += 1) {
      const target = targets[i];
      const {
        value: targetValue,
        text: text2,
        size,
        shape,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset
      } = target;
      if (targetValue < Math.min(...scale2.domain) || targetValue > Math.max(...scale2.domain)) {
        continue;
      }
      const targetRadius = this.getTargetRadius(target);
      const targetAngle = scale2.convert(targetValue);
      const targetRotation = toRadians5(target.rotation + targetPlacementRotation[target.placement]);
      targetData.push({
        series: this,
        itemId: `target-${i}`,
        midPoint: {
          x: targetRadius * Math.cos(targetAngle) + centerX,
          y: targetRadius * Math.sin(targetAngle) + centerY
        },
        datum: { value: targetValue },
        datumIndex: { type: 1, index: i },
        type: 1,
        value: targetValue,
        text: text2,
        centerX,
        centerY,
        shape,
        radius: targetRadius,
        angle: targetAngle,
        rotation: targetRotation,
        size,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        label: this.getTargetLabel(target)
      });
    }
    return {
      itemId: seriesId,
      nodeData,
      needleData,
      targetData,
      labelData,
      scaleData,
      tickData
    };
  }
  updateSelections(resize) {
    if (this.nodeDataRefresh || resize) {
      this.contextNodeData = this.createNodeData();
      this.nodeDataRefresh = false;
    }
  }
  highlightDatum(node) {
    if (node != null && node.series === this && node.type === 1) {
      return node;
    }
  }
  update({ seriesRect }) {
    const {
      datumSelection,
      labelSelection,
      needleSelection,
      targetSelection,
      targetLabelSelection,
      scaleSelection,
      highlightTargetSelection,
      tickSelection
    } = this;
    const resize = this.checkResize(seriesRect);
    this.updateSelections(resize);
    this.contentGroup.visible = this.visible;
    this.contentGroup.opacity = this.getOpacity();
    const nodeData = this.contextNodeData?.nodeData ?? [];
    const labelData = this.contextNodeData?.labelData ?? [];
    const needleData = this.contextNodeData?.needleData ?? [];
    const targetData = this.contextNodeData?.targetData ?? [];
    const scaleData = this.contextNodeData?.scaleData ?? [];
    const tickData = this.contextNodeData?.tickData ?? [];
    const highlightTargetDatum = this.highlightDatum(this.ctx.highlightManager.getActiveHighlight());
    this.scaleSelection = this.updateScaleSelection({ scaleData, scaleSelection });
    this.updateScaleNodes({ scaleSelection });
    this.needleSelection = this.updateNeedleSelection({ needleData, needleSelection });
    this.updateNeedleNodes({ needleSelection });
    this.targetSelection = this.updateTargetSelection({ targetData, targetSelection });
    this.updateTargetNodes({ targetSelection, isHighlight: false });
    this.targetLabelSelection = this.updateTargetLabelSelection({ targetData, targetLabelSelection });
    this.updateTargetLabelNodes({ targetLabelSelection });
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.updateDatumNodes({ datumSelection });
    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection });
    this.updateLabelNodes({ labelSelection });
    this.highlightTargetSelection = this.updateTargetSelection({
      targetData: highlightTargetDatum != null ? [highlightTargetDatum] : [],
      targetSelection: highlightTargetSelection
    });
    this.updateTargetNodes({ targetSelection: highlightTargetSelection, isHighlight: true });
    this.tickSelection = this.updateTickSelection({ tickData, tickSelection });
    this.updateTickNodes({ tickSelection });
    if (resize) {
      this.animationState.transition("resize");
    }
    this.animationState.transition("update");
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => {
      return createDatumId18(opts.nodeData.length, datum.itemId);
    });
  }
  updateDatumNodes(opts) {
    const { datumSelection } = opts;
    const { ctx, properties } = this;
    const { bar, segmentation } = properties;
    const sectorSpacing = segmentation.spacing ?? 0;
    const { fillOpacity, stroke: stroke22, strokeOpacity, lineDash, lineDashOffset } = bar;
    const strokeWidth = bar.strokeWidth;
    const animationDisabled = ctx.animationManager.isSkipped();
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((sector, datum) => {
      const { centerX, centerY, innerRadius, outerRadius, startCornerRadius, endCornerRadius, fill } = datum;
      sector.centerX = centerX;
      sector.centerY = centerY;
      sector.innerRadius = innerRadius;
      sector.outerRadius = outerRadius;
      sector.pointerEvents = this.properties.bar.enabled ? module_support_exports.PointerEvents.All : module_support_exports.PointerEvents.None;
      sector.fill = fill;
      sector.fillBBox = fillBBox;
      sector.fillOpacity = fillOpacity;
      sector.stroke = stroke22;
      sector.strokeOpacity = strokeOpacity;
      sector.strokeWidth = strokeWidth;
      sector.lineDash = lineDash;
      sector.lineDashOffset = lineDashOffset;
      sector.startOuterCornerRadius = startCornerRadius;
      sector.startInnerCornerRadius = startCornerRadius;
      sector.endOuterCornerRadius = endCornerRadius;
      sector.endInnerCornerRadius = endCornerRadius;
      sector.radialEdgeInset = (sectorSpacing + sector.strokeWidth) / 2;
      sector.concentricEdgeInset = sector.strokeWidth / 2;
      if (animationDisabled || sector.previousDatum == null) {
        sector.setProperties(resetRadialGaugeSeriesResetSectorFunction(sector, datum));
      }
    });
    this.datumUnion.update(datumSelection, this.itemGroup, module_support_exports.Sector, (node, first2, last) => {
      node.clipSector ?? (node.clipSector = new SectorBox6(NaN, NaN, NaN, NaN));
      node.centerX = first2.centerX;
      node.centerY = first2.centerY;
      node.outerRadius = node.clipSector.outerRadius = first2.outerRadius;
      node.innerRadius = node.clipSector.innerRadius = first2.innerRadius;
      node.startAngle = node.clipSector.startAngle = first2.startAngle;
      node.startInnerCornerRadius = first2.startInnerCornerRadius;
      node.startOuterCornerRadius = first2.startOuterCornerRadius;
      node.endAngle = last.endAngle;
      node.clipSector.endAngle = last.clipSector?.endAngle ?? last.endAngle;
      node.endInnerCornerRadius = last.endInnerCornerRadius;
      node.endOuterCornerRadius = last.endOuterCornerRadius;
      node.pointerEvents = module_support_exports.PointerEvents.None;
    });
  }
  updateScaleSelection(opts) {
    return opts.scaleSelection.update(opts.scaleData, void 0, (datum) => {
      return createDatumId18(opts.scaleData.length, datum.itemId);
    });
  }
  updateScaleNodes(opts) {
    const { scaleSelection } = opts;
    const { scale: scale2, segmentation } = this.properties;
    const sectorSpacing = segmentation.spacing ?? 0;
    const { fillOpacity, stroke: stroke22, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = scale2;
    const fillBBox = this.getShapeFillBBox();
    scaleSelection.each((sector, datum) => {
      const { centerX, centerY, innerRadius, outerRadius, startCornerRadius, endCornerRadius, fill } = datum;
      sector.centerX = centerX;
      sector.centerY = centerY;
      sector.innerRadius = innerRadius;
      sector.outerRadius = outerRadius;
      sector.fill = fill;
      sector.fillBBox = fillBBox;
      sector.fillOpacity = fillOpacity;
      sector.stroke = stroke22;
      sector.strokeOpacity = strokeOpacity;
      sector.strokeWidth = strokeWidth;
      sector.lineDash = lineDash;
      sector.lineDashOffset = lineDashOffset;
      sector.startOuterCornerRadius = startCornerRadius;
      sector.startInnerCornerRadius = startCornerRadius;
      sector.endOuterCornerRadius = endCornerRadius;
      sector.endInnerCornerRadius = endCornerRadius;
      sector.radialEdgeInset = (sectorSpacing + sector.strokeWidth) / 2;
      sector.concentricEdgeInset = sector.strokeWidth / 2;
      sector.setProperties(resetRadialGaugeSeriesResetSectorFunction(sector, datum));
    });
  }
  updateNeedleSelection(opts) {
    return opts.needleSelection.update(opts.needleData, void 0, () => createDatumId18([]));
  }
  updateNeedleNodes(opts) {
    const { needleSelection } = opts;
    const { fill, fillOpacity, stroke: stroke22, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties.needle;
    const animationDisabled = this.ctx.animationManager.isSkipped();
    needleSelection.each((needle, datum) => {
      const { centerX, centerY, radius } = datum;
      const scale2 = radius * 2;
      needle.d = RadialGaugeNeedle.defaultPathData;
      needle.fill = fill;
      needle.fillOpacity = fillOpacity;
      needle.stroke = stroke22;
      needle.strokeOpacity = strokeOpacity;
      needle.strokeWidth = strokeWidth / scale2;
      needle.lineDash = lineDash.map((d) => d / scale2);
      needle.lineDashOffset = lineDashOffset / scale2;
      needle.translationX = centerX;
      needle.translationY = centerY;
      needle.scalingX = scale2;
      needle.scalingY = scale2;
      if (animationDisabled) {
        needle.setProperties(resetRadialGaugeSeriesResetNeedleFunction(needle, datum));
      }
    });
  }
  updateTargetSelection(opts) {
    return opts.targetSelection.update(opts.targetData, void 0, (target) => target.itemId);
  }
  updateTargetNodes(opts) {
    const { targetSelection, isHighlight } = opts;
    targetSelection.each((target, datum) => {
      const {
        centerX,
        centerY,
        angle: angle2,
        radius,
        shape,
        size,
        rotation,
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      } = datum;
      const highlightStyle = this.getHighlightStyle(isHighlight, datum.datumIndex);
      const style2 = mergeDefaults20(highlightStyle, {
        fill,
        fillOpacity,
        stroke: stroke22,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset,
        opacity: 1
      });
      applyShapeStyle17(target, style2);
      target.size = size;
      target.shape = shape === "line" ? lineMarker : shape;
      target.translationX = centerX + radius * Math.cos(angle2);
      target.translationY = centerY + radius * Math.sin(angle2);
      target.rotation = angle2 + rotation;
    });
  }
  updateTargetLabelSelection(opts) {
    return opts.targetLabelSelection.update(opts.targetData, void 0, (target) => target.itemId);
  }
  updateTargetLabelNodes(opts) {
    const { targetLabelSelection } = opts;
    targetLabelSelection.each((label, target) => {
      const { centerX, centerY, radius, angle: angle2, text: text2 } = target;
      const { offsetX, offsetY, fill, fontStyle, fontWeight, fontSize, fontFamily, textAlign, textBaseline } = target.label;
      if (text2 == null) {
        label.visible = false;
        return;
      }
      label.visible = true;
      label.x = centerX + radius * Math.cos(angle2) + offsetX;
      label.y = centerY + radius * Math.sin(angle2) + offsetY;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = textAlign;
      label.textBaseline = textBaseline;
    });
  }
  updateLabelSelection(opts) {
    return opts.labelSelection.update(opts.labelData, void 0, (datum) => datum.label);
  }
  updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const animationDisabled = this.ctx.animationManager.isSkipped();
    labelSelection.each((label, datum) => {
      label.fill = datum.fill;
      label.fontStyle = datum.fontStyle;
      label.fontWeight = datum.fontWeight;
      label.fontFamily = datum.fontFamily;
    });
    if (animationDisabled || this.labelsHaveExplicitText()) {
      this.formatLabelText();
    }
  }
  updateTickSelection(opts) {
    return opts.tickSelection.update(opts.tickData, void 0, (datum) => datum.index);
  }
  updateTickNodes(opts) {
    const { scale: scale2, radius, centerX, centerY, properties } = this;
    const { enabled, color: color6, fontFamily, fontSize, fontStyle, fontWeight, spacing } = properties.scale.label;
    const rotation = toRadians5(properties.scale.label.rotation ?? 0);
    opts.tickSelection.each((label, datum) => {
      if (!enabled) {
        label.visible = false;
        return;
      }
      label.visible = true;
      label.text = datum.text;
      label.fill = color6;
      label.fontFamily = fontFamily;
      label.fontSize = fontSize;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.textAlign = "center";
      label.textBaseline = "middle";
      const angle2 = scale2.convert(datum.value);
      const { width: width2, height: height2 } = datum;
      const originX = Math.abs(radius * Math.cos(angle2));
      const originY = Math.abs(radius * Math.sin(angle2));
      const x0 = Math.min(Math.max(Math.abs(radius / Math.tan(angle2)), originX - width2 / 2), originX + width2 / 2);
      const y0 = Math.min(
        Math.max(Math.abs(radius * Math.tan(angle2)), originY - height2 / 2),
        originY + height2 / 2
      );
      const outerR = Math.hypot(x0, y0);
      const x = centerX + (outerR + spacing) * Math.cos(angle2);
      const y = centerY + (outerR + spacing) * Math.sin(angle2);
      label.x = x;
      label.y = y;
      label.rotationCenterX = x;
      label.rotationCenterY = y;
      label.rotation = rotation;
    });
  }
  labelsHaveExplicitText() {
    for (const { datum } of this.labelSelection) {
      if (datum.text == null) {
        return false;
      }
    }
    return true;
  }
  formatLabelText(datum) {
    const { labelSelection, radius, textAlign, verticalAlign } = this;
    const { spacing: padding2, innerRadiusRatio } = this.properties;
    formatRadialGaugeLabels(
      this,
      this.ctx,
      labelSelection,
      { padding: padding2, textAlign, verticalAlign },
      radius * innerRadiusRatio,
      datum
    );
  }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    resetMotion4([this.datumSelection], resetRadialGaugeSeriesResetSectorFunction);
    resetMotion4([this.needleSelection], resetRadialGaugeSeriesResetNeedleFunction);
    this.formatLabelText();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  animateLabelText(params = {}) {
    const { animationManager } = this.ctx;
    let labelFrom;
    let labelTo;
    let secondaryLabelFrom;
    let secondaryLabelTo;
    this.labelSelection.each((label, datum) => {
      label.opacity = 1;
      if (datum.label === "primary") {
        labelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
        labelTo = datum.value;
      } else if (datum.label === "secondary") {
        secondaryLabelFrom = label.previousDatum?.value ?? params.from ?? datum.value;
        secondaryLabelTo = datum.value;
      }
    });
    if (this.labelsHaveExplicitText()) {
    } else if (labelTo == null || secondaryLabelTo == null) {
      this.formatLabelText();
    } else if (labelFrom === labelTo && secondaryLabelFrom === secondaryLabelTo) {
      this.formatLabelText({ label: labelTo, secondaryLabel: secondaryLabelTo });
    } else {
      const animationId = `${this.id}_labels`;
      animationManager.animate({
        id: animationId,
        groupId: "label",
        from: { label: labelFrom, secondaryLabel: secondaryLabelFrom },
        to: { label: labelTo, secondaryLabel: secondaryLabelTo },
        phase: params.phase ?? "update",
        onUpdate: (datum) => this.formatLabelText(datum),
        onStop: () => this.formatLabelText({ label: labelTo, secondaryLabel: secondaryLabelTo })
      });
    }
  }
  animateEmptyUpdateReady() {
    const { animationManager } = this.ctx;
    const { node, needle } = prepareRadialGaugeSeriesAnimationFunctions(true, this.scale.range[0]);
    fromToMotion5(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
    fromToMotion5(this.id, "needle", animationManager, [this.needleSelection], needle, () => "needle");
    fromToMotion5(
      this.id,
      "label",
      animationManager,
      [this.labelSelection],
      fadeInFns,
      (_label, datum) => datum.label
    );
    this.animateLabelText({
      from: this.properties.scale.min,
      phase: "initial"
    });
  }
  animateWaitingUpdateReady() {
    const { animationManager } = this.ctx;
    const { node, needle } = prepareRadialGaugeSeriesAnimationFunctions(false, this.scale.range[0]);
    fromToMotion5(this.id, "node", animationManager, [this.datumSelection], node, (_sector, datum) => datum.itemId);
    fromToMotion5(this.id, "needle", animationManager, [this.needleSelection], needle, () => "needle");
    this.animateLabelText();
  }
  animateReadyResize() {
    this.resetAllAnimation();
  }
  dataCount() {
    return NaN;
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, properties } = this;
    const { tooltip } = properties;
    let value;
    let text2;
    if (datumIndex.type === 0) {
      value = properties.value;
      text2 = properties.label.text;
    } else {
      ({ value, text: text2 } = properties.targets[datumIndex.index]);
    }
    if (value == null)
      return;
    return this.formatTooltipWithContext(
      tooltip,
      {
        data: [{ label: text2, fallbackLabel: "Value", value: this.formatLabel(value) }]
      },
      { seriesId, title: void 0, datum: void 0, value }
    );
  }
  pickNodeClosestDatum(point) {
    return pickGaugeNearestDatum(this, point);
  }
  pickFocus(opts) {
    return pickGaugeFocus(this, opts);
  }
  getCaptionText() {
    const { value } = this.properties;
    const description = [];
    description.push(this.formatLabel(value));
    this.labelSelection.each((_label, datum) => {
      const text2 = getLabelText(this.id, this.ctx, datum);
      if (text2 != null) {
        description.push(text2);
      }
    });
    return description.join(". ");
  }
  getCategoryValue(_datumIndex) {
    return;
  }
  datumIndexForCategoryValue(_categoryValue) {
    return;
  }
  hasItemStylers() {
    return false;
  }
};
RadialGaugeSeries.className = "RadialGaugeSeries";
RadialGaugeSeries.type = "radial-gauge";
var { FONT_SIZE_RATIO: FONT_SIZE_RATIO22 } = module_support_exports;
var RadialGaugeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  identifier: "radial-gauge",
  moduleFactory: (ctx) => new RadialGaugeSeries(ctx),
  themeTemplate: {
    minWidth: 200,
    minHeight: 200,
    tooltip: {
      enabled: false
    },
    series: {
      outerRadiusRatio: 1,
      innerRadiusRatio: 0.8,
      startAngle: 270,
      endAngle: 270 + 180,
      defaultColorRange: {
        $if: [
          { $eq: [{ $palette: "type" }, "inbuilt"] },
          { $interpolate: [{ $palette: "secondDivergingColors" }, 5] },
          module_support_exports.SAFE_RANGE2_OPERATION
        ]
      },
      scale: {
        // @ts-expect-error undocumented option
        defaultFill: { $path: ["/1", { $palette: "fill" }, { $palette: "hierarchyColors" }] },
        // TODO: mix backgroundColor and foregroundColor?
        stroke: { $path: ["/2", module_support_exports.SAFE_STROKE_FILL_OPERATION, { $palette: "hierarchyColors" }] },
        // TODO: mix backgroundColor and foregroundColor?
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] },
        label: {
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $ref: "fontSize" },
          fontFamily: { $ref: "fontFamily" },
          color: { $ref: "textColor" },
          spacing: 12
        }
      },
      bar: {
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] }
      },
      segmentation: {
        enabled: false,
        interval: {},
        spacing: 2
      },
      defaultTarget: {
        fill: { $ref: "foregroundColor" },
        stroke: { $ref: "foregroundColor" },
        size: 10,
        shape: "triangle",
        placement: "outside",
        spacing: 5,
        label: {
          enabled: true,
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $ref: "fontSize" },
          fontFamily: { $ref: "fontFamily" },
          color: { $ref: "textColor" },
          spacing: 5
        }
      },
      needle: {
        enabled: false,
        fill: { $ref: "foregroundColor" },
        spacing: 10
      },
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        enabled: true,
        fontWeight: { $ref: "fontWeight" },
        fontSize: 56,
        minimumFontSize: 18 / 56,
        fontFamily: { $ref: "fontFamily" },
        color: { $ref: "textColor" }
      },
      secondaryLabel: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        enabled: true,
        fontWeight: { $ref: "fontWeight" },
        fontSize: { $rem: FONT_SIZE_RATIO22.LARGE },
        minimumFontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        color: { $ref: "subtleTextColor" }
      },
      tooltip: {
        range: { $path: ["/tooltip/range", 10] }
      }
    }
  }
};
var RadialGaugeSeriesModule = {
  type: "series",
  name: "radial-gauge",
  chartType: "standalone",
  enterprise: true,
  options: module_support_exports.radialGaugeSeriesOptionsDef,
  create: (ctx) => new RadialGaugeSeries(ctx)
};
function sortNodesByY(column) {
  column.nodes.sort((a, b) => Math.round((a.datum.y - b.datum.y) * 100) / 100 || -(a.datum.size - b.datum.size));
}
function justifyNodesAcrossColumn({ nodes, size }, { seriesRectHeight, nodeSpacing, sizeScale }) {
  const nodesHeight = seriesRectHeight * size * sizeScale;
  let y = (seriesRectHeight - (nodesHeight + nodeSpacing * (nodes.length - 1))) / 2;
  nodes.forEach(({ datum: node }) => {
    const height2 = seriesRectHeight * node.size * sizeScale;
    node.y = y;
    node.height = height2;
    y += height2 + nodeSpacing;
  });
}
function separateNodesInColumn(column, layout) {
  const { nodes } = column;
  const { seriesRectHeight, nodeSpacing } = layout;
  sortNodesByY(column);
  let totalShift = 0;
  let currentTop = 0;
  for (const { datum: node } of nodes) {
    const shift = Math.max(currentTop - node.y, 0);
    node.y += shift;
    totalShift += shift;
    currentTop = node.y + node.height + nodeSpacing;
  }
  const lastNodeBottom = currentTop - nodeSpacing;
  if (lastNodeBottom < seriesRectHeight) {
    return totalShift > 0;
  }
  let currentBottom = seriesRectHeight;
  for (let i = nodes.length - 1; i >= 0; i -= 1) {
    const { datum: node } = nodes[i];
    const nodeBottom = node.y + node.height;
    const shift = Math.min(currentBottom - nodeBottom, 0);
    node.y += shift;
    totalShift += shift;
    currentBottom = node.y - nodeSpacing;
  }
  return true;
}
function hasCrossOver(x00, y00, x01, y01, x10, y10, x11, y11) {
  const recM0 = (x01 - x00) / (y01 - y00);
  const recM1 = (x11 - x10) / (y11 - y10);
  const x = ((y10 - y00) * (recM0 * recM1) + x00 * recM1 - x10 * recM0) / (recM1 - recM0);
  if (x00 < x01) {
    return x > x00 && x < Math.min(x01, x11);
  } else {
    return x < x00 && x > Math.max(x01, x11);
  }
}
function removeColumnCrossoversInDirection(column, getLinks) {
  let didShift = false;
  const singleCrossoverColumns = column.nodes.filter((node) => getLinks(node).length === 1);
  let didRemoveCrossover = true;
  for (let runs = 0; didRemoveCrossover && runs < singleCrossoverColumns.length; runs += 1) {
    didRemoveCrossover = false;
    for (let i = 0; i < singleCrossoverColumns.length - 1; i += 1) {
      const { datum: node } = singleCrossoverColumns[i];
      const nodeAfter = getLinks(singleCrossoverColumns[i])[0].node.datum;
      const { datum: otherNode } = singleCrossoverColumns[i + 1];
      const otherNodeAfter = getLinks(singleCrossoverColumns[i + 1])[0].node.datum;
      const crossover = hasCrossOver(
        node.x,
        node.y,
        nodeAfter.x,
        nodeAfter.y,
        otherNode.x,
        otherNode.y,
        otherNodeAfter.x,
        otherNodeAfter.y
      ) || hasCrossOver(
        node.x,
        node.y + node.height / 2,
        nodeAfter.x,
        nodeAfter.y + nodeAfter.height / 2,
        otherNode.x,
        otherNode.y + otherNode.height / 2,
        otherNodeAfter.x,
        otherNodeAfter.y + otherNodeAfter.height / 2
      ) || hasCrossOver(
        node.x,
        node.y + node.height,
        nodeAfter.x,
        nodeAfter.y + nodeAfter.height,
        otherNode.x,
        otherNode.y + otherNode.height,
        otherNodeAfter.x,
        otherNodeAfter.y + otherNodeAfter.height
      );
      if (!crossover)
        continue;
      const current = singleCrossoverColumns[i];
      singleCrossoverColumns[i] = singleCrossoverColumns[i + 1];
      singleCrossoverColumns[i + 1] = current;
      const y = node.y;
      node.y = otherNode.y + otherNode.height - node.height;
      otherNode.y = y;
      didShift = true;
      didRemoveCrossover = true;
    }
  }
  return didShift;
}
function removeColumnCrossovers(column) {
  let didShift = false;
  sortNodesByY(column);
  didShift = removeColumnCrossoversInDirection(column, (node) => node.linksBefore) || didShift;
  didShift = removeColumnCrossoversInDirection(column, (node) => node.linksAfter) || didShift;
  return didShift;
}
function weightedNodeY(links) {
  if (links.length === 0)
    return;
  let totalYValues = 0;
  let totalSize = 0;
  for (const {
    node: { datum: node }
  } of links) {
    totalYValues += node.y * node.size;
    totalSize += node.size;
  }
  return totalYValues / totalSize;
}
function layoutColumn(column, layout, weight, direction) {
  column.nodes.forEach(({ datum: node, linksBefore, linksAfter }) => {
    const forwardLinks = direction === 1 ? linksBefore : linksAfter;
    const backwardsLinks = direction === 1 ? linksAfter : linksBefore;
    const nextY = weightedNodeY(forwardLinks);
    if (nextY != null) {
      const nodeWeight = backwardsLinks.length !== 0 ? weight : 1;
      node.y = node.y + (nextY - node.y) * nodeWeight;
    }
  });
  return separateNodesInColumn(column, layout);
}
function layoutColumnsForward(columns, layout, weight) {
  let didShift = false;
  for (const column of columns) {
    didShift = layoutColumn(column, layout, weight, 1) || didShift;
  }
  return didShift;
}
function layoutColumnsBackwards(columns, layout, weight) {
  let didShift = false;
  for (let i = columns.length - 1; i >= 0; i -= 1) {
    didShift = layoutColumn(columns[i], layout, weight, -1) || didShift;
  }
  return didShift;
}
function removeColumnsCrossovers(columns) {
  let didShift = false;
  for (let i = columns.length - 1; i >= 0; i -= 1) {
    didShift = removeColumnCrossovers(columns[i]) || didShift;
  }
  return didShift;
}
function layoutColumns(columns, layout) {
  columns.forEach((column) => {
    justifyNodesAcrossColumn(column, layout);
  });
  let didLayoutColumnsBackwards = false;
  for (let i = 0; i < 6; i += 1) {
    const didLayoutColumnsForward = layoutColumnsForward(columns, layout, 1);
    didLayoutColumnsBackwards = layoutColumnsBackwards(columns, layout, 0.5);
    const didRemoveColumnCrossovers = removeColumnsCrossovers(columns);
    if (!didLayoutColumnsForward && !didLayoutColumnsBackwards && !didRemoveColumnCrossovers) {
      break;
    }
  }
  if (didLayoutColumnsBackwards) {
    layoutColumnsForward(columns, layout, 1);
    removeColumnsCrossovers(columns);
  }
}
var { BBox: BBox25, Path: Path13, SceneChangeDetection: SceneChangeDetection9, splitBezier2D: splitBezier2D2 } = module_support_exports;
function offsetTrivialCubicBezier(path, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, offset) {
  let tx, ty;
  if (p1y !== p0y && p3y !== p2y) {
    const slope1 = -(p1x - p0x) / (p1y - p0y);
    const slope2 = -(p3x - p2x) / (p3y - p2y);
    tx = (p2y - p0y + slope1 * p0x - slope2 * p2x) / (slope1 - slope2);
    ty = slope1 * (tx - p0x) + p0y;
  } else if (p1y === p0y && p3y !== p2y) {
    tx = p0x;
    const slope2 = -(p3x - p2x) / (p3y - p2y);
    ty = slope2 * (tx - p3x) + p3y;
  } else if (p1y !== p0y && p3y === p2y) {
    tx = p3x;
    const slope1 = -(p1x - p0x) / (p1y - p0y);
    ty = slope1 * (tx - p0x) + p0y;
  } else {
    throw new Error("Offsetting flat bezier curve");
  }
  const d0 = Math.hypot(p0y - ty, p0x - tx);
  const s0 = (d0 + offset) / d0;
  const d1 = Math.hypot(p3y - ty, p3x - tx);
  const s1 = (d1 + offset) / d1;
  const q1x = tx + (p1x - tx) * s0;
  const q1y = ty + (p1y - ty) * s0;
  const q2x = tx + (p2x - tx) * s1;
  const q2y = ty + (p2y - ty) * s1;
  const q3x = tx + (p3x - tx) * s1;
  const q3y = ty + (p3y - ty) * s1;
  path.cubicCurveTo(q1x, q1y, q2x, q2y, q3x, q3y);
}
var SankeyLink = class extends Path13 {
  constructor() {
    super(...arguments);
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.height = 0;
    this.inset = 0;
  }
  computeBBox() {
    const x = Math.min(this.x1, this.x2);
    const width2 = Math.max(this.x1, this.x2) - x;
    const y = Math.min(this.y1, this.y2);
    const height2 = Math.max(this.y1, this.y2) - y + this.height;
    return new BBox25(x, y, width2, height2);
  }
  updatePath() {
    const { path, inset } = this;
    path.clear();
    const x1 = this.x1 + inset;
    const x2 = this.x2 - inset;
    const y1 = this.y1 + inset;
    const y2 = this.y2 + inset;
    const height2 = this.height - 2 * inset;
    if (height2 < 0 || x1 > x2)
      return;
    const p0x = x1;
    const p0y = y1 + height2 / 2;
    const p1x = (x1 + x2) / 2;
    const p1y = y1 + height2 / 2;
    const p2x = (x1 + x2) / 2;
    const p2y = y2 + height2 / 2;
    const p3x = x2;
    const p3y = y2 + height2 / 2;
    path.moveTo(p0x, p0y - height2 / 2);
    if (Math.abs(this.y2 - this.y1) < 1 || this.x2 - this.x1 < this.height * Math.SQRT2) {
      path.cubicCurveTo(p1x, p1y - height2 / 2, p2x, p2y - height2 / 2, p3x, p3y - height2 / 2);
      path.lineTo(p3x, p3y + height2 / 2);
      path.cubicCurveTo(p2x, p2y + height2 / 2, p1x, p1y + height2 / 2, p0x, p0y + height2 / 2);
    } else {
      const [a, b] = splitBezier2D2(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, 0.5);
      const offset = (y2 > y1 ? 1 : -1) * height2 / 2;
      offsetTrivialCubicBezier(path, a[0].x, a[0].y, a[1].x, a[1].y, a[2].x, a[2].y, a[3].x, a[3].y, offset);
      offsetTrivialCubicBezier(path, b[0].x, b[0].y, b[1].x, b[1].y, b[2].x, b[2].y, b[3].x, b[3].y, -offset);
      path.lineTo(p3x, p3y + height2 / 2);
      offsetTrivialCubicBezier(path, b[3].x, b[3].y, b[2].x, b[2].y, b[1].x, b[1].y, b[0].x, b[0].y, offset);
      offsetTrivialCubicBezier(path, a[3].x, a[3].y, a[2].x, a[2].y, a[1].x, a[1].y, a[0].x, a[0].y, -offset);
    }
    path.closePath();
  }
};
__decorateClass2([
  SceneChangeDetection9()
], SankeyLink.prototype, "x1", 2);
__decorateClass2([
  SceneChangeDetection9()
], SankeyLink.prototype, "x2", 2);
__decorateClass2([
  SceneChangeDetection9()
], SankeyLink.prototype, "y1", 2);
__decorateClass2([
  SceneChangeDetection9()
], SankeyLink.prototype, "y2", 2);
__decorateClass2([
  SceneChangeDetection9()
], SankeyLink.prototype, "height", 2);
__decorateClass2([
  SceneChangeDetection9()
], SankeyLink.prototype, "inset", 2);
var {
  BaseProperties: BaseProperties28,
  FillGradientDefaults: FillGradientDefaults17,
  FillPatternDefaults: FillPatternDefaults17,
  FillImageDefaults: FillImageDefaults17,
  makeSeriesTooltip: makeSeriesTooltip222,
  SeriesProperties: SeriesProperties13,
  Property: Property82,
  Label: Label17
} = module_support_exports;
var SankeySeriesLabelProperties = class extends Label17 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
  }
};
__decorateClass2([
  Property82
], SankeySeriesLabelProperties.prototype, "spacing", 2);
var SankeySeriesLinkProperties = class extends BaseProperties28 {
  constructor() {
    super(...arguments);
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "fill", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "stroke", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property82
], SankeySeriesLinkProperties.prototype, "itemStyler", 2);
var SankeySeriesNodeProperties = class extends BaseProperties28 {
  constructor() {
    super(...arguments);
    this.spacing = 1;
    this.width = 1;
    this.alignment = "justify";
    this.fill = void 0;
    this.fillOpacity = 1;
    this.stroke = void 0;
    this.strokeOpacity = 1;
    this.strokeWidth = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "spacing", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "width", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "alignment", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "fill", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "stroke", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "lineDash", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Property82
], SankeySeriesNodeProperties.prototype, "itemStyler", 2);
var SankeySeriesProperties = class extends SeriesProperties13 {
  constructor() {
    super();
    this.nodes = void 0;
    this.idKey = "";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.sizeKey = void 0;
    this.sizeName = void 0;
    this.fillGradientDefaults = new FillGradientDefaults17();
    this.fillPatternDefaults = new FillPatternDefaults17();
    this.fillImageDefaults = new FillImageDefaults17();
    this.defaultColorRange = [];
    this.defaultPatternFills = [];
    this.fills = [];
    this.strokes = [];
    this.label = new SankeySeriesLabelProperties();
    this.link = new SankeySeriesLinkProperties();
    this.node = new SankeySeriesNodeProperties();
    this.tooltip = makeSeriesTooltip222();
    this.highlightStyle.deprecated = false;
  }
  getStyle(isLink, fills, strokes, index) {
    const {
      fillOpacity,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fill = fills[index % fills.length],
      stroke: stroke22 = strokes[index % fills.length]
    } = isLink ? this.link : this.node;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
};
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "nodes", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "fromKey", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "toKey", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "sizeKey", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "defaultPatternFills", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "fills", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "strokes", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "link", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "node", 2);
__decorateClass2([
  Property82
], SankeySeriesProperties.prototype, "tooltip", 2);
var {
  Transformable: Transformable3,
  applyShapeStyle: applyShapeStyle18,
  SeriesNodePickMode: SeriesNodePickMode16,
  CachedTextMeasurerPool: CachedTextMeasurerPool13,
  TextWrapper: TextWrapper6,
  TextUtils: TextUtils8,
  createDatumId: createDatumId19,
  getShapeStyle: getShapeStyle17,
  getLabelStyles: getLabelStyles6,
  Rect: Rect9,
  BBox: BBox26,
  mergeDefaults: mergeDefaults21
} = module_support_exports;
var SankeySeries = class extends FlowProportionSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode16.NEAREST_NODE, SeriesNodePickMode16.EXACT_SHAPE_MATCH]
    });
    this.properties = new SankeySeriesProperties();
  }
  isLabelEnabled() {
    return (this.properties.labelKey != null || this.nodes == null) && this.properties.label.enabled;
  }
  linkFactory() {
    return new SankeyLink();
  }
  nodeFactory() {
    return new Rect9();
  }
  createNodeData() {
    const {
      id: seriesId,
      _nodeDataDependencies: { seriesRectWidth, seriesRectHeight } = { seriesRectWidth: 0, seriesRectHeight: 0 }
    } = this;
    const {
      fromKey,
      toKey,
      sizeKey,
      labelKey,
      label: { spacing: labelSpacing },
      node: { spacing: nodeSpacing, width: nodeWidth, alignment }
    } = this.properties;
    const {
      nodeGraph: baseNodeGraph,
      links,
      maxPathLength
    } = this.getNodeGraph(
      (node) => ({
        ...node,
        x: NaN,
        y: NaN,
        width: nodeWidth,
        height: NaN
      }),
      (link) => ({
        ...link,
        x1: NaN,
        x2: NaN,
        y1: NaN,
        y2: NaN,
        height: NaN
      }),
      { includeCircularReferences: false }
    );
    const nodeGraph = baseNodeGraph;
    const inset = this.isLabelEnabled() ? (seriesRectWidth - nodeWidth) * (1 - maxPathLength / (maxPathLength + 1)) : 0;
    const columnWidth = (seriesRectWidth - nodeWidth - 2 * inset) / (maxPathLength - 1);
    const columns = [];
    for (let index = 0; index < maxPathLength; index += 1) {
      const x = inset + index * columnWidth;
      columns.push({ index, size: 0, nodes: [], x });
    }
    nodeGraph.forEach((graphNode) => {
      const { datum: node, linksBefore, linksAfter, maxPathLengthBefore, maxPathLengthAfter } = graphNode;
      const size = Math.max(
        linksBefore.reduce((acc, { link }) => acc + link.size, 0),
        linksAfter.reduce((acc, { link }) => acc + link.size, 0)
      );
      if (linksBefore.length === 0 && linksAfter.length === 0 || size === 0) {
        graphNode.columnIndex = -1;
        return;
      }
      let column;
      switch (alignment) {
        case "left":
          column = columns[maxPathLengthBefore];
          break;
        case "right":
          column = columns[maxPathLength - 1 - maxPathLengthAfter];
          break;
        case "center": {
          if (linksBefore.length !== 0) {
            column = columns[maxPathLengthBefore];
          } else if (linksAfter.length !== 0) {
            const columnIndex = linksAfter.reduce(
              (acc, link) => Math.min(acc, link.node.maxPathLengthBefore),
              maxPathLength
            ) - 1;
            column = columns[columnIndex];
          } else {
            column = columns[0];
          }
          break;
        }
        case "justify": {
          column = linksAfter.length === 0 ? columns[maxPathLength - 1] : columns[maxPathLengthBefore];
          break;
        }
      }
      node.x = column.x;
      node.size = size;
      const { label } = this.properties;
      const labelText = label.enabled ? this.getLabelText(
        node.label,
        node.datum,
        labelKey,
        "label",
        [],
        this.properties.label,
        { datum: node.datum, value: node.label, fromKey, toKey, sizeKey, size }
      ) : void 0;
      node.label = labelText;
      column.nodes.push(graphNode);
      column.size += size;
      graphNode.columnIndex = column.index;
    });
    nodeGraph.forEach((graphNode) => {
      let closestColumnIndex = Infinity;
      let maxSizeOfClosestNodesAfter = 0;
      graphNode.linksAfter.forEach((link) => {
        const node = link.node;
        const { columnIndex } = node;
        if (columnIndex < closestColumnIndex) {
          closestColumnIndex = columnIndex;
          maxSizeOfClosestNodesAfter = node.datum.size;
        } else if (columnIndex === closestColumnIndex) {
          maxSizeOfClosestNodesAfter = Math.max(maxSizeOfClosestNodesAfter, node.datum.size);
        }
      });
      graphNode.closestColumnIndex = closestColumnIndex;
      graphNode.maxSizeOfClosestNodesAfter = maxSizeOfClosestNodesAfter;
    });
    const sizeScale = columns.reduce((acc, { size, nodes }) => {
      const columnSizeScale = (1 - (nodes.length - 1) * (nodeSpacing / seriesRectHeight)) / size;
      return Math.min(acc, columnSizeScale);
    }, Infinity);
    for (let i = columns.length - 1; i >= 0; i -= 1) {
      const nodes = columns[i].nodes;
      nodes.sort(
        (a, b) => a.closestColumnIndex - b.closestColumnIndex || a.maxSizeOfClosestNodesAfter - b.maxSizeOfClosestNodesAfter || a.datum.size - b.datum.size
      );
    }
    layoutColumns(columns, {
      seriesRectHeight,
      nodeSpacing,
      sizeScale
    });
    let hasNegativeNodeHeight = false;
    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }) => {
      hasNegativeNodeHeight || (hasNegativeNodeHeight = node.height < 0);
      const bottom = node.y + node.height;
      const sortNodes = (l) => {
        return l.sort((a, b) => {
          const aNode = a.node.datum;
          const bNode = b.node.datum;
          const aBottom = aNode.y + aNode.height;
          const bBottom = bNode.y + bNode.height;
          const dAngleTop = Math.atan2(aNode.y - node.y, Math.abs(aNode.x - node.x)) - Math.atan2(bNode.y - node.y, Math.abs(bNode.x - node.x));
          const dAngleBottom = Math.atan2(aBottom - bottom, Math.abs(aNode.x - node.x)) - Math.atan2(bBottom - bottom, Math.abs(bNode.x - node.x));
          return dAngleTop + dAngleBottom;
        });
      };
      let y2 = node.y;
      sortNodes(linksBefore).forEach(({ link }) => {
        link.y2 = y2;
        y2 += link.size * seriesRectHeight * sizeScale;
      });
      let y1 = node.y;
      sortNodes(linksAfter).forEach(({ link }) => {
        link.y1 = y1;
        y1 += link.size * seriesRectHeight * sizeScale;
      });
    });
    if (hasNegativeNodeHeight) {
      logger_exports.warnOnce(
        "There was insufficient space to display the Sankey Series. Reduce the node spacing, or provide a larger container."
      );
      return;
    }
    const nodeData = [];
    const labelData = [];
    const { fontSize } = this.properties.label;
    const measurer22 = CachedTextMeasurerPool13.getMeasurer({ font: this.properties.label });
    columns.forEach((column, index) => {
      const leading = index === 0;
      const trailing = index === columns.length - 1;
      let bottom = -Infinity;
      column.nodes.sort((a, b) => a.datum.y - b.datum.y);
      column.nodes.forEach(({ datum: node }) => {
        node.midPoint = {
          x: node.x + node.width / 2,
          y: node.y + node.height / 2
        };
        nodeData.push(node);
        if (node.label == null)
          return;
        const x = leading ? node.x - labelSpacing : node.x + node.width + labelSpacing;
        const y = node.y + node.height / 2;
        let text2;
        if (!leading && !trailing) {
          const y12 = y - TextUtils8.getLineHeight(fontSize);
          const y2 = y + TextUtils8.getLineHeight(fontSize);
          let maxX = seriesRectWidth;
          nodeGraph.forEach(({ datum }) => {
            const intersectsLabel = datum.x > node.x && Math.max(datum.y, y12) <= Math.min(datum.y + datum.height, y2);
            if (intersectsLabel) {
              maxX = Math.min(maxX, datum.x - labelSpacing);
            }
          });
          const maxWidth = maxX - node.x - 2 * labelSpacing;
          text2 = TextWrapper6.wrapText(node.label, {
            maxWidth,
            maxHeight: node.height,
            font: this.properties.label,
            textWrap: "never",
            overflow: "hide"
          });
        }
        if (text2 == null || text2 === "") {
          const labelInset = leading || trailing ? labelSpacing : labelSpacing * 2;
          text2 = TextWrapper6.wrapText(node.label, {
            maxWidth: columnWidth - labelInset,
            maxHeight: node.height,
            font: this.properties.label,
            textWrap: "never"
          });
        }
        if (text2 === "")
          return;
        const { height: height2 } = measurer22.measureText(text2);
        const y0 = y - height2 / 2;
        const y1 = y + height2 / 2;
        if (y0 >= bottom) {
          labelData.push({ x, y, leading, text: text2, size: node.size });
          bottom = y1;
        }
      });
    });
    links.forEach((link) => {
      const { fromNode, toNode, size } = link;
      link.height = seriesRectHeight * size * sizeScale;
      link.x1 = fromNode.x + nodeWidth;
      link.x2 = toNode.x;
      link.midPoint = {
        x: (link.x1 + link.x2) / 2,
        y: (link.y1 + link.y2) / 2 + link.height / 2
      };
      nodeData.push(link);
    });
    return {
      itemId: seriesId,
      nodeData,
      labelData
    };
  }
  updateLabelSelection(opts) {
    const labels = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(labels);
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((label, datum) => {
      const { x, y, leading, text: text2 } = datum;
      const params = datum;
      const style2 = getLabelStyles6(this, void 0, params, this.properties.label);
      const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = style2;
      label.visible = true;
      label.x = x;
      label.y = y;
      label.text = text2;
      label.fill = fill;
      label.fontStyle = fontStyle;
      label.fontWeight = fontWeight;
      label.fontSize = fontSize;
      label.fontFamily = fontFamily;
      label.textAlign = leading ? "right" : "left";
      label.textBaseline = "middle";
      label.setBoxing(style2);
    });
  }
  updateNodeSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId19([datum.type, datum.id]));
  }
  getNodeStyle({ datumIndex, datum, size = 0, label }, fromNodeDatumIndex, isHighlight) {
    const { id: seriesId, properties } = this;
    const {
      fills,
      strokes,
      defaultColorRange,
      defaultPatternFills,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = properties;
    const { itemStyler } = properties.node;
    const defaultColorStops = defaultColorRange[fromNodeDatumIndex % defaultColorRange.length].map((color6) => ({
      color: color6
    }));
    const defaultPatternFill = defaultPatternFills[fromNodeDatumIndex % defaultPatternFills.length];
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults21(highlightStyle, properties.getStyle(false, fills, strokes, fromNodeDatumIndex));
    const hasNodeFill = properties.node.fill != null;
    let style2 = getShapeStyle17(
      baseStyle,
      hasNodeFill ? fillGradientDefaults5 : { ...fillGradientDefaults5.toJson(), colorStops: defaultColorStops },
      hasNodeFill ? fillPatternDefaults5 : { ...fillPatternDefaults5.toJson(), fill: defaultPatternFill, stroke: defaultPatternFill },
      fillImageDefaults5
    );
    if (itemStyler != null && datumIndex != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId19(datumIndex.index, "node", isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            ...style2,
            size,
            label
          });
        }
      );
      if (overrides) {
        style2 = mergeDefaults21(
          overrides,
          style2,
          { ...fillGradientDefaults5.toJson(), colorStops: defaultColorStops },
          { ...fillPatternDefaults5.toJson(), fill: defaultPatternFill, stroke: defaultPatternFill },
          fillImageDefaults5
        );
      }
    }
    style2.opacity = 1;
    return style2;
  }
  updateNodeNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((rect, datum) => {
      const { datumIndex } = datum;
      const style2 = this.getNodeStyle(datum, datumIndex.index, isHighlight);
      rect.x = datum.x;
      rect.y = datum.y;
      rect.width = Math.max(datum.width, 0);
      rect.height = Math.max(datum.height, 0);
      applyShapeStyle18(rect, style2, fillBBox);
    });
  }
  getShapeFillBBox() {
    const width2 = this._nodeDataDependencies?.seriesRectWidth ?? 0;
    const height2 = this._nodeDataDependencies?.seriesRectHeight ?? 0;
    const bbox = new BBox26(0, 0, width2, height2);
    return { series: bbox, axis: bbox };
  }
  updateLinkSelection(opts) {
    return opts.datumSelection.update(
      opts.nodeData,
      void 0,
      (datum) => createDatumId19([datum.type, datum.index, datum.fromNode.id, datum.toNode.id])
    );
  }
  getLinkStyle({ datumIndex, datum }, fromNodeDatumIndex, isHighlight) {
    const { id: seriesId, properties } = this;
    const {
      fills,
      strokes,
      defaultColorRange,
      defaultPatternFills,
      fillGradientDefaults: fillGradientDefaults5,
      fillPatternDefaults: fillPatternDefaults5,
      fillImageDefaults: fillImageDefaults5
    } = properties;
    const { itemStyler } = properties.link;
    const defaultColorStops = defaultColorRange[fromNodeDatumIndex % defaultColorRange.length].map((color6) => ({
      color: color6
    }));
    const defaultPatternFill = defaultPatternFills[fromNodeDatumIndex % defaultPatternFills.length];
    const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
    const baseStyle = mergeDefaults21(highlightStyle, properties.getStyle(true, fills, strokes, fromNodeDatumIndex));
    const hasLinkFill = properties.link.fill != null;
    let style2 = getShapeStyle17(
      baseStyle,
      hasLinkFill ? fillGradientDefaults5 : { ...fillGradientDefaults5.toJson(), colorStops: defaultColorStops },
      hasLinkFill ? fillPatternDefaults5 : { ...fillPatternDefaults5.toJson(), fill: defaultPatternFill, stroke: defaultPatternFill },
      fillImageDefaults5
    );
    if (itemStyler != null && datumIndex != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId19(datumIndex.index, "link", isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
          return this.callWithContext(itemStyler, {
            seriesId,
            datum,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = mergeDefaults21(
          overrides,
          style2,
          { ...fillGradientDefaults5.toJson(), colorStops: defaultColorStops },
          { ...fillPatternDefaults5.toJson(), fill: defaultPatternFill, stroke: defaultPatternFill },
          fillImageDefaults5
        );
      }
    }
    style2.opacity = 1;
    return style2;
  }
  updateLinkNodes(opts) {
    const { datumSelection, isHighlight } = opts;
    const fillBBox = this.getShapeFillBBox();
    datumSelection.each((link, datum) => {
      const fromNodeDatumIndex = datum.fromNode.datumIndex.index;
      const style2 = this.getLinkStyle(datum, fromNodeDatumIndex, isHighlight);
      link.x1 = datum.x1;
      link.y1 = datum.y1;
      link.x2 = datum.x2;
      link.y2 = datum.y2;
      link.height = datum.height;
      applyShapeStyle18(link, style2, fillBBox);
      link.inset = link.strokeWidth / 2;
    });
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      linksProcessedData,
      nodesProcessedData,
      properties,
      ctx: { formatManager }
    } = this;
    const { fromKey, toKey, sizeKey, sizeName, tooltip } = properties;
    const seriesDatum = this.contextNodeData?.nodeData.find(
      (d) => d.datumIndex.type === datumIndex.type && d.datumIndex.index === datumIndex.index
    );
    if (seriesDatum == null)
      return;
    const nodeIndex = seriesDatum.type === 0 ? seriesDatum.fromNode.index : seriesDatum.index;
    const title = seriesDatum.type === 0 ? `${seriesDatum.fromNode.label} - ${seriesDatum.toNode.label}` : seriesDatum.label;
    const datum = datumIndex.type === 0 ? linksProcessedData?.dataSources.get(this.id)?.[datumIndex.index] : nodesProcessedData?.dataSources.get(this.id)?.[datumIndex.index];
    const size = seriesDatum.size;
    let format;
    if (seriesDatum.type === 0) {
      const fromNodeDatumIndex = seriesDatum.fromNode.datumIndex;
      format = this.getLinkStyle({ datumIndex, datum }, fromNodeDatumIndex.index, false);
    } else {
      format = this.getNodeStyle({ datumIndex, datum }, datumIndex.index, false);
    }
    const data = [];
    if (sizeKey != null) {
      const content = formatManager.format(this.callWithContext.bind(this), {
        type: "number",
        value: size,
        datum,
        seriesId,
        legendItemName: void 0,
        key: sizeKey,
        source: "tooltip",
        property: "size",
        domain: [],
        boundSeries: this.getFormatterContext("size"),
        fractionDigits: void 0
      });
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: content ?? String(size) });
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(seriesDatum.type, nodeIndex, format),
        data
      },
      {
        seriesId,
        datum,
        title,
        fromKey,
        toKey,
        sizeKey,
        sizeName,
        size,
        ...format
      }
    );
  }
  computeFocusBounds(node) {
    if (node instanceof Rect9) {
      const { x, y, width: width2, height: height2 } = node;
      const bbox = new BBox26(x, y, width2, height2);
      return Transformable3.toCanvas(this.contentGroup, bbox);
    }
    return node;
  }
  hasItemStylers() {
    return this.properties.node.itemStyler != null || this.properties.link.itemStyler != null;
  }
};
SankeySeries.className = "SankeySeries";
SankeySeries.type = "sankey";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs21, sankeySeriesThemeableOptionsDef: sankeySeriesThemeableOptionsDef2 } = module_support_exports;
var sankeySeriesOptionsDef = {
  ...sankeySeriesThemeableOptionsDef2,
  ...commonSeriesOptionsDefs21,
  type: required(constant("sankey")),
  fromKey: required(string),
  toKey: required(string),
  sizeKey: string,
  sizeName: string
};
sankeySeriesOptionsDef.fillGradientDefaults = undocumented(fillGradientDefaults);
sankeySeriesOptionsDef.fillPatternDefaults = undocumented(fillPatternDefaults);
sankeySeriesOptionsDef.fillImageDefaults = undocumented(fillImageDefaults);
sankeySeriesOptionsDef.defaultColorRange = undocumented(arrayOf(arrayOf(color)));
sankeySeriesOptionsDef.defaultPatternFills = undocumented(arrayOf(color));
var SankeyModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  solo: true,
  identifier: "sankey",
  moduleFactory: (ctx) => new SankeySeries(ctx),
  themeTemplate: {
    seriesArea: {
      padding: {
        top: 10,
        bottom: 10
      }
    },
    series: {
      fills: { $palette: "fills" },
      strokes: { $palette: "strokes" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      defaultColorRange: { $palette: "gradients" },
      defaultPatternFills: module_support_exports.SAFE_FILLS_OPERATION,
      highlightStyle: {
        series: {
          dimOpacity: 0.2
        }
      },
      highlight: {
        ...module_support_exports.singleSeriesHighlightStyle()
      },
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $ref: "fontSize" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" },
        spacing: 10
      },
      node: {
        spacing: 20,
        width: 10,
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] }
      },
      link: {
        fillOpacity: 0.5,
        strokeWidth: { $isUserOption: ["./stroke", 2, 0] }
      }
    },
    legend: {
      enabled: false,
      toggleSeries: false
    }
  }
};
var SankeySeriesModule = {
  type: "series",
  name: "sankey",
  chartType: "standalone",
  enterprise: true,
  options: sankeySeriesOptionsDef,
  create: (ctx) => new SankeySeries(ctx)
};
var { HierarchySeriesProperties: HierarchySeriesProperties2, HighlightStyle: HighlightStyle2, makeSeriesTooltip: makeSeriesTooltip23, Property: Property83 } = module_support_exports;
var SunburstSeriesTileHighlightStyle = class extends HighlightStyle2 {
  constructor() {
    super(false);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedLabel();
  }
};
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass2([
  Property83
], SunburstSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var SunburstSeriesProperties = class extends HierarchySeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.highlightStyle = new SunburstSeriesTileHighlightStyle();
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedSecondaryLabel();
    this.tooltip = makeSeriesTooltip23();
  }
  getStyle(index) {
    const { fills, strokes, fillOpacity, strokeWidth, strokeOpacity } = this;
    return {
      fill: fills[index % fills.length],
      fillOpacity,
      stroke: strokes[index % strokes.length],
      strokeWidth,
      strokeOpacity,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "padding", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass2([
  Property83
], SunburstSeriesProperties.prototype, "tooltip", 2);
var {
  fromToMotion: fromToMotion6,
  normalizeAngle360: normalizeAngle3607,
  createDatumId: createDatumId20,
  PointerEvents: PointerEvents13,
  Sector: Sector7,
  Group: Group20,
  ScalableGroup: ScalableGroup22,
  Selection: Selection18,
  TransformableText: TransformableText3,
  BBox: BBox27,
  applyShapeStyle: applyShapeStyle19,
  getShapeStyle: getShapeStyle18,
  mergeDefaults: mergeDefaults222
} = module_support_exports;
var SunburstNode = class extends module_support_exports.HierarchyNode {
  constructor() {
    super(...arguments);
    this.label = void 0;
    this.secondaryLabel = void 0;
    this.contentHeight = 0;
    this.bbox = void 0;
    this.startAngle = 0;
    this.endAngle = 0;
  }
};
function setAngleData(node, startAngle = 0, angleScale = 2 * Math.PI / node.sumSize) {
  for (const child of node.children) {
    const endAngle = startAngle + child.sumSize * angleScale;
    child.startAngle = startAngle;
    child.endAngle = endAngle;
    setAngleData(child, startAngle, angleScale);
    startAngle = endAngle;
  }
}
var SunburstSeries = class extends module_support_exports.HierarchySeries {
  constructor(moduleCtx) {
    super(moduleCtx);
    this.NodeClass = SunburstNode;
    this.properties = new SunburstSeriesProperties();
    this.scalingGroup = this.contentGroup.appendChild(new ScalableGroup22());
    this.sectorGroup = this.scalingGroup.appendChild(new Group20());
    this.sectorLabelGroup = this.scalingGroup.appendChild(new Group20());
    this.highlightSectorGroup = this.scalingGroup.appendChild(new Group20());
    this.datumSelection = Selection18.select(this.sectorGroup, Sector7);
    this.labelSelection = Selection18.select(
      this.sectorLabelGroup,
      Group20
    );
    this.highlightSelection = Selection18.select(
      this.highlightSectorGroup,
      Sector7
    );
    this.sectorLabelGroup.pointerEvents = PointerEvents13.None;
  }
  processData() {
    super.processData();
    setAngleData(this.rootNode);
  }
  updateSelections() {
    const highlightedNode = this.ctx.highlightManager?.getActiveHighlight();
    this.highlightSelection.update(
      highlightedNode != null ? [highlightedNode] : [],
      void 0,
      (node) => this.getDatumId(node)
    );
    if (!this.nodeDataRefresh)
      return;
    this.nodeDataRefresh = false;
    const { chart } = this;
    if (chart == null)
      return;
    const seriesRect = chart.seriesRect;
    if (seriesRect == null)
      return;
    const descendants = Array.from(this.rootNode);
    const updateLabelGroup = (group) => {
      group.append([
        new TransformableText3({
          tag: 0
          /* Primary */
        }),
        new TransformableText3({
          tag: 1
          /* Secondary */
        })
      ]);
    };
    this.datumSelection.update(descendants, void 0, (node) => this.getDatumId(node));
    this.labelSelection.update(descendants, updateLabelGroup, (node) => this.getDatumId(node));
  }
  getItemStyle(nodeDatum, isHighlight) {
    const { id: seriesId, properties, colorScale } = this;
    const { itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const rootIndex = nodeDatum.datumIndex?.[0] ?? 0;
    const highlightStyle = isHighlight ? properties.highlightStyle : void 0;
    const baseStyle = mergeDefaults222(highlightStyle, properties.getStyle(rootIndex));
    if (!isHighlight && nodeDatum.colorValue != null) {
      baseStyle.fill = colorScale.convert(nodeDatum.colorValue);
    }
    let style2 = getShapeStyle18(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && nodeDatum != null) {
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const overrides = this.cachedDatumCallback(
        createDatumId20(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"),
        () => {
          const highlightState = this.getHighlightStateString(
            activeHighlight,
            isHighlight,
            nodeDatum.datumIndex
          );
          return this.callWithContext(itemStyler, {
            seriesId,
            datum: nodeDatum.datum,
            depth: nodeDatum.depth ?? 0,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle18(
          mergeDefaults222(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateNodes() {
    const { chart, data, maxDepth } = this;
    if (chart == null || data == null) {
      return;
    }
    const { width: width2, height: height2 } = chart.seriesRect;
    const {
      sectorSpacing = 0,
      padding: padding2 = 0,
      cornerRadius,
      childrenKey,
      colorKey,
      colorName,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName
    } = this.properties;
    this.contentGroup.translationX = width2 / 2;
    this.contentGroup.translationY = height2 / 2;
    const baseInset = sectorSpacing * 0.5;
    const radius = Math.min(width2, height2) / 2;
    const radiusScale = radius / (maxDepth + 1);
    const angleOffset = -Math.PI / 2;
    const seriesFillBBox = {
      series: new BBox27(-radius, -radius, 2 * radius, 2 * radius),
      axis: new BBox27(-radius, -radius, 2 * radius, 2 * radius)
    };
    this.rootNode?.walk((node) => {
      const { startAngle, endAngle } = node;
      if (node.depth != null) {
        const midAngle = (startAngle + endAngle) / 2 + angleOffset;
        const midRadius = (node.depth + 0.5) * radiusScale;
        node.midPoint.x = Math.cos(midAngle) * midRadius;
        node.midPoint.y = Math.sin(midAngle) * midRadius;
      }
    });
    this.rootNode?.walk((node) => {
      const { datum, depth, startAngle, endAngle, parent, sumSize } = node;
      node.label = void 0;
      node.secondaryLabel = void 0;
      node.contentHeight = 0;
      let labelValue;
      if (datum != null && depth != null && labelKey != null) {
        const value = datum[labelKey];
        labelValue = this.getLabelText(
          value,
          datum,
          labelKey,
          "label",
          [],
          this.properties.label,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          }
        );
      }
      if (labelValue === "") {
        labelValue = void 0;
      }
      let secondaryLabelValue;
      if (datum != null && depth != null && secondaryLabelKey != null) {
        const value = datum[secondaryLabelKey];
        secondaryLabelValue = this.getLabelText(
          value,
          datum,
          secondaryLabelKey,
          "secondaryLabel",
          [],
          this.properties.secondaryLabel,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          }
        );
      }
      if (secondaryLabelValue === "") {
        secondaryLabelValue = void 0;
      }
      if (depth == null)
        return;
      const innerRadius = depth * radiusScale + baseInset;
      const outerRadius = (depth + 1) * radiusScale - baseInset;
      const innerAngleOffset = innerRadius > baseInset ? baseInset / innerRadius : baseInset;
      const outerAngleOffset = outerRadius > baseInset ? baseInset / outerRadius : baseInset;
      const innerStartAngle = startAngle + innerAngleOffset;
      const innerEndAngle = endAngle + innerAngleOffset;
      const deltaInnerAngle = innerEndAngle - innerStartAngle;
      const outerStartAngle = startAngle + outerAngleOffset;
      const outerEndAngle = endAngle + outerAngleOffset;
      const deltaOuterAngle = outerEndAngle - outerStartAngle;
      const sizeFittingHeight = (labelHeight2) => {
        const isCenterCircle = depth === 0 && parent?.sumSize === sumSize;
        if (isCenterCircle) {
          const labelWidth2 = 2 * Math.sqrt(outerRadius ** 2 - (labelHeight2 * 0.5) ** 2);
          return {
            width: labelWidth2,
            height: labelHeight2,
            meta: 0
            /* CenterCircle */
          };
        }
        const parallelHeight = labelHeight2;
        const availableWidthUntilItHitsTheOuterRadius = 2 * Math.sqrt(outerRadius ** 2 - (innerRadius + parallelHeight) ** 2);
        const availableWidthUntilItHitsTheStraightEdges = deltaInnerAngle < Math.PI ? 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5) : Infinity;
        const parallelWidth = Math.min(
          availableWidthUntilItHitsTheOuterRadius,
          availableWidthUntilItHitsTheStraightEdges
        );
        const maxPerpendicularAngle = Math.PI / 4;
        let perpendicularHeight;
        let perpendicularWidth;
        if (depth === 0) {
          perpendicularHeight = labelHeight2;
          perpendicularWidth = Math.sqrt(outerRadius ** 2 - (perpendicularHeight / 2) ** 2) - labelHeight2 / (2 * Math.tan(deltaOuterAngle * 0.5));
        } else if (normalizeAngle3607(deltaInnerAngle) < maxPerpendicularAngle) {
          perpendicularHeight = 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5);
          perpendicularWidth = Math.sqrt(outerRadius ** 2 - (perpendicularHeight / 2) ** 2) - innerRadius;
        } else {
          perpendicularWidth = 0;
          perpendicularHeight = 0;
        }
        return parallelWidth >= perpendicularWidth ? {
          width: parallelWidth,
          height: parallelHeight,
          meta: 1
          /* Parallel */
        } : {
          width: perpendicularWidth,
          height: perpendicularHeight,
          meta: 2
          /* Perpendicular */
        };
      };
      const formatting = formatLabels(
        labelValue,
        this.properties.label,
        secondaryLabelValue,
        this.properties.secondaryLabel,
        { padding: padding2 },
        sizeFittingHeight
      );
      if (formatting == null)
        return;
      const { width: labelWidth, height: labelHeight, meta: labelPlacement, label, secondaryLabel } = formatting;
      const theta = angleOffset + (startAngle + endAngle) / 2;
      const top = Math.sin(theta) >= 0;
      const right = Math.cos(theta) >= 0;
      const circleQuarter = (top ? 3 : 12) & (right ? 6 : 9);
      let labelRadius;
      switch (labelPlacement) {
        case 0:
          labelRadius = 0;
          break;
        case 1: {
          const opticalCentering = 0.58;
          const idealRadius = outerRadius - (radiusScale - labelHeight) * opticalCentering;
          const maximumRadius = Math.sqrt((outerRadius - padding2) ** 2 - (labelWidth / 2) ** 2);
          labelRadius = Math.min(idealRadius, maximumRadius);
          break;
        }
        case 2:
          if (depth === 0) {
            const minimumRadius = labelHeight / (2 * Math.tan(deltaInnerAngle * 0.5)) + labelWidth * 0.5;
            const maximumRadius = Math.sqrt(outerRadius ** 2 - (labelHeight * 0.5) ** 2) - labelWidth * 0.5;
            labelRadius = (minimumRadius + maximumRadius) * 0.5;
          } else {
            labelRadius = (innerRadius + outerRadius) * 0.5;
          }
          break;
      }
      if (label != null) {
        const {
          fontStyle = "normal",
          fontFamily,
          fontWeight = "normal",
          color: color6 = "black"
        } = this.properties.label;
        node.label = {
          ...label,
          fontStyle,
          fontFamily,
          fontWeight,
          color: color6,
          labelPlacement,
          circleQuarter,
          radius: labelRadius,
          theta
        };
      }
      if (secondaryLabel != null) {
        const {
          fontStyle = "normal",
          fontFamily,
          fontWeight = "normal",
          color: color6 = "black"
        } = this.properties.secondaryLabel;
        node.secondaryLabel = {
          ...secondaryLabel,
          fontStyle,
          fontFamily,
          fontWeight,
          color: color6,
          labelPlacement,
          circleQuarter,
          radius: labelRadius,
          theta
        };
      }
      node.contentHeight = formatting.height;
    });
    const updateSector = (nodeDatum, sector, highlighted) => {
      const { depth, startAngle, endAngle } = nodeDatum;
      if (depth == null) {
        sector.visible = false;
        return;
      }
      sector.visible = true;
      const style2 = this.getItemStyle(nodeDatum, highlighted);
      const fill = style2.fill;
      const strokeWidth = style2.strokeWidth;
      const fillBBox = module_support_exports.isGradientFill(fill) && fill.bounds !== "item" ? seriesFillBBox : void 0;
      applyShapeStyle19(sector, style2, fillBBox);
      sector.centerX = 0;
      sector.centerY = 0;
      sector.innerRadius = depth * radiusScale;
      sector.outerRadius = (depth + 1) * radiusScale;
      sector.startAngle = startAngle + angleOffset;
      sector.endAngle = endAngle + angleOffset;
      sector.inset = baseInset + strokeWidth * 0.5;
      sector.cornerRadius = cornerRadius;
    };
    this.datumSelection.each((sector, datum) => {
      updateSector(datum, sector, false);
    });
    this.highlightSelection.each((rect, datum) => {
      updateSector(datum, rect, true);
    });
    const updateText = (node, text2, tag, highlighted) => {
      const { depth, contentHeight } = node;
      const primary = tag === 0;
      const label = primary ? node.label : node.secondaryLabel;
      if (depth == null || label == null) {
        text2.visible = false;
        return;
      }
      const { labelPlacement, circleQuarter, radius: textRadius, theta } = label;
      let highlightedColor;
      if (highlighted) {
        const highlightedLabelStyle = primary ? this.properties.highlightStyle.label : this.properties.highlightStyle.secondaryLabel;
        highlightedColor = highlightedLabelStyle.color;
      }
      text2.text = label.text;
      text2.fontSize = label.fontSize;
      text2.lineHeight = label.lineHeight;
      text2.fontStyle = label.fontStyle;
      text2.fontFamily = label.fontFamily;
      text2.fontWeight = label.fontWeight;
      text2.fill = highlightedColor ?? label.color;
      text2.fillOpacity = this.getHighlightStyle(highlighted, node.datumIndex)?.opacity ?? 1;
      switch (labelPlacement) {
        case 0:
          text2.textAlign = "center";
          text2.textBaseline = "top";
          text2.translationX = 0;
          text2.translationY = (primary ? 0 : contentHeight - label.height) - contentHeight * 0.5;
          text2.rotation = 0;
          break;
        case 1: {
          const topHalf = (circleQuarter & 3) !== 0;
          const translationRadius = primary === !topHalf ? textRadius : textRadius - (contentHeight - label.height);
          text2.textAlign = "center";
          text2.textBaseline = topHalf ? "bottom" : "top";
          text2.translationX = Math.cos(theta) * translationRadius;
          text2.translationY = Math.sin(theta) * translationRadius;
          text2.rotation = topHalf ? theta - Math.PI * 0.5 : theta + Math.PI * 0.5;
          break;
        }
        case 2: {
          const rightHalf = (circleQuarter & 6) !== 0;
          const translation = primary === !rightHalf ? (contentHeight - label.height) * 0.5 : (label.height - contentHeight) * 0.5;
          text2.textAlign = "center";
          text2.textBaseline = "middle";
          text2.translationX = Math.cos(theta) * textRadius + Math.cos(theta + Math.PI / 2) * translation;
          text2.translationY = Math.sin(theta) * textRadius + Math.sin(theta + Math.PI / 2) * translation;
          text2.rotation = rightHalf ? theta : theta + Math.PI;
          break;
        }
      }
      text2.visible = true;
    };
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    this.labelSelection.selectByClass(TransformableText3).forEach((text2) => {
      const datum = text2.closestDatum();
      updateText(datum, text2, text2.tag, datum === highlightedDatum);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, properties } = this;
    const { labelKey, secondaryLabelKey, childrenKey, sizeKey, sizeName, colorKey, colorName, tooltip } = properties;
    const nodeDatum = datumIndex.reduce((n, i) => n?.children[i], this.rootNode);
    if (nodeDatum == null)
      return;
    const { datum, depth } = nodeDatum;
    if (datum == null || depth == null)
      return;
    const data = [];
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: datumSize });
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      data.push({ label: colorName, fallbackLabel: colorKey, value: datumColor });
    }
    const format = this.getItemStyle(
      { ...nodeDatum, colorValue: datumColor ?? nodeDatum.colorValue },
      false
    );
    const color6 = format.fill;
    const markerStyle = getShapeStyle18(
      {
        shape: "square",
        fill: color6,
        fillOpacity: 1,
        stroke: void 0,
        strokeWidth: 0,
        strokeOpacity: 1,
        lineDash: [0],
        lineDashOffset: 0
      },
      properties.fillGradientDefaults,
      properties.fillPatternDefaults,
      properties.fillImageDefaults
    );
    if (module_support_exports.isGradientFill(markerStyle.fill)) {
      markerStyle.fill = { ...markerStyle.fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        title: labelKey != null ? datum[labelKey] : void 0,
        symbol: {
          marker: markerStyle
        },
        data
      },
      {
        seriesId,
        datum,
        title: void 0,
        depth,
        labelKey,
        secondaryLabelKey,
        childrenKey,
        sizeKey,
        sizeName,
        colorKey,
        colorName,
        ...format
      }
    );
  }
  createNodeData() {
    return void 0;
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.datumSelection.nodes());
  }
  animateEmptyUpdateReady() {
    fromToMotion6(this.id, "nodes", this.ctx.animationManager, [this.scalingGroup], {
      toFn() {
        return { scalingX: 1, scalingY: 1 };
      },
      fromFn() {
        return { scalingX: 0, scalingY: 0 };
      }
    });
  }
  computeFocusBounds(node) {
    return node;
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
SunburstSeries.className = "SunburstSeries";
SunburstSeries.type = "sunburst";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs222, sunburstSeriesThemeableOptionsDef: sunburstSeriesThemeableOptionsDef2, without: without8 } = module_support_exports;
var sunburstSeriesOptionsDef = {
  ...sunburstSeriesThemeableOptionsDef2,
  ...without8(commonSeriesOptionsDefs222, ["highlightStyle", "highlight", "showInLegend"]),
  type: required(constant("sunburst")),
  labelKey: string,
  secondaryLabelKey: string,
  childrenKey: string,
  sizeKey: string,
  colorKey: string,
  sizeName: string,
  colorName: string
};
var { BASE_FONT_SIZE: BASE_FONT_SIZE2, FONT_SIZE_RATIO: FONT_SIZE_RATIO3 } = module_support_exports;
var SunburstModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  identifier: "sunburst",
  moduleFactory: (ctx) => new SunburstSeries(ctx),
  solo: true,
  themeTemplate: {
    series: {
      fills: { $palette: "fills" },
      strokes: { $palette: "strokes" },
      colorRange: { $palette: "divergingColors" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      strokeWidth: { $isUserOption: ["./strokes/0", 2, 0] },
      label: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $rem: FONT_SIZE_RATIO3.LARGE },
        minimumFontSize: { $rem: 9 / BASE_FONT_SIZE2 },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "chartBackgroundColor" },
        overflowStrategy: "ellipsis",
        wrapping: "never",
        spacing: 2
      },
      secondaryLabel: {
        ...module_support_exports.LABEL_BOXING_DEFAULTS,
        fontFamily: { $ref: "fontFamily" },
        fontSize: { $rem: FONT_SIZE_RATIO3.SMALLEST },
        minimumFontSize: { $rem: 7 / BASE_FONT_SIZE2 },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "chartBackgroundColor" },
        overflowStrategy: "ellipsis",
        wrapping: "never"
      },
      sectorSpacing: 2,
      padding: 3,
      highlightStyle: {
        label: {
          color: { $ref: "chartBackgroundColor" }
        },
        secondaryLabel: {
          color: { $ref: "chartBackgroundColor" }
        },
        fill: "rgba(255,255,255, 0.33)",
        stroke: `rgba(0, 0, 0, 0.4)`,
        strokeWidth: 2
      }
    },
    gradientLegend: {
      enabled: true,
      ...module_support_exports.LEGEND_CONTAINER_THEME
    }
  }
};
var SunburstSeriesModule = {
  type: "series",
  name: "sunburst",
  chartType: "standalone",
  enterprise: true,
  options: sunburstSeriesOptionsDef,
  create: (ctx) => new SunburstSeries(ctx)
};
var { BaseProperties: BaseProperties29, HierarchySeriesProperties: HierarchySeriesProperties22, HighlightStyle: HighlightStyle22, makeSeriesTooltip: makeSeriesTooltip24, Property: Property84, Label: Label18 } = module_support_exports;
var TreemapGroupLabel = class extends Label18 {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass2([
  Property84
], TreemapGroupLabel.prototype, "spacing", 2);
var TreemapSeriesGroup = class extends BaseProperties29 {
  constructor() {
    super(...arguments);
    this.fill = void 0;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.textAlign = "center";
    this.gap = 0;
    this.padding = 0;
    this.interactive = true;
    this.label = new TreemapGroupLabel();
  }
};
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "fill", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "fillOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "stroke", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "strokeWidth", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "cornerRadius", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "textAlign", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "gap", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "padding", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "interactive", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroup.prototype, "label", 2);
var TreemapSeriesTile = class extends BaseProperties29 {
  constructor() {
    super(...arguments);
    this.fill = void 0;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.gap = 0;
    this.padding = 0;
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedSecondaryLabel();
  }
};
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "fill", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "fillOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "stroke", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "strokeWidth", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "cornerRadius", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "textAlign", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "verticalAlign", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "gap", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "padding", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "label", 2);
__decorateClass2([
  Property84
], TreemapSeriesTile.prototype, "secondaryLabel", 2);
var TreemapSeriesGroupHighlightStyle = class extends BaseProperties29 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
  }
};
__decorateClass2([
  Property84
], TreemapSeriesGroupHighlightStyle.prototype, "fill", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroupHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroupHighlightStyle.prototype, "stroke", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroupHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroupHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesGroupHighlightStyle.prototype, "label", 2);
var TreemapSeriesTileHighlightStyle = class extends BaseProperties29 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedSecondaryLabel();
  }
};
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass2([
  Property84
], TreemapSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var TreemapSeriesHighlightStyle = class extends HighlightStyle22 {
  constructor() {
    super(false);
    this.group = new TreemapSeriesGroupHighlightStyle();
    this.tile = new TreemapSeriesTileHighlightStyle();
  }
  getStyle(isLeaf) {
    return isLeaf ? this.tile : this.group;
  }
};
__decorateClass2([
  Property84
], TreemapSeriesHighlightStyle.prototype, "group", 2);
__decorateClass2([
  Property84
], TreemapSeriesHighlightStyle.prototype, "tile", 2);
var TreemapSeriesProperties = class extends HierarchySeriesProperties22 {
  constructor() {
    super(...arguments);
    this.highlightStyle = new TreemapSeriesHighlightStyle();
    this.tooltip = makeSeriesTooltip24();
    this.group = new TreemapSeriesGroup();
    this.tile = new TreemapSeriesTile();
    this.undocumentedGroupFills = [];
    this.undocumentedGroupStrokes = [];
  }
  getStyle(isLeaf, fills, strokes, index) {
    const {
      fillOpacity,
      strokeWidth,
      strokeOpacity,
      fill = isLeaf ? fills[index % fills.length] : fills[Math.min(index, fills.length)],
      stroke: stroke22 = isLeaf ? strokes[index % fills.length] : strokes[Math.min(index, strokes.length)]
    } = isLeaf ? this.tile : this.group;
    return {
      fill,
      fillOpacity,
      stroke: stroke22,
      strokeWidth,
      strokeOpacity,
      opacity: 1
    };
  }
};
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "itemStyler", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "group", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "tile", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "undocumentedGroupFills", 2);
__decorateClass2([
  Property84
], TreemapSeriesProperties.prototype, "undocumentedGroupStrokes", 2);
var {
  TextUtils: TextUtils9,
  TextWrapper: TextWrapper7,
  createDatumId: createDatumId21,
  Rect: Rect10,
  Group: Group21,
  BBox: BBox28,
  Selection: Selection19,
  Text: Text10,
  Transformable: Transformable4,
  applyShapeStyle: applyShapeStyle20,
  getShapeStyle: getShapeStyle19,
  getLabelStyles: getLabelStyles7,
  mergeDefaults: mergeDefaults23
} = module_support_exports;
var TreemapNode = class extends module_support_exports.HierarchyNode {
  constructor() {
    super(...arguments);
    this.labelValue = void 0;
    this.secondaryLabelValue = void 0;
    this.label = void 0;
    this.secondaryLabel = void 0;
    this.bbox = void 0;
    this.padding = void 0;
  }
};
var tempText = new Text10();
function getTextSize(text2, style2) {
  const { fontStyle, fontWeight, fontSize, fontFamily } = style2;
  tempText.setProperties({
    text: text2,
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    textAlign: "left",
    textBaseline: "top"
  });
  const { width: width2, height: height2 } = tempText.getBBox();
  return { width: width2, height: height2 };
}
function nodeSize(node) {
  return node.children.length > 0 ? node.sumSize - node.sizeValue : node.sizeValue;
}
var textAlignFactors2 = {
  left: 0,
  center: 0.5,
  right: 1
};
var verticalAlignFactors4 = {
  top: 0,
  middle: 0.5,
  bottom: 1
};
var DistantGroup = class extends module_support_exports.Group {
  distanceSquared(x, y) {
    return this.getBBox().distanceSquared(x, y);
  }
};
var TreemapSeries = class extends module_support_exports.HierarchySeries {
  constructor() {
    super(...arguments);
    this.NodeClass = TreemapNode;
    this.properties = new TreemapSeriesProperties();
    this.rectGroup = this.contentGroup.appendChild(new Group21());
    this.datumSelection = Selection19.select(this.rectGroup, Rect10);
    this.labelSelection = Selection19.select(this.labelGroup, Group21);
    this.highlightSelection = Selection19.select(
      this.rectGroup,
      Rect10
    );
  }
  groupTitleHeight(node, bbox) {
    const { labelValue } = node;
    const { label: font22 } = this.properties.group;
    const heightRatioThreshold = 3;
    if (labelValue == null) {
      return;
    } else if (font22.fontSize > bbox.width / heightRatioThreshold || font22.fontSize > bbox.height / heightRatioThreshold) {
      return;
    } else {
      const { height: fontHeight } = getTextSize(labelValue, font22);
      return Math.max(fontHeight, font22.fontSize);
    }
  }
  getNodePadding(node, bbox) {
    if (node.parent == null) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    } else if (node.children.length === 0) {
      const { padding: padding22 } = this.properties.tile;
      return {
        top: padding22,
        right: padding22,
        bottom: padding22,
        left: padding22
      };
    }
    const {
      label: { spacing },
      padding: padding2
    } = this.properties.group;
    const fontHeight = this.groupTitleHeight(node, bbox);
    const titleHeight = fontHeight != null ? fontHeight + spacing : 0;
    return {
      top: padding2 + titleHeight,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  sortChildren({ children }) {
    const sortedChildrenIndices = Array.from(children, (_, i) => i).filter((i) => nodeSize(children[i]) > 0).sort((aIndex, bIndex) => nodeSize(children[bIndex]) - nodeSize(children[aIndex]));
    const childAt = (i) => {
      const sortedIndex = sortedChildrenIndices[i];
      return children[sortedIndex];
    };
    return { sortedChildrenIndices, childAt };
  }
  /**
   * Squarified Treemap algorithm
   * https://www.win.tue.nl/~vanwijk/stm.pdf
   */
  squarify(node, bbox) {
    const { datum, children } = node;
    if (bbox.width <= 0 || bbox.height <= 0) {
      node.bbox = void 0;
      node.padding = void 0;
      node.midPoint.x = NaN;
      node.midPoint.y = NaN;
      return;
    }
    const padding2 = datum != null ? this.getNodePadding(node, bbox) : { top: 0, right: 0, bottom: 0, left: 0 };
    if (node.parent == null) {
      node.bbox = void 0;
      node.padding = void 0;
      node.midPoint.x = NaN;
      node.midPoint.y = NaN;
    } else {
      node.bbox = bbox;
      node.padding = padding2;
      node.midPoint.x = bbox.x + bbox.width / 2;
      node.midPoint.y = bbox.y;
    }
    const { sortedChildrenIndices, childAt } = this.sortChildren(node);
    const allLeafNodes = sortedChildrenIndices.every((sortedIndex) => children[sortedIndex].children.length === 0);
    const targetTileAspectRatio = 1;
    const width2 = bbox.width - padding2.left - padding2.right;
    const height2 = bbox.height - padding2.top - padding2.bottom;
    if (width2 <= 0 || height2 <= 0)
      return;
    const numChildren = sortedChildrenIndices.length;
    let stackSum = 0;
    let startIndex = 0;
    let minRatioDiff = Infinity;
    let partitionSum = sortedChildrenIndices.reduce((sum2, sortedIndex) => sum2 + nodeSize(children[sortedIndex]), 0);
    const innerBox = new BBox28(bbox.x + padding2.left, bbox.y + padding2.top, width2, height2);
    const partition = innerBox.clone();
    let i = 0;
    while (i < numChildren) {
      const value = nodeSize(childAt(i));
      const firstValue = nodeSize(childAt(startIndex));
      const isVertical2 = partition.width < partition.height;
      stackSum += value;
      const partThickness = isVertical2 ? partition.height : partition.width;
      const partLength = isVertical2 ? partition.width : partition.height;
      const firstTileLength = partLength * firstValue / stackSum;
      let stackThickness = partThickness * stackSum / partitionSum;
      const ratio3 = Math.max(firstTileLength, stackThickness) / Math.min(firstTileLength, stackThickness);
      const diff8 = Math.abs(targetTileAspectRatio - ratio3);
      if (diff8 < minRatioDiff) {
        minRatioDiff = diff8;
        i++;
        continue;
      }
      stackSum -= value;
      stackThickness = partThickness * stackSum / partitionSum;
      let start22 = isVertical2 ? partition.x : partition.y;
      for (let j = startIndex; j < i; j++) {
        const child = childAt(j);
        const childSize = nodeSize(child);
        const x = isVertical2 ? start22 : partition.x;
        const y = isVertical2 ? partition.y : start22;
        const length2 = partLength * childSize / stackSum;
        const stackWidth = isVertical2 ? length2 : stackThickness;
        const stackHeight = isVertical2 ? stackThickness : length2;
        const childBbox = new BBox28(x, y, stackWidth, stackHeight);
        this.applyGap(innerBox, childBbox, allLeafNodes);
        this.squarify(child, childBbox);
        partitionSum -= childSize;
        start22 += length2;
      }
      if (isVertical2) {
        partition.y += stackThickness;
        partition.height -= stackThickness;
      } else {
        partition.x += stackThickness;
        partition.width -= stackThickness;
      }
      startIndex = i;
      stackSum = 0;
      minRatioDiff = Infinity;
    }
    const isVertical = partition.width < partition.height;
    let start2 = isVertical ? partition.x : partition.y;
    for (let childIdx = startIndex; childIdx < numChildren; childIdx++) {
      const child = childAt(childIdx);
      const x = isVertical ? start2 : partition.x;
      const y = isVertical ? partition.y : start2;
      const part = nodeSize(child) / partitionSum;
      const childWidth = partition.width * (isVertical ? part : 1);
      const childHeight = partition.height * (isVertical ? 1 : part);
      const childBox = new BBox28(x, y, childWidth, childHeight);
      this.applyGap(innerBox, childBox, allLeafNodes);
      this.squarify(child, childBox);
      start2 += isVertical ? childWidth : childHeight;
    }
  }
  applyGap(innerBox, childBox, allLeafNodes) {
    const gap = allLeafNodes ? this.properties.tile.gap * 0.5 : this.properties.group.gap * 0.5;
    const getBounds = (box) => ({
      left: box.x,
      top: box.y,
      right: box.x + box.width,
      bottom: box.y + box.height
    });
    const innerBounds = getBounds(innerBox);
    const childBounds = getBounds(childBox);
    const sides = ["top", "right", "bottom", "left"];
    sides.forEach((side) => {
      if (!isNumberEqual(innerBounds[side], childBounds[side])) {
        childBox.shrink(gap, side);
      }
    });
  }
  createNodeData() {
    return void 0;
  }
  getItemStyle(nodeDatum, isLeaf, isHighlight) {
    const { id: seriesId, properties, colorScale, ctx } = this;
    const { itemStyler, fillGradientDefaults: fillGradientDefaults5, fillPatternDefaults: fillPatternDefaults5, fillImageDefaults: fillImageDefaults5 } = properties;
    const rootIndex = nodeDatum.datumIndex?.[0] ?? 0;
    const fills = isLeaf ? properties.fills : properties.undocumentedGroupFills;
    const strokes = isLeaf ? properties.strokes : properties.undocumentedGroupStrokes;
    const index = isLeaf ? rootIndex : nodeDatum.depth ?? -1;
    const highlightStyle = isHighlight ? properties.highlightStyle.getStyle(isLeaf) : void 0;
    const baseStyle = mergeDefaults23(highlightStyle, properties.getStyle(isLeaf, fills, strokes, index));
    if (!isHighlight && isLeaf && nodeDatum.colorValue != null) {
      baseStyle.fill = colorScale.convert(nodeDatum.colorValue);
    }
    let style2 = getShapeStyle19(baseStyle, fillGradientDefaults5, fillPatternDefaults5, fillImageDefaults5);
    if (itemStyler != null && nodeDatum != null) {
      const overrides = this.cachedDatumCallback(
        createDatumId21(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"),
        () => {
          const activeHighlight = ctx.highlightManager?.getActiveHighlight();
          const highlightState = this.getHighlightStateString(
            activeHighlight,
            isHighlight,
            nodeDatum.datumIndex
          );
          return this.callWithContext(itemStyler, {
            seriesId,
            datum: nodeDatum.datum,
            depth: nodeDatum.depth ?? -1,
            highlighted: isHighlight,
            highlightState,
            ...style2
          });
        }
      );
      if (overrides) {
        style2 = getShapeStyle19(
          mergeDefaults23(overrides, style2),
          fillGradientDefaults5,
          fillPatternDefaults5,
          fillImageDefaults5
        );
      }
    }
    return style2;
  }
  updateSelections() {
    let highlightedNode = this.ctx.highlightManager?.getActiveHighlight();
    if (highlightedNode != null && !this.properties.group.interactive && highlightedNode.children.length !== 0) {
      highlightedNode = void 0;
    }
    this.highlightSelection.update(
      highlightedNode != null ? [highlightedNode] : [],
      void 0,
      (node) => this.getDatumId(node)
    );
    if (!this.nodeDataRefresh) {
      return;
    }
    this.nodeDataRefresh = false;
    const { seriesRect } = this.chart ?? {};
    if (!seriesRect)
      return;
    const descendants = Array.from(this.rootNode);
    const updateLabelGroup = (group) => {
      group.append([new Text10({
        tag: 0
        /* Primary */
      }), new Text10({
        tag: 1
        /* Secondary */
      })]);
    };
    this.datumSelection.update(descendants, void 0, (node) => this.getDatumId(node));
    this.labelSelection.update(descendants, updateLabelGroup, (node) => this.getDatumId(node));
  }
  updateNodes() {
    const { rootNode, data } = this;
    const {
      childrenKey,
      colorKey,
      colorName,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName,
      highlightStyle,
      tile,
      group
    } = this.properties;
    const { seriesRect } = this.chart ?? {};
    if (!seriesRect || !data)
      return;
    this.rootNode?.walk((node) => {
      const { datum, depth, children } = node;
      const isLeaf = children.length === 0;
      const labelStyle = isLeaf ? tile.label : group.label;
      let labelValue;
      if (labelStyle.enabled && datum != null && depth != null && labelKey != null) {
        const value = datum[labelKey];
        labelValue = this.getLabelText(
          value,
          datum,
          labelKey,
          "label",
          [],
          labelStyle,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          }
        );
      }
      if (labelValue === "") {
        labelValue = void 0;
      }
      let secondaryLabelValue;
      if (tile.secondaryLabel.enabled && isLeaf && datum != null && depth != null && secondaryLabelKey != null) {
        const value = datum[secondaryLabelKey];
        secondaryLabelValue = this.getLabelText(
          value,
          datum,
          secondaryLabelKey,
          "secondaryLabel",
          [],
          tile.secondaryLabel,
          {
            depth,
            datum,
            childrenKey,
            colorKey,
            colorName,
            labelKey,
            secondaryLabelKey,
            sizeKey,
            sizeName,
            value
          }
        );
      }
      if (secondaryLabelValue === "") {
        secondaryLabelValue = void 0;
      }
      node.labelValue = labelValue;
      node.secondaryLabelValue = secondaryLabelValue;
    });
    const { width: width2, height: height2 } = seriesRect;
    this.squarify(rootNode, new BBox28(0, 0, width2, height2));
    this.rootNode?.walk((node) => {
      const { bbox, children, labelValue, secondaryLabelValue } = node;
      node.label = void 0;
      node.secondaryLabel = void 0;
      if (bbox == null)
        return;
      if (children.length === 0) {
        const layout = {
          width: bbox.width,
          height: bbox.height,
          meta: null
        };
        const formatting = formatLabels(
          labelValue,
          this.properties.tile.label,
          secondaryLabelValue,
          this.properties.tile.secondaryLabel,
          { padding: tile.padding },
          () => layout
        );
        if (formatting == null) {
          return;
        }
        const { height: labelHeight, label, secondaryLabel } = formatting;
        const { textAlign, verticalAlign, padding: padding2 } = tile;
        const textAlignFactor = textAlignFactors2[textAlign] ?? 0.5;
        const labelX = bbox.x + padding2 + (bbox.width - 2 * padding2) * textAlignFactor;
        const verticalAlignFactor = verticalAlignFactors4[verticalAlign] ?? 0.5;
        const labelYStart = bbox.y + padding2 + labelHeight * 0.5 + (bbox.height - 2 * padding2 - labelHeight) * verticalAlignFactor;
        if (label != null) {
          const {
            fontStyle = "normal",
            fontFamily,
            fontWeight = "normal",
            color: color6 = "black"
          } = this.properties.tile.label;
          node.label = {
            text: label.text,
            fontSize: label.fontSize,
            lineHeight: label.lineHeight,
            fontStyle,
            fontFamily,
            fontWeight,
            color: color6,
            textAlign,
            verticalAlign: "middle",
            x: labelX,
            y: labelYStart - (labelHeight - label.height) * 0.5
          };
        }
        if (secondaryLabel != null) {
          const {
            fontStyle = "normal",
            fontFamily,
            fontWeight = "normal",
            color: color6 = "black"
          } = this.properties.tile.secondaryLabel;
          node.secondaryLabel = {
            text: secondaryLabel.text,
            fontSize: secondaryLabel.fontSize,
            lineHeight: secondaryLabel.fontSize,
            fontStyle,
            fontFamily,
            fontWeight,
            color: color6,
            textAlign,
            verticalAlign: "middle",
            x: labelX,
            y: labelYStart + (labelHeight - secondaryLabel.height) * 0.5
          };
        }
      } else if (labelValue == null) {
        return;
      } else {
        const { padding: padding2, textAlign } = group;
        const groupTitleHeight = this.groupTitleHeight(node, bbox);
        if (groupTitleHeight == null)
          return;
        const innerWidth = bbox.width - 2 * padding2;
        const text2 = TextWrapper7.wrapText(labelValue, {
          maxWidth: bbox.width - 2 * padding2,
          font: group.label,
          textWrap: "never"
        });
        const textAlignFactor = textAlignFactors2[textAlign] ?? 0.5;
        const {
          fontStyle = "normal",
          fontFamily,
          fontWeight = "normal",
          color: color6 = "black"
        } = this.properties.group.label;
        node.label = {
          text: text2,
          fontSize: group.label.fontSize,
          lineHeight: TextUtils9.getLineHeight(group.label.fontSize),
          fontStyle,
          fontFamily,
          fontWeight,
          color: color6,
          textAlign,
          verticalAlign: "middle",
          x: bbox.x + padding2 + innerWidth * textAlignFactor,
          y: bbox.y + padding2 + groupTitleHeight * 0.5
        };
      }
    });
    const fillBBox = {
      series: new BBox28(0, 0, width2, height2),
      axis: new BBox28(0, 0, width2, height2)
    };
    const updateRectFn = (node, rect, isHighlight) => {
      const { bbox } = node;
      if (bbox == null) {
        rect.visible = false;
        return;
      }
      const { depth = -1 } = node;
      const isLeaf = node.children.length === 0;
      const style2 = this.getItemStyle(node, isLeaf, isHighlight);
      rect.crisp = true;
      applyShapeStyle20(rect, style2, fillBBox);
      rect.cornerRadius = isLeaf ? tile.cornerRadius : group.cornerRadius;
      rect.zIndex = [0, depth, isHighlight ? 1 : 0];
      const onlyLeaves = node.parent?.children.every((n) => n.children.length === 0);
      const parentBbox = node.parent != null ? node.parent.bbox : void 0;
      const parentPadding = node.parent != null ? node.parent.padding : void 0;
      if (onlyLeaves === true && parentBbox != null && parentPadding != null) {
        rect.clipBBox = bbox;
        rect.x = parentBbox.x + parentPadding.left;
        rect.y = parentBbox.y + parentPadding.top;
        rect.width = parentBbox.width - (parentPadding.left + parentPadding.right);
        rect.height = parentBbox.height - (parentPadding.top + parentPadding.bottom);
      } else {
        rect.clipBBox = void 0;
        rect.x = bbox.x;
        rect.y = bbox.y;
        rect.width = bbox.width;
        rect.height = bbox.height;
      }
      rect.visible = true;
    };
    this.datumSelection.each((rect, datum) => updateRectFn(datum, rect, false));
    this.highlightSelection.each((rect, datum) => {
      updateRectFn(datum, rect, true);
    });
    const updateLabelFn = (node, text2, tag, highlighted) => {
      const isLeaf = node.children.length === 0;
      const label = tag === 0 ? node.label : node.secondaryLabel;
      if (label == null) {
        text2.visible = false;
        return;
      }
      const labelProps = tag === 0 ? tile.label : tile.secondaryLabel;
      let highlightedColor;
      if (highlighted) {
        const { tile: hTitle, group: hGroup } = highlightStyle;
        highlightedColor = hTitle.secondaryLabel.color;
        if (!isLeaf) {
          highlightedColor = hGroup.label.color;
        } else if (tag === 0) {
          highlightedColor = hTitle.label.color;
        }
      }
      const params = {
        childrenKey: this.properties.childrenKey,
        colorKey: this.properties.colorKey,
        colorName: this.properties.colorName ?? this.properties.colorKey,
        depth: node.depth ?? NaN,
        labelKey: this.properties.labelKey,
        secondaryLabelKey: this.properties.secondaryLabelKey,
        sizeKey: this.properties.sizeKey,
        sizeName: this.properties.sizeName ?? this.properties.sizeKey
      };
      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();
      const highlightState = this.getHighlightStateString(activeHighlight, highlighted, node.datumIndex);
      const style2 = getLabelStyles7(this, node, params, labelProps, highlighted, highlightState);
      text2.text = label.text;
      text2.fontSize = label.fontSize;
      text2.lineHeight = label.lineHeight;
      text2.fontStyle = label.fontStyle;
      text2.fontFamily = label.fontFamily;
      text2.fontWeight = label.fontWeight;
      text2.fill = highlightedColor ?? label.color;
      text2.fillOpacity = this.getHighlightStyle(highlighted, node.datumIndex)?.opacity ?? 1;
      text2.textAlign = label.textAlign;
      text2.textBaseline = label.verticalAlign;
      text2.x = label.x;
      text2.y = label.y;
      text2.setBoxing(style2);
      text2.visible = true;
      text2.zIndex = 1;
    };
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    this.labelSelection.selectByClass(Text10).forEach((text2) => {
      const datum = text2.closestDatum();
      updateLabelFn(datum, text2, text2.tag, datum === highlightedDatum);
    });
  }
  pickNodesExactShape(point) {
    const nodes = super.pickNodesExactShape(point);
    nodes.sort((a, b) => b.datumIndex.length - a.datumIndex.length);
    return nodes;
  }
  pickNodeClosestDatum(point) {
    const exactMatch = this.pickNodesExactShape(point);
    if (exactMatch.length !== 0) {
      return { datum: exactMatch[0], distance: 0 };
    }
    return this.pickNodeNearestDistantObject(point, this.datumSelection.nodes());
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, properties } = this;
    const { labelKey, secondaryLabelKey, childrenKey, sizeKey, sizeName, colorKey, colorName, tooltip } = properties;
    const nodeDatum = datumIndex.reduce((n, i) => n?.children[i], this.rootNode);
    if (nodeDatum == null)
      return;
    const { datum, depth, children } = nodeDatum;
    if (datum == null || depth == null)
      return;
    const isLeaf = children.length === 0;
    const data = [];
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: datumSize });
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      data.push({ label: colorName, fallbackLabel: colorKey, value: datumColor });
    }
    const format = this.getItemStyle(
      { ...nodeDatum, colorValue: datumColor ?? nodeDatum.colorValue },
      isLeaf,
      false
    );
    const color6 = format.fill;
    const markerStyle = getShapeStyle19(
      {
        shape: "square",
        fill: color6,
        fillOpacity: 1,
        stroke: void 0,
        strokeWidth: 0,
        strokeOpacity: 1,
        lineDash: [0],
        lineDashOffset: 0
      },
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    if (module_support_exports.isGradientFill(markerStyle.fill)) {
      markerStyle.fill = { ...markerStyle.fill, gradient: "linear", rotation: 0, reverse: false };
    }
    const symbol = isLeaf ? { marker: markerStyle } : void 0;
    return this.formatTooltipWithContext(
      tooltip,
      {
        title: labelKey != null ? datum[labelKey] : void 0,
        symbol,
        data
      },
      {
        seriesId,
        datum,
        title: void 0,
        depth,
        labelKey,
        secondaryLabelKey,
        childrenKey,
        sizeKey,
        sizeName,
        colorKey,
        colorName,
        ...format
      }
    );
  }
  computeFocusBounds(node) {
    return Transformable4.toCanvas(this.contentGroup, node.getBBox());
  }
  hasItemStylers() {
    return this.properties.itemStyler != null;
  }
};
TreemapSeries.className = "TreemapSeries";
TreemapSeries.type = "treemap";
var { commonSeriesOptionsDefs: commonSeriesOptionsDefs23, treemapSeriesThemeableOptionsDef: treemapSeriesThemeableOptionsDef2, without: without9 } = module_support_exports;
var treemapSeriesOptionsDef = {
  ...treemapSeriesThemeableOptionsDef2,
  ...without9(commonSeriesOptionsDefs23, ["highlightStyle", "highlight", "showInLegend"]),
  type: required(constant("treemap")),
  labelKey: string,
  secondaryLabelKey: string,
  childrenKey: string,
  sizeKey: string,
  colorKey: string,
  sizeName: string,
  colorName: string
};
treemapSeriesOptionsDef.fillGradientDefaults = undocumented(fillGradientDefaults);
treemapSeriesOptionsDef.fillPatternDefaults = undocumented(fillPatternDefaults);
treemapSeriesOptionsDef.fillImageDefaults = undocumented(fillImageDefaults);
treemapSeriesOptionsDef.undocumentedGroupFills = undocumented(arrayOf(color));
treemapSeriesOptionsDef.undocumentedGroupStrokes = undocumented(arrayOf(color));
var { FONT_SIZE_RATIO: FONT_SIZE_RATIO4 } = module_support_exports;
var TreemapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["standalone"],
  identifier: "treemap",
  moduleFactory: (ctx) => new TreemapSeries(ctx),
  solo: true,
  themeTemplate: {
    series: {
      fills: { $palette: "fills" },
      strokes: { $palette: "strokes" },
      colorRange: { $palette: "divergingColors" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: module_support_exports.FILL_GRADIENT_LINEAR_DEFAULTS,
      fillPatternDefaults: module_support_exports.FILL_PATTERN_DEFAULTS,
      fillImageDefaults: module_support_exports.FILL_IMAGE_DEFAULTS,
      undocumentedGroupFills: { $palette: "hierarchyColors" },
      undocumentedGroupStrokes: { $palette: "secondHierarchyColors" },
      group: {
        label: {
          ...module_support_exports.LABEL_BOXING_DEFAULTS,
          enabled: true,
          color: { $ref: "textColor" },
          fontStyle: void 0,
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $ref: "fontSize" },
          fontFamily: { $ref: "fontFamily" },
          spacing: 4
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 1,
        padding: 4,
        gap: 2,
        textAlign: "left"
      },
      tile: {
        label: {
          ...module_support_exports.LABEL_BOXING_DEFAULTS,
          enabled: true,
          color: { $ref: "chartBackgroundColor" },
          fontStyle: void 0,
          fontWeight: { $ref: "fontWeight" },
          fontSize: { $rem: 1.5 },
          minimumFontSize: { $rem: FONT_SIZE_RATIO4.SMALLER },
          fontFamily: { $ref: "fontFamily" },
          wrapping: "on-space",
          overflowStrategy: "ellipsis",
          spacing: 2
        },
        secondaryLabel: {
          ...module_support_exports.LABEL_BOXING_DEFAULTS,
          enabled: true,
          color: { $ref: "chartBackgroundColor" },
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: { $ref: "fontSize" },
          minimumFontSize: { $rem: FONT_SIZE_RATIO4.SMALLER },
          fontFamily: { $ref: "fontFamily" },
          wrapping: "never",
          overflowStrategy: "ellipsis"
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: { $isUserOption: ["../strokes/0", 2, { $isUserOption: ["./stroke", 2, 0] }] },
        padding: 3,
        gap: 1
      },
      // Override defaults
      highlightStyle: {
        group: {
          label: {
            color: { $ref: "textColor" }
          },
          fill: "rgba(255,255,255, 0.33)",
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        },
        tile: {
          label: {
            color: { $ref: "chartBackgroundColor" }
          },
          secondaryLabel: {
            color: { $ref: "chartBackgroundColor" }
          },
          fill: "rgba(255,255,255, 0.33)",
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        }
      }
    },
    gradientLegend: {
      enabled: true,
      ...module_support_exports.LEGEND_CONTAINER_THEME
    }
  }
};
var TreemapSeriesModule = {
  type: "series",
  name: "treemap",
  chartType: "standalone",
  enterprise: true,
  options: treemapSeriesOptionsDef,
  create: (ctx) => new TreemapSeries(ctx)
};
var ModuleRegistry2 = module_support_exports.ModuleRegistry;
var AllCartesianEnterpriseModules = [
  OrdinalTimeAxisModule2,
  BoxPlotSeriesModule,
  CandlestickSeriesModule,
  ConeFunnelSeriesModule,
  FunnelSeriesModule,
  HeatmapSeriesModule,
  OhlcSeriesModule,
  RangeAreaSeriesModule,
  RangeBarSeriesModule,
  WaterfallSeriesModule
];
var AllPolarEnterpriseModules = [
  AngleNumberAxisModule2,
  AngleCategoryAxisModule2,
  RadiusNumberAxisModule2,
  RadiusCategoryAxisModule2,
  NightingaleSeriesModule,
  RadarAreaSeriesModule,
  RadarLineSeriesModule,
  RadialBarSeriesModule,
  RadialColumnSeriesModule
];
var AllStandaloneEnterpriseModules = [
  StandaloneChartModule2,
  PyramidSeriesModule,
  LinearGaugeSeriesModule,
  RadialGaugeSeriesModule,
  SunburstSeriesModule,
  TreemapSeriesModule,
  ChordSeriesModule,
  SankeySeriesModule
];
var AllTopologyEnterpriseModules = [
  TopologyChartModule2,
  MapLineSeriesModule,
  MapLineBackgroundSeriesModule,
  MapMarkerSeriesModule,
  MapShapeSeriesModule,
  MapShapeBackgroundSeriesModule
];
var AllEnterpriseModules = [
  ...AllCartesianEnterpriseModules,
  ...AllPolarEnterpriseModules,
  ...AllStandaloneEnterpriseModules,
  ...AllTopologyEnterpriseModules,
  // Plugins, WIP
  AnnotationsModule2,
  NavigatorModule2,
  InitialStateModule
];
var styles_default2 = `.ag-watermark{position:absolute;bottom:20px;right:25px;font-weight:700;font-family:Impact,sans-serif;font-size:19px;opacity:.7;animation:1s ease-out 3s ag-watermark-fadeout;color:#9b9b9b;pointer-events:none;&:before{content:"";display:block;height:40px;width:170px;background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;background-size:170px 40px}>span{padding-left:.7rem}}@keyframes ag-watermark-fadeout{0%{opacity:.5}to{opacity:0}}.ag-charts-dialog{display:flex;flex-direction:column;font-size:var(--ag-charts-chrome-font-size-large)}.ag-charts-dialog__tabs{display:flex;flex-direction:column}.ag-charts-dialog__header{border-bottom:1px solid var(--ag-charts-border-color);display:flex}.ag-charts-dialog__tab-list{display:flex;gap:calc(var(--ag-charts-spacing) * 2)}.ag-charts-dialog__drag-handle{align-items:center;color:inherit;cursor:grab;display:flex;padding:1px 6px;text-align:center}.ag-charts-dialog__drag-handle--dragging{cursor:grabbing}.ag-charts-dialog__tab-button{background:none;border:0;border-bottom:2px solid transparent;border-radius:0;color:var(--ag-charts-panel-subtle-text-color);margin-bottom:-1px;padding:var(--input-padding) calc(var(--input-padding) / 2)}.ag-charts-dialog__tab-button:hover{background:none}.ag-charts-dialog__tab-button--active{border-color:var(--ag-charts-accent-color);color:inherit}.ag-charts-dialog__drag-handle+.ag-charts-dialog__tab-button{margin-left:calc(var(--ag-charts-spacing) * -2)}.ag-charts-button.ag-charts-dialog__close-button{background:none;border:0;margin-left:auto;padding:1px 6px}.ag-charts-dialog__close-button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-dialog__tab-panel{display:none;flex-direction:column;gap:calc(var(--ag-charts-spacing) * 4);margin:0 calc(var(--ag-charts-spacing) * 4);padding:calc(var(--ag-charts-spacing) * 4) 0}.ag-charts-dialog__tab-panel--active{display:flex}.ag-charts-dialog__input-group-line{display:flex;gap:16px 18px;flex-wrap:wrap}.ag-charts-dialog__input-group{align-items:center;display:flex;font-size:var(--ag-charts-chrome-font-size)}.ag-charts-dialog__input-group-label{color:var(--ag-charts-panel-subtle-text-color);margin-right:5px}.ag-charts-dialog__input-group-label[for]{cursor:pointer}.ag-charts-dialog__button{border-radius:0;margin-right:-1px}.ag-charts-dialog__button.ag-charts-dialog__button--active{background:var(--ag-charts-button-focus-background-color);border-color:var(--ag-charts-input-focus-border-color);color:var(--ag-charts-input-focus-text-color);z-index:var(--input-layer-active)}.ag-charts-dialog__button:first-child,.ag-charts-dialog__input-group-label+.ag-charts-dialog__button{border-bottom-left-radius:var(--ag-charts-input-border-radius);border-top-left-radius:var(--ag-charts-input-border-radius)}.ag-charts-dialog__button:last-child{border-bottom-right-radius:var(--ag-charts-input-border-radius);border-top-right-radius:var(--ag-charts-input-border-radius)}.ag-charts-dialog__color-picker-button{--color: #000;background:var(--color);border:none;color:transparent;height:26px;width:26px}.ag-charts-dialog__color-picker-button:hover{background:var(--color)}.ag-charts-dialog__color-picker-button--multi-color,.ag-charts-dialog__color-picker-button--multi-color:hover{background:linear-gradient(135deg,red 0%,#ff0 calc(100% * 1 / 6),#0f0 calc(100% * 2 / 6),#0ff 50%,#00f calc(100% * 4 / 6),#f0f calc(100% * 5 / 6),red 100%)}.ag-charts-color-picker{width:190px;padding:8px;cursor:default;--h: 0;--s: 0;--v: 0;--a: 0;--color: #000;--color-a: #000;--thumb-size: 18px;--inner-width: 172px;--track-height: 12px;--palette-height: 136px;--checker: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect x="0" y="0" width="4" height="4" fill="%23fff"/><path d="M0 0H2V4H4V2H0Z" fill="%23b2b2b2"/></svg>');--multi-color: linear-gradient( 135deg, #f00 0% , #ff0 calc(100% * 1 / 6), #0f0 calc(100% * 2 / 6), #0ff 50% , #00f calc(100% * 4 / 6), #f0f calc(100% * 5 / 6), #f00 100% )}.ag-charts-color-picker__content{display:flex;flex-direction:column}.ag-charts-color-picker__palette{position:relative;width:100%;height:var(--palette-height);margin-bottom:8px;background:linear-gradient(to bottom,#0000,#000),linear-gradient(to right,#fff,#fff0) hsl(var(--h),100%,50%);border-radius:calc(var(--ag-charts-border-radius) * 1.5);box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__palette:after{content:"";position:absolute;display:block;top:calc(var(--thumb-size) * -.5 + (1 - var(--v)) * 100%);left:calc(var(--thumb-size) * -.5 + var(--s) * 100%);background:var(--color);width:var(--thumb-size);height:var(--thumb-size);border-radius:calc(var(--ag-charts-border-radius) * 99);box-shadow:var(--box-shadow);--box-shadow: inset 0 0 0 3px white, inset 0 0 1px 3px #0006, 0 0 5px #00000038}.ag-charts-color-picker__palette:focus-visible:after{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),0 0 0 2px #fff8,var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__color-row{display:flex;gap:8px;align-items:center;margin-bottom:4px;--inset: calc((var(--thumb-size) - var(--track-height)) / 2)}.ag-charts-color-picker__hue-input,.ag-charts-color-picker__alpha-input{-webkit-appearance:none;display:block;position:relative;padding:0;margin:0 calc(var(--inset) * -1);border:0;height:var(--thumb-size);width:auto;background:transparent;--inset: calc((var(--thumb-size) - var(--track-height)) / 2)}.ag-charts-color-picker__hue-input::-moz-range-thumb,.ag-charts-color-picker__alpha-input::-moz-range-thumb{appearance:none;width:var(--thumb-size);height:var(--thumb-size);border-radius:calc(var(--ag-charts-border-radius) * 99);box-shadow:var(--box-shadow);--box-shadow: inset 0 0 0 3px white, inset 0 0 1px 3px #0006, 0 0 5px #00000038}.ag-charts-color-picker__hue-input::-webkit-slider-thumb,.ag-charts-color-picker__alpha-input::-webkit-slider-thumb{-webkit-appearance:none;width:var(--thumb-size);height:var(--thumb-size);border-radius:calc(var(--ag-charts-border-radius) * 99);box-shadow:var(--box-shadow);--box-shadow: inset 0 0 0 3px white, inset 0 0 1px 3px #0006, 0 0 5px #00000038;transform:translateZ(0)}.ag-charts-color-picker__hue-input::-moz-range-thumb{background:hsl(var(--h),100%,50%)}.ag-charts-color-picker__hue-input::-webkit-slider-thumb{background:hsl(var(--h),100%,50%)}.ag-charts-color-picker__alpha-input::-moz-range-thumb{background:transparent}.ag-charts-color-picker__alpha-input::-webkit-slider-thumb{background:transparent}.ag-charts-color-picker__alpha-input--opaque::-moz-range-thumb{background:var(--color)}.ag-charts-color-picker__alpha-input--opaque::-webkit-slider-thumb{background:var(--color)}.ag-charts-color-picker__hue-input:focus-visible::-moz-range-thumb,.ag-charts-color-picker__alpha-input:focus-visible::-moz-range-thumb{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__hue-input:focus-visible::-webkit-slider-thumb,.ag-charts-color-picker__alpha-input:focus-visible::-webkit-slider-thumb{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__hue-input::-moz-range-track,.ag-charts-color-picker__alpha-input::-moz-range-track{position:absolute;content:"";display:block;top:calc(50% - var(--track-height) / 2);left:var(--inset);right:var(--inset);height:var(--track-height);border-radius:calc(var(--ag-charts-border-radius) * 99);box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__hue-input:before,.ag-charts-color-picker__alpha-input:before{position:absolute;content:"";display:block;top:calc(50% - var(--track-height) / 2);left:var(--inset);right:var(--inset);height:var(--track-height);border-radius:calc(var(--ag-charts-border-radius) * 99);box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__multi-color-button{width:36px;margin-left:var(--inset);height:var(--track-height);border-radius:calc(var(--ag-charts-border-radius) * 99);border:0;background:var(--multi-color);box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__multi-color-button--hidden{display:none}.ag-charts-color-picker__multi-color-button--active{box-shadow:inset 0 0 0 1px #0003;outline-offset:1px;outline:2px solid #2196f3}.ag-charts-color-picker__hue-input{flex:1 0 0}.ag-charts-color-picker__hue-input::-moz-range-track{background:linear-gradient(to right,red,red calc((100% - var(--track-height)) * 0 / 6 + var(--track-height) / 2),#ff0 calc((100% - var(--track-height)) * 1 / 6 + var(--track-height) / 2),#0f0 calc((100% - var(--track-height)) * 2 / 6 + var(--track-height) / 2),#0ff calc((100% - var(--track-height)) * 3 / 6 + var(--track-height) / 2),#00f calc((100% - var(--track-height)) * 4 / 6 + var(--track-height) / 2),#f0f calc((100% - var(--track-height)) * 5 / 6 + var(--track-height) / 2),red calc((100% - var(--track-height)) * 6 / 6 + var(--track-height) / 2))}.ag-charts-color-picker__hue-input:before{background:linear-gradient(to right,red,red calc((100% - var(--track-height)) * 0 / 6 + var(--track-height) / 2),#ff0 calc((100% - var(--track-height)) * 1 / 6 + var(--track-height) / 2),#0f0 calc((100% - var(--track-height)) * 2 / 6 + var(--track-height) / 2),#0ff calc((100% - var(--track-height)) * 3 / 6 + var(--track-height) / 2),#00f calc((100% - var(--track-height)) * 4 / 6 + var(--track-height) / 2),#f0f calc((100% - var(--track-height)) * 5 / 6 + var(--track-height) / 2),red calc((100% - var(--track-height)) * 6 / 6 + var(--track-height) / 2))}.ag-charts-color-picker__alpha-input{margin-bottom:7px}.ag-charts-color-picker__alpha-input::-moz-range-track{background:linear-gradient(to right,transparent,var(--color)),var(--checker) top left / 4px 4px}.ag-charts-color-picker__alpha-input:before{background:linear-gradient(to right,transparent,var(--color)),var(--checker) top left / 4px 4px}.ag-charts-color-picker__color-field{display:flex;border:var(--ag-charts-border);background:var(--ag-charts-background-color);border-radius:var(--ag-charts-border-radius);overflow:hidden}.ag-charts-color-picker__color-field:has(:focus-visible){border-color:var(--ag-charts-accent-color);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__color-label{width:16px;height:16px;margin:7px 0 7px 7px;color:transparent;background:linear-gradient(to right,var(--color-a),var(--color-a)),var(--checker) top left / 4px 4px;border-radius:calc(var(--ag-charts-border-radius) / 2);box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__color-label--multi-color{background:var(--multi-color)}.ag-charts-color-picker__color-input{flex:1;min-width:0;padding:7px 7px 7px 8px;border:0;margin:0;color:inherit;background:transparent;font-variant:tabular-nums}.ag-charts-color-picker__color-input:focus-visible{border:none;outline:none}.ag-charts-annotations__line-stroke-width-menu,.ag-charts-annotations__line-style-type-menu,.ag-charts-annotations__text-size-menu{border-top-left-radius:0;border-top-right-radius:0;.ag-charts-menu__row:first-child{border-radius:0}}.ag-charts-annotations__text-size-menu{--item-padding: 4px 8px;min-width:34px;text-align:center}.ag-charts-annotations__line-stroke-width-menu{--item-padding: 6px;column-gap:6px}.ag-charts-annotations__line-style-type-menu{--item-padding: 6px;column-gap:0}.ag-charts-annotations__stroke-width-button:before{background:var(--ag-charts-foreground-color);content:"";margin-right:var(--toolbar-button-padding);height:min(var(--stroke-width),20px);width:12px}.ag-charts-annotations__stroke-width-button[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-annotations__color-picker-button{--emblem: var(--color)}.ag-charts-annotations__color-picker-button--multi-color{--emblem: linear-gradient( to right, #f00 0% , #ff0 calc(100% * 1 / 6), #0f0 calc(100% * 2 / 6), #0ff 50% , #00f calc(100% * 4 / 6), #f0f calc(100% * 5 / 6), #f00 100% )}.ag-charts-annotations__color-picker-button:after{content:"";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--emblem)}.ag-charts-annotations__color-picker-button[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-annotations__toolbar-menu{min-width:200px}.ag-charts-annotations__axis-button--hidden{display:none}.ag-charts-annotations__axis-button{background-color:var(--ag-charts-crosshair-label-background-color);border-radius:calc(var(--ag-charts-border-radius) / 2);border:none;box-sizing:border-box;color:var(--ag-charts-crosshair-label-text-color);cursor:pointer;font-family:var(--ag-charts-button-font-family);font-size:var(--ag-charts-button-font-size);font-weight:var(--ag-charts-button-font-weight);left:0;line-height:16px;overflow:hidden;padding:0;position:absolute;top:0;user-select:none;white-space:nowrap;z-index:var(--ag-charts-layer-annotations)}.ag-charts-annotations__axis-button:hover{opacity:.8;color:var(--ag-charts-background-color)}.ag-charts-dialog--annotation-settings{min-height:233px;width:289px}.ag-charts-dialog--annotation-settings .ag-charts-textarea{height:calc(10px * 2 + var(--textarea-line-height) * 1em * 3 + 2px);overflow-y:auto;resize:vertical}.ag-charts-context-menu{font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-context-menu__cover{position:fixed;left:0;top:0}.ag-charts-context-menu__menu{background:var(--ag-charts-menu-background-color);border-radius:var(--ag-charts-border-radius);border:var(--ag-charts-menu-border);box-shadow:var(--ag-charts-popup-shadow);color:var(--ag-charts-menu-text-color);display:flex;flex-direction:column;padding:.5em 0;transition:transform .1s ease;white-space:nowrap}.ag-charts-context-menu__menu:focus{outline:none}.ag-charts-context-menu__item{align-items:center;background:none;border:none;box-sizing:border-box;color:inherit;cursor:pointer;display:flex;font:inherit;justify-content:space-between;text-align:left;width:100%;-webkit-appearance:none;-moz-appearance:none}.ag-charts-context-menu__icon>img{width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size)}.ag-charts-context-menu__icon,.ag-charts-context-menu__cell{display:flex;align-items:center;flex-shrink:0}.ag-charts-context-menu__cell{flex-grow:1}.ag-charts-context-menu__cellpadding{padding:.5em 1em}.ag-charts-context-menu__icon{padding-right:0}.ag-charts-context-menu__item[data-focus-override=true],.ag-charts-context-menu__item:focus,.ag-charts-context-menu__item:active{background:var(--ag-charts-focus-color)}.ag-charts-context-menu__item[data-focus-override=false]{background:inherit}.ag-charts-context-menu__item[data-focus-visible-override=true]:focus,.ag-charts-context-menu__item:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-context-menu__item[data-focus-visible-override=false]{outline:inherit;box-shadow:inherit;z-index:inherit}.ag-charts-context-menu__item[aria-disabled=true]{border:none;color:color-mix(in srgb,var(--ag-charts-input-text-color) 50%,transparent)}.ag-charts-context-menu__item[aria-disabled=true]:focus{background:inherit;cursor:inherit}.ag-charts-context-menu__divider{padding:5px 0}.ag-charts-context-menu__divider:after{content:"";display:block;border-top:1px solid var(--ag-charts-border-color)}.ag-charts-crosshair-label{position:absolute;left:0;top:0;user-select:none;pointer-events:none;font-family:var(--ag-charts-font-family);font-size:var(--ag-charts-font-size);font-weight:var(--ag-charts-font-weight);overflow:hidden;white-space:nowrap;z-index:var(--ag-charts-layer-crosshair);box-sizing:border-box}.ag-charts-crosshair-label-content{padding:0 8px;border-radius:calc(var(--ag-charts-border-radius) / 2);line-height:calc(var(--ag-charts-font-size) + 8px);background-color:var(--ag-charts-crosshair-label-background-color);color:var(--ag-charts-crosshair-label-text-color)}.ag-charts-crosshair-label--hidden{visibility:hidden!important}.ag-charts-text-input{position:absolute}.ag-charts-text-input__textarea{--placeholder-text-color: var(--ag-charts-input-placeholder-text-color);display:block;height:100%;width:100%;border:0;background:none;line-height:1.38;outline:none;transform:translateY(.09em)}.ag-charts-text-input__textarea[placeholder]:empty:before{content:attr(placeholder);color:var(--placeholder-text-color);font-weight:400}.ag-charts-text-input__textarea[placeholder]:not(:empty):before{content:""}.ag-charts-chart-toolbar__menu{min-width:200px}.ag-charts-range-buttons .ag-charts-toolbar__button{padding:var(--toolbar-button-padding) calc(var(--toolbar-button-padding) * 1.5)}.ag-charts-zoom-buttons{align-items:center;display:flex;height:44px;justify-content:center;overflow:hidden;padding-bottom:10px;pointer-events:none;width:100%;.ag-charts-toolbar{--toolbar-size: 24px;--toolbar-button-padding: 1px;display:flex;font-size:var(--ag-charts-chrome-font-size);height:var(--toolbar-size);justify-content:center;opacity:1;pointer-events:auto;transition:opacity .2s ease-in-out,transform .4s ease-in-out;.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius)}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius)}.ag-charts-toolbar__label{padding-left:var(--ag-charts-spacing);padding-right:var(--ag-charts-spacing)}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{padding-left:0}.ag-charts-toolbar__button--gap{margin-left:var(--toolbar-gap)}&.ag-charts-zoom-buttons__toolbar--hidden{opacity:0;transition:opacity .4s ease-in-out,transform .4s ease-in-out}}}.ag-charts-shared-toolbar{gap:var(--toolbar-gap);.ag-charts-toolbar__button{border-radius:var(--ag-charts-border-radius);margin:0}}
`;
module_support_exports.ModuleRegistry.registerMany(AllEnterpriseModules, VERSION);
function setupEnterpriseModules() {
  module_support_exports.moduleRegistry.register(
    AngleCategoryAxisModule,
    AngleNumberAxisModule,
    AnimationModule,
    AnnotationsModule,
    BackgroundModule2,
    ForegroundModule,
    BoxPlotModule,
    CandlestickModule,
    ChordModule,
    ConeFunnelModule,
    FunnelModule,
    OhlcModule,
    ChartToolbarModule,
    ContextMenuModule,
    CrosshairModule,
    BandHighlightModule,
    DataSourceModule,
    ErrorBarsModule,
    LinearGaugeModule,
    MapLineModule,
    MapLineBackgroundModule,
    MapMarkerModule,
    MapShapeModule,
    MapShapeBackgroundModule,
    NavigatorModule,
    StatusBarModule,
    GradientLegendModule,
    HeatmapModule,
    NightingaleModule,
    OrdinalTimeAxisModule,
    RadarAreaModule,
    RadarLineModule,
    RadialBarModule,
    RadialColumnModule,
    RadiusCategoryAxisModule,
    RadialGaugeModule,
    RadiusNumberAxisModule,
    RangeBarModule,
    RangeAreaModule,
    RangesModule,
    PyramidModule,
    SankeyModule,
    SharedToolbarModule,
    SunburstModule,
    SyncModule,
    TreemapModule,
    WaterfallModule,
    ZoomModule
  );
  module_support_exports.enterpriseModule.isEnterprise = true;
  module_support_exports.enterpriseModule.styles = styles_default2;
  module_support_exports.enterpriseModule.licenseManager = (options) => new LicenseManager(
    options.container?.ownerDocument ?? (typeof document === "undefined" ? void 0 : document)
  );
  module_support_exports.enterpriseModule.injectWatermark = injectWatermark;
}
setupEnterpriseModules();
var LicenseManager2 = {
  setLicenseKey(key) {
    LicenseManager.setLicenseKey(key);
  }
};
function setupEnterpriseModules2() {
  setupEnterpriseModules();
  registerInbuiltModules();
}
var AgChartsEnterpriseModule = {
  VERSION,
  _Scene: integrated_charts_scene_exports,
  _Theme: integrated_charts_theme_exports,
  _Util: integrated_charts_util_exports,
  create: AgCharts.create.bind(AgCharts),
  createSparkline: AgCharts.__createSparkline.bind(AgCharts),
  setup: setupEnterpriseModules2,
  setGridContext: LicenseManager.setGridContext.bind(LicenseManager),
  setLicenseKey: LicenseManager.setLicenseKey.bind(LicenseManager),
  isEnterprise: true
};
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
